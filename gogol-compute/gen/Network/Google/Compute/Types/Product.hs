{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric      #-}
{-# LANGUAGE NoImplicitPrelude  #-}
{-# LANGUAGE OverloadedStrings  #-}
{-# LANGUAGE RecordWildCards    #-}

{-# OPTIONS_GHC -fno-warn-unused-binds   #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}

-- |
-- Module      : Network.Google.Compute.Types.Product
-- Copyright   : (c) 2015-2016 Brendan Hay
-- License     : Mozilla Public License, v. 2.0.
-- Maintainer  : Brendan Hay <brendan.g.hay@gmail.com>
-- Stability   : auto-generated
-- Portability : non-portable (GHC extensions)
--
module Network.Google.Compute.Types.Product where

import Network.Google.Compute.Types.Sum
import Network.Google.Prelude

--
-- /See:/ 'regionInstanceGroupManagersListErrorsResponse' smart constructor.
data RegionInstanceGroupManagersListErrorsResponse =
  RegionInstanceGroupManagersListErrorsResponse'
    { _rigmlerNextPageToken :: !(Maybe Text)
    , _rigmlerItems :: !(Maybe [InstanceManagedByIgmError])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupManagersListErrorsResponse' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rigmlerNextPageToken'
--
-- * 'rigmlerItems'
regionInstanceGroupManagersListErrorsResponse
    :: RegionInstanceGroupManagersListErrorsResponse
regionInstanceGroupManagersListErrorsResponse =
  RegionInstanceGroupManagersListErrorsResponse'
    {_rigmlerNextPageToken = Nothing, _rigmlerItems = Nothing}


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
rigmlerNextPageToken :: Lens' RegionInstanceGroupManagersListErrorsResponse (Maybe Text)
rigmlerNextPageToken
  = lens _rigmlerNextPageToken
      (\ s a -> s{_rigmlerNextPageToken = a})

-- | [Output Only] The list of errors of the managed instance group.
rigmlerItems :: Lens' RegionInstanceGroupManagersListErrorsResponse [InstanceManagedByIgmError]
rigmlerItems
  = lens _rigmlerItems (\ s a -> s{_rigmlerItems = a})
      . _Default
      . _Coerce

instance FromJSON
           RegionInstanceGroupManagersListErrorsResponse
         where
        parseJSON
          = withObject
              "RegionInstanceGroupManagersListErrorsResponse"
              (\ o ->
                 RegionInstanceGroupManagersListErrorsResponse' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "items" .!= mempty))

instance ToJSON
           RegionInstanceGroupManagersListErrorsResponse
         where
        toJSON
          RegionInstanceGroupManagersListErrorsResponse'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _rigmlerNextPageToken,
                  ("items" .=) <$> _rigmlerItems])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'instanceAggregatedListWarning' smart constructor.
data InstanceAggregatedListWarning =
  InstanceAggregatedListWarning'
    { _ialwData :: !(Maybe [InstanceAggregatedListWarningDataItem])
    , _ialwCode :: !(Maybe InstanceAggregatedListWarningCode)
    , _ialwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ialwData'
--
-- * 'ialwCode'
--
-- * 'ialwMessage'
instanceAggregatedListWarning
    :: InstanceAggregatedListWarning
instanceAggregatedListWarning =
  InstanceAggregatedListWarning'
    {_ialwData = Nothing, _ialwCode = Nothing, _ialwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
ialwData :: Lens' InstanceAggregatedListWarning [InstanceAggregatedListWarningDataItem]
ialwData
  = lens _ialwData (\ s a -> s{_ialwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
ialwCode :: Lens' InstanceAggregatedListWarning (Maybe InstanceAggregatedListWarningCode)
ialwCode = lens _ialwCode (\ s a -> s{_ialwCode = a})

-- | [Output Only] A human-readable description of the warning code.
ialwMessage :: Lens' InstanceAggregatedListWarning (Maybe Text)
ialwMessage
  = lens _ialwMessage (\ s a -> s{_ialwMessage = a})

instance FromJSON InstanceAggregatedListWarning where
        parseJSON
          = withObject "InstanceAggregatedListWarning"
              (\ o ->
                 InstanceAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON InstanceAggregatedListWarning where
        toJSON InstanceAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _ialwData,
                  ("code" .=) <$> _ialwCode,
                  ("message" .=) <$> _ialwMessage])

-- | Contains a list of TargetHttpsProxy resources.
--
-- /See:/ 'targetHTTPSProxyList' smart constructor.
data TargetHTTPSProxyList =
  TargetHTTPSProxyList'
    { _thplNextPageToken :: !(Maybe Text)
    , _thplKind :: !Text
    , _thplItems :: !(Maybe [TargetHTTPSProxy])
    , _thplSelfLink :: !(Maybe Text)
    , _thplWarning :: !(Maybe TargetHTTPSProxyListWarning)
    , _thplId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetHTTPSProxyList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'thplNextPageToken'
--
-- * 'thplKind'
--
-- * 'thplItems'
--
-- * 'thplSelfLink'
--
-- * 'thplWarning'
--
-- * 'thplId'
targetHTTPSProxyList
    :: TargetHTTPSProxyList
targetHTTPSProxyList =
  TargetHTTPSProxyList'
    { _thplNextPageToken = Nothing
    , _thplKind = "compute#targetHttpsProxyList"
    , _thplItems = Nothing
    , _thplSelfLink = Nothing
    , _thplWarning = Nothing
    , _thplId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
thplNextPageToken :: Lens' TargetHTTPSProxyList (Maybe Text)
thplNextPageToken
  = lens _thplNextPageToken
      (\ s a -> s{_thplNextPageToken = a})

-- | Type of resource. Always compute#targetHttpsProxyList for lists of
-- target HTTPS proxies.
thplKind :: Lens' TargetHTTPSProxyList Text
thplKind = lens _thplKind (\ s a -> s{_thplKind = a})

-- | A list of TargetHttpsProxy resources.
thplItems :: Lens' TargetHTTPSProxyList [TargetHTTPSProxy]
thplItems
  = lens _thplItems (\ s a -> s{_thplItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
thplSelfLink :: Lens' TargetHTTPSProxyList (Maybe Text)
thplSelfLink
  = lens _thplSelfLink (\ s a -> s{_thplSelfLink = a})

-- | [Output Only] Informational warning message.
thplWarning :: Lens' TargetHTTPSProxyList (Maybe TargetHTTPSProxyListWarning)
thplWarning
  = lens _thplWarning (\ s a -> s{_thplWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
thplId :: Lens' TargetHTTPSProxyList (Maybe Text)
thplId = lens _thplId (\ s a -> s{_thplId = a})

instance FromJSON TargetHTTPSProxyList where
        parseJSON
          = withObject "TargetHTTPSProxyList"
              (\ o ->
                 TargetHTTPSProxyList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#targetHttpsProxyList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON TargetHTTPSProxyList where
        toJSON TargetHTTPSProxyList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _thplNextPageToken,
                  Just ("kind" .= _thplKind),
                  ("items" .=) <$> _thplItems,
                  ("selfLink" .=) <$> _thplSelfLink,
                  ("warning" .=) <$> _thplWarning,
                  ("id" .=) <$> _thplId])

--
-- /See:/ 'routersScopedList' smart constructor.
data RoutersScopedList =
  RoutersScopedList'
    { _rslRouters :: !(Maybe [Router])
    , _rslWarning :: !(Maybe RoutersScopedListWarning)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RoutersScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rslRouters'
--
-- * 'rslWarning'
routersScopedList
    :: RoutersScopedList
routersScopedList =
  RoutersScopedList' {_rslRouters = Nothing, _rslWarning = Nothing}


-- | A list of routers contained in this scope.
rslRouters :: Lens' RoutersScopedList [Router]
rslRouters
  = lens _rslRouters (\ s a -> s{_rslRouters = a}) .
      _Default
      . _Coerce

-- | Informational warning which replaces the list of routers when the list
-- is empty.
rslWarning :: Lens' RoutersScopedList (Maybe RoutersScopedListWarning)
rslWarning
  = lens _rslWarning (\ s a -> s{_rslWarning = a})

instance FromJSON RoutersScopedList where
        parseJSON
          = withObject "RoutersScopedList"
              (\ o ->
                 RoutersScopedList' <$>
                   (o .:? "routers" .!= mempty) <*> (o .:? "warning"))

instance ToJSON RoutersScopedList where
        toJSON RoutersScopedList'{..}
          = object
              (catMaybes
                 [("routers" .=) <$> _rslRouters,
                  ("warning" .=) <$> _rslWarning])

--
-- /See:/ 'routerStatusResponse' smart constructor.
data RouterStatusResponse =
  RouterStatusResponse'
    { _rsrKind :: !Text
    , _rsrResult :: !(Maybe RouterStatus)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RouterStatusResponse' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rsrKind'
--
-- * 'rsrResult'
routerStatusResponse
    :: RouterStatusResponse
routerStatusResponse =
  RouterStatusResponse'
    {_rsrKind = "compute#routerStatusResponse", _rsrResult = Nothing}


-- | Type of resource.
rsrKind :: Lens' RouterStatusResponse Text
rsrKind = lens _rsrKind (\ s a -> s{_rsrKind = a})

rsrResult :: Lens' RouterStatusResponse (Maybe RouterStatus)
rsrResult
  = lens _rsrResult (\ s a -> s{_rsrResult = a})

instance FromJSON RouterStatusResponse where
        parseJSON
          = withObject "RouterStatusResponse"
              (\ o ->
                 RouterStatusResponse' <$>
                   (o .:? "kind" .!= "compute#routerStatusResponse") <*>
                     (o .:? "result"))

instance ToJSON RouterStatusResponse where
        toJSON RouterStatusResponse'{..}
          = object
              (catMaybes
                 [Just ("kind" .= _rsrKind),
                  ("result" .=) <$> _rsrResult])

--
-- /See:/ 'regionInstanceGroupManagersDeleteInstancesRequest' smart constructor.
newtype RegionInstanceGroupManagersDeleteInstancesRequest =
  RegionInstanceGroupManagersDeleteInstancesRequest'
    { _rigmdirInstances :: Maybe [Text]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupManagersDeleteInstancesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rigmdirInstances'
regionInstanceGroupManagersDeleteInstancesRequest
    :: RegionInstanceGroupManagersDeleteInstancesRequest
regionInstanceGroupManagersDeleteInstancesRequest =
  RegionInstanceGroupManagersDeleteInstancesRequest'
    {_rigmdirInstances = Nothing}


-- | The URLs of one or more instances to delete. This can be a full URL or a
-- partial URL, such as zones\/[ZONE]\/instances\/[INSTANCE_NAME].
rigmdirInstances :: Lens' RegionInstanceGroupManagersDeleteInstancesRequest [Text]
rigmdirInstances
  = lens _rigmdirInstances
      (\ s a -> s{_rigmdirInstances = a})
      . _Default
      . _Coerce

instance FromJSON
           RegionInstanceGroupManagersDeleteInstancesRequest
         where
        parseJSON
          = withObject
              "RegionInstanceGroupManagersDeleteInstancesRequest"
              (\ o ->
                 RegionInstanceGroupManagersDeleteInstancesRequest'
                   <$> (o .:? "instances" .!= mempty))

instance ToJSON
           RegionInstanceGroupManagersDeleteInstancesRequest
         where
        toJSON
          RegionInstanceGroupManagersDeleteInstancesRequest'{..}
          = object
              (catMaybes [("instances" .=) <$> _rigmdirInstances])

--
-- /See:/ 'interconnectDiagnosticsLinkLACPStatus' smart constructor.
data InterconnectDiagnosticsLinkLACPStatus =
  InterconnectDiagnosticsLinkLACPStatus'
    { _idllacpsState :: !(Maybe InterconnectDiagnosticsLinkLACPStatusState)
    , _idllacpsNeighborSystemId :: !(Maybe Text)
    , _idllacpsGoogleSystemId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectDiagnosticsLinkLACPStatus' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'idllacpsState'
--
-- * 'idllacpsNeighborSystemId'
--
-- * 'idllacpsGoogleSystemId'
interconnectDiagnosticsLinkLACPStatus
    :: InterconnectDiagnosticsLinkLACPStatus
interconnectDiagnosticsLinkLACPStatus =
  InterconnectDiagnosticsLinkLACPStatus'
    { _idllacpsState = Nothing
    , _idllacpsNeighborSystemId = Nothing
    , _idllacpsGoogleSystemId = Nothing
    }


-- | The state of a LACP link, which can take one of the following values: -
-- ACTIVE: The link is configured and active within the bundle. - DETACHED:
-- The link is not configured within the bundle. This means that the rest
-- of the object should be empty.
idllacpsState :: Lens' InterconnectDiagnosticsLinkLACPStatus (Maybe InterconnectDiagnosticsLinkLACPStatusState)
idllacpsState
  = lens _idllacpsState
      (\ s a -> s{_idllacpsState = a})

-- | System ID of the port on the neighbor\'s side of the LACP exchange.
idllacpsNeighborSystemId :: Lens' InterconnectDiagnosticsLinkLACPStatus (Maybe Text)
idllacpsNeighborSystemId
  = lens _idllacpsNeighborSystemId
      (\ s a -> s{_idllacpsNeighborSystemId = a})

-- | System ID of the port on Google\'s side of the LACP exchange.
idllacpsGoogleSystemId :: Lens' InterconnectDiagnosticsLinkLACPStatus (Maybe Text)
idllacpsGoogleSystemId
  = lens _idllacpsGoogleSystemId
      (\ s a -> s{_idllacpsGoogleSystemId = a})

instance FromJSON
           InterconnectDiagnosticsLinkLACPStatus
         where
        parseJSON
          = withObject "InterconnectDiagnosticsLinkLACPStatus"
              (\ o ->
                 InterconnectDiagnosticsLinkLACPStatus' <$>
                   (o .:? "state") <*> (o .:? "neighborSystemId") <*>
                     (o .:? "googleSystemId"))

instance ToJSON InterconnectDiagnosticsLinkLACPStatus
         where
        toJSON InterconnectDiagnosticsLinkLACPStatus'{..}
          = object
              (catMaybes
                 [("state" .=) <$> _idllacpsState,
                  ("neighborSystemId" .=) <$>
                    _idllacpsNeighborSystemId,
                  ("googleSystemId" .=) <$> _idllacpsGoogleSystemId])

-- | Specifies options for controlling advanced machine features. Options
-- that would traditionally be configured in a BIOS belong here. Features
-- that require operating system support may have corresponding entries in
-- the GuestOsFeatures of an Image (e.g., whether or not the OS in the
-- Image supports nested virtualization being enabled or disabled).
--
-- /See:/ 'advancedMachineFeatures' smart constructor.
data AdvancedMachineFeatures =
  AdvancedMachineFeatures'
    { _amfThreadsPerCore :: !(Maybe (Textual Int32))
    , _amfEnableNestedVirtualization :: !(Maybe Bool)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AdvancedMachineFeatures' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'amfThreadsPerCore'
--
-- * 'amfEnableNestedVirtualization'
advancedMachineFeatures
    :: AdvancedMachineFeatures
advancedMachineFeatures =
  AdvancedMachineFeatures'
    {_amfThreadsPerCore = Nothing, _amfEnableNestedVirtualization = Nothing}


-- | The number of threads per physical core. To disable simultaneous
-- multithreading (SMT) set this to 1. If unset, the maximum number of
-- threads supported per core by the underlying processor is assumed.
amfThreadsPerCore :: Lens' AdvancedMachineFeatures (Maybe Int32)
amfThreadsPerCore
  = lens _amfThreadsPerCore
      (\ s a -> s{_amfThreadsPerCore = a})
      . mapping _Coerce

-- | Whether to enable nested virtualization or not (default is false).
amfEnableNestedVirtualization :: Lens' AdvancedMachineFeatures (Maybe Bool)
amfEnableNestedVirtualization
  = lens _amfEnableNestedVirtualization
      (\ s a -> s{_amfEnableNestedVirtualization = a})

instance FromJSON AdvancedMachineFeatures where
        parseJSON
          = withObject "AdvancedMachineFeatures"
              (\ o ->
                 AdvancedMachineFeatures' <$>
                   (o .:? "threadsPerCore") <*>
                     (o .:? "enableNestedVirtualization"))

instance ToJSON AdvancedMachineFeatures where
        toJSON AdvancedMachineFeatures'{..}
          = object
              (catMaybes
                 [("threadsPerCore" .=) <$> _amfThreadsPerCore,
                  ("enableNestedVirtualization" .=) <$>
                    _amfEnableNestedVirtualization])

--
-- /See:/ 'addressesScopedList' smart constructor.
data AddressesScopedList =
  AddressesScopedList'
    { _aslAddresses :: !(Maybe [Address])
    , _aslWarning :: !(Maybe AddressesScopedListWarning)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AddressesScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'aslAddresses'
--
-- * 'aslWarning'
addressesScopedList
    :: AddressesScopedList
addressesScopedList =
  AddressesScopedList' {_aslAddresses = Nothing, _aslWarning = Nothing}


-- | [Output Only] A list of addresses contained in this scope.
aslAddresses :: Lens' AddressesScopedList [Address]
aslAddresses
  = lens _aslAddresses (\ s a -> s{_aslAddresses = a})
      . _Default
      . _Coerce

-- | [Output Only] Informational warning which replaces the list of addresses
-- when the list is empty.
aslWarning :: Lens' AddressesScopedList (Maybe AddressesScopedListWarning)
aslWarning
  = lens _aslWarning (\ s a -> s{_aslWarning = a})

instance FromJSON AddressesScopedList where
        parseJSON
          = withObject "AddressesScopedList"
              (\ o ->
                 AddressesScopedList' <$>
                   (o .:? "addresses" .!= mempty) <*> (o .:? "warning"))

instance ToJSON AddressesScopedList where
        toJSON AddressesScopedList'{..}
          = object
              (catMaybes
                 [("addresses" .=) <$> _aslAddresses,
                  ("warning" .=) <$> _aslWarning])

--
-- /See:/ 'operationWarningsItemDataItem' smart constructor.
data OperationWarningsItemDataItem =
  OperationWarningsItemDataItem'
    { _owidiValue :: !(Maybe Text)
    , _owidiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'OperationWarningsItemDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'owidiValue'
--
-- * 'owidiKey'
operationWarningsItemDataItem
    :: OperationWarningsItemDataItem
operationWarningsItemDataItem =
  OperationWarningsItemDataItem' {_owidiValue = Nothing, _owidiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
owidiValue :: Lens' OperationWarningsItemDataItem (Maybe Text)
owidiValue
  = lens _owidiValue (\ s a -> s{_owidiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
owidiKey :: Lens' OperationWarningsItemDataItem (Maybe Text)
owidiKey = lens _owidiKey (\ s a -> s{_owidiKey = a})

instance FromJSON OperationWarningsItemDataItem where
        parseJSON
          = withObject "OperationWarningsItemDataItem"
              (\ o ->
                 OperationWarningsItemDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON OperationWarningsItemDataItem where
        toJSON OperationWarningsItemDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _owidiValue,
                  ("key" .=) <$> _owidiKey])

--
-- /See:/ 'instanceGroupManagerUpdatePolicy' smart constructor.
data InstanceGroupManagerUpdatePolicy =
  InstanceGroupManagerUpdatePolicy'
    { _igmupInstanceRedistributionType :: !(Maybe InstanceGroupManagerUpdatePolicyInstanceRedistributionType)
    , _igmupMaxSurge :: !(Maybe FixedOrPercent)
    , _igmupMaxUnavailable :: !(Maybe FixedOrPercent)
    , _igmupMinimalAction :: !(Maybe InstanceGroupManagerUpdatePolicyMinimalAction)
    , _igmupType :: !(Maybe InstanceGroupManagerUpdatePolicyType)
    , _igmupReplacementMethod :: !(Maybe InstanceGroupManagerUpdatePolicyReplacementMethod)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagerUpdatePolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmupInstanceRedistributionType'
--
-- * 'igmupMaxSurge'
--
-- * 'igmupMaxUnavailable'
--
-- * 'igmupMinimalAction'
--
-- * 'igmupType'
--
-- * 'igmupReplacementMethod'
instanceGroupManagerUpdatePolicy
    :: InstanceGroupManagerUpdatePolicy
instanceGroupManagerUpdatePolicy =
  InstanceGroupManagerUpdatePolicy'
    { _igmupInstanceRedistributionType = Nothing
    , _igmupMaxSurge = Nothing
    , _igmupMaxUnavailable = Nothing
    , _igmupMinimalAction = Nothing
    , _igmupType = Nothing
    , _igmupReplacementMethod = Nothing
    }


-- | The instance redistribution policy for regional managed instance groups.
-- Valid values are: - PROACTIVE (default): The group attempts to maintain
-- an even distribution of VM instances across zones in the region. - NONE:
-- For non-autoscaled groups, proactive redistribution is disabled.
igmupInstanceRedistributionType :: Lens' InstanceGroupManagerUpdatePolicy (Maybe InstanceGroupManagerUpdatePolicyInstanceRedistributionType)
igmupInstanceRedistributionType
  = lens _igmupInstanceRedistributionType
      (\ s a -> s{_igmupInstanceRedistributionType = a})

-- | The maximum number of instances that can be created above the specified
-- targetSize during the update process. This value can be either a fixed
-- number or, if the group has 10 or more instances, a percentage. If you
-- set a percentage, the number of instances is rounded if necessary. The
-- default value for maxSurge is a fixed value equal to the number of zones
-- in which the managed instance group operates. At least one of either
-- maxSurge or maxUnavailable must be greater than 0. Learn more about
-- maxSurge.
igmupMaxSurge :: Lens' InstanceGroupManagerUpdatePolicy (Maybe FixedOrPercent)
igmupMaxSurge
  = lens _igmupMaxSurge
      (\ s a -> s{_igmupMaxSurge = a})

-- | The maximum number of instances that can be unavailable during the
-- update process. An instance is considered available if all of the
-- following conditions are satisfied: - The instance\'s status is RUNNING.
-- - If there is a health check on the instance group, the instance\'s
-- health check status must be HEALTHY at least once. If there is no health
-- check on the group, then the instance only needs to have a status of
-- RUNNING to be considered available. This value can be either a fixed
-- number or, if the group has 10 or more instances, a percentage. If you
-- set a percentage, the number of instances is rounded if necessary. The
-- default value for maxUnavailable is a fixed value equal to the number of
-- zones in which the managed instance group operates. At least one of
-- either maxSurge or maxUnavailable must be greater than 0. Learn more
-- about maxUnavailable.
igmupMaxUnavailable :: Lens' InstanceGroupManagerUpdatePolicy (Maybe FixedOrPercent)
igmupMaxUnavailable
  = lens _igmupMaxUnavailable
      (\ s a -> s{_igmupMaxUnavailable = a})

-- | Minimal action to be taken on an instance. You can specify either
-- RESTART to restart existing instances or REPLACE to delete and create
-- new instances from the target template. If you specify a RESTART, the
-- Updater will attempt to perform that action only. However, if the
-- Updater determines that the minimal action you specify is not enough to
-- perform the update, it might perform a more disruptive action.
igmupMinimalAction :: Lens' InstanceGroupManagerUpdatePolicy (Maybe InstanceGroupManagerUpdatePolicyMinimalAction)
igmupMinimalAction
  = lens _igmupMinimalAction
      (\ s a -> s{_igmupMinimalAction = a})

-- | The type of update process. You can specify either PROACTIVE so that the
-- instance group manager proactively executes actions in order to bring
-- instances to their target versions or OPPORTUNISTIC so that no action is
-- proactively executed but the update will be performed as part of other
-- actions (for example, resizes or recreateInstances calls).
igmupType :: Lens' InstanceGroupManagerUpdatePolicy (Maybe InstanceGroupManagerUpdatePolicyType)
igmupType
  = lens _igmupType (\ s a -> s{_igmupType = a})

-- | What action should be used to replace instances. See
-- minimal_action.REPLACE
igmupReplacementMethod :: Lens' InstanceGroupManagerUpdatePolicy (Maybe InstanceGroupManagerUpdatePolicyReplacementMethod)
igmupReplacementMethod
  = lens _igmupReplacementMethod
      (\ s a -> s{_igmupReplacementMethod = a})

instance FromJSON InstanceGroupManagerUpdatePolicy
         where
        parseJSON
          = withObject "InstanceGroupManagerUpdatePolicy"
              (\ o ->
                 InstanceGroupManagerUpdatePolicy' <$>
                   (o .:? "instanceRedistributionType") <*>
                     (o .:? "maxSurge")
                     <*> (o .:? "maxUnavailable")
                     <*> (o .:? "minimalAction")
                     <*> (o .:? "type")
                     <*> (o .:? "replacementMethod"))

instance ToJSON InstanceGroupManagerUpdatePolicy
         where
        toJSON InstanceGroupManagerUpdatePolicy'{..}
          = object
              (catMaybes
                 [("instanceRedistributionType" .=) <$>
                    _igmupInstanceRedistributionType,
                  ("maxSurge" .=) <$> _igmupMaxSurge,
                  ("maxUnavailable" .=) <$> _igmupMaxUnavailable,
                  ("minimalAction" .=) <$> _igmupMinimalAction,
                  ("type" .=) <$> _igmupType,
                  ("replacementMethod" .=) <$>
                    _igmupReplacementMethod])

--
-- /See:/ 'regionInstanceGroupsListInstancesRequest' smart constructor.
data RegionInstanceGroupsListInstancesRequest =
  RegionInstanceGroupsListInstancesRequest'
    { _riglirInstanceState :: !(Maybe RegionInstanceGroupsListInstancesRequestInstanceState)
    , _riglirPortName :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupsListInstancesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'riglirInstanceState'
--
-- * 'riglirPortName'
regionInstanceGroupsListInstancesRequest
    :: RegionInstanceGroupsListInstancesRequest
regionInstanceGroupsListInstancesRequest =
  RegionInstanceGroupsListInstancesRequest'
    {_riglirInstanceState = Nothing, _riglirPortName = Nothing}


-- | Instances in which state should be returned. Valid options are: \'ALL\',
-- \'RUNNING\'. By default, it lists all instances.
riglirInstanceState :: Lens' RegionInstanceGroupsListInstancesRequest (Maybe RegionInstanceGroupsListInstancesRequestInstanceState)
riglirInstanceState
  = lens _riglirInstanceState
      (\ s a -> s{_riglirInstanceState = a})

-- | Name of port user is interested in. It is optional. If it is set, only
-- information about this ports will be returned. If it is not set, all the
-- named ports will be returned. Always lists all instances.
riglirPortName :: Lens' RegionInstanceGroupsListInstancesRequest (Maybe Text)
riglirPortName
  = lens _riglirPortName
      (\ s a -> s{_riglirPortName = a})

instance FromJSON
           RegionInstanceGroupsListInstancesRequest
         where
        parseJSON
          = withObject
              "RegionInstanceGroupsListInstancesRequest"
              (\ o ->
                 RegionInstanceGroupsListInstancesRequest' <$>
                   (o .:? "instanceState") <*> (o .:? "portName"))

instance ToJSON
           RegionInstanceGroupsListInstancesRequest
         where
        toJSON RegionInstanceGroupsListInstancesRequest'{..}
          = object
              (catMaybes
                 [("instanceState" .=) <$> _riglirInstanceState,
                  ("portName" .=) <$> _riglirPortName])

-- | matchRule criteria for request header matches.
--
-- /See:/ 'hTTPHeaderMatch' smart constructor.
data HTTPHeaderMatch =
  HTTPHeaderMatch'
    { _httphmSuffixMatch :: !(Maybe Text)
    , _httphmHeaderName :: !(Maybe Text)
    , _httphmRangeMatch :: !(Maybe Int64RangeMatch)
    , _httphmPresentMatch :: !(Maybe Bool)
    , _httphmExactMatch :: !(Maybe Text)
    , _httphmPrefixMatch :: !(Maybe Text)
    , _httphmRegexMatch :: !(Maybe Text)
    , _httphmInvertMatch :: !(Maybe Bool)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HTTPHeaderMatch' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'httphmSuffixMatch'
--
-- * 'httphmHeaderName'
--
-- * 'httphmRangeMatch'
--
-- * 'httphmPresentMatch'
--
-- * 'httphmExactMatch'
--
-- * 'httphmPrefixMatch'
--
-- * 'httphmRegexMatch'
--
-- * 'httphmInvertMatch'
hTTPHeaderMatch
    :: HTTPHeaderMatch
hTTPHeaderMatch =
  HTTPHeaderMatch'
    { _httphmSuffixMatch = Nothing
    , _httphmHeaderName = Nothing
    , _httphmRangeMatch = Nothing
    , _httphmPresentMatch = Nothing
    , _httphmExactMatch = Nothing
    , _httphmPrefixMatch = Nothing
    , _httphmRegexMatch = Nothing
    , _httphmInvertMatch = Nothing
    }


-- | The value of the header must end with the contents of suffixMatch. Only
-- one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
-- rangeMatch must be set.
httphmSuffixMatch :: Lens' HTTPHeaderMatch (Maybe Text)
httphmSuffixMatch
  = lens _httphmSuffixMatch
      (\ s a -> s{_httphmSuffixMatch = a})

-- | The name of the HTTP header to match. For matching against the HTTP
-- request\'s authority, use a headerMatch with the header name
-- \":authority\". For matching a request\'s method, use the headerName
-- \":method\". When the URL map is bound to target gRPC proxy that has
-- validateForProxyless field set to true, only non-binary user-specified
-- custom metadata and the \`content-type\` header are supported. The
-- following transport-level headers cannot be used in header matching
-- rules: \`:authority\`, \`:method\`, \`:path\`, \`:scheme\`,
-- \`user-agent\`, \`accept-encoding\`, \`content-encoding\`,
-- \`grpc-accept-encoding\`, \`grpc-encoding\`,
-- \`grpc-previous-rpc-attempts\`, \`grpc-tags-bin\`, \`grpc-timeout\` and
-- \`grpc-trace-bin.
httphmHeaderName :: Lens' HTTPHeaderMatch (Maybe Text)
httphmHeaderName
  = lens _httphmHeaderName
      (\ s a -> s{_httphmHeaderName = a})

-- | The header value must be an integer and its value must be in the range
-- specified in rangeMatch. If the header does not contain an integer,
-- number or is empty, the match fails. For example for a range [-5, 0] -
-- -3 will match. - 0 will not match. - 0.25 will not match. - -3someString
-- will not match. Only one of exactMatch, prefixMatch, suffixMatch,
-- regexMatch, presentMatch or rangeMatch must be set. Note that rangeMatch
-- is not supported for Loadbalancers that have their loadBalancingScheme
-- set to EXTERNAL.
httphmRangeMatch :: Lens' HTTPHeaderMatch (Maybe Int64RangeMatch)
httphmRangeMatch
  = lens _httphmRangeMatch
      (\ s a -> s{_httphmRangeMatch = a})

-- | A header with the contents of headerName must exist. The match takes
-- place whether or not the request\'s header has a value. Only one of
-- exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
-- rangeMatch must be set.
httphmPresentMatch :: Lens' HTTPHeaderMatch (Maybe Bool)
httphmPresentMatch
  = lens _httphmPresentMatch
      (\ s a -> s{_httphmPresentMatch = a})

-- | The value should exactly match contents of exactMatch. Only one of
-- exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or
-- rangeMatch must be set.
httphmExactMatch :: Lens' HTTPHeaderMatch (Maybe Text)
httphmExactMatch
  = lens _httphmExactMatch
      (\ s a -> s{_httphmExactMatch = a})

-- | The value of the header must start with the contents of prefixMatch.
-- Only one of exactMatch, prefixMatch, suffixMatch, regexMatch,
-- presentMatch or rangeMatch must be set.
httphmPrefixMatch :: Lens' HTTPHeaderMatch (Maybe Text)
httphmPrefixMatch
  = lens _httphmPrefixMatch
      (\ s a -> s{_httphmPrefixMatch = a})

-- | The value of the header must match the regular expression specified in
-- regexMatch. For regular expression grammar, please see:
-- github.com\/google\/re2\/wiki\/Syntax For matching against a port
-- specified in the HTTP request, use a headerMatch with headerName set to
-- PORT and a regular expression that satisfies the RFC2616 Host header\'s
-- port specifier. Only one of exactMatch, prefixMatch, suffixMatch,
-- regexMatch, presentMatch or rangeMatch must be set. Note that regexMatch
-- only applies to Loadbalancers that have their loadBalancingScheme set to
-- INTERNAL_SELF_MANAGED.
httphmRegexMatch :: Lens' HTTPHeaderMatch (Maybe Text)
httphmRegexMatch
  = lens _httphmRegexMatch
      (\ s a -> s{_httphmRegexMatch = a})

-- | If set to false, the headerMatch is considered a match if the match
-- criteria above are met. If set to true, the headerMatch is considered a
-- match if the match criteria above are NOT met. The default setting is
-- false.
httphmInvertMatch :: Lens' HTTPHeaderMatch (Maybe Bool)
httphmInvertMatch
  = lens _httphmInvertMatch
      (\ s a -> s{_httphmInvertMatch = a})

instance FromJSON HTTPHeaderMatch where
        parseJSON
          = withObject "HTTPHeaderMatch"
              (\ o ->
                 HTTPHeaderMatch' <$>
                   (o .:? "suffixMatch") <*> (o .:? "headerName") <*>
                     (o .:? "rangeMatch")
                     <*> (o .:? "presentMatch")
                     <*> (o .:? "exactMatch")
                     <*> (o .:? "prefixMatch")
                     <*> (o .:? "regexMatch")
                     <*> (o .:? "invertMatch"))

instance ToJSON HTTPHeaderMatch where
        toJSON HTTPHeaderMatch'{..}
          = object
              (catMaybes
                 [("suffixMatch" .=) <$> _httphmSuffixMatch,
                  ("headerName" .=) <$> _httphmHeaderName,
                  ("rangeMatch" .=) <$> _httphmRangeMatch,
                  ("presentMatch" .=) <$> _httphmPresentMatch,
                  ("exactMatch" .=) <$> _httphmExactMatch,
                  ("prefixMatch" .=) <$> _httphmPrefixMatch,
                  ("regexMatch" .=) <$> _httphmRegexMatch,
                  ("invertMatch" .=) <$> _httphmInvertMatch])

-- | Informational warning which replaces the list of packetMirrorings when
-- the list is empty.
--
-- /See:/ 'packetMirroringsScopedListWarning' smart constructor.
data PacketMirroringsScopedListWarning =
  PacketMirroringsScopedListWarning'
    { _pmslwData :: !(Maybe [PacketMirroringsScopedListWarningDataItem])
    , _pmslwCode :: !(Maybe PacketMirroringsScopedListWarningCode)
    , _pmslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PacketMirroringsScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pmslwData'
--
-- * 'pmslwCode'
--
-- * 'pmslwMessage'
packetMirroringsScopedListWarning
    :: PacketMirroringsScopedListWarning
packetMirroringsScopedListWarning =
  PacketMirroringsScopedListWarning'
    {_pmslwData = Nothing, _pmslwCode = Nothing, _pmslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
pmslwData :: Lens' PacketMirroringsScopedListWarning [PacketMirroringsScopedListWarningDataItem]
pmslwData
  = lens _pmslwData (\ s a -> s{_pmslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
pmslwCode :: Lens' PacketMirroringsScopedListWarning (Maybe PacketMirroringsScopedListWarningCode)
pmslwCode
  = lens _pmslwCode (\ s a -> s{_pmslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
pmslwMessage :: Lens' PacketMirroringsScopedListWarning (Maybe Text)
pmslwMessage
  = lens _pmslwMessage (\ s a -> s{_pmslwMessage = a})

instance FromJSON PacketMirroringsScopedListWarning
         where
        parseJSON
          = withObject "PacketMirroringsScopedListWarning"
              (\ o ->
                 PacketMirroringsScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON PacketMirroringsScopedListWarning
         where
        toJSON PacketMirroringsScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _pmslwData,
                  ("code" .=) <$> _pmslwCode,
                  ("message" .=) <$> _pmslwMessage])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'backendServiceAggregatedListWarning' smart constructor.
data BackendServiceAggregatedListWarning =
  BackendServiceAggregatedListWarning'
    { _bsalwData :: !(Maybe [BackendServiceAggregatedListWarningDataItem])
    , _bsalwCode :: !(Maybe BackendServiceAggregatedListWarningCode)
    , _bsalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendServiceAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bsalwData'
--
-- * 'bsalwCode'
--
-- * 'bsalwMessage'
backendServiceAggregatedListWarning
    :: BackendServiceAggregatedListWarning
backendServiceAggregatedListWarning =
  BackendServiceAggregatedListWarning'
    {_bsalwData = Nothing, _bsalwCode = Nothing, _bsalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
bsalwData :: Lens' BackendServiceAggregatedListWarning [BackendServiceAggregatedListWarningDataItem]
bsalwData
  = lens _bsalwData (\ s a -> s{_bsalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
bsalwCode :: Lens' BackendServiceAggregatedListWarning (Maybe BackendServiceAggregatedListWarningCode)
bsalwCode
  = lens _bsalwCode (\ s a -> s{_bsalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
bsalwMessage :: Lens' BackendServiceAggregatedListWarning (Maybe Text)
bsalwMessage
  = lens _bsalwMessage (\ s a -> s{_bsalwMessage = a})

instance FromJSON BackendServiceAggregatedListWarning
         where
        parseJSON
          = withObject "BackendServiceAggregatedListWarning"
              (\ o ->
                 BackendServiceAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON BackendServiceAggregatedListWarning
         where
        toJSON BackendServiceAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _bsalwData,
                  ("code" .=) <$> _bsalwCode,
                  ("message" .=) <$> _bsalwMessage])

--
-- /See:/ 'exchangedPeeringRoute' smart constructor.
data ExchangedPeeringRoute =
  ExchangedPeeringRoute'
    { _eprImported :: !(Maybe Bool)
    , _eprPriority :: !(Maybe (Textual Word32))
    , _eprDestRange :: !(Maybe Text)
    , _eprNextHopRegion :: !(Maybe Text)
    , _eprType :: !(Maybe ExchangedPeeringRouteType)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ExchangedPeeringRoute' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'eprImported'
--
-- * 'eprPriority'
--
-- * 'eprDestRange'
--
-- * 'eprNextHopRegion'
--
-- * 'eprType'
exchangedPeeringRoute
    :: ExchangedPeeringRoute
exchangedPeeringRoute =
  ExchangedPeeringRoute'
    { _eprImported = Nothing
    , _eprPriority = Nothing
    , _eprDestRange = Nothing
    , _eprNextHopRegion = Nothing
    , _eprType = Nothing
    }


-- | True if the peering route has been imported from a peer. The actual
-- import happens if the field networkPeering.importCustomRoutes is true
-- for this network, and networkPeering.exportCustomRoutes is true for the
-- peer network, and the import does not result in a route conflict.
eprImported :: Lens' ExchangedPeeringRoute (Maybe Bool)
eprImported
  = lens _eprImported (\ s a -> s{_eprImported = a})

-- | The priority of the peering route.
eprPriority :: Lens' ExchangedPeeringRoute (Maybe Word32)
eprPriority
  = lens _eprPriority (\ s a -> s{_eprPriority = a}) .
      mapping _Coerce

-- | The destination range of the route.
eprDestRange :: Lens' ExchangedPeeringRoute (Maybe Text)
eprDestRange
  = lens _eprDestRange (\ s a -> s{_eprDestRange = a})

-- | The region of peering route next hop, only applies to dynamic routes.
eprNextHopRegion :: Lens' ExchangedPeeringRoute (Maybe Text)
eprNextHopRegion
  = lens _eprNextHopRegion
      (\ s a -> s{_eprNextHopRegion = a})

-- | The type of the peering route.
eprType :: Lens' ExchangedPeeringRoute (Maybe ExchangedPeeringRouteType)
eprType = lens _eprType (\ s a -> s{_eprType = a})

instance FromJSON ExchangedPeeringRoute where
        parseJSON
          = withObject "ExchangedPeeringRoute"
              (\ o ->
                 ExchangedPeeringRoute' <$>
                   (o .:? "imported") <*> (o .:? "priority") <*>
                     (o .:? "destRange")
                     <*> (o .:? "nextHopRegion")
                     <*> (o .:? "type"))

instance ToJSON ExchangedPeeringRoute where
        toJSON ExchangedPeeringRoute'{..}
          = object
              (catMaybes
                 [("imported" .=) <$> _eprImported,
                  ("priority" .=) <$> _eprPriority,
                  ("destRange" .=) <$> _eprDestRange,
                  ("nextHopRegion" .=) <$> _eprNextHopRegion,
                  ("type" .=) <$> _eprType])

-- | Represents an SSL Policy resource. Use SSL policies to control the SSL
-- features, such as versions and cipher suites, offered by an HTTPS or SSL
-- Proxy load balancer. For more information, read SSL Policy Concepts. (==
-- resource_for {$api_version}.sslPolicies ==)
--
-- /See:/ 'sslPolicy' smart constructor.
data SSLPolicy =
  SSLPolicy'
    { _spKind :: !Text
    , _spFingerprint :: !(Maybe Bytes)
    , _spProFile :: !(Maybe SSLPolicyProFile)
    , _spWarnings :: !(Maybe [SSLPolicyWarningsItem])
    , _spCustomFeatures :: !(Maybe [Text])
    , _spSelfLink :: !(Maybe Text)
    , _spName :: !(Maybe Text)
    , _spCreationTimestamp :: !(Maybe Text)
    , _spEnabledFeatures :: !(Maybe [Text])
    , _spId :: !(Maybe (Textual Word64))
    , _spMinTLSVersion :: !(Maybe SSLPolicyMinTLSVersion)
    , _spDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SSLPolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'spKind'
--
-- * 'spFingerprint'
--
-- * 'spProFile'
--
-- * 'spWarnings'
--
-- * 'spCustomFeatures'
--
-- * 'spSelfLink'
--
-- * 'spName'
--
-- * 'spCreationTimestamp'
--
-- * 'spEnabledFeatures'
--
-- * 'spId'
--
-- * 'spMinTLSVersion'
--
-- * 'spDescription'
sslPolicy
    :: SSLPolicy
sslPolicy =
  SSLPolicy'
    { _spKind = "compute#sslPolicy"
    , _spFingerprint = Nothing
    , _spProFile = Nothing
    , _spWarnings = Nothing
    , _spCustomFeatures = Nothing
    , _spSelfLink = Nothing
    , _spName = Nothing
    , _spCreationTimestamp = Nothing
    , _spEnabledFeatures = Nothing
    , _spId = Nothing
    , _spMinTLSVersion = Nothing
    , _spDescription = Nothing
    }


-- | [Output only] Type of the resource. Always compute#sslPolicyfor SSL
-- policies.
spKind :: Lens' SSLPolicy Text
spKind = lens _spKind (\ s a -> s{_spKind = a})

-- | Fingerprint of this resource. A hash of the contents stored in this
-- object. This field is used in optimistic locking. This field will be
-- ignored when inserting a SslPolicy. An up-to-date fingerprint must be
-- provided in order to update the SslPolicy, otherwise the request will
-- fail with error 412 conditionNotMet. To see the latest fingerprint, make
-- a get() request to retrieve an SslPolicy.
spFingerprint :: Lens' SSLPolicy (Maybe ByteString)
spFingerprint
  = lens _spFingerprint
      (\ s a -> s{_spFingerprint = a})
      . mapping _Bytes

-- | Profile specifies the set of SSL features that can be used by the load
-- balancer when negotiating SSL with clients. This can be one of
-- COMPATIBLE, MODERN, RESTRICTED, or CUSTOM. If using CUSTOM, the set of
-- SSL features to enable must be specified in the customFeatures field.
spProFile :: Lens' SSLPolicy (Maybe SSLPolicyProFile)
spProFile
  = lens _spProFile (\ s a -> s{_spProFile = a})

-- | [Output Only] If potential misconfigurations are detected for this SSL
-- policy, this field will be populated with warning messages.
spWarnings :: Lens' SSLPolicy [SSLPolicyWarningsItem]
spWarnings
  = lens _spWarnings (\ s a -> s{_spWarnings = a}) .
      _Default
      . _Coerce

-- | A list of features enabled when the selected profile is CUSTOM. The -
-- method returns the set of features that can be specified in this list.
-- This field must be empty if the profile is not CUSTOM.
spCustomFeatures :: Lens' SSLPolicy [Text]
spCustomFeatures
  = lens _spCustomFeatures
      (\ s a -> s{_spCustomFeatures = a})
      . _Default
      . _Coerce

-- | [Output Only] Server-defined URL for the resource.
spSelfLink :: Lens' SSLPolicy (Maybe Text)
spSelfLink
  = lens _spSelfLink (\ s a -> s{_spSelfLink = a})

-- | Name of the resource. The name must be 1-63 characters long, and comply
-- with RFC1035. Specifically, the name must be 1-63 characters long and
-- match the regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means
-- the first character must be a lowercase letter, and all following
-- characters must be a dash, lowercase letter, or digit, except the last
-- character, which cannot be a dash.
spName :: Lens' SSLPolicy (Maybe Text)
spName = lens _spName (\ s a -> s{_spName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
spCreationTimestamp :: Lens' SSLPolicy (Maybe Text)
spCreationTimestamp
  = lens _spCreationTimestamp
      (\ s a -> s{_spCreationTimestamp = a})

-- | [Output Only] The list of features enabled in the SSL policy.
spEnabledFeatures :: Lens' SSLPolicy [Text]
spEnabledFeatures
  = lens _spEnabledFeatures
      (\ s a -> s{_spEnabledFeatures = a})
      . _Default
      . _Coerce

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
spId :: Lens' SSLPolicy (Maybe Word64)
spId
  = lens _spId (\ s a -> s{_spId = a}) .
      mapping _Coerce

-- | The minimum version of SSL protocol that can be used by the clients to
-- establish a connection with the load balancer. This can be one of
-- TLS_1_0, TLS_1_1, TLS_1_2.
spMinTLSVersion :: Lens' SSLPolicy (Maybe SSLPolicyMinTLSVersion)
spMinTLSVersion
  = lens _spMinTLSVersion
      (\ s a -> s{_spMinTLSVersion = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource.
spDescription :: Lens' SSLPolicy (Maybe Text)
spDescription
  = lens _spDescription
      (\ s a -> s{_spDescription = a})

instance FromJSON SSLPolicy where
        parseJSON
          = withObject "SSLPolicy"
              (\ o ->
                 SSLPolicy' <$>
                   (o .:? "kind" .!= "compute#sslPolicy") <*>
                     (o .:? "fingerprint")
                     <*> (o .:? "profile")
                     <*> (o .:? "warnings" .!= mempty)
                     <*> (o .:? "customFeatures" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "enabledFeatures" .!= mempty)
                     <*> (o .:? "id")
                     <*> (o .:? "minTlsVersion")
                     <*> (o .:? "description"))

instance ToJSON SSLPolicy where
        toJSON SSLPolicy'{..}
          = object
              (catMaybes
                 [Just ("kind" .= _spKind),
                  ("fingerprint" .=) <$> _spFingerprint,
                  ("profile" .=) <$> _spProFile,
                  ("warnings" .=) <$> _spWarnings,
                  ("customFeatures" .=) <$> _spCustomFeatures,
                  ("selfLink" .=) <$> _spSelfLink,
                  ("name" .=) <$> _spName,
                  ("creationTimestamp" .=) <$> _spCreationTimestamp,
                  ("enabledFeatures" .=) <$> _spEnabledFeatures,
                  ("id" .=) <$> _spId,
                  ("minTlsVersion" .=) <$> _spMinTLSVersion,
                  ("description" .=) <$> _spDescription])

--
-- /See:/ 'backendServiceListWarningDataItem' smart constructor.
data BackendServiceListWarningDataItem =
  BackendServiceListWarningDataItem'
    { _bslwdiValue :: !(Maybe Text)
    , _bslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendServiceListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bslwdiValue'
--
-- * 'bslwdiKey'
backendServiceListWarningDataItem
    :: BackendServiceListWarningDataItem
backendServiceListWarningDataItem =
  BackendServiceListWarningDataItem'
    {_bslwdiValue = Nothing, _bslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
bslwdiValue :: Lens' BackendServiceListWarningDataItem (Maybe Text)
bslwdiValue
  = lens _bslwdiValue (\ s a -> s{_bslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
bslwdiKey :: Lens' BackendServiceListWarningDataItem (Maybe Text)
bslwdiKey
  = lens _bslwdiKey (\ s a -> s{_bslwdiKey = a})

instance FromJSON BackendServiceListWarningDataItem
         where
        parseJSON
          = withObject "BackendServiceListWarningDataItem"
              (\ o ->
                 BackendServiceListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON BackendServiceListWarningDataItem
         where
        toJSON BackendServiceListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _bslwdiValue,
                  ("key" .=) <$> _bslwdiKey])

--
-- /See:/ 'firewallDeniedItem' smart constructor.
data FirewallDeniedItem =
  FirewallDeniedItem'
    { _fdiIPProtocol :: !(Maybe Text)
    , _fdiPorts :: !(Maybe [Text])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'FirewallDeniedItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'fdiIPProtocol'
--
-- * 'fdiPorts'
firewallDeniedItem
    :: FirewallDeniedItem
firewallDeniedItem =
  FirewallDeniedItem' {_fdiIPProtocol = Nothing, _fdiPorts = Nothing}


-- | The IP protocol to which this rule applies. The protocol type is
-- required when creating a firewall rule. This value can either be one of
-- the following well known protocol strings (tcp, udp, icmp, esp, ah,
-- ipip, sctp) or the IP protocol number.
fdiIPProtocol :: Lens' FirewallDeniedItem (Maybe Text)
fdiIPProtocol
  = lens _fdiIPProtocol
      (\ s a -> s{_fdiIPProtocol = a})

-- | An optional list of ports to which this rule applies. This field is only
-- applicable for the UDP or TCP protocol. Each entry must be either an
-- integer or a range. If not specified, this rule applies to connections
-- through any port. Example inputs include: [\"22\"], [\"80\",\"443\"],
-- and [\"12345-12349\"].
fdiPorts :: Lens' FirewallDeniedItem [Text]
fdiPorts
  = lens _fdiPorts (\ s a -> s{_fdiPorts = a}) .
      _Default
      . _Coerce

instance FromJSON FirewallDeniedItem where
        parseJSON
          = withObject "FirewallDeniedItem"
              (\ o ->
                 FirewallDeniedItem' <$>
                   (o .:? "IPProtocol") <*> (o .:? "ports" .!= mempty))

instance ToJSON FirewallDeniedItem where
        toJSON FirewallDeniedItem'{..}
          = object
              (catMaybes
                 [("IPProtocol" .=) <$> _fdiIPProtocol,
                  ("ports" .=) <$> _fdiPorts])

--
-- /See:/ 'instanceGroupManagersAbandonInstancesRequest' smart constructor.
newtype InstanceGroupManagersAbandonInstancesRequest =
  InstanceGroupManagersAbandonInstancesRequest'
    { _igmairInstances :: Maybe [Text]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagersAbandonInstancesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmairInstances'
instanceGroupManagersAbandonInstancesRequest
    :: InstanceGroupManagersAbandonInstancesRequest
instanceGroupManagersAbandonInstancesRequest =
  InstanceGroupManagersAbandonInstancesRequest' {_igmairInstances = Nothing}


-- | The URLs of one or more instances to abandon. This can be a full URL or
-- a partial URL, such as zones\/[ZONE]\/instances\/[INSTANCE_NAME].
igmairInstances :: Lens' InstanceGroupManagersAbandonInstancesRequest [Text]
igmairInstances
  = lens _igmairInstances
      (\ s a -> s{_igmairInstances = a})
      . _Default
      . _Coerce

instance FromJSON
           InstanceGroupManagersAbandonInstancesRequest
         where
        parseJSON
          = withObject
              "InstanceGroupManagersAbandonInstancesRequest"
              (\ o ->
                 InstanceGroupManagersAbandonInstancesRequest' <$>
                   (o .:? "instances" .!= mempty))

instance ToJSON
           InstanceGroupManagersAbandonInstancesRequest
         where
        toJSON
          InstanceGroupManagersAbandonInstancesRequest'{..}
          = object
              (catMaybes [("instances" .=) <$> _igmairInstances])

-- | A list of MachineTypesScopedList resources.
--
-- /See:/ 'machineTypeAggregatedListItems' smart constructor.
newtype MachineTypeAggregatedListItems =
  MachineTypeAggregatedListItems'
    { _mtaliAddtional :: HashMap Text MachineTypesScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'MachineTypeAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'mtaliAddtional'
machineTypeAggregatedListItems
    :: HashMap Text MachineTypesScopedList -- ^ 'mtaliAddtional'
    -> MachineTypeAggregatedListItems
machineTypeAggregatedListItems pMtaliAddtional_ =
  MachineTypeAggregatedListItems' {_mtaliAddtional = _Coerce # pMtaliAddtional_}


-- | [Output Only] Name of the scope containing this set of machine types.
mtaliAddtional :: Lens' MachineTypeAggregatedListItems (HashMap Text MachineTypesScopedList)
mtaliAddtional
  = lens _mtaliAddtional
      (\ s a -> s{_mtaliAddtional = a})
      . _Coerce

instance FromJSON MachineTypeAggregatedListItems
         where
        parseJSON
          = withObject "MachineTypeAggregatedListItems"
              (\ o ->
                 MachineTypeAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON MachineTypeAggregatedListItems where
        toJSON = toJSON . _mtaliAddtional

-- | A list of TargetHttpProxiesScopedList resources.
--
-- /See:/ 'targetHTTPProxyAggregatedListItems' smart constructor.
newtype TargetHTTPProxyAggregatedListItems =
  TargetHTTPProxyAggregatedListItems'
    { _thttppaliAddtional :: HashMap Text TargetHTTPProxiesScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetHTTPProxyAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'thttppaliAddtional'
targetHTTPProxyAggregatedListItems
    :: HashMap Text TargetHTTPProxiesScopedList -- ^ 'thttppaliAddtional'
    -> TargetHTTPProxyAggregatedListItems
targetHTTPProxyAggregatedListItems pThttppaliAddtional_ =
  TargetHTTPProxyAggregatedListItems'
    {_thttppaliAddtional = _Coerce # pThttppaliAddtional_}


-- | Name of the scope containing this set of TargetHttpProxies.
thttppaliAddtional :: Lens' TargetHTTPProxyAggregatedListItems (HashMap Text TargetHTTPProxiesScopedList)
thttppaliAddtional
  = lens _thttppaliAddtional
      (\ s a -> s{_thttppaliAddtional = a})
      . _Coerce

instance FromJSON TargetHTTPProxyAggregatedListItems
         where
        parseJSON
          = withObject "TargetHTTPProxyAggregatedListItems"
              (\ o ->
                 TargetHTTPProxyAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON TargetHTTPProxyAggregatedListItems
         where
        toJSON = toJSON . _thttppaliAddtional

-- | A list of DiskTypesScopedList resources.
--
-- /See:/ 'diskTypeAggregatedListItems' smart constructor.
newtype DiskTypeAggregatedListItems =
  DiskTypeAggregatedListItems'
    { _dtaliAddtional :: HashMap Text DiskTypesScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DiskTypeAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dtaliAddtional'
diskTypeAggregatedListItems
    :: HashMap Text DiskTypesScopedList -- ^ 'dtaliAddtional'
    -> DiskTypeAggregatedListItems
diskTypeAggregatedListItems pDtaliAddtional_ =
  DiskTypeAggregatedListItems' {_dtaliAddtional = _Coerce # pDtaliAddtional_}


-- | [Output Only] Name of the scope containing this set of disk types.
dtaliAddtional :: Lens' DiskTypeAggregatedListItems (HashMap Text DiskTypesScopedList)
dtaliAddtional
  = lens _dtaliAddtional
      (\ s a -> s{_dtaliAddtional = a})
      . _Coerce

instance FromJSON DiskTypeAggregatedListItems where
        parseJSON
          = withObject "DiskTypeAggregatedListItems"
              (\ o ->
                 DiskTypeAggregatedListItems' <$> (parseJSONObject o))

instance ToJSON DiskTypeAggregatedListItems where
        toJSON = toJSON . _dtaliAddtional

--
-- /See:/ 'instancesSetLabelsRequest' smart constructor.
data InstancesSetLabelsRequest =
  InstancesSetLabelsRequest'
    { _islrLabels :: !(Maybe InstancesSetLabelsRequestLabels)
    , _islrLabelFingerprint :: !(Maybe Bytes)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstancesSetLabelsRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'islrLabels'
--
-- * 'islrLabelFingerprint'
instancesSetLabelsRequest
    :: InstancesSetLabelsRequest
instancesSetLabelsRequest =
  InstancesSetLabelsRequest'
    {_islrLabels = Nothing, _islrLabelFingerprint = Nothing}


islrLabels :: Lens' InstancesSetLabelsRequest (Maybe InstancesSetLabelsRequestLabels)
islrLabels
  = lens _islrLabels (\ s a -> s{_islrLabels = a})

-- | Fingerprint of the previous set of labels for this resource, used to
-- prevent conflicts. Provide the latest fingerprint value when making a
-- request to add or change labels.
islrLabelFingerprint :: Lens' InstancesSetLabelsRequest (Maybe ByteString)
islrLabelFingerprint
  = lens _islrLabelFingerprint
      (\ s a -> s{_islrLabelFingerprint = a})
      . mapping _Bytes

instance FromJSON InstancesSetLabelsRequest where
        parseJSON
          = withObject "InstancesSetLabelsRequest"
              (\ o ->
                 InstancesSetLabelsRequest' <$>
                   (o .:? "labels") <*> (o .:? "labelFingerprint"))

instance ToJSON InstancesSetLabelsRequest where
        toJSON InstancesSetLabelsRequest'{..}
          = object
              (catMaybes
                 [("labels" .=) <$> _islrLabels,
                  ("labelFingerprint" .=) <$> _islrLabelFingerprint])

-- | Contains a list of routers.
--
-- /See:/ 'routerAggregatedList' smart constructor.
data RouterAggregatedList =
  RouterAggregatedList'
    { _ralUnreachables :: !(Maybe [Text])
    , _ralNextPageToken :: !(Maybe Text)
    , _ralKind :: !Text
    , _ralItems :: !(Maybe RouterAggregatedListItems)
    , _ralSelfLink :: !(Maybe Text)
    , _ralWarning :: !(Maybe RouterAggregatedListWarning)
    , _ralId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RouterAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ralUnreachables'
--
-- * 'ralNextPageToken'
--
-- * 'ralKind'
--
-- * 'ralItems'
--
-- * 'ralSelfLink'
--
-- * 'ralWarning'
--
-- * 'ralId'
routerAggregatedList
    :: RouterAggregatedList
routerAggregatedList =
  RouterAggregatedList'
    { _ralUnreachables = Nothing
    , _ralNextPageToken = Nothing
    , _ralKind = "compute#routerAggregatedList"
    , _ralItems = Nothing
    , _ralSelfLink = Nothing
    , _ralWarning = Nothing
    , _ralId = Nothing
    }


-- | [Output Only] Unreachable resources.
ralUnreachables :: Lens' RouterAggregatedList [Text]
ralUnreachables
  = lens _ralUnreachables
      (\ s a -> s{_ralUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
ralNextPageToken :: Lens' RouterAggregatedList (Maybe Text)
ralNextPageToken
  = lens _ralNextPageToken
      (\ s a -> s{_ralNextPageToken = a})

-- | Type of resource.
ralKind :: Lens' RouterAggregatedList Text
ralKind = lens _ralKind (\ s a -> s{_ralKind = a})

-- | A list of Router resources.
ralItems :: Lens' RouterAggregatedList (Maybe RouterAggregatedListItems)
ralItems = lens _ralItems (\ s a -> s{_ralItems = a})

-- | [Output Only] Server-defined URL for this resource.
ralSelfLink :: Lens' RouterAggregatedList (Maybe Text)
ralSelfLink
  = lens _ralSelfLink (\ s a -> s{_ralSelfLink = a})

-- | [Output Only] Informational warning message.
ralWarning :: Lens' RouterAggregatedList (Maybe RouterAggregatedListWarning)
ralWarning
  = lens _ralWarning (\ s a -> s{_ralWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
ralId :: Lens' RouterAggregatedList (Maybe Text)
ralId = lens _ralId (\ s a -> s{_ralId = a})

instance FromJSON RouterAggregatedList where
        parseJSON
          = withObject "RouterAggregatedList"
              (\ o ->
                 RouterAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*> (o .:? "kind" .!= "compute#routerAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON RouterAggregatedList where
        toJSON RouterAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _ralUnreachables,
                  ("nextPageToken" .=) <$> _ralNextPageToken,
                  Just ("kind" .= _ralKind),
                  ("items" .=) <$> _ralItems,
                  ("selfLink" .=) <$> _ralSelfLink,
                  ("warning" .=) <$> _ralWarning,
                  ("id" .=) <$> _ralId])

--
-- /See:/ 'globalNetworkEndpointGroupsDetachEndpointsRequest' smart constructor.
newtype GlobalNetworkEndpointGroupsDetachEndpointsRequest =
  GlobalNetworkEndpointGroupsDetachEndpointsRequest'
    { _gnegderNetworkEndpoints :: Maybe [NetworkEndpoint]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'GlobalNetworkEndpointGroupsDetachEndpointsRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'gnegderNetworkEndpoints'
globalNetworkEndpointGroupsDetachEndpointsRequest
    :: GlobalNetworkEndpointGroupsDetachEndpointsRequest
globalNetworkEndpointGroupsDetachEndpointsRequest =
  GlobalNetworkEndpointGroupsDetachEndpointsRequest'
    {_gnegderNetworkEndpoints = Nothing}


-- | The list of network endpoints to be detached.
gnegderNetworkEndpoints :: Lens' GlobalNetworkEndpointGroupsDetachEndpointsRequest [NetworkEndpoint]
gnegderNetworkEndpoints
  = lens _gnegderNetworkEndpoints
      (\ s a -> s{_gnegderNetworkEndpoints = a})
      . _Default
      . _Coerce

instance FromJSON
           GlobalNetworkEndpointGroupsDetachEndpointsRequest
         where
        parseJSON
          = withObject
              "GlobalNetworkEndpointGroupsDetachEndpointsRequest"
              (\ o ->
                 GlobalNetworkEndpointGroupsDetachEndpointsRequest'
                   <$> (o .:? "networkEndpoints" .!= mempty))

instance ToJSON
           GlobalNetworkEndpointGroupsDetachEndpointsRequest
         where
        toJSON
          GlobalNetworkEndpointGroupsDetachEndpointsRequest'{..}
          = object
              (catMaybes
                 [("networkEndpoints" .=) <$>
                    _gnegderNetworkEndpoints])

-- | Contains a list of firewalls.
--
-- /See:/ 'firewallList' smart constructor.
data FirewallList =
  FirewallList'
    { _flNextPageToken :: !(Maybe Text)
    , _flKind :: !Text
    , _flItems :: !(Maybe [Firewall])
    , _flSelfLink :: !(Maybe Text)
    , _flWarning :: !(Maybe FirewallListWarning)
    , _flId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'FirewallList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'flNextPageToken'
--
-- * 'flKind'
--
-- * 'flItems'
--
-- * 'flSelfLink'
--
-- * 'flWarning'
--
-- * 'flId'
firewallList
    :: FirewallList
firewallList =
  FirewallList'
    { _flNextPageToken = Nothing
    , _flKind = "compute#firewallList"
    , _flItems = Nothing
    , _flSelfLink = Nothing
    , _flWarning = Nothing
    , _flId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
flNextPageToken :: Lens' FirewallList (Maybe Text)
flNextPageToken
  = lens _flNextPageToken
      (\ s a -> s{_flNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#firewallList for lists of
-- firewalls.
flKind :: Lens' FirewallList Text
flKind = lens _flKind (\ s a -> s{_flKind = a})

-- | A list of Firewall resources.
flItems :: Lens' FirewallList [Firewall]
flItems
  = lens _flItems (\ s a -> s{_flItems = a}) . _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
flSelfLink :: Lens' FirewallList (Maybe Text)
flSelfLink
  = lens _flSelfLink (\ s a -> s{_flSelfLink = a})

-- | [Output Only] Informational warning message.
flWarning :: Lens' FirewallList (Maybe FirewallListWarning)
flWarning
  = lens _flWarning (\ s a -> s{_flWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
flId :: Lens' FirewallList (Maybe Text)
flId = lens _flId (\ s a -> s{_flId = a})

instance FromJSON FirewallList where
        parseJSON
          = withObject "FirewallList"
              (\ o ->
                 FirewallList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#firewallList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON FirewallList where
        toJSON FirewallList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _flNextPageToken,
                  Just ("kind" .= _flKind), ("items" .=) <$> _flItems,
                  ("selfLink" .=) <$> _flSelfLink,
                  ("warning" .=) <$> _flWarning, ("id" .=) <$> _flId])

-- | [Output Only] Informational warning which replaces the list of instances
-- when the list is empty.
--
-- /See:/ 'instancesScopedListWarning' smart constructor.
data InstancesScopedListWarning =
  InstancesScopedListWarning'
    { _islwData :: !(Maybe [InstancesScopedListWarningDataItem])
    , _islwCode :: !(Maybe InstancesScopedListWarningCode)
    , _islwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstancesScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'islwData'
--
-- * 'islwCode'
--
-- * 'islwMessage'
instancesScopedListWarning
    :: InstancesScopedListWarning
instancesScopedListWarning =
  InstancesScopedListWarning'
    {_islwData = Nothing, _islwCode = Nothing, _islwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
islwData :: Lens' InstancesScopedListWarning [InstancesScopedListWarningDataItem]
islwData
  = lens _islwData (\ s a -> s{_islwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
islwCode :: Lens' InstancesScopedListWarning (Maybe InstancesScopedListWarningCode)
islwCode = lens _islwCode (\ s a -> s{_islwCode = a})

-- | [Output Only] A human-readable description of the warning code.
islwMessage :: Lens' InstancesScopedListWarning (Maybe Text)
islwMessage
  = lens _islwMessage (\ s a -> s{_islwMessage = a})

instance FromJSON InstancesScopedListWarning where
        parseJSON
          = withObject "InstancesScopedListWarning"
              (\ o ->
                 InstancesScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON InstancesScopedListWarning where
        toJSON InstancesScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _islwData,
                  ("code" .=) <$> _islwCode,
                  ("message" .=) <$> _islwMessage])

--
-- /See:/ 'regionInstanceGroupManagersRecreateRequest' smart constructor.
newtype RegionInstanceGroupManagersRecreateRequest =
  RegionInstanceGroupManagersRecreateRequest'
    { _rigmrrInstances :: Maybe [Text]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupManagersRecreateRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rigmrrInstances'
regionInstanceGroupManagersRecreateRequest
    :: RegionInstanceGroupManagersRecreateRequest
regionInstanceGroupManagersRecreateRequest =
  RegionInstanceGroupManagersRecreateRequest' {_rigmrrInstances = Nothing}


-- | The URLs of one or more instances to recreate. This can be a full URL or
-- a partial URL, such as zones\/[ZONE]\/instances\/[INSTANCE_NAME].
rigmrrInstances :: Lens' RegionInstanceGroupManagersRecreateRequest [Text]
rigmrrInstances
  = lens _rigmrrInstances
      (\ s a -> s{_rigmrrInstances = a})
      . _Default
      . _Coerce

instance FromJSON
           RegionInstanceGroupManagersRecreateRequest
         where
        parseJSON
          = withObject
              "RegionInstanceGroupManagersRecreateRequest"
              (\ o ->
                 RegionInstanceGroupManagersRecreateRequest' <$>
                   (o .:? "instances" .!= mempty))

instance ToJSON
           RegionInstanceGroupManagersRecreateRequest
         where
        toJSON
          RegionInstanceGroupManagersRecreateRequest'{..}
          = object
              (catMaybes [("instances" .=) <$> _rigmrrInstances])

-- | Labels to apply to this instance. These can be later modified by the
-- setLabels method.
--
-- /See:/ 'instanceLabels' smart constructor.
newtype InstanceLabels =
  InstanceLabels'
    { _ilAddtional :: HashMap Text Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceLabels' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ilAddtional'
instanceLabels
    :: HashMap Text Text -- ^ 'ilAddtional'
    -> InstanceLabels
instanceLabels pIlAddtional_ =
  InstanceLabels' {_ilAddtional = _Coerce # pIlAddtional_}


ilAddtional :: Lens' InstanceLabels (HashMap Text Text)
ilAddtional
  = lens _ilAddtional (\ s a -> s{_ilAddtional = a}) .
      _Coerce

instance FromJSON InstanceLabels where
        parseJSON
          = withObject "InstanceLabels"
              (\ o -> InstanceLabels' <$> (parseJSONObject o))

instance ToJSON InstanceLabels where
        toJSON = toJSON . _ilAddtional

-- | Configuration of logging on a health check. If logging is enabled, logs
-- will be exported to Stackdriver.
--
-- /See:/ 'healthCheckLogConfig' smart constructor.
newtype HealthCheckLogConfig =
  HealthCheckLogConfig'
    { _hclcEnable :: Maybe Bool
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HealthCheckLogConfig' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hclcEnable'
healthCheckLogConfig
    :: HealthCheckLogConfig
healthCheckLogConfig = HealthCheckLogConfig' {_hclcEnable = Nothing}


-- | Indicates whether or not to export logs. This is false by default, which
-- means no health check logging will be done.
hclcEnable :: Lens' HealthCheckLogConfig (Maybe Bool)
hclcEnable
  = lens _hclcEnable (\ s a -> s{_hclcEnable = a})

instance FromJSON HealthCheckLogConfig where
        parseJSON
          = withObject "HealthCheckLogConfig"
              (\ o -> HealthCheckLogConfig' <$> (o .:? "enable"))

instance ToJSON HealthCheckLogConfig where
        toJSON HealthCheckLogConfig'{..}
          = object (catMaybes [("enable" .=) <$> _hclcEnable])

-- | Informational warning which replaces the list of backend services when
-- the list is empty.
--
-- /See:/ 'backendServicesScopedListWarning' smart constructor.
data BackendServicesScopedListWarning =
  BackendServicesScopedListWarning'
    { _bsslwData :: !(Maybe [BackendServicesScopedListWarningDataItem])
    , _bsslwCode :: !(Maybe BackendServicesScopedListWarningCode)
    , _bsslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendServicesScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bsslwData'
--
-- * 'bsslwCode'
--
-- * 'bsslwMessage'
backendServicesScopedListWarning
    :: BackendServicesScopedListWarning
backendServicesScopedListWarning =
  BackendServicesScopedListWarning'
    {_bsslwData = Nothing, _bsslwCode = Nothing, _bsslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
bsslwData :: Lens' BackendServicesScopedListWarning [BackendServicesScopedListWarningDataItem]
bsslwData
  = lens _bsslwData (\ s a -> s{_bsslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
bsslwCode :: Lens' BackendServicesScopedListWarning (Maybe BackendServicesScopedListWarningCode)
bsslwCode
  = lens _bsslwCode (\ s a -> s{_bsslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
bsslwMessage :: Lens' BackendServicesScopedListWarning (Maybe Text)
bsslwMessage
  = lens _bsslwMessage (\ s a -> s{_bsslwMessage = a})

instance FromJSON BackendServicesScopedListWarning
         where
        parseJSON
          = withObject "BackendServicesScopedListWarning"
              (\ o ->
                 BackendServicesScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON BackendServicesScopedListWarning
         where
        toJSON BackendServicesScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _bsslwData,
                  ("code" .=) <$> _bsslwCode,
                  ("message" .=) <$> _bsslwMessage])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'packetMirroringAggregatedListWarning' smart constructor.
data PacketMirroringAggregatedListWarning =
  PacketMirroringAggregatedListWarning'
    { _pmalwData :: !(Maybe [PacketMirroringAggregatedListWarningDataItem])
    , _pmalwCode :: !(Maybe PacketMirroringAggregatedListWarningCode)
    , _pmalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PacketMirroringAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pmalwData'
--
-- * 'pmalwCode'
--
-- * 'pmalwMessage'
packetMirroringAggregatedListWarning
    :: PacketMirroringAggregatedListWarning
packetMirroringAggregatedListWarning =
  PacketMirroringAggregatedListWarning'
    {_pmalwData = Nothing, _pmalwCode = Nothing, _pmalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
pmalwData :: Lens' PacketMirroringAggregatedListWarning [PacketMirroringAggregatedListWarningDataItem]
pmalwData
  = lens _pmalwData (\ s a -> s{_pmalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
pmalwCode :: Lens' PacketMirroringAggregatedListWarning (Maybe PacketMirroringAggregatedListWarningCode)
pmalwCode
  = lens _pmalwCode (\ s a -> s{_pmalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
pmalwMessage :: Lens' PacketMirroringAggregatedListWarning (Maybe Text)
pmalwMessage
  = lens _pmalwMessage (\ s a -> s{_pmalwMessage = a})

instance FromJSON
           PacketMirroringAggregatedListWarning
         where
        parseJSON
          = withObject "PacketMirroringAggregatedListWarning"
              (\ o ->
                 PacketMirroringAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON PacketMirroringAggregatedListWarning
         where
        toJSON PacketMirroringAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _pmalwData,
                  ("code" .=) <$> _pmalwCode,
                  ("message" .=) <$> _pmalwMessage])

--
-- /See:/ 'packetMirroringListWarningDataItem' smart constructor.
data PacketMirroringListWarningDataItem =
  PacketMirroringListWarningDataItem'
    { _pmlwdiValue :: !(Maybe Text)
    , _pmlwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PacketMirroringListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pmlwdiValue'
--
-- * 'pmlwdiKey'
packetMirroringListWarningDataItem
    :: PacketMirroringListWarningDataItem
packetMirroringListWarningDataItem =
  PacketMirroringListWarningDataItem'
    {_pmlwdiValue = Nothing, _pmlwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
pmlwdiValue :: Lens' PacketMirroringListWarningDataItem (Maybe Text)
pmlwdiValue
  = lens _pmlwdiValue (\ s a -> s{_pmlwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
pmlwdiKey :: Lens' PacketMirroringListWarningDataItem (Maybe Text)
pmlwdiKey
  = lens _pmlwdiKey (\ s a -> s{_pmlwdiKey = a})

instance FromJSON PacketMirroringListWarningDataItem
         where
        parseJSON
          = withObject "PacketMirroringListWarningDataItem"
              (\ o ->
                 PacketMirroringListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON PacketMirroringListWarningDataItem
         where
        toJSON PacketMirroringListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _pmlwdiValue,
                  ("key" .=) <$> _pmlwdiKey])

-- | Represents a match condition that incoming traffic is evaluated against.
-- Exactly one field must be specified.
--
-- /See:/ 'securityPolicyRuleMatcher' smart constructor.
data SecurityPolicyRuleMatcher =
  SecurityPolicyRuleMatcher'
    { _sprmVersionedExpr :: !(Maybe SecurityPolicyRuleMatcherVersionedExpr)
    , _sprmExpr :: !(Maybe Expr)
    , _sprmConfig :: !(Maybe SecurityPolicyRuleMatcherConfig)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SecurityPolicyRuleMatcher' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sprmVersionedExpr'
--
-- * 'sprmExpr'
--
-- * 'sprmConfig'
securityPolicyRuleMatcher
    :: SecurityPolicyRuleMatcher
securityPolicyRuleMatcher =
  SecurityPolicyRuleMatcher'
    {_sprmVersionedExpr = Nothing, _sprmExpr = Nothing, _sprmConfig = Nothing}


-- | Preconfigured versioned expression. If this field is specified, config
-- must also be specified. Available preconfigured expressions along with
-- their requirements are: SRC_IPS_V1 - must specify the corresponding
-- src_ip_range field in config.
sprmVersionedExpr :: Lens' SecurityPolicyRuleMatcher (Maybe SecurityPolicyRuleMatcherVersionedExpr)
sprmVersionedExpr
  = lens _sprmVersionedExpr
      (\ s a -> s{_sprmVersionedExpr = a})

-- | User defined CEVAL expression. A CEVAL expression is used to specify
-- match criteria such as origin.ip, source.region_code and contents in the
-- request header.
sprmExpr :: Lens' SecurityPolicyRuleMatcher (Maybe Expr)
sprmExpr = lens _sprmExpr (\ s a -> s{_sprmExpr = a})

-- | The configuration options available when specifying versioned_expr. This
-- field must be specified if versioned_expr is specified and cannot be
-- specified if versioned_expr is not specified.
sprmConfig :: Lens' SecurityPolicyRuleMatcher (Maybe SecurityPolicyRuleMatcherConfig)
sprmConfig
  = lens _sprmConfig (\ s a -> s{_sprmConfig = a})

instance FromJSON SecurityPolicyRuleMatcher where
        parseJSON
          = withObject "SecurityPolicyRuleMatcher"
              (\ o ->
                 SecurityPolicyRuleMatcher' <$>
                   (o .:? "versionedExpr") <*> (o .:? "expr") <*>
                     (o .:? "config"))

instance ToJSON SecurityPolicyRuleMatcher where
        toJSON SecurityPolicyRuleMatcher'{..}
          = object
              (catMaybes
                 [("versionedExpr" .=) <$> _sprmVersionedExpr,
                  ("expr" .=) <$> _sprmExpr,
                  ("config" .=) <$> _sprmConfig])

-- | Represents a sub PublicDelegatedPrefix.
--
-- /See:/ 'publicDelegatedPrefixPublicDelegatedSubPrefix' smart constructor.
data PublicDelegatedPrefixPublicDelegatedSubPrefix =
  PublicDelegatedPrefixPublicDelegatedSubPrefix'
    { _pdppdspIsAddress :: !(Maybe Bool)
    , _pdppdspStatus :: !(Maybe PublicDelegatedPrefixPublicDelegatedSubPrefixStatus)
    , _pdppdspDelegateeProject :: !(Maybe Text)
    , _pdppdspName :: !(Maybe Text)
    , _pdppdspIPCIdRRange :: !(Maybe Text)
    , _pdppdspRegion :: !(Maybe Text)
    , _pdppdspDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PublicDelegatedPrefixPublicDelegatedSubPrefix' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pdppdspIsAddress'
--
-- * 'pdppdspStatus'
--
-- * 'pdppdspDelegateeProject'
--
-- * 'pdppdspName'
--
-- * 'pdppdspIPCIdRRange'
--
-- * 'pdppdspRegion'
--
-- * 'pdppdspDescription'
publicDelegatedPrefixPublicDelegatedSubPrefix
    :: PublicDelegatedPrefixPublicDelegatedSubPrefix
publicDelegatedPrefixPublicDelegatedSubPrefix =
  PublicDelegatedPrefixPublicDelegatedSubPrefix'
    { _pdppdspIsAddress = Nothing
    , _pdppdspStatus = Nothing
    , _pdppdspDelegateeProject = Nothing
    , _pdppdspName = Nothing
    , _pdppdspIPCIdRRange = Nothing
    , _pdppdspRegion = Nothing
    , _pdppdspDescription = Nothing
    }


-- | Whether the sub prefix is delegated to create Address resources in the
-- delegatee project.
pdppdspIsAddress :: Lens' PublicDelegatedPrefixPublicDelegatedSubPrefix (Maybe Bool)
pdppdspIsAddress
  = lens _pdppdspIsAddress
      (\ s a -> s{_pdppdspIsAddress = a})

-- | [Output Only] The status of the sub public delegated prefix.
pdppdspStatus :: Lens' PublicDelegatedPrefixPublicDelegatedSubPrefix (Maybe PublicDelegatedPrefixPublicDelegatedSubPrefixStatus)
pdppdspStatus
  = lens _pdppdspStatus
      (\ s a -> s{_pdppdspStatus = a})

-- | Name of the project scoping this PublicDelegatedSubPrefix.
pdppdspDelegateeProject :: Lens' PublicDelegatedPrefixPublicDelegatedSubPrefix (Maybe Text)
pdppdspDelegateeProject
  = lens _pdppdspDelegateeProject
      (\ s a -> s{_pdppdspDelegateeProject = a})

-- | The name of the sub public delegated prefix.
pdppdspName :: Lens' PublicDelegatedPrefixPublicDelegatedSubPrefix (Maybe Text)
pdppdspName
  = lens _pdppdspName (\ s a -> s{_pdppdspName = a})

-- | The IPv4 address range, in CIDR format, represented by this sub public
-- delegated prefix.
pdppdspIPCIdRRange :: Lens' PublicDelegatedPrefixPublicDelegatedSubPrefix (Maybe Text)
pdppdspIPCIdRRange
  = lens _pdppdspIPCIdRRange
      (\ s a -> s{_pdppdspIPCIdRRange = a})

-- | [Output Only] The region of the sub public delegated prefix if it is
-- regional. If absent, the sub prefix is global.
pdppdspRegion :: Lens' PublicDelegatedPrefixPublicDelegatedSubPrefix (Maybe Text)
pdppdspRegion
  = lens _pdppdspRegion
      (\ s a -> s{_pdppdspRegion = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource.
pdppdspDescription :: Lens' PublicDelegatedPrefixPublicDelegatedSubPrefix (Maybe Text)
pdppdspDescription
  = lens _pdppdspDescription
      (\ s a -> s{_pdppdspDescription = a})

instance FromJSON
           PublicDelegatedPrefixPublicDelegatedSubPrefix
         where
        parseJSON
          = withObject
              "PublicDelegatedPrefixPublicDelegatedSubPrefix"
              (\ o ->
                 PublicDelegatedPrefixPublicDelegatedSubPrefix' <$>
                   (o .:? "isAddress") <*> (o .:? "status") <*>
                     (o .:? "delegateeProject")
                     <*> (o .:? "name")
                     <*> (o .:? "ipCidrRange")
                     <*> (o .:? "region")
                     <*> (o .:? "description"))

instance ToJSON
           PublicDelegatedPrefixPublicDelegatedSubPrefix
         where
        toJSON
          PublicDelegatedPrefixPublicDelegatedSubPrefix'{..}
          = object
              (catMaybes
                 [("isAddress" .=) <$> _pdppdspIsAddress,
                  ("status" .=) <$> _pdppdspStatus,
                  ("delegateeProject" .=) <$> _pdppdspDelegateeProject,
                  ("name" .=) <$> _pdppdspName,
                  ("ipCidrRange" .=) <$> _pdppdspIPCIdRRange,
                  ("region" .=) <$> _pdppdspRegion,
                  ("description" .=) <$> _pdppdspDescription])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'healthChecksAggregatedListWarning' smart constructor.
data HealthChecksAggregatedListWarning =
  HealthChecksAggregatedListWarning'
    { _hcalwData :: !(Maybe [HealthChecksAggregatedListWarningDataItem])
    , _hcalwCode :: !(Maybe HealthChecksAggregatedListWarningCode)
    , _hcalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HealthChecksAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hcalwData'
--
-- * 'hcalwCode'
--
-- * 'hcalwMessage'
healthChecksAggregatedListWarning
    :: HealthChecksAggregatedListWarning
healthChecksAggregatedListWarning =
  HealthChecksAggregatedListWarning'
    {_hcalwData = Nothing, _hcalwCode = Nothing, _hcalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
hcalwData :: Lens' HealthChecksAggregatedListWarning [HealthChecksAggregatedListWarningDataItem]
hcalwData
  = lens _hcalwData (\ s a -> s{_hcalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
hcalwCode :: Lens' HealthChecksAggregatedListWarning (Maybe HealthChecksAggregatedListWarningCode)
hcalwCode
  = lens _hcalwCode (\ s a -> s{_hcalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
hcalwMessage :: Lens' HealthChecksAggregatedListWarning (Maybe Text)
hcalwMessage
  = lens _hcalwMessage (\ s a -> s{_hcalwMessage = a})

instance FromJSON HealthChecksAggregatedListWarning
         where
        parseJSON
          = withObject "HealthChecksAggregatedListWarning"
              (\ o ->
                 HealthChecksAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON HealthChecksAggregatedListWarning
         where
        toJSON HealthChecksAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _hcalwData,
                  ("code" .=) <$> _hcalwCode,
                  ("message" .=) <$> _hcalwMessage])

--
-- /See:/ 'perInstanceConfig' smart constructor.
data PerInstanceConfig =
  PerInstanceConfig'
    { _picStatus :: !(Maybe PerInstanceConfigStatus)
    , _picFingerprint :: !(Maybe Bytes)
    , _picName :: !(Maybe Text)
    , _picPreservedState :: !(Maybe PreservedState)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PerInstanceConfig' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'picStatus'
--
-- * 'picFingerprint'
--
-- * 'picName'
--
-- * 'picPreservedState'
perInstanceConfig
    :: PerInstanceConfig
perInstanceConfig =
  PerInstanceConfig'
    { _picStatus = Nothing
    , _picFingerprint = Nothing
    , _picName = Nothing
    , _picPreservedState = Nothing
    }


-- | The status of applying this per-instance config on the corresponding
-- managed instance.
picStatus :: Lens' PerInstanceConfig (Maybe PerInstanceConfigStatus)
picStatus
  = lens _picStatus (\ s a -> s{_picStatus = a})

-- | Fingerprint of this per-instance config. This field can be used in
-- optimistic locking. It is ignored when inserting a per-instance config.
-- An up-to-date fingerprint must be provided in order to update an
-- existing per-instance config or the field needs to be unset.
picFingerprint :: Lens' PerInstanceConfig (Maybe ByteString)
picFingerprint
  = lens _picFingerprint
      (\ s a -> s{_picFingerprint = a})
      . mapping _Bytes

-- | The name of a per-instance config and its corresponding instance. Serves
-- as a merge key during UpdatePerInstanceConfigs operations, that is, if a
-- per-instance config with the same name exists then it will be updated,
-- otherwise a new one will be created for the VM instance with the same
-- name. An attempt to create a per-instance config for a VM instance that
-- either doesn\'t exist or is not part of the group will result in an
-- error.
picName :: Lens' PerInstanceConfig (Maybe Text)
picName = lens _picName (\ s a -> s{_picName = a})

-- | The intended preserved state for the given instance. Does not contain
-- preserved state generated from a stateful policy.
picPreservedState :: Lens' PerInstanceConfig (Maybe PreservedState)
picPreservedState
  = lens _picPreservedState
      (\ s a -> s{_picPreservedState = a})

instance FromJSON PerInstanceConfig where
        parseJSON
          = withObject "PerInstanceConfig"
              (\ o ->
                 PerInstanceConfig' <$>
                   (o .:? "status") <*> (o .:? "fingerprint") <*>
                     (o .:? "name")
                     <*> (o .:? "preservedState"))

instance ToJSON PerInstanceConfig where
        toJSON PerInstanceConfig'{..}
          = object
              (catMaybes
                 [("status" .=) <$> _picStatus,
                  ("fingerprint" .=) <$> _picFingerprint,
                  ("name" .=) <$> _picName,
                  ("preservedState" .=) <$> _picPreservedState])

-- | A list of InstanceGroup resources.
--
-- /See:/ 'instanceGroupList' smart constructor.
data InstanceGroupList =
  InstanceGroupList'
    { _iglNextPageToken :: !(Maybe Text)
    , _iglKind :: !Text
    , _iglItems :: !(Maybe [InstanceGroup])
    , _iglSelfLink :: !(Maybe Text)
    , _iglWarning :: !(Maybe InstanceGroupListWarning)
    , _iglId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iglNextPageToken'
--
-- * 'iglKind'
--
-- * 'iglItems'
--
-- * 'iglSelfLink'
--
-- * 'iglWarning'
--
-- * 'iglId'
instanceGroupList
    :: InstanceGroupList
instanceGroupList =
  InstanceGroupList'
    { _iglNextPageToken = Nothing
    , _iglKind = "compute#instanceGroupList"
    , _iglItems = Nothing
    , _iglSelfLink = Nothing
    , _iglWarning = Nothing
    , _iglId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
iglNextPageToken :: Lens' InstanceGroupList (Maybe Text)
iglNextPageToken
  = lens _iglNextPageToken
      (\ s a -> s{_iglNextPageToken = a})

-- | [Output Only] The resource type, which is always
-- compute#instanceGroupList for instance group lists.
iglKind :: Lens' InstanceGroupList Text
iglKind = lens _iglKind (\ s a -> s{_iglKind = a})

-- | A list of InstanceGroup resources.
iglItems :: Lens' InstanceGroupList [InstanceGroup]
iglItems
  = lens _iglItems (\ s a -> s{_iglItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
iglSelfLink :: Lens' InstanceGroupList (Maybe Text)
iglSelfLink
  = lens _iglSelfLink (\ s a -> s{_iglSelfLink = a})

-- | [Output Only] Informational warning message.
iglWarning :: Lens' InstanceGroupList (Maybe InstanceGroupListWarning)
iglWarning
  = lens _iglWarning (\ s a -> s{_iglWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
iglId :: Lens' InstanceGroupList (Maybe Text)
iglId = lens _iglId (\ s a -> s{_iglId = a})

instance FromJSON InstanceGroupList where
        parseJSON
          = withObject "InstanceGroupList"
              (\ o ->
                 InstanceGroupList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#instanceGroupList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON InstanceGroupList where
        toJSON InstanceGroupList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _iglNextPageToken,
                  Just ("kind" .= _iglKind),
                  ("items" .=) <$> _iglItems,
                  ("selfLink" .=) <$> _iglSelfLink,
                  ("warning" .=) <$> _iglWarning,
                  ("id" .=) <$> _iglId])

--
-- /See:/ 'instancesSetMachineTypeRequest' smart constructor.
newtype InstancesSetMachineTypeRequest =
  InstancesSetMachineTypeRequest'
    { _ismtrMachineType :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstancesSetMachineTypeRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ismtrMachineType'
instancesSetMachineTypeRequest
    :: InstancesSetMachineTypeRequest
instancesSetMachineTypeRequest =
  InstancesSetMachineTypeRequest' {_ismtrMachineType = Nothing}


-- | Full or partial URL of the machine type resource. See Machine Types for
-- a full list of machine types. For example:
-- zones\/us-central1-f\/machineTypes\/n1-standard-1
ismtrMachineType :: Lens' InstancesSetMachineTypeRequest (Maybe Text)
ismtrMachineType
  = lens _ismtrMachineType
      (\ s a -> s{_ismtrMachineType = a})

instance FromJSON InstancesSetMachineTypeRequest
         where
        parseJSON
          = withObject "InstancesSetMachineTypeRequest"
              (\ o ->
                 InstancesSetMachineTypeRequest' <$>
                   (o .:? "machineType"))

instance ToJSON InstancesSetMachineTypeRequest where
        toJSON InstancesSetMachineTypeRequest'{..}
          = object
              (catMaybes
                 [("machineType" .=) <$> _ismtrMachineType])

-- | Contain information of Nat mapping for a VM endpoint (i.e., NIC).
--
-- /See:/ 'vMEndpointNATMAppings' smart constructor.
data VMEndpointNATMAppings =
  VMEndpointNATMAppings'
    { _vmenatmaInstanceName :: !(Maybe Text)
    , _vmenatmaInterfaceNATMAppings :: !(Maybe [VMEndpointNATMAppingsInterfaceNATMAppings])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VMEndpointNATMAppings' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vmenatmaInstanceName'
--
-- * 'vmenatmaInterfaceNATMAppings'
vMEndpointNATMAppings
    :: VMEndpointNATMAppings
vMEndpointNATMAppings =
  VMEndpointNATMAppings'
    {_vmenatmaInstanceName = Nothing, _vmenatmaInterfaceNATMAppings = Nothing}


-- | Name of the VM instance which the endpoint belongs to
vmenatmaInstanceName :: Lens' VMEndpointNATMAppings (Maybe Text)
vmenatmaInstanceName
  = lens _vmenatmaInstanceName
      (\ s a -> s{_vmenatmaInstanceName = a})

vmenatmaInterfaceNATMAppings :: Lens' VMEndpointNATMAppings [VMEndpointNATMAppingsInterfaceNATMAppings]
vmenatmaInterfaceNATMAppings
  = lens _vmenatmaInterfaceNATMAppings
      (\ s a -> s{_vmenatmaInterfaceNATMAppings = a})
      . _Default
      . _Coerce

instance FromJSON VMEndpointNATMAppings where
        parseJSON
          = withObject "VMEndpointNATMAppings"
              (\ o ->
                 VMEndpointNATMAppings' <$>
                   (o .:? "instanceName") <*>
                     (o .:? "interfaceNatMappings" .!= mempty))

instance ToJSON VMEndpointNATMAppings where
        toJSON VMEndpointNATMAppings'{..}
          = object
              (catMaybes
                 [("instanceName" .=) <$> _vmenatmaInstanceName,
                  ("interfaceNatMappings" .=) <$>
                    _vmenatmaInterfaceNATMAppings])

--
-- /See:/ 'customerEncryptionKey' smart constructor.
data CustomerEncryptionKey =
  CustomerEncryptionKey'
    { _cekKmsKeyServiceAccount :: !(Maybe Text)
    , _cekKmsKeyName :: !(Maybe Text)
    , _cekSha256 :: !(Maybe Text)
    , _cekRawKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'CustomerEncryptionKey' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'cekKmsKeyServiceAccount'
--
-- * 'cekKmsKeyName'
--
-- * 'cekSha256'
--
-- * 'cekRawKey'
customerEncryptionKey
    :: CustomerEncryptionKey
customerEncryptionKey =
  CustomerEncryptionKey'
    { _cekKmsKeyServiceAccount = Nothing
    , _cekKmsKeyName = Nothing
    , _cekSha256 = Nothing
    , _cekRawKey = Nothing
    }


-- | The service account being used for the encryption request for the given
-- KMS key. If absent, the Compute Engine default service account is used.
cekKmsKeyServiceAccount :: Lens' CustomerEncryptionKey (Maybe Text)
cekKmsKeyServiceAccount
  = lens _cekKmsKeyServiceAccount
      (\ s a -> s{_cekKmsKeyServiceAccount = a})

-- | The name of the encryption key that is stored in Google Cloud KMS.
cekKmsKeyName :: Lens' CustomerEncryptionKey (Maybe Text)
cekKmsKeyName
  = lens _cekKmsKeyName
      (\ s a -> s{_cekKmsKeyName = a})

-- | [Output only] The RFC 4648 base64 encoded SHA-256 hash of the
-- customer-supplied encryption key that protects this resource.
cekSha256 :: Lens' CustomerEncryptionKey (Maybe Text)
cekSha256
  = lens _cekSha256 (\ s a -> s{_cekSha256 = a})

-- | Specifies a 256-bit customer-supplied encryption key, encoded in RFC
-- 4648 base64 to either encrypt or decrypt this resource.
cekRawKey :: Lens' CustomerEncryptionKey (Maybe Text)
cekRawKey
  = lens _cekRawKey (\ s a -> s{_cekRawKey = a})

instance FromJSON CustomerEncryptionKey where
        parseJSON
          = withObject "CustomerEncryptionKey"
              (\ o ->
                 CustomerEncryptionKey' <$>
                   (o .:? "kmsKeyServiceAccount") <*>
                     (o .:? "kmsKeyName")
                     <*> (o .:? "sha256")
                     <*> (o .:? "rawKey"))

instance ToJSON CustomerEncryptionKey where
        toJSON CustomerEncryptionKey'{..}
          = object
              (catMaybes
                 [("kmsKeyServiceAccount" .=) <$>
                    _cekKmsKeyServiceAccount,
                  ("kmsKeyName" .=) <$> _cekKmsKeyName,
                  ("sha256" .=) <$> _cekSha256,
                  ("rawKey" .=) <$> _cekRawKey])

-- | A list of AutoscalersScopedList resources.
--
-- /See:/ 'autoscalerAggregatedListItems' smart constructor.
newtype AutoscalerAggregatedListItems =
  AutoscalerAggregatedListItems'
    { _aaliAddtional :: HashMap Text AutoscalersScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AutoscalerAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'aaliAddtional'
autoscalerAggregatedListItems
    :: HashMap Text AutoscalersScopedList -- ^ 'aaliAddtional'
    -> AutoscalerAggregatedListItems
autoscalerAggregatedListItems pAaliAddtional_ =
  AutoscalerAggregatedListItems' {_aaliAddtional = _Coerce # pAaliAddtional_}


-- | [Output Only] Name of the scope containing this set of autoscalers.
aaliAddtional :: Lens' AutoscalerAggregatedListItems (HashMap Text AutoscalersScopedList)
aaliAddtional
  = lens _aaliAddtional
      (\ s a -> s{_aaliAddtional = a})
      . _Coerce

instance FromJSON AutoscalerAggregatedListItems where
        parseJSON
          = withObject "AutoscalerAggregatedListItems"
              (\ o ->
                 AutoscalerAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON AutoscalerAggregatedListItems where
        toJSON = toJSON . _aaliAddtional

--
-- /See:/ 'instanceListWarningDataItem' smart constructor.
data InstanceListWarningDataItem =
  InstanceListWarningDataItem'
    { _ilwdiValue :: !(Maybe Text)
    , _ilwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ilwdiValue'
--
-- * 'ilwdiKey'
instanceListWarningDataItem
    :: InstanceListWarningDataItem
instanceListWarningDataItem =
  InstanceListWarningDataItem' {_ilwdiValue = Nothing, _ilwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
ilwdiValue :: Lens' InstanceListWarningDataItem (Maybe Text)
ilwdiValue
  = lens _ilwdiValue (\ s a -> s{_ilwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
ilwdiKey :: Lens' InstanceListWarningDataItem (Maybe Text)
ilwdiKey = lens _ilwdiKey (\ s a -> s{_ilwdiKey = a})

instance FromJSON InstanceListWarningDataItem where
        parseJSON
          = withObject "InstanceListWarningDataItem"
              (\ o ->
                 InstanceListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON InstanceListWarningDataItem where
        toJSON InstanceListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _ilwdiValue,
                  ("key" .=) <$> _ilwdiKey])

--
-- /See:/ 'instanceGroupManagersSetInstanceTemplateRequest' smart constructor.
newtype InstanceGroupManagersSetInstanceTemplateRequest =
  InstanceGroupManagersSetInstanceTemplateRequest'
    { _igmsitrInstanceTemplate :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagersSetInstanceTemplateRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmsitrInstanceTemplate'
instanceGroupManagersSetInstanceTemplateRequest
    :: InstanceGroupManagersSetInstanceTemplateRequest
instanceGroupManagersSetInstanceTemplateRequest =
  InstanceGroupManagersSetInstanceTemplateRequest'
    {_igmsitrInstanceTemplate = Nothing}


-- | The URL of the instance template that is specified for this managed
-- instance group. The group uses this template to create all new instances
-- in the managed instance group. The templates for existing instances in
-- the group do not change unless you run recreateInstances, run
-- applyUpdatesToInstances, or set the group\'s updatePolicy.type to
-- PROACTIVE.
igmsitrInstanceTemplate :: Lens' InstanceGroupManagersSetInstanceTemplateRequest (Maybe Text)
igmsitrInstanceTemplate
  = lens _igmsitrInstanceTemplate
      (\ s a -> s{_igmsitrInstanceTemplate = a})

instance FromJSON
           InstanceGroupManagersSetInstanceTemplateRequest
         where
        parseJSON
          = withObject
              "InstanceGroupManagersSetInstanceTemplateRequest"
              (\ o ->
                 InstanceGroupManagersSetInstanceTemplateRequest' <$>
                   (o .:? "instanceTemplate"))

instance ToJSON
           InstanceGroupManagersSetInstanceTemplateRequest
         where
        toJSON
          InstanceGroupManagersSetInstanceTemplateRequest'{..}
          = object
              (catMaybes
                 [("instanceTemplate" .=) <$>
                    _igmsitrInstanceTemplate])

-- | An instance\'s screenshot.
--
-- /See:/ 'screenshot' smart constructor.
data Screenshot =
  Screenshot'
    { _sContents :: !(Maybe Text)
    , _sKind :: !Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Screenshot' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sContents'
--
-- * 'sKind'
screenshot
    :: Screenshot
screenshot = Screenshot' {_sContents = Nothing, _sKind = "compute#screenshot"}


-- | [Output Only] The Base64-encoded screenshot data.
sContents :: Lens' Screenshot (Maybe Text)
sContents
  = lens _sContents (\ s a -> s{_sContents = a})

-- | [Output Only] Type of the resource. Always compute#screenshot for the
-- screenshots.
sKind :: Lens' Screenshot Text
sKind = lens _sKind (\ s a -> s{_sKind = a})

instance FromJSON Screenshot where
        parseJSON
          = withObject "Screenshot"
              (\ o ->
                 Screenshot' <$>
                   (o .:? "contents") <*>
                     (o .:? "kind" .!= "compute#screenshot"))

instance ToJSON Screenshot where
        toJSON Screenshot'{..}
          = object
              (catMaybes
                 [("contents" .=) <$> _sContents,
                  Just ("kind" .= _sKind)])

-- | Array of guest attribute namespace\/key\/value tuples.
--
-- /See:/ 'guestAttributesValue' smart constructor.
newtype GuestAttributesValue =
  GuestAttributesValue'
    { _gavItems :: Maybe [GuestAttributesEntry]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'GuestAttributesValue' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'gavItems'
guestAttributesValue
    :: GuestAttributesValue
guestAttributesValue = GuestAttributesValue' {_gavItems = Nothing}


gavItems :: Lens' GuestAttributesValue [GuestAttributesEntry]
gavItems
  = lens _gavItems (\ s a -> s{_gavItems = a}) .
      _Default
      . _Coerce

instance FromJSON GuestAttributesValue where
        parseJSON
          = withObject "GuestAttributesValue"
              (\ o ->
                 GuestAttributesValue' <$> (o .:? "items" .!= mempty))

instance ToJSON GuestAttributesValue where
        toJSON GuestAttributesValue'{..}
          = object (catMaybes [("items" .=) <$> _gavItems])

--
-- /See:/ 'instancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy' smart constructor.
data InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy =
  InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy'
    { _igefrefpRules :: !(Maybe [FirewallPolicyRule])
    , _igefrefpShortName :: !(Maybe Text)
    , _igefrefpName :: !(Maybe Text)
    , _igefrefpDisplayName :: !(Maybe Text)
    , _igefrefpType :: !(Maybe InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicyType)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igefrefpRules'
--
-- * 'igefrefpShortName'
--
-- * 'igefrefpName'
--
-- * 'igefrefpDisplayName'
--
-- * 'igefrefpType'
instancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy
    :: InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy
instancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy =
  InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy'
    { _igefrefpRules = Nothing
    , _igefrefpShortName = Nothing
    , _igefrefpName = Nothing
    , _igefrefpDisplayName = Nothing
    , _igefrefpType = Nothing
    }


-- | The rules that apply to the network.
igefrefpRules :: Lens' InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy [FirewallPolicyRule]
igefrefpRules
  = lens _igefrefpRules
      (\ s a -> s{_igefrefpRules = a})
      . _Default
      . _Coerce

-- | [Output Only] The short name of the firewall policy.
igefrefpShortName :: Lens' InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy (Maybe Text)
igefrefpShortName
  = lens _igefrefpShortName
      (\ s a -> s{_igefrefpShortName = a})

-- | [Output Only] The name of the firewall policy.
igefrefpName :: Lens' InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy (Maybe Text)
igefrefpName
  = lens _igefrefpName (\ s a -> s{_igefrefpName = a})

-- | [Output Only] Deprecated, please use short name instead. The display
-- name of the firewall policy.
igefrefpDisplayName :: Lens' InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy (Maybe Text)
igefrefpDisplayName
  = lens _igefrefpDisplayName
      (\ s a -> s{_igefrefpDisplayName = a})

-- | [Output Only] The type of the firewall policy.
igefrefpType :: Lens' InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy (Maybe InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicyType)
igefrefpType
  = lens _igefrefpType (\ s a -> s{_igefrefpType = a})

instance FromJSON
           InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy
         where
        parseJSON
          = withObject
              "InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy"
              (\ o ->
                 InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy'
                   <$>
                   (o .:? "rules" .!= mempty) <*> (o .:? "shortName")
                     <*> (o .:? "name")
                     <*> (o .:? "displayName")
                     <*> (o .:? "type"))

instance ToJSON
           InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy
         where
        toJSON
          InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy'{..}
          = object
              (catMaybes
                 [("rules" .=) <$> _igefrefpRules,
                  ("shortName" .=) <$> _igefrefpShortName,
                  ("name" .=) <$> _igefrefpName,
                  ("displayName" .=) <$> _igefrefpDisplayName,
                  ("type" .=) <$> _igefrefpType])

-- | Deprecation status for a public resource.
--
-- /See:/ 'deprecationStatus' smart constructor.
data DeprecationStatus =
  DeprecationStatus'
    { _dsState :: !(Maybe DeprecationStatusState)
    , _dsDeleted :: !(Maybe Text)
    , _dsReplacement :: !(Maybe Text)
    , _dsObsolete :: !(Maybe Text)
    , _dsDeprecated :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DeprecationStatus' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dsState'
--
-- * 'dsDeleted'
--
-- * 'dsReplacement'
--
-- * 'dsObsolete'
--
-- * 'dsDeprecated'
deprecationStatus
    :: DeprecationStatus
deprecationStatus =
  DeprecationStatus'
    { _dsState = Nothing
    , _dsDeleted = Nothing
    , _dsReplacement = Nothing
    , _dsObsolete = Nothing
    , _dsDeprecated = Nothing
    }


-- | The deprecation state of this resource. This can be ACTIVE, DEPRECATED,
-- OBSOLETE, or DELETED. Operations which communicate the end of life date
-- for an image, can use ACTIVE. Operations which create a new resource
-- using a DEPRECATED resource will return successfully, but with a warning
-- indicating the deprecated resource and recommending its replacement.
-- Operations which use OBSOLETE or DELETED resources will be rejected and
-- result in an error.
dsState :: Lens' DeprecationStatus (Maybe DeprecationStatusState)
dsState = lens _dsState (\ s a -> s{_dsState = a})

-- | An optional RFC3339 timestamp on or after which the state of this
-- resource is intended to change to DELETED. This is only informational
-- and the status will not change unless the client explicitly changes it.
dsDeleted :: Lens' DeprecationStatus (Maybe Text)
dsDeleted
  = lens _dsDeleted (\ s a -> s{_dsDeleted = a})

-- | The URL of the suggested replacement for a deprecated resource. The
-- suggested replacement resource must be the same kind of resource as the
-- deprecated resource.
dsReplacement :: Lens' DeprecationStatus (Maybe Text)
dsReplacement
  = lens _dsReplacement
      (\ s a -> s{_dsReplacement = a})

-- | An optional RFC3339 timestamp on or after which the state of this
-- resource is intended to change to OBSOLETE. This is only informational
-- and the status will not change unless the client explicitly changes it.
dsObsolete :: Lens' DeprecationStatus (Maybe Text)
dsObsolete
  = lens _dsObsolete (\ s a -> s{_dsObsolete = a})

-- | An optional RFC3339 timestamp on or after which the state of this
-- resource is intended to change to DEPRECATED. This is only informational
-- and the status will not change unless the client explicitly changes it.
dsDeprecated :: Lens' DeprecationStatus (Maybe Text)
dsDeprecated
  = lens _dsDeprecated (\ s a -> s{_dsDeprecated = a})

instance FromJSON DeprecationStatus where
        parseJSON
          = withObject "DeprecationStatus"
              (\ o ->
                 DeprecationStatus' <$>
                   (o .:? "state") <*> (o .:? "deleted") <*>
                     (o .:? "replacement")
                     <*> (o .:? "obsolete")
                     <*> (o .:? "deprecated"))

instance ToJSON DeprecationStatus where
        toJSON DeprecationStatus'{..}
          = object
              (catMaybes
                 [("state" .=) <$> _dsState,
                  ("deleted" .=) <$> _dsDeleted,
                  ("replacement" .=) <$> _dsReplacement,
                  ("obsolete" .=) <$> _dsObsolete,
                  ("deprecated" .=) <$> _dsDeprecated])

-- | HttpRouteRuleMatch specifies a set of criteria for matching requests to
-- an HttpRouteRule. All specified criteria must be satisfied for a match
-- to occur.
--
-- /See:/ 'hTTPRouteRuleMatch' smart constructor.
data HTTPRouteRuleMatch =
  HTTPRouteRuleMatch'
    { _httprrmHeaderMatches :: !(Maybe [HTTPHeaderMatch])
    , _httprrmFullPathMatch :: !(Maybe Text)
    , _httprrmQueryParameterMatches :: !(Maybe [HTTPQueryParameterMatch])
    , _httprrmIgnoreCase :: !(Maybe Bool)
    , _httprrmPrefixMatch :: !(Maybe Text)
    , _httprrmMetadataFilters :: !(Maybe [MetadataFilter])
    , _httprrmRegexMatch :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HTTPRouteRuleMatch' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'httprrmHeaderMatches'
--
-- * 'httprrmFullPathMatch'
--
-- * 'httprrmQueryParameterMatches'
--
-- * 'httprrmIgnoreCase'
--
-- * 'httprrmPrefixMatch'
--
-- * 'httprrmMetadataFilters'
--
-- * 'httprrmRegexMatch'
hTTPRouteRuleMatch
    :: HTTPRouteRuleMatch
hTTPRouteRuleMatch =
  HTTPRouteRuleMatch'
    { _httprrmHeaderMatches = Nothing
    , _httprrmFullPathMatch = Nothing
    , _httprrmQueryParameterMatches = Nothing
    , _httprrmIgnoreCase = Nothing
    , _httprrmPrefixMatch = Nothing
    , _httprrmMetadataFilters = Nothing
    , _httprrmRegexMatch = Nothing
    }


-- | Specifies a list of header match criteria, all of which must match
-- corresponding headers in the request.
httprrmHeaderMatches :: Lens' HTTPRouteRuleMatch [HTTPHeaderMatch]
httprrmHeaderMatches
  = lens _httprrmHeaderMatches
      (\ s a -> s{_httprrmHeaderMatches = a})
      . _Default
      . _Coerce

-- | For satisfying the matchRule condition, the path of the request must
-- exactly match the value specified in fullPathMatch after removing any
-- query parameters and anchor that may be part of the original URL.
-- fullPathMatch must be between 1 and 1024 characters. Only one of
-- prefixMatch, fullPathMatch or regexMatch must be specified.
httprrmFullPathMatch :: Lens' HTTPRouteRuleMatch (Maybe Text)
httprrmFullPathMatch
  = lens _httprrmFullPathMatch
      (\ s a -> s{_httprrmFullPathMatch = a})

-- | Specifies a list of query parameter match criteria, all of which must
-- match corresponding query parameters in the request. Not supported when
-- the URL map is bound to target gRPC proxy.
httprrmQueryParameterMatches :: Lens' HTTPRouteRuleMatch [HTTPQueryParameterMatch]
httprrmQueryParameterMatches
  = lens _httprrmQueryParameterMatches
      (\ s a -> s{_httprrmQueryParameterMatches = a})
      . _Default
      . _Coerce

-- | Specifies that prefixMatch and fullPathMatch matches are case sensitive.
-- The default value is false. ignoreCase must not be used with regexMatch.
-- Not supported when the URL map is bound to target gRPC proxy.
httprrmIgnoreCase :: Lens' HTTPRouteRuleMatch (Maybe Bool)
httprrmIgnoreCase
  = lens _httprrmIgnoreCase
      (\ s a -> s{_httprrmIgnoreCase = a})

-- | For satisfying the matchRule condition, the request\'s path must begin
-- with the specified prefixMatch. prefixMatch must begin with a \/. The
-- value must be between 1 and 1024 characters. Only one of prefixMatch,
-- fullPathMatch or regexMatch must be specified.
httprrmPrefixMatch :: Lens' HTTPRouteRuleMatch (Maybe Text)
httprrmPrefixMatch
  = lens _httprrmPrefixMatch
      (\ s a -> s{_httprrmPrefixMatch = a})

-- | Opaque filter criteria used by Loadbalancer to restrict routing
-- configuration to a limited set of xDS compliant clients. In their xDS
-- requests to Loadbalancer, xDS clients present node metadata. When there
-- is a match, the relevant routing configuration is made available to
-- those proxies. For each metadataFilter in this list, if its
-- filterMatchCriteria is set to MATCH_ANY, at least one of the
-- filterLabels must match the corresponding label provided in the
-- metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of
-- its filterLabels must match with corresponding labels provided in the
-- metadata. If multiple metadataFilters are specified, all of them need to
-- be satisfied in order to be considered a match. metadataFilters
-- specified here will be applied after those specified in ForwardingRule
-- that refers to the UrlMap this HttpRouteRuleMatch belongs to.
-- metadataFilters only applies to Loadbalancers that have their
-- loadBalancingScheme set to INTERNAL_SELF_MANAGED. Not supported when the
-- URL map is bound to target gRPC proxy that has validateForProxyless
-- field set to true.
httprrmMetadataFilters :: Lens' HTTPRouteRuleMatch [MetadataFilter]
httprrmMetadataFilters
  = lens _httprrmMetadataFilters
      (\ s a -> s{_httprrmMetadataFilters = a})
      . _Default
      . _Coerce

-- | For satisfying the matchRule condition, the path of the request must
-- satisfy the regular expression specified in regexMatch after removing
-- any query parameters and anchor supplied with the original URL. For
-- regular expression grammar please see
-- github.com\/google\/re2\/wiki\/Syntax Only one of prefixMatch,
-- fullPathMatch or regexMatch must be specified. Note that regexMatch only
-- applies to Loadbalancers that have their loadBalancingScheme set to
-- INTERNAL_SELF_MANAGED.
httprrmRegexMatch :: Lens' HTTPRouteRuleMatch (Maybe Text)
httprrmRegexMatch
  = lens _httprrmRegexMatch
      (\ s a -> s{_httprrmRegexMatch = a})

instance FromJSON HTTPRouteRuleMatch where
        parseJSON
          = withObject "HTTPRouteRuleMatch"
              (\ o ->
                 HTTPRouteRuleMatch' <$>
                   (o .:? "headerMatches" .!= mempty) <*>
                     (o .:? "fullPathMatch")
                     <*> (o .:? "queryParameterMatches" .!= mempty)
                     <*> (o .:? "ignoreCase")
                     <*> (o .:? "prefixMatch")
                     <*> (o .:? "metadataFilters" .!= mempty)
                     <*> (o .:? "regexMatch"))

instance ToJSON HTTPRouteRuleMatch where
        toJSON HTTPRouteRuleMatch'{..}
          = object
              (catMaybes
                 [("headerMatches" .=) <$> _httprrmHeaderMatches,
                  ("fullPathMatch" .=) <$> _httprrmFullPathMatch,
                  ("queryParameterMatches" .=) <$>
                    _httprrmQueryParameterMatches,
                  ("ignoreCase" .=) <$> _httprrmIgnoreCase,
                  ("prefixMatch" .=) <$> _httprrmPrefixMatch,
                  ("metadataFilters" .=) <$> _httprrmMetadataFilters,
                  ("regexMatch" .=) <$> _httprrmRegexMatch])

--
-- /See:/ 'httpsHealthCheckListWarningDataItem' smart constructor.
data HTTPSHealthCheckListWarningDataItem =
  HTTPSHealthCheckListWarningDataItem'
    { _hhclwdiValue :: !(Maybe Text)
    , _hhclwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HTTPSHealthCheckListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hhclwdiValue'
--
-- * 'hhclwdiKey'
httpsHealthCheckListWarningDataItem
    :: HTTPSHealthCheckListWarningDataItem
httpsHealthCheckListWarningDataItem =
  HTTPSHealthCheckListWarningDataItem'
    {_hhclwdiValue = Nothing, _hhclwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
hhclwdiValue :: Lens' HTTPSHealthCheckListWarningDataItem (Maybe Text)
hhclwdiValue
  = lens _hhclwdiValue (\ s a -> s{_hhclwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
hhclwdiKey :: Lens' HTTPSHealthCheckListWarningDataItem (Maybe Text)
hhclwdiKey
  = lens _hhclwdiKey (\ s a -> s{_hhclwdiKey = a})

instance FromJSON HTTPSHealthCheckListWarningDataItem
         where
        parseJSON
          = withObject "HTTPSHealthCheckListWarningDataItem"
              (\ o ->
                 HTTPSHealthCheckListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON HTTPSHealthCheckListWarningDataItem
         where
        toJSON HTTPSHealthCheckListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _hhclwdiValue,
                  ("key" .=) <$> _hhclwdiKey])

-- | A transient resource used in compute.instances.bulkInsert and
-- compute.regionInstances.bulkInsert and
-- compute.regionInstances.recommendLocations. This resource is not
-- persisted anywhere, it is used only for processing the requests.
--
-- /See:/ 'bulkInsertInstanceResource' smart constructor.
data BulkInsertInstanceResource =
  BulkInsertInstanceResource'
    { _biirNamePattern :: !(Maybe Text)
    , _biirInstanceProperties :: !(Maybe InstanceProperties)
    , _biirCount :: !(Maybe (Textual Int64))
    , _biirSourceInstanceTemplate :: !(Maybe Text)
    , _biirPerInstanceProperties :: !(Maybe BulkInsertInstanceResourceSchema)
    , _biirLocationPolicy :: !(Maybe LocationPolicy)
    , _biirMinCount :: !(Maybe (Textual Int64))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BulkInsertInstanceResource' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'biirNamePattern'
--
-- * 'biirInstanceProperties'
--
-- * 'biirCount'
--
-- * 'biirSourceInstanceTemplate'
--
-- * 'biirPerInstanceProperties'
--
-- * 'biirLocationPolicy'
--
-- * 'biirMinCount'
bulkInsertInstanceResource
    :: BulkInsertInstanceResource
bulkInsertInstanceResource =
  BulkInsertInstanceResource'
    { _biirNamePattern = Nothing
    , _biirInstanceProperties = Nothing
    , _biirCount = Nothing
    , _biirSourceInstanceTemplate = Nothing
    , _biirPerInstanceProperties = Nothing
    , _biirLocationPolicy = Nothing
    , _biirMinCount = Nothing
    }


-- | The string pattern used for the names of the VMs. Either name_pattern or
-- per_instance_properties must be set. The pattern should contain one
-- continuous sequence of placeholder hash characters (#) with each
-- character corresponding to one digit of the generated instance name.
-- Example: name_pattern of inst-#### will generate instance names such as
-- inst-0001, inst-0002, ... . If there already exist instance(s) whose
-- names match the name pattern in the same project and zone, then the
-- generated instance numbers will start after the biggest existing number.
-- For example, if there exists an instance with name inst-0050, then
-- instance names generated using the pattern inst-#### will be inst-0051,
-- inst-0052, etc. The name pattern placeholder #...# can contain up to 18
-- characters.
biirNamePattern :: Lens' BulkInsertInstanceResource (Maybe Text)
biirNamePattern
  = lens _biirNamePattern
      (\ s a -> s{_biirNamePattern = a})

-- | The instance properties defining the VM instances to be created.
-- Required if sourceInstanceTemplate is not provided.
biirInstanceProperties :: Lens' BulkInsertInstanceResource (Maybe InstanceProperties)
biirInstanceProperties
  = lens _biirInstanceProperties
      (\ s a -> s{_biirInstanceProperties = a})

-- | The maximum number of instances to create.
biirCount :: Lens' BulkInsertInstanceResource (Maybe Int64)
biirCount
  = lens _biirCount (\ s a -> s{_biirCount = a}) .
      mapping _Coerce

-- | Specifies the instance template from which to create instances. You may
-- combine sourceInstanceTemplate with instanceProperties to override
-- specific values from an existing instance template. Bulk API follows the
-- semantics of JSON Merge Patch described by RFC 7396. It can be a full or
-- partial URL. For example, the following are all valid URLs to an
-- instance template: -
-- https:\/\/www.googleapis.com\/compute\/v1\/projects\/project\/global\/instanceTemplates\/instanceTemplate
-- - projects\/project\/global\/instanceTemplates\/instanceTemplate -
-- global\/instanceTemplates\/instanceTemplate This field is optional.
biirSourceInstanceTemplate :: Lens' BulkInsertInstanceResource (Maybe Text)
biirSourceInstanceTemplate
  = lens _biirSourceInstanceTemplate
      (\ s a -> s{_biirSourceInstanceTemplate = a})

-- | Per-instance properties to be set on individual instances. Keys of this
-- map specify requested instance names. Can be empty if name_pattern is
-- used.
biirPerInstanceProperties :: Lens' BulkInsertInstanceResource (Maybe BulkInsertInstanceResourceSchema)
biirPerInstanceProperties
  = lens _biirPerInstanceProperties
      (\ s a -> s{_biirPerInstanceProperties = a})

-- | Policy for chosing target zone.
biirLocationPolicy :: Lens' BulkInsertInstanceResource (Maybe LocationPolicy)
biirLocationPolicy
  = lens _biirLocationPolicy
      (\ s a -> s{_biirLocationPolicy = a})

-- | The minimum number of instances to create. If no min_count is specified
-- then count is used as the default value. If min_count instances cannot
-- be created, then no instances will be created and instances already
-- created will be deleted.
biirMinCount :: Lens' BulkInsertInstanceResource (Maybe Int64)
biirMinCount
  = lens _biirMinCount (\ s a -> s{_biirMinCount = a})
      . mapping _Coerce

instance FromJSON BulkInsertInstanceResource where
        parseJSON
          = withObject "BulkInsertInstanceResource"
              (\ o ->
                 BulkInsertInstanceResource' <$>
                   (o .:? "namePattern") <*>
                     (o .:? "instanceProperties")
                     <*> (o .:? "count")
                     <*> (o .:? "sourceInstanceTemplate")
                     <*> (o .:? "perInstanceProperties")
                     <*> (o .:? "locationPolicy")
                     <*> (o .:? "minCount"))

instance ToJSON BulkInsertInstanceResource where
        toJSON BulkInsertInstanceResource'{..}
          = object
              (catMaybes
                 [("namePattern" .=) <$> _biirNamePattern,
                  ("instanceProperties" .=) <$>
                    _biirInstanceProperties,
                  ("count" .=) <$> _biirCount,
                  ("sourceInstanceTemplate" .=) <$>
                    _biirSourceInstanceTemplate,
                  ("perInstanceProperties" .=) <$>
                    _biirPerInstanceProperties,
                  ("locationPolicy" .=) <$> _biirLocationPolicy,
                  ("minCount" .=) <$> _biirMinCount])

-- | Represents a match condition that incoming traffic is evaluated against.
-- Exactly one field must be specified.
--
-- /See:/ 'firewallPolicyRuleMatcher' smart constructor.
data FirewallPolicyRuleMatcher =
  FirewallPolicyRuleMatcher'
    { _fprmSrcIPRanges :: !(Maybe [Text])
    , _fprmDestIPRanges :: !(Maybe [Text])
    , _fprmLayer4Configs :: !(Maybe [FirewallPolicyRuleMatcherLayer4Config])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'FirewallPolicyRuleMatcher' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'fprmSrcIPRanges'
--
-- * 'fprmDestIPRanges'
--
-- * 'fprmLayer4Configs'
firewallPolicyRuleMatcher
    :: FirewallPolicyRuleMatcher
firewallPolicyRuleMatcher =
  FirewallPolicyRuleMatcher'
    { _fprmSrcIPRanges = Nothing
    , _fprmDestIPRanges = Nothing
    , _fprmLayer4Configs = Nothing
    }


-- | CIDR IP address range. Maximum number of source CIDR IP ranges allowed
-- is 256.
fprmSrcIPRanges :: Lens' FirewallPolicyRuleMatcher [Text]
fprmSrcIPRanges
  = lens _fprmSrcIPRanges
      (\ s a -> s{_fprmSrcIPRanges = a})
      . _Default
      . _Coerce

-- | CIDR IP address range. Maximum number of destination CIDR IP ranges
-- allowed is 256.
fprmDestIPRanges :: Lens' FirewallPolicyRuleMatcher [Text]
fprmDestIPRanges
  = lens _fprmDestIPRanges
      (\ s a -> s{_fprmDestIPRanges = a})
      . _Default
      . _Coerce

-- | Pairs of IP protocols and ports that the rule should match.
fprmLayer4Configs :: Lens' FirewallPolicyRuleMatcher [FirewallPolicyRuleMatcherLayer4Config]
fprmLayer4Configs
  = lens _fprmLayer4Configs
      (\ s a -> s{_fprmLayer4Configs = a})
      . _Default
      . _Coerce

instance FromJSON FirewallPolicyRuleMatcher where
        parseJSON
          = withObject "FirewallPolicyRuleMatcher"
              (\ o ->
                 FirewallPolicyRuleMatcher' <$>
                   (o .:? "srcIpRanges" .!= mempty) <*>
                     (o .:? "destIpRanges" .!= mempty)
                     <*> (o .:? "layer4Configs" .!= mempty))

instance ToJSON FirewallPolicyRuleMatcher where
        toJSON FirewallPolicyRuleMatcher'{..}
          = object
              (catMaybes
                 [("srcIpRanges" .=) <$> _fprmSrcIPRanges,
                  ("destIpRanges" .=) <$> _fprmDestIPRanges,
                  ("layer4Configs" .=) <$> _fprmLayer4Configs])

-- | Represents a Persistent Disk Snapshot resource. You can use snapshots to
-- back up data on a regular interval. For more information, read Creating
-- persistent disk snapshots. (== resource_for {$api_version}.snapshots ==)
--
-- /See:/ 'snapshot' smart constructor.
data Snapshot =
  Snapshot'
    { _snaStorageBytesStatus :: !(Maybe SnapshotStorageBytesStatus)
    , _snaSatisfiesPzs :: !(Maybe Bool)
    , _snaStatus :: !(Maybe SnapshotStatus)
    , _snaChainName :: !(Maybe Text)
    , _snaDiskSizeGb :: !(Maybe (Textual Int64))
    , _snaDownloadBytes :: !(Maybe (Textual Int64))
    , _snaSourceDiskId :: !(Maybe Text)
    , _snaKind :: !Text
    , _snaSourceDiskEncryptionKey :: !(Maybe CustomerEncryptionKey)
    , _snaStorageBytes :: !(Maybe (Textual Int64))
    , _snaSelfLink :: !(Maybe Text)
    , _snaSnapshotEncryptionKey :: !(Maybe CustomerEncryptionKey)
    , _snaAutoCreated :: !(Maybe Bool)
    , _snaName :: !(Maybe Text)
    , _snaStorageLocations :: !(Maybe [Text])
    , _snaCreationTimestamp :: !(Maybe Text)
    , _snaLicenseCodes :: !(Maybe [Textual Int64])
    , _snaId :: !(Maybe (Textual Word64))
    , _snaLabels :: !(Maybe SnapshotLabels)
    , _snaLicenses :: !(Maybe [Text])
    , _snaSourceDisk :: !(Maybe Text)
    , _snaLocationHint :: !(Maybe Text)
    , _snaLabelFingerprint :: !(Maybe Bytes)
    , _snaDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Snapshot' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'snaStorageBytesStatus'
--
-- * 'snaSatisfiesPzs'
--
-- * 'snaStatus'
--
-- * 'snaChainName'
--
-- * 'snaDiskSizeGb'
--
-- * 'snaDownloadBytes'
--
-- * 'snaSourceDiskId'
--
-- * 'snaKind'
--
-- * 'snaSourceDiskEncryptionKey'
--
-- * 'snaStorageBytes'
--
-- * 'snaSelfLink'
--
-- * 'snaSnapshotEncryptionKey'
--
-- * 'snaAutoCreated'
--
-- * 'snaName'
--
-- * 'snaStorageLocations'
--
-- * 'snaCreationTimestamp'
--
-- * 'snaLicenseCodes'
--
-- * 'snaId'
--
-- * 'snaLabels'
--
-- * 'snaLicenses'
--
-- * 'snaSourceDisk'
--
-- * 'snaLocationHint'
--
-- * 'snaLabelFingerprint'
--
-- * 'snaDescription'
snapshot
    :: Snapshot
snapshot =
  Snapshot'
    { _snaStorageBytesStatus = Nothing
    , _snaSatisfiesPzs = Nothing
    , _snaStatus = Nothing
    , _snaChainName = Nothing
    , _snaDiskSizeGb = Nothing
    , _snaDownloadBytes = Nothing
    , _snaSourceDiskId = Nothing
    , _snaKind = "compute#snapshot"
    , _snaSourceDiskEncryptionKey = Nothing
    , _snaStorageBytes = Nothing
    , _snaSelfLink = Nothing
    , _snaSnapshotEncryptionKey = Nothing
    , _snaAutoCreated = Nothing
    , _snaName = Nothing
    , _snaStorageLocations = Nothing
    , _snaCreationTimestamp = Nothing
    , _snaLicenseCodes = Nothing
    , _snaId = Nothing
    , _snaLabels = Nothing
    , _snaLicenses = Nothing
    , _snaSourceDisk = Nothing
    , _snaLocationHint = Nothing
    , _snaLabelFingerprint = Nothing
    , _snaDescription = Nothing
    }


-- | [Output Only] An indicator whether storageBytes is in a stable state or
-- it is being adjusted as a result of shared storage reallocation. This
-- status can either be UPDATING, meaning the size of the snapshot is being
-- updated, or UP_TO_DATE, meaning the size of the snapshot is up-to-date.
snaStorageBytesStatus :: Lens' Snapshot (Maybe SnapshotStorageBytesStatus)
snaStorageBytesStatus
  = lens _snaStorageBytesStatus
      (\ s a -> s{_snaStorageBytesStatus = a})

-- | [Output Only] Reserved for future use.
snaSatisfiesPzs :: Lens' Snapshot (Maybe Bool)
snaSatisfiesPzs
  = lens _snaSatisfiesPzs
      (\ s a -> s{_snaSatisfiesPzs = a})

-- | [Output Only] The status of the snapshot. This can be CREATING,
-- DELETING, FAILED, READY, or UPLOADING.
snaStatus :: Lens' Snapshot (Maybe SnapshotStatus)
snaStatus
  = lens _snaStatus (\ s a -> s{_snaStatus = a})

-- | Creates the new snapshot in the snapshot chain labeled with the
-- specified name. The chain name must be 1-63 characters long and comply
-- with RFC1035. This is an uncommon option only for advanced service
-- owners who needs to create separate snapshot chains, for example, for
-- chargeback tracking. When you describe your snapshot resource, this
-- field is visible only if it has a non-empty value.
snaChainName :: Lens' Snapshot (Maybe Text)
snaChainName
  = lens _snaChainName (\ s a -> s{_snaChainName = a})

-- | [Output Only] Size of the source disk, specified in GB.
snaDiskSizeGb :: Lens' Snapshot (Maybe Int64)
snaDiskSizeGb
  = lens _snaDiskSizeGb
      (\ s a -> s{_snaDiskSizeGb = a})
      . mapping _Coerce

-- | [Output Only] Number of bytes downloaded to restore a snapshot to a
-- disk.
snaDownloadBytes :: Lens' Snapshot (Maybe Int64)
snaDownloadBytes
  = lens _snaDownloadBytes
      (\ s a -> s{_snaDownloadBytes = a})
      . mapping _Coerce

-- | [Output Only] The ID value of the disk used to create this snapshot.
-- This value may be used to determine whether the snapshot was taken from
-- the current or a previous instance of a given disk name.
snaSourceDiskId :: Lens' Snapshot (Maybe Text)
snaSourceDiskId
  = lens _snaSourceDiskId
      (\ s a -> s{_snaSourceDiskId = a})

-- | [Output Only] Type of the resource. Always compute#snapshot for Snapshot
-- resources.
snaKind :: Lens' Snapshot Text
snaKind = lens _snaKind (\ s a -> s{_snaKind = a})

-- | The customer-supplied encryption key of the source disk. Required if the
-- source disk is protected by a customer-supplied encryption key.
snaSourceDiskEncryptionKey :: Lens' Snapshot (Maybe CustomerEncryptionKey)
snaSourceDiskEncryptionKey
  = lens _snaSourceDiskEncryptionKey
      (\ s a -> s{_snaSourceDiskEncryptionKey = a})

-- | [Output Only] A size of the storage used by the snapshot. As snapshots
-- share storage, this number is expected to change with snapshot
-- creation\/deletion.
snaStorageBytes :: Lens' Snapshot (Maybe Int64)
snaStorageBytes
  = lens _snaStorageBytes
      (\ s a -> s{_snaStorageBytes = a})
      . mapping _Coerce

-- | [Output Only] Server-defined URL for the resource.
snaSelfLink :: Lens' Snapshot (Maybe Text)
snaSelfLink
  = lens _snaSelfLink (\ s a -> s{_snaSelfLink = a})

-- | Encrypts the snapshot using a customer-supplied encryption key. After
-- you encrypt a snapshot using a customer-supplied key, you must provide
-- the same key if you use the snapshot later. For example, you must
-- provide the encryption key when you create a disk from the encrypted
-- snapshot in a future request. Customer-supplied encryption keys do not
-- protect access to metadata of the snapshot. If you do not provide an
-- encryption key when creating the snapshot, then the snapshot will be
-- encrypted using an automatically generated key and you do not need to
-- provide a key to use the snapshot later.
snaSnapshotEncryptionKey :: Lens' Snapshot (Maybe CustomerEncryptionKey)
snaSnapshotEncryptionKey
  = lens _snaSnapshotEncryptionKey
      (\ s a -> s{_snaSnapshotEncryptionKey = a})

-- | [Output Only] Set to true if snapshots are automatically created by
-- applying resource policy on the target disk.
snaAutoCreated :: Lens' Snapshot (Maybe Bool)
snaAutoCreated
  = lens _snaAutoCreated
      (\ s a -> s{_snaAutoCreated = a})

-- | Name of the resource; provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
snaName :: Lens' Snapshot (Maybe Text)
snaName = lens _snaName (\ s a -> s{_snaName = a})

-- | Cloud Storage bucket storage location of the snapshot (regional or
-- multi-regional).
snaStorageLocations :: Lens' Snapshot [Text]
snaStorageLocations
  = lens _snaStorageLocations
      (\ s a -> s{_snaStorageLocations = a})
      . _Default
      . _Coerce

-- | [Output Only] Creation timestamp in RFC3339 text format.
snaCreationTimestamp :: Lens' Snapshot (Maybe Text)
snaCreationTimestamp
  = lens _snaCreationTimestamp
      (\ s a -> s{_snaCreationTimestamp = a})

-- | [Output Only] Integer license codes indicating which licenses are
-- attached to this snapshot.
snaLicenseCodes :: Lens' Snapshot [Int64]
snaLicenseCodes
  = lens _snaLicenseCodes
      (\ s a -> s{_snaLicenseCodes = a})
      . _Default
      . _Coerce

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
snaId :: Lens' Snapshot (Maybe Word64)
snaId
  = lens _snaId (\ s a -> s{_snaId = a}) .
      mapping _Coerce

-- | Labels to apply to this snapshot. These can be later modified by the
-- setLabels method. Label values may be empty.
snaLabels :: Lens' Snapshot (Maybe SnapshotLabels)
snaLabels
  = lens _snaLabels (\ s a -> s{_snaLabels = a})

-- | [Output Only] A list of public visible licenses that apply to this
-- snapshot. This can be because the original image had licenses attached
-- (such as a Windows image).
snaLicenses :: Lens' Snapshot [Text]
snaLicenses
  = lens _snaLicenses (\ s a -> s{_snaLicenses = a}) .
      _Default
      . _Coerce

-- | The source disk used to create this snapshot.
snaSourceDisk :: Lens' Snapshot (Maybe Text)
snaSourceDisk
  = lens _snaSourceDisk
      (\ s a -> s{_snaSourceDisk = a})

-- | An opaque location hint used to place the snapshot close to other
-- resources. This field is for use by internal tools that use the public
-- API.
snaLocationHint :: Lens' Snapshot (Maybe Text)
snaLocationHint
  = lens _snaLocationHint
      (\ s a -> s{_snaLocationHint = a})

-- | A fingerprint for the labels being applied to this snapshot, which is
-- essentially a hash of the labels set used for optimistic locking. The
-- fingerprint is initially generated by Compute Engine and changes after
-- every request to modify or update labels. You must always provide an
-- up-to-date fingerprint hash in order to update or change labels,
-- otherwise the request will fail with error 412 conditionNotMet. To see
-- the latest fingerprint, make a get() request to retrieve a snapshot.
snaLabelFingerprint :: Lens' Snapshot (Maybe ByteString)
snaLabelFingerprint
  = lens _snaLabelFingerprint
      (\ s a -> s{_snaLabelFingerprint = a})
      . mapping _Bytes

-- | An optional description of this resource. Provide this property when you
-- create the resource.
snaDescription :: Lens' Snapshot (Maybe Text)
snaDescription
  = lens _snaDescription
      (\ s a -> s{_snaDescription = a})

instance FromJSON Snapshot where
        parseJSON
          = withObject "Snapshot"
              (\ o ->
                 Snapshot' <$>
                   (o .:? "storageBytesStatus") <*>
                     (o .:? "satisfiesPzs")
                     <*> (o .:? "status")
                     <*> (o .:? "chainName")
                     <*> (o .:? "diskSizeGb")
                     <*> (o .:? "downloadBytes")
                     <*> (o .:? "sourceDiskId")
                     <*> (o .:? "kind" .!= "compute#snapshot")
                     <*> (o .:? "sourceDiskEncryptionKey")
                     <*> (o .:? "storageBytes")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "snapshotEncryptionKey")
                     <*> (o .:? "autoCreated")
                     <*> (o .:? "name")
                     <*> (o .:? "storageLocations" .!= mempty)
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "licenseCodes" .!= mempty)
                     <*> (o .:? "id")
                     <*> (o .:? "labels")
                     <*> (o .:? "licenses" .!= mempty)
                     <*> (o .:? "sourceDisk")
                     <*> (o .:? "locationHint")
                     <*> (o .:? "labelFingerprint")
                     <*> (o .:? "description"))

instance ToJSON Snapshot where
        toJSON Snapshot'{..}
          = object
              (catMaybes
                 [("storageBytesStatus" .=) <$>
                    _snaStorageBytesStatus,
                  ("satisfiesPzs" .=) <$> _snaSatisfiesPzs,
                  ("status" .=) <$> _snaStatus,
                  ("chainName" .=) <$> _snaChainName,
                  ("diskSizeGb" .=) <$> _snaDiskSizeGb,
                  ("downloadBytes" .=) <$> _snaDownloadBytes,
                  ("sourceDiskId" .=) <$> _snaSourceDiskId,
                  Just ("kind" .= _snaKind),
                  ("sourceDiskEncryptionKey" .=) <$>
                    _snaSourceDiskEncryptionKey,
                  ("storageBytes" .=) <$> _snaStorageBytes,
                  ("selfLink" .=) <$> _snaSelfLink,
                  ("snapshotEncryptionKey" .=) <$>
                    _snaSnapshotEncryptionKey,
                  ("autoCreated" .=) <$> _snaAutoCreated,
                  ("name" .=) <$> _snaName,
                  ("storageLocations" .=) <$> _snaStorageLocations,
                  ("creationTimestamp" .=) <$> _snaCreationTimestamp,
                  ("licenseCodes" .=) <$> _snaLicenseCodes,
                  ("id" .=) <$> _snaId, ("labels" .=) <$> _snaLabels,
                  ("licenses" .=) <$> _snaLicenses,
                  ("sourceDisk" .=) <$> _snaSourceDisk,
                  ("locationHint" .=) <$> _snaLocationHint,
                  ("labelFingerprint" .=) <$> _snaLabelFingerprint,
                  ("description" .=) <$> _snaDescription])

--
-- /See:/ 'routerStatus' smart constructor.
data RouterStatus =
  RouterStatus'
    { _rsBestRoutesForRouter :: !(Maybe [Route])
    , _rsBGPPeerStatus :: !(Maybe [RouterStatusBGPPeerStatus])
    , _rsNetwork :: !(Maybe Text)
    , _rsNATStatus :: !(Maybe [RouterStatusNATStatus])
    , _rsBestRoutes :: !(Maybe [Route])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RouterStatus' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rsBestRoutesForRouter'
--
-- * 'rsBGPPeerStatus'
--
-- * 'rsNetwork'
--
-- * 'rsNATStatus'
--
-- * 'rsBestRoutes'
routerStatus
    :: RouterStatus
routerStatus =
  RouterStatus'
    { _rsBestRoutesForRouter = Nothing
    , _rsBGPPeerStatus = Nothing
    , _rsNetwork = Nothing
    , _rsNATStatus = Nothing
    , _rsBestRoutes = Nothing
    }


-- | Best routes learned by this router.
rsBestRoutesForRouter :: Lens' RouterStatus [Route]
rsBestRoutesForRouter
  = lens _rsBestRoutesForRouter
      (\ s a -> s{_rsBestRoutesForRouter = a})
      . _Default
      . _Coerce

rsBGPPeerStatus :: Lens' RouterStatus [RouterStatusBGPPeerStatus]
rsBGPPeerStatus
  = lens _rsBGPPeerStatus
      (\ s a -> s{_rsBGPPeerStatus = a})
      . _Default
      . _Coerce

-- | URI of the network to which this router belongs.
rsNetwork :: Lens' RouterStatus (Maybe Text)
rsNetwork
  = lens _rsNetwork (\ s a -> s{_rsNetwork = a})

rsNATStatus :: Lens' RouterStatus [RouterStatusNATStatus]
rsNATStatus
  = lens _rsNATStatus (\ s a -> s{_rsNATStatus = a}) .
      _Default
      . _Coerce

-- | Best routes for this router\'s network.
rsBestRoutes :: Lens' RouterStatus [Route]
rsBestRoutes
  = lens _rsBestRoutes (\ s a -> s{_rsBestRoutes = a})
      . _Default
      . _Coerce

instance FromJSON RouterStatus where
        parseJSON
          = withObject "RouterStatus"
              (\ o ->
                 RouterStatus' <$>
                   (o .:? "bestRoutesForRouter" .!= mempty) <*>
                     (o .:? "bgpPeerStatus" .!= mempty)
                     <*> (o .:? "network")
                     <*> (o .:? "natStatus" .!= mempty)
                     <*> (o .:? "bestRoutes" .!= mempty))

instance ToJSON RouterStatus where
        toJSON RouterStatus'{..}
          = object
              (catMaybes
                 [("bestRoutesForRouter" .=) <$>
                    _rsBestRoutesForRouter,
                  ("bgpPeerStatus" .=) <$> _rsBGPPeerStatus,
                  ("network" .=) <$> _rsNetwork,
                  ("natStatus" .=) <$> _rsNATStatus,
                  ("bestRoutes" .=) <$> _rsBestRoutes])

-- | Custom utilization metric policy.
--
-- /See:/ 'autoscalingPolicyCustomMetricUtilization' smart constructor.
data AutoscalingPolicyCustomMetricUtilization =
  AutoscalingPolicyCustomMetricUtilization'
    { _apcmuUtilizationTarget :: !(Maybe (Textual Double))
    , _apcmuMetric :: !(Maybe Text)
    , _apcmuFilter :: !(Maybe Text)
    , _apcmuSingleInstanceAssignment :: !(Maybe (Textual Double))
    , _apcmuUtilizationTargetType :: !(Maybe AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AutoscalingPolicyCustomMetricUtilization' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'apcmuUtilizationTarget'
--
-- * 'apcmuMetric'
--
-- * 'apcmuFilter'
--
-- * 'apcmuSingleInstanceAssignment'
--
-- * 'apcmuUtilizationTargetType'
autoscalingPolicyCustomMetricUtilization
    :: AutoscalingPolicyCustomMetricUtilization
autoscalingPolicyCustomMetricUtilization =
  AutoscalingPolicyCustomMetricUtilization'
    { _apcmuUtilizationTarget = Nothing
    , _apcmuMetric = Nothing
    , _apcmuFilter = Nothing
    , _apcmuSingleInstanceAssignment = Nothing
    , _apcmuUtilizationTargetType = Nothing
    }


-- | The target value of the metric that autoscaler maintains. This must be a
-- positive value. A utilization metric scales number of virtual machines
-- handling requests to increase or decrease proportionally to the metric.
-- For example, a good metric to use as a utilization_target is
-- https:\/\/www.googleapis.com\/compute\/v1\/instance\/network\/received_bytes_count.
-- The autoscaler works to keep this value constant for each of the
-- instances.
apcmuUtilizationTarget :: Lens' AutoscalingPolicyCustomMetricUtilization (Maybe Double)
apcmuUtilizationTarget
  = lens _apcmuUtilizationTarget
      (\ s a -> s{_apcmuUtilizationTarget = a})
      . mapping _Coerce

-- | The identifier (type) of the Stackdriver Monitoring metric. The metric
-- cannot have negative values. The metric must have a value type of INT64
-- or DOUBLE.
apcmuMetric :: Lens' AutoscalingPolicyCustomMetricUtilization (Maybe Text)
apcmuMetric
  = lens _apcmuMetric (\ s a -> s{_apcmuMetric = a})

-- | A filter string, compatible with a Stackdriver Monitoring filter string
-- for TimeSeries.list API call. This filter is used to select a specific
-- TimeSeries for the purpose of autoscaling and to determine whether the
-- metric is exporting per-instance or per-group data. For the filter to be
-- valid for autoscaling purposes, the following rules apply: - You can
-- only use the AND operator for joining selectors. - You can only use
-- direct equality comparison operator (=) without any functions for each
-- selector. - You can specify the metric in both the filter string and in
-- the metric field. However, if specified in both places, the metric must
-- be identical. - The monitored resource type determines what kind of
-- values are expected for the metric. If it is a gce_instance, the
-- autoscaler expects the metric to include a separate TimeSeries for each
-- instance in a group. In such a case, you cannot filter on resource
-- labels. If the resource type is any other value, the autoscaler expects
-- this metric to contain values that apply to the entire autoscaled
-- instance group and resource label filtering can be performed to point
-- autoscaler at the correct TimeSeries to scale upon. This is called a
-- per-group metric for the purpose of autoscaling. If not specified, the
-- type defaults to gce_instance. Try to provide a filter that is selective
-- enough to pick just one TimeSeries for the autoscaled group or for each
-- of the instances (if you are using gce_instance resource type). If
-- multiple TimeSeries are returned upon the query execution, the
-- autoscaler will sum their respective values to obtain its scaling value.
apcmuFilter :: Lens' AutoscalingPolicyCustomMetricUtilization (Maybe Text)
apcmuFilter
  = lens _apcmuFilter (\ s a -> s{_apcmuFilter = a})

-- | If scaling is based on a per-group metric value that represents the
-- total amount of work to be done or resource usage, set this value to an
-- amount assigned for a single instance of the scaled group. Autoscaler
-- keeps the number of instances proportional to the value of this metric.
-- The metric itself does not change value due to group resizing. A good
-- metric to use with the target is for example
-- pubsub.googleapis.com\/subscription\/num_undelivered_messages or a
-- custom metric exporting the total number of requests coming to your
-- instances. A bad example would be a metric exporting an average or
-- median latency, since this value can\'t include a chunk assignable to a
-- single instance, it could be better used with utilization_target
-- instead.
apcmuSingleInstanceAssignment :: Lens' AutoscalingPolicyCustomMetricUtilization (Maybe Double)
apcmuSingleInstanceAssignment
  = lens _apcmuSingleInstanceAssignment
      (\ s a -> s{_apcmuSingleInstanceAssignment = a})
      . mapping _Coerce

-- | Defines how target utilization value is expressed for a Stackdriver
-- Monitoring metric. Either GAUGE, DELTA_PER_SECOND, or DELTA_PER_MINUTE.
apcmuUtilizationTargetType :: Lens' AutoscalingPolicyCustomMetricUtilization (Maybe AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType)
apcmuUtilizationTargetType
  = lens _apcmuUtilizationTargetType
      (\ s a -> s{_apcmuUtilizationTargetType = a})

instance FromJSON
           AutoscalingPolicyCustomMetricUtilization
         where
        parseJSON
          = withObject
              "AutoscalingPolicyCustomMetricUtilization"
              (\ o ->
                 AutoscalingPolicyCustomMetricUtilization' <$>
                   (o .:? "utilizationTarget") <*> (o .:? "metric") <*>
                     (o .:? "filter")
                     <*> (o .:? "singleInstanceAssignment")
                     <*> (o .:? "utilizationTargetType"))

instance ToJSON
           AutoscalingPolicyCustomMetricUtilization
         where
        toJSON AutoscalingPolicyCustomMetricUtilization'{..}
          = object
              (catMaybes
                 [("utilizationTarget" .=) <$>
                    _apcmuUtilizationTarget,
                  ("metric" .=) <$> _apcmuMetric,
                  ("filter" .=) <$> _apcmuFilter,
                  ("singleInstanceAssignment" .=) <$>
                    _apcmuSingleInstanceAssignment,
                  ("utilizationTargetType" .=) <$>
                    _apcmuUtilizationTargetType])

-- | Contains a list of ForwardingRule resources.
--
-- /See:/ 'forwardingRuleList' smart constructor.
data ForwardingRuleList =
  ForwardingRuleList'
    { _frlNextPageToken :: !(Maybe Text)
    , _frlKind :: !Text
    , _frlItems :: !(Maybe [ForwardingRule])
    , _frlSelfLink :: !(Maybe Text)
    , _frlWarning :: !(Maybe ForwardingRuleListWarning)
    , _frlId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ForwardingRuleList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'frlNextPageToken'
--
-- * 'frlKind'
--
-- * 'frlItems'
--
-- * 'frlSelfLink'
--
-- * 'frlWarning'
--
-- * 'frlId'
forwardingRuleList
    :: ForwardingRuleList
forwardingRuleList =
  ForwardingRuleList'
    { _frlNextPageToken = Nothing
    , _frlKind = "compute#forwardingRuleList"
    , _frlItems = Nothing
    , _frlSelfLink = Nothing
    , _frlWarning = Nothing
    , _frlId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
frlNextPageToken :: Lens' ForwardingRuleList (Maybe Text)
frlNextPageToken
  = lens _frlNextPageToken
      (\ s a -> s{_frlNextPageToken = a})

-- | Type of resource.
frlKind :: Lens' ForwardingRuleList Text
frlKind = lens _frlKind (\ s a -> s{_frlKind = a})

-- | A list of ForwardingRule resources.
frlItems :: Lens' ForwardingRuleList [ForwardingRule]
frlItems
  = lens _frlItems (\ s a -> s{_frlItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
frlSelfLink :: Lens' ForwardingRuleList (Maybe Text)
frlSelfLink
  = lens _frlSelfLink (\ s a -> s{_frlSelfLink = a})

-- | [Output Only] Informational warning message.
frlWarning :: Lens' ForwardingRuleList (Maybe ForwardingRuleListWarning)
frlWarning
  = lens _frlWarning (\ s a -> s{_frlWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
frlId :: Lens' ForwardingRuleList (Maybe Text)
frlId = lens _frlId (\ s a -> s{_frlId = a})

instance FromJSON ForwardingRuleList where
        parseJSON
          = withObject "ForwardingRuleList"
              (\ o ->
                 ForwardingRuleList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#forwardingRuleList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON ForwardingRuleList where
        toJSON ForwardingRuleList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _frlNextPageToken,
                  Just ("kind" .= _frlKind),
                  ("items" .=) <$> _frlItems,
                  ("selfLink" .=) <$> _frlSelfLink,
                  ("warning" .=) <$> _frlWarning,
                  ("id" .=) <$> _frlId])

-- | Represent a sole-tenant Node Group resource. A sole-tenant node is a
-- physical server that is dedicated to hosting VM instances only for your
-- specific project. Use sole-tenant nodes to keep your instances
-- physically separated from instances in other projects, or to group your
-- instances together on the same host hardware. For more information, read
-- Sole-tenant nodes. (== resource_for {$api_version}.nodeGroups ==)
--
-- /See:/ 'nodeGroup' smart constructor.
data NodeGroup =
  NodeGroup'
    { _ngStatus :: !(Maybe NodeGroupStatus)
    , _ngSize :: !(Maybe (Textual Int32))
    , _ngKind :: !Text
    , _ngFingerprint :: !(Maybe Bytes)
    , _ngZone :: !(Maybe Text)
    , _ngMaintenanceWindow :: !(Maybe NodeGroupMaintenanceWindow)
    , _ngSelfLink :: !(Maybe Text)
    , _ngName :: !(Maybe Text)
    , _ngCreationTimestamp :: !(Maybe Text)
    , _ngAutoscalingPolicy :: !(Maybe NodeGroupAutoscalingPolicy)
    , _ngId :: !(Maybe (Textual Word64))
    , _ngMaintenancePolicy :: !(Maybe NodeGroupMaintenancePolicy)
    , _ngNodeTemplate :: !(Maybe Text)
    , _ngLocationHint :: !(Maybe Text)
    , _ngDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeGroup' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ngStatus'
--
-- * 'ngSize'
--
-- * 'ngKind'
--
-- * 'ngFingerprint'
--
-- * 'ngZone'
--
-- * 'ngMaintenanceWindow'
--
-- * 'ngSelfLink'
--
-- * 'ngName'
--
-- * 'ngCreationTimestamp'
--
-- * 'ngAutoscalingPolicy'
--
-- * 'ngId'
--
-- * 'ngMaintenancePolicy'
--
-- * 'ngNodeTemplate'
--
-- * 'ngLocationHint'
--
-- * 'ngDescription'
nodeGroup
    :: NodeGroup
nodeGroup =
  NodeGroup'
    { _ngStatus = Nothing
    , _ngSize = Nothing
    , _ngKind = "compute#nodeGroup"
    , _ngFingerprint = Nothing
    , _ngZone = Nothing
    , _ngMaintenanceWindow = Nothing
    , _ngSelfLink = Nothing
    , _ngName = Nothing
    , _ngCreationTimestamp = Nothing
    , _ngAutoscalingPolicy = Nothing
    , _ngId = Nothing
    , _ngMaintenancePolicy = Nothing
    , _ngNodeTemplate = Nothing
    , _ngLocationHint = Nothing
    , _ngDescription = Nothing
    }


ngStatus :: Lens' NodeGroup (Maybe NodeGroupStatus)
ngStatus = lens _ngStatus (\ s a -> s{_ngStatus = a})

-- | [Output Only] The total number of nodes in the node group.
ngSize :: Lens' NodeGroup (Maybe Int32)
ngSize
  = lens _ngSize (\ s a -> s{_ngSize = a}) .
      mapping _Coerce

-- | [Output Only] The type of the resource. Always compute#nodeGroup for
-- node group.
ngKind :: Lens' NodeGroup Text
ngKind = lens _ngKind (\ s a -> s{_ngKind = a})

ngFingerprint :: Lens' NodeGroup (Maybe ByteString)
ngFingerprint
  = lens _ngFingerprint
      (\ s a -> s{_ngFingerprint = a})
      . mapping _Bytes

-- | [Output Only] The name of the zone where the node group resides, such as
-- us-central1-a.
ngZone :: Lens' NodeGroup (Maybe Text)
ngZone = lens _ngZone (\ s a -> s{_ngZone = a})

ngMaintenanceWindow :: Lens' NodeGroup (Maybe NodeGroupMaintenanceWindow)
ngMaintenanceWindow
  = lens _ngMaintenanceWindow
      (\ s a -> s{_ngMaintenanceWindow = a})

-- | [Output Only] Server-defined URL for the resource.
ngSelfLink :: Lens' NodeGroup (Maybe Text)
ngSelfLink
  = lens _ngSelfLink (\ s a -> s{_ngSelfLink = a})

-- | The name of the resource, provided by the client when initially creating
-- the resource. The resource name must be 1-63 characters long, and comply
-- with RFC1035. Specifically, the name must be 1-63 characters long and
-- match the regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means
-- the first character must be a lowercase letter, and all following
-- characters must be a dash, lowercase letter, or digit, except the last
-- character, which cannot be a dash.
ngName :: Lens' NodeGroup (Maybe Text)
ngName = lens _ngName (\ s a -> s{_ngName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
ngCreationTimestamp :: Lens' NodeGroup (Maybe Text)
ngCreationTimestamp
  = lens _ngCreationTimestamp
      (\ s a -> s{_ngCreationTimestamp = a})

-- | Specifies how autoscaling should behave.
ngAutoscalingPolicy :: Lens' NodeGroup (Maybe NodeGroupAutoscalingPolicy)
ngAutoscalingPolicy
  = lens _ngAutoscalingPolicy
      (\ s a -> s{_ngAutoscalingPolicy = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
ngId :: Lens' NodeGroup (Maybe Word64)
ngId
  = lens _ngId (\ s a -> s{_ngId = a}) .
      mapping _Coerce

-- | Specifies how to handle instances when a node in the group undergoes
-- maintenance. Set to one of: DEFAULT, RESTART_IN_PLACE, or
-- MIGRATE_WITHIN_NODE_GROUP. The default value is DEFAULT. For more
-- information, see Maintenance policies.
ngMaintenancePolicy :: Lens' NodeGroup (Maybe NodeGroupMaintenancePolicy)
ngMaintenancePolicy
  = lens _ngMaintenancePolicy
      (\ s a -> s{_ngMaintenancePolicy = a})

-- | URL of the node template to create the node group from.
ngNodeTemplate :: Lens' NodeGroup (Maybe Text)
ngNodeTemplate
  = lens _ngNodeTemplate
      (\ s a -> s{_ngNodeTemplate = a})

-- | An opaque location hint used to place the Node close to other resources.
-- This field is for use by internal tools that use the public API. The
-- location hint here on the NodeGroup overrides any location_hint present
-- in the NodeTemplate.
ngLocationHint :: Lens' NodeGroup (Maybe Text)
ngLocationHint
  = lens _ngLocationHint
      (\ s a -> s{_ngLocationHint = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource.
ngDescription :: Lens' NodeGroup (Maybe Text)
ngDescription
  = lens _ngDescription
      (\ s a -> s{_ngDescription = a})

instance FromJSON NodeGroup where
        parseJSON
          = withObject "NodeGroup"
              (\ o ->
                 NodeGroup' <$>
                   (o .:? "status") <*> (o .:? "size") <*>
                     (o .:? "kind" .!= "compute#nodeGroup")
                     <*> (o .:? "fingerprint")
                     <*> (o .:? "zone")
                     <*> (o .:? "maintenanceWindow")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "autoscalingPolicy")
                     <*> (o .:? "id")
                     <*> (o .:? "maintenancePolicy")
                     <*> (o .:? "nodeTemplate")
                     <*> (o .:? "locationHint")
                     <*> (o .:? "description"))

instance ToJSON NodeGroup where
        toJSON NodeGroup'{..}
          = object
              (catMaybes
                 [("status" .=) <$> _ngStatus,
                  ("size" .=) <$> _ngSize, Just ("kind" .= _ngKind),
                  ("fingerprint" .=) <$> _ngFingerprint,
                  ("zone" .=) <$> _ngZone,
                  ("maintenanceWindow" .=) <$> _ngMaintenanceWindow,
                  ("selfLink" .=) <$> _ngSelfLink,
                  ("name" .=) <$> _ngName,
                  ("creationTimestamp" .=) <$> _ngCreationTimestamp,
                  ("autoscalingPolicy" .=) <$> _ngAutoscalingPolicy,
                  ("id" .=) <$> _ngId,
                  ("maintenancePolicy" .=) <$> _ngMaintenancePolicy,
                  ("nodeTemplate" .=) <$> _ngNodeTemplate,
                  ("locationHint" .=) <$> _ngLocationHint,
                  ("description" .=) <$> _ngDescription])

--
-- /See:/ 'vpnTunnelsScopedList' smart constructor.
data VPNTunnelsScopedList =
  VPNTunnelsScopedList'
    { _vtslVPNTunnels :: !(Maybe [VPNTunnel])
    , _vtslWarning :: !(Maybe VPNTunnelsScopedListWarning)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNTunnelsScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vtslVPNTunnels'
--
-- * 'vtslWarning'
vpnTunnelsScopedList
    :: VPNTunnelsScopedList
vpnTunnelsScopedList =
  VPNTunnelsScopedList' {_vtslVPNTunnels = Nothing, _vtslWarning = Nothing}


-- | A list of VPN tunnels contained in this scope.
vtslVPNTunnels :: Lens' VPNTunnelsScopedList [VPNTunnel]
vtslVPNTunnels
  = lens _vtslVPNTunnels
      (\ s a -> s{_vtslVPNTunnels = a})
      . _Default
      . _Coerce

-- | Informational warning which replaces the list of addresses when the list
-- is empty.
vtslWarning :: Lens' VPNTunnelsScopedList (Maybe VPNTunnelsScopedListWarning)
vtslWarning
  = lens _vtslWarning (\ s a -> s{_vtslWarning = a})

instance FromJSON VPNTunnelsScopedList where
        parseJSON
          = withObject "VPNTunnelsScopedList"
              (\ o ->
                 VPNTunnelsScopedList' <$>
                   (o .:? "vpnTunnels" .!= mempty) <*>
                     (o .:? "warning"))

instance ToJSON VPNTunnelsScopedList where
        toJSON VPNTunnelsScopedList'{..}
          = object
              (catMaybes
                 [("vpnTunnels" .=) <$> _vtslVPNTunnels,
                  ("warning" .=) <$> _vtslWarning])

-- | Represents a secondary IP range of a subnetwork.
--
-- /See:/ 'subnetworkSecondaryRange' smart constructor.
data SubnetworkSecondaryRange =
  SubnetworkSecondaryRange'
    { _ssrRangeName :: !(Maybe Text)
    , _ssrIPCIdRRange :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SubnetworkSecondaryRange' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ssrRangeName'
--
-- * 'ssrIPCIdRRange'
subnetworkSecondaryRange
    :: SubnetworkSecondaryRange
subnetworkSecondaryRange =
  SubnetworkSecondaryRange' {_ssrRangeName = Nothing, _ssrIPCIdRRange = Nothing}


-- | The name associated with this subnetwork secondary range, used when
-- adding an alias IP range to a VM instance. The name must be 1-63
-- characters long, and comply with RFC1035. The name must be unique within
-- the subnetwork.
ssrRangeName :: Lens' SubnetworkSecondaryRange (Maybe Text)
ssrRangeName
  = lens _ssrRangeName (\ s a -> s{_ssrRangeName = a})

-- | The range of IP addresses belonging to this subnetwork secondary range.
-- Provide this property when you create the subnetwork. Ranges must be
-- unique and non-overlapping with all primary and secondary IP ranges
-- within a network. Only IPv4 is supported. The range can be any range
-- listed in the Valid ranges list.
ssrIPCIdRRange :: Lens' SubnetworkSecondaryRange (Maybe Text)
ssrIPCIdRRange
  = lens _ssrIPCIdRRange
      (\ s a -> s{_ssrIPCIdRRange = a})

instance FromJSON SubnetworkSecondaryRange where
        parseJSON
          = withObject "SubnetworkSecondaryRange"
              (\ o ->
                 SubnetworkSecondaryRange' <$>
                   (o .:? "rangeName") <*> (o .:? "ipCidrRange"))

instance ToJSON SubnetworkSecondaryRange where
        toJSON SubnetworkSecondaryRange'{..}
          = object
              (catMaybes
                 [("rangeName" .=) <$> _ssrRangeName,
                  ("ipCidrRange" .=) <$> _ssrIPCIdRRange])

--
-- /See:/ 'nodeTypesScopedList' smart constructor.
data NodeTypesScopedList =
  NodeTypesScopedList'
    { _ntslNodeTypes :: !(Maybe [NodeType])
    , _ntslWarning :: !(Maybe NodeTypesScopedListWarning)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeTypesScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ntslNodeTypes'
--
-- * 'ntslWarning'
nodeTypesScopedList
    :: NodeTypesScopedList
nodeTypesScopedList =
  NodeTypesScopedList' {_ntslNodeTypes = Nothing, _ntslWarning = Nothing}


-- | [Output Only] A list of node types contained in this scope.
ntslNodeTypes :: Lens' NodeTypesScopedList [NodeType]
ntslNodeTypes
  = lens _ntslNodeTypes
      (\ s a -> s{_ntslNodeTypes = a})
      . _Default
      . _Coerce

-- | [Output Only] An informational warning that appears when the node types
-- list is empty.
ntslWarning :: Lens' NodeTypesScopedList (Maybe NodeTypesScopedListWarning)
ntslWarning
  = lens _ntslWarning (\ s a -> s{_ntslWarning = a})

instance FromJSON NodeTypesScopedList where
        parseJSON
          = withObject "NodeTypesScopedList"
              (\ o ->
                 NodeTypesScopedList' <$>
                   (o .:? "nodeTypes" .!= mempty) <*> (o .:? "warning"))

instance ToJSON NodeTypesScopedList where
        toJSON NodeTypesScopedList'{..}
          = object
              (catMaybes
                 [("nodeTypes" .=) <$> _ntslNodeTypes,
                  ("warning" .=) <$> _ntslWarning])

--
-- /See:/ 'firewallPolicyAssociation' smart constructor.
data FirewallPolicyAssociation =
  FirewallPolicyAssociation'
    { _fpaShortName :: !(Maybe Text)
    , _fpaFirewallPolicyId :: !(Maybe Text)
    , _fpaName :: !(Maybe Text)
    , _fpaDisplayName :: !(Maybe Text)
    , _fpaAttachmentTarget :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'FirewallPolicyAssociation' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'fpaShortName'
--
-- * 'fpaFirewallPolicyId'
--
-- * 'fpaName'
--
-- * 'fpaDisplayName'
--
-- * 'fpaAttachmentTarget'
firewallPolicyAssociation
    :: FirewallPolicyAssociation
firewallPolicyAssociation =
  FirewallPolicyAssociation'
    { _fpaShortName = Nothing
    , _fpaFirewallPolicyId = Nothing
    , _fpaName = Nothing
    , _fpaDisplayName = Nothing
    , _fpaAttachmentTarget = Nothing
    }


-- | [Output Only] The short name of the firewall policy of the association.
fpaShortName :: Lens' FirewallPolicyAssociation (Maybe Text)
fpaShortName
  = lens _fpaShortName (\ s a -> s{_fpaShortName = a})

-- | [Output Only] The firewall policy ID of the association.
fpaFirewallPolicyId :: Lens' FirewallPolicyAssociation (Maybe Text)
fpaFirewallPolicyId
  = lens _fpaFirewallPolicyId
      (\ s a -> s{_fpaFirewallPolicyId = a})

-- | The name for an association.
fpaName :: Lens' FirewallPolicyAssociation (Maybe Text)
fpaName = lens _fpaName (\ s a -> s{_fpaName = a})

-- | [Output Only] Deprecated, please use short name instead. The display
-- name of the firewall policy of the association.
fpaDisplayName :: Lens' FirewallPolicyAssociation (Maybe Text)
fpaDisplayName
  = lens _fpaDisplayName
      (\ s a -> s{_fpaDisplayName = a})

-- | The target that the firewall policy is attached to.
fpaAttachmentTarget :: Lens' FirewallPolicyAssociation (Maybe Text)
fpaAttachmentTarget
  = lens _fpaAttachmentTarget
      (\ s a -> s{_fpaAttachmentTarget = a})

instance FromJSON FirewallPolicyAssociation where
        parseJSON
          = withObject "FirewallPolicyAssociation"
              (\ o ->
                 FirewallPolicyAssociation' <$>
                   (o .:? "shortName") <*> (o .:? "firewallPolicyId")
                     <*> (o .:? "name")
                     <*> (o .:? "displayName")
                     <*> (o .:? "attachmentTarget"))

instance ToJSON FirewallPolicyAssociation where
        toJSON FirewallPolicyAssociation'{..}
          = object
              (catMaybes
                 [("shortName" .=) <$> _fpaShortName,
                  ("firewallPolicyId" .=) <$> _fpaFirewallPolicyId,
                  ("name" .=) <$> _fpaName,
                  ("displayName" .=) <$> _fpaDisplayName,
                  ("attachmentTarget" .=) <$> _fpaAttachmentTarget])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'regionInstanceGroupsListInstancesWarning' smart constructor.
data RegionInstanceGroupsListInstancesWarning =
  RegionInstanceGroupsListInstancesWarning'
    { _rigliwData :: !(Maybe [RegionInstanceGroupsListInstancesWarningDataItem])
    , _rigliwCode :: !(Maybe RegionInstanceGroupsListInstancesWarningCode)
    , _rigliwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupsListInstancesWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rigliwData'
--
-- * 'rigliwCode'
--
-- * 'rigliwMessage'
regionInstanceGroupsListInstancesWarning
    :: RegionInstanceGroupsListInstancesWarning
regionInstanceGroupsListInstancesWarning =
  RegionInstanceGroupsListInstancesWarning'
    {_rigliwData = Nothing, _rigliwCode = Nothing, _rigliwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
rigliwData :: Lens' RegionInstanceGroupsListInstancesWarning [RegionInstanceGroupsListInstancesWarningDataItem]
rigliwData
  = lens _rigliwData (\ s a -> s{_rigliwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
rigliwCode :: Lens' RegionInstanceGroupsListInstancesWarning (Maybe RegionInstanceGroupsListInstancesWarningCode)
rigliwCode
  = lens _rigliwCode (\ s a -> s{_rigliwCode = a})

-- | [Output Only] A human-readable description of the warning code.
rigliwMessage :: Lens' RegionInstanceGroupsListInstancesWarning (Maybe Text)
rigliwMessage
  = lens _rigliwMessage
      (\ s a -> s{_rigliwMessage = a})

instance FromJSON
           RegionInstanceGroupsListInstancesWarning
         where
        parseJSON
          = withObject
              "RegionInstanceGroupsListInstancesWarning"
              (\ o ->
                 RegionInstanceGroupsListInstancesWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON
           RegionInstanceGroupsListInstancesWarning
         where
        toJSON RegionInstanceGroupsListInstancesWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _rigliwData,
                  ("code" .=) <$> _rigliwCode,
                  ("message" .=) <$> _rigliwMessage])

--
-- /See:/ 'networkEndpointGroupsDetachEndpointsRequest' smart constructor.
newtype NetworkEndpointGroupsDetachEndpointsRequest =
  NetworkEndpointGroupsDetachEndpointsRequest'
    { _negderNetworkEndpoints :: Maybe [NetworkEndpoint]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkEndpointGroupsDetachEndpointsRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'negderNetworkEndpoints'
networkEndpointGroupsDetachEndpointsRequest
    :: NetworkEndpointGroupsDetachEndpointsRequest
networkEndpointGroupsDetachEndpointsRequest =
  NetworkEndpointGroupsDetachEndpointsRequest'
    {_negderNetworkEndpoints = Nothing}


-- | The list of network endpoints to be detached.
negderNetworkEndpoints :: Lens' NetworkEndpointGroupsDetachEndpointsRequest [NetworkEndpoint]
negderNetworkEndpoints
  = lens _negderNetworkEndpoints
      (\ s a -> s{_negderNetworkEndpoints = a})
      . _Default
      . _Coerce

instance FromJSON
           NetworkEndpointGroupsDetachEndpointsRequest
         where
        parseJSON
          = withObject
              "NetworkEndpointGroupsDetachEndpointsRequest"
              (\ o ->
                 NetworkEndpointGroupsDetachEndpointsRequest' <$>
                   (o .:? "networkEndpoints" .!= mempty))

instance ToJSON
           NetworkEndpointGroupsDetachEndpointsRequest
         where
        toJSON
          NetworkEndpointGroupsDetachEndpointsRequest'{..}
          = object
              (catMaybes
                 [("networkEndpoints" .=) <$>
                    _negderNetworkEndpoints])

-- | Specifies the audit configuration for a service. The configuration
-- determines which permission types are logged, and what identities, if
-- any, are exempted from logging. An AuditConfig must have one or more
-- AuditLogConfigs. If there are AuditConfigs for both \`allServices\` and
-- a specific service, the union of the two AuditConfigs is used for that
-- service: the log_types specified in each AuditConfig are enabled, and
-- the exempted_members in each AuditLogConfig are exempted. Example Policy
-- with multiple AuditConfigs: { \"audit_configs\": [ { \"service\":
-- \"allServices\", \"audit_log_configs\": [ { \"log_type\": \"DATA_READ\",
-- \"exempted_members\": [ \"user:jose\'example.com\" ] }, { \"log_type\":
-- \"DATA_WRITE\" }, { \"log_type\": \"ADMIN_READ\" } ] }, { \"service\":
-- \"sampleservice.googleapis.com\", \"audit_log_configs\": [ {
-- \"log_type\": \"DATA_READ\" }, { \"log_type\": \"DATA_WRITE\",
-- \"exempted_members\": [ \"user:aliya\'example.com\" ] } ] } ] } For
-- sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ
-- logging. It also exempts jose\'example.com from DATA_READ logging, and
-- aliya\'example.com from DATA_WRITE logging.
--
-- /See:/ 'auditConfig' smart constructor.
data AuditConfig =
  AuditConfig'
    { _acService :: !(Maybe Text)
    , _acAuditLogConfigs :: !(Maybe [AuditLogConfig])
    , _acExemptedMembers :: !(Maybe [Text])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AuditConfig' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'acService'
--
-- * 'acAuditLogConfigs'
--
-- * 'acExemptedMembers'
auditConfig
    :: AuditConfig
auditConfig =
  AuditConfig'
    { _acService = Nothing
    , _acAuditLogConfigs = Nothing
    , _acExemptedMembers = Nothing
    }


-- | Specifies a service that will be enabled for audit logging. For example,
-- \`storage.googleapis.com\`, \`cloudsql.googleapis.com\`. \`allServices\`
-- is a special value that covers all services.
acService :: Lens' AuditConfig (Maybe Text)
acService
  = lens _acService (\ s a -> s{_acService = a})

-- | The configuration for logging of each type of permission.
acAuditLogConfigs :: Lens' AuditConfig [AuditLogConfig]
acAuditLogConfigs
  = lens _acAuditLogConfigs
      (\ s a -> s{_acAuditLogConfigs = a})
      . _Default
      . _Coerce

-- |
acExemptedMembers :: Lens' AuditConfig [Text]
acExemptedMembers
  = lens _acExemptedMembers
      (\ s a -> s{_acExemptedMembers = a})
      . _Default
      . _Coerce

instance FromJSON AuditConfig where
        parseJSON
          = withObject "AuditConfig"
              (\ o ->
                 AuditConfig' <$>
                   (o .:? "service") <*>
                     (o .:? "auditLogConfigs" .!= mempty)
                     <*> (o .:? "exemptedMembers" .!= mempty))

instance ToJSON AuditConfig where
        toJSON AuditConfig'{..}
          = object
              (catMaybes
                 [("service" .=) <$> _acService,
                  ("auditLogConfigs" .=) <$> _acAuditLogConfigs,
                  ("exemptedMembers" .=) <$> _acExemptedMembers])

--
-- /See:/ 'acceleratorTypeAggregatedListWarningDataItem' smart constructor.
data AcceleratorTypeAggregatedListWarningDataItem =
  AcceleratorTypeAggregatedListWarningDataItem'
    { _atalwdiValue :: !(Maybe Text)
    , _atalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AcceleratorTypeAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'atalwdiValue'
--
-- * 'atalwdiKey'
acceleratorTypeAggregatedListWarningDataItem
    :: AcceleratorTypeAggregatedListWarningDataItem
acceleratorTypeAggregatedListWarningDataItem =
  AcceleratorTypeAggregatedListWarningDataItem'
    {_atalwdiValue = Nothing, _atalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
atalwdiValue :: Lens' AcceleratorTypeAggregatedListWarningDataItem (Maybe Text)
atalwdiValue
  = lens _atalwdiValue (\ s a -> s{_atalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
atalwdiKey :: Lens' AcceleratorTypeAggregatedListWarningDataItem (Maybe Text)
atalwdiKey
  = lens _atalwdiKey (\ s a -> s{_atalwdiKey = a})

instance FromJSON
           AcceleratorTypeAggregatedListWarningDataItem
         where
        parseJSON
          = withObject
              "AcceleratorTypeAggregatedListWarningDataItem"
              (\ o ->
                 AcceleratorTypeAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           AcceleratorTypeAggregatedListWarningDataItem
         where
        toJSON
          AcceleratorTypeAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _atalwdiValue,
                  ("key" .=) <$> _atalwdiKey])

--
-- /See:/ 'instanceGroupsSetNamedPortsRequest' smart constructor.
data InstanceGroupsSetNamedPortsRequest =
  InstanceGroupsSetNamedPortsRequest'
    { _igsnprFingerprint :: !(Maybe Bytes)
    , _igsnprNamedPorts :: !(Maybe [NamedPort])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupsSetNamedPortsRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igsnprFingerprint'
--
-- * 'igsnprNamedPorts'
instanceGroupsSetNamedPortsRequest
    :: InstanceGroupsSetNamedPortsRequest
instanceGroupsSetNamedPortsRequest =
  InstanceGroupsSetNamedPortsRequest'
    {_igsnprFingerprint = Nothing, _igsnprNamedPorts = Nothing}


-- | The fingerprint of the named ports information for this instance group.
-- Use this optional property to prevent conflicts when multiple users
-- change the named ports settings concurrently. Obtain the fingerprint
-- with the instanceGroups.get method. Then, include the fingerprint in
-- your request to ensure that you do not overwrite changes that were
-- applied from another concurrent request. A request with an incorrect
-- fingerprint will fail with error 412 conditionNotMet.
igsnprFingerprint :: Lens' InstanceGroupsSetNamedPortsRequest (Maybe ByteString)
igsnprFingerprint
  = lens _igsnprFingerprint
      (\ s a -> s{_igsnprFingerprint = a})
      . mapping _Bytes

-- | The list of named ports to set for this instance group.
igsnprNamedPorts :: Lens' InstanceGroupsSetNamedPortsRequest [NamedPort]
igsnprNamedPorts
  = lens _igsnprNamedPorts
      (\ s a -> s{_igsnprNamedPorts = a})
      . _Default
      . _Coerce

instance FromJSON InstanceGroupsSetNamedPortsRequest
         where
        parseJSON
          = withObject "InstanceGroupsSetNamedPortsRequest"
              (\ o ->
                 InstanceGroupsSetNamedPortsRequest' <$>
                   (o .:? "fingerprint") <*>
                     (o .:? "namedPorts" .!= mempty))

instance ToJSON InstanceGroupsSetNamedPortsRequest
         where
        toJSON InstanceGroupsSetNamedPortsRequest'{..}
          = object
              (catMaybes
                 [("fingerprint" .=) <$> _igsnprFingerprint,
                  ("namedPorts" .=) <$> _igsnprNamedPorts])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'publicDelegatedPrefixAggregatedListWarning' smart constructor.
data PublicDelegatedPrefixAggregatedListWarning =
  PublicDelegatedPrefixAggregatedListWarning'
    { _pdpalwData :: !(Maybe [PublicDelegatedPrefixAggregatedListWarningDataItem])
    , _pdpalwCode :: !(Maybe PublicDelegatedPrefixAggregatedListWarningCode)
    , _pdpalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PublicDelegatedPrefixAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pdpalwData'
--
-- * 'pdpalwCode'
--
-- * 'pdpalwMessage'
publicDelegatedPrefixAggregatedListWarning
    :: PublicDelegatedPrefixAggregatedListWarning
publicDelegatedPrefixAggregatedListWarning =
  PublicDelegatedPrefixAggregatedListWarning'
    {_pdpalwData = Nothing, _pdpalwCode = Nothing, _pdpalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
pdpalwData :: Lens' PublicDelegatedPrefixAggregatedListWarning [PublicDelegatedPrefixAggregatedListWarningDataItem]
pdpalwData
  = lens _pdpalwData (\ s a -> s{_pdpalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
pdpalwCode :: Lens' PublicDelegatedPrefixAggregatedListWarning (Maybe PublicDelegatedPrefixAggregatedListWarningCode)
pdpalwCode
  = lens _pdpalwCode (\ s a -> s{_pdpalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
pdpalwMessage :: Lens' PublicDelegatedPrefixAggregatedListWarning (Maybe Text)
pdpalwMessage
  = lens _pdpalwMessage
      (\ s a -> s{_pdpalwMessage = a})

instance FromJSON
           PublicDelegatedPrefixAggregatedListWarning
         where
        parseJSON
          = withObject
              "PublicDelegatedPrefixAggregatedListWarning"
              (\ o ->
                 PublicDelegatedPrefixAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON
           PublicDelegatedPrefixAggregatedListWarning
         where
        toJSON
          PublicDelegatedPrefixAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _pdpalwData,
                  ("code" .=) <$> _pdpalwCode,
                  ("message" .=) <$> _pdpalwMessage])

-- | Labels to use for node affinity, which will be used in instance
-- scheduling.
--
-- /See:/ 'nodeTemplateNodeAffinityLabels' smart constructor.
newtype NodeTemplateNodeAffinityLabels =
  NodeTemplateNodeAffinityLabels'
    { _ntnalAddtional :: HashMap Text Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeTemplateNodeAffinityLabels' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ntnalAddtional'
nodeTemplateNodeAffinityLabels
    :: HashMap Text Text -- ^ 'ntnalAddtional'
    -> NodeTemplateNodeAffinityLabels
nodeTemplateNodeAffinityLabels pNtnalAddtional_ =
  NodeTemplateNodeAffinityLabels' {_ntnalAddtional = _Coerce # pNtnalAddtional_}


ntnalAddtional :: Lens' NodeTemplateNodeAffinityLabels (HashMap Text Text)
ntnalAddtional
  = lens _ntnalAddtional
      (\ s a -> s{_ntnalAddtional = a})
      . _Coerce

instance FromJSON NodeTemplateNodeAffinityLabels
         where
        parseJSON
          = withObject "NodeTemplateNodeAffinityLabels"
              (\ o ->
                 NodeTemplateNodeAffinityLabels' <$>
                   (parseJSONObject o))

instance ToJSON NodeTemplateNodeAffinityLabels where
        toJSON = toJSON . _ntnalAddtional

-- | Contains a list of Operation resources.
--
-- /See:/ 'operationList' smart constructor.
data OperationList =
  OperationList'
    { _olNextPageToken :: !(Maybe Text)
    , _olKind :: !Text
    , _olItems :: !(Maybe [Operation])
    , _olSelfLink :: !(Maybe Text)
    , _olWarning :: !(Maybe OperationListWarning)
    , _olId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'OperationList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'olNextPageToken'
--
-- * 'olKind'
--
-- * 'olItems'
--
-- * 'olSelfLink'
--
-- * 'olWarning'
--
-- * 'olId'
operationList
    :: OperationList
operationList =
  OperationList'
    { _olNextPageToken = Nothing
    , _olKind = "compute#operationList"
    , _olItems = Nothing
    , _olSelfLink = Nothing
    , _olWarning = Nothing
    , _olId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than \`maxResults\`,
-- use the \`nextPageToken\` as a value for the query parameter
-- \`pageToken\` in the next list request. Subsequent list requests will
-- have their own \`nextPageToken\` to continue paging through the results.
olNextPageToken :: Lens' OperationList (Maybe Text)
olNextPageToken
  = lens _olNextPageToken
      (\ s a -> s{_olNextPageToken = a})

-- | [Output Only] Type of resource. Always \`compute#operations\` for
-- Operations resource.
olKind :: Lens' OperationList Text
olKind = lens _olKind (\ s a -> s{_olKind = a})

-- | [Output Only] A list of Operation resources.
olItems :: Lens' OperationList [Operation]
olItems
  = lens _olItems (\ s a -> s{_olItems = a}) . _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
olSelfLink :: Lens' OperationList (Maybe Text)
olSelfLink
  = lens _olSelfLink (\ s a -> s{_olSelfLink = a})

-- | [Output Only] Informational warning message.
olWarning :: Lens' OperationList (Maybe OperationListWarning)
olWarning
  = lens _olWarning (\ s a -> s{_olWarning = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
olId :: Lens' OperationList (Maybe Text)
olId = lens _olId (\ s a -> s{_olId = a})

instance FromJSON OperationList where
        parseJSON
          = withObject "OperationList"
              (\ o ->
                 OperationList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#operationList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON OperationList where
        toJSON OperationList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _olNextPageToken,
                  Just ("kind" .= _olKind), ("items" .=) <$> _olItems,
                  ("selfLink" .=) <$> _olSelfLink,
                  ("warning" .=) <$> _olWarning, ("id" .=) <$> _olId])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'nodeGroupListWarning' smart constructor.
data NodeGroupListWarning =
  NodeGroupListWarning'
    { _nglwData :: !(Maybe [NodeGroupListWarningDataItem])
    , _nglwCode :: !(Maybe NodeGroupListWarningCode)
    , _nglwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeGroupListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nglwData'
--
-- * 'nglwCode'
--
-- * 'nglwMessage'
nodeGroupListWarning
    :: NodeGroupListWarning
nodeGroupListWarning =
  NodeGroupListWarning'
    {_nglwData = Nothing, _nglwCode = Nothing, _nglwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
nglwData :: Lens' NodeGroupListWarning [NodeGroupListWarningDataItem]
nglwData
  = lens _nglwData (\ s a -> s{_nglwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
nglwCode :: Lens' NodeGroupListWarning (Maybe NodeGroupListWarningCode)
nglwCode = lens _nglwCode (\ s a -> s{_nglwCode = a})

-- | [Output Only] A human-readable description of the warning code.
nglwMessage :: Lens' NodeGroupListWarning (Maybe Text)
nglwMessage
  = lens _nglwMessage (\ s a -> s{_nglwMessage = a})

instance FromJSON NodeGroupListWarning where
        parseJSON
          = withObject "NodeGroupListWarning"
              (\ o ->
                 NodeGroupListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON NodeGroupListWarning where
        toJSON NodeGroupListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _nglwData,
                  ("code" .=) <$> _nglwCode,
                  ("message" .=) <$> _nglwMessage])

-- | A list of Disk resources.
--
-- /See:/ 'diskList' smart constructor.
data DiskList =
  DiskList'
    { _dlNextPageToken :: !(Maybe Text)
    , _dlKind :: !Text
    , _dlItems :: !(Maybe [Disk])
    , _dlSelfLink :: !(Maybe Text)
    , _dlWarning :: !(Maybe DiskListWarning)
    , _dlId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DiskList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dlNextPageToken'
--
-- * 'dlKind'
--
-- * 'dlItems'
--
-- * 'dlSelfLink'
--
-- * 'dlWarning'
--
-- * 'dlId'
diskList
    :: DiskList
diskList =
  DiskList'
    { _dlNextPageToken = Nothing
    , _dlKind = "compute#diskList"
    , _dlItems = Nothing
    , _dlSelfLink = Nothing
    , _dlWarning = Nothing
    , _dlId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
dlNextPageToken :: Lens' DiskList (Maybe Text)
dlNextPageToken
  = lens _dlNextPageToken
      (\ s a -> s{_dlNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#diskList for lists of
-- disks.
dlKind :: Lens' DiskList Text
dlKind = lens _dlKind (\ s a -> s{_dlKind = a})

-- | A list of Disk resources.
dlItems :: Lens' DiskList [Disk]
dlItems
  = lens _dlItems (\ s a -> s{_dlItems = a}) . _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
dlSelfLink :: Lens' DiskList (Maybe Text)
dlSelfLink
  = lens _dlSelfLink (\ s a -> s{_dlSelfLink = a})

-- | [Output Only] Informational warning message.
dlWarning :: Lens' DiskList (Maybe DiskListWarning)
dlWarning
  = lens _dlWarning (\ s a -> s{_dlWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
dlId :: Lens' DiskList (Maybe Text)
dlId = lens _dlId (\ s a -> s{_dlId = a})

instance FromJSON DiskList where
        parseJSON
          = withObject "DiskList"
              (\ o ->
                 DiskList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#diskList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON DiskList where
        toJSON DiskList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _dlNextPageToken,
                  Just ("kind" .= _dlKind), ("items" .=) <$> _dlItems,
                  ("selfLink" .=) <$> _dlSelfLink,
                  ("warning" .=) <$> _dlWarning, ("id" .=) <$> _dlId])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'networkEndpointGroupsListNetworkEndpointsWarning' smart constructor.
data NetworkEndpointGroupsListNetworkEndpointsWarning =
  NetworkEndpointGroupsListNetworkEndpointsWarning'
    { _neglnewData :: !(Maybe [NetworkEndpointGroupsListNetworkEndpointsWarningDataItem])
    , _neglnewCode :: !(Maybe NetworkEndpointGroupsListNetworkEndpointsWarningCode)
    , _neglnewMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkEndpointGroupsListNetworkEndpointsWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'neglnewData'
--
-- * 'neglnewCode'
--
-- * 'neglnewMessage'
networkEndpointGroupsListNetworkEndpointsWarning
    :: NetworkEndpointGroupsListNetworkEndpointsWarning
networkEndpointGroupsListNetworkEndpointsWarning =
  NetworkEndpointGroupsListNetworkEndpointsWarning'
    {_neglnewData = Nothing, _neglnewCode = Nothing, _neglnewMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
neglnewData :: Lens' NetworkEndpointGroupsListNetworkEndpointsWarning [NetworkEndpointGroupsListNetworkEndpointsWarningDataItem]
neglnewData
  = lens _neglnewData (\ s a -> s{_neglnewData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
neglnewCode :: Lens' NetworkEndpointGroupsListNetworkEndpointsWarning (Maybe NetworkEndpointGroupsListNetworkEndpointsWarningCode)
neglnewCode
  = lens _neglnewCode (\ s a -> s{_neglnewCode = a})

-- | [Output Only] A human-readable description of the warning code.
neglnewMessage :: Lens' NetworkEndpointGroupsListNetworkEndpointsWarning (Maybe Text)
neglnewMessage
  = lens _neglnewMessage
      (\ s a -> s{_neglnewMessage = a})

instance FromJSON
           NetworkEndpointGroupsListNetworkEndpointsWarning
         where
        parseJSON
          = withObject
              "NetworkEndpointGroupsListNetworkEndpointsWarning"
              (\ o ->
                 NetworkEndpointGroupsListNetworkEndpointsWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON
           NetworkEndpointGroupsListNetworkEndpointsWarning
         where
        toJSON
          NetworkEndpointGroupsListNetworkEndpointsWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _neglnewData,
                  ("code" .=) <$> _neglnewCode,
                  ("message" .=) <$> _neglnewMessage])

--
-- /See:/ 'regionInstanceGroupManagersListInstanceConfigsRespWarningDataItem' smart constructor.
data RegionInstanceGroupManagersListInstanceConfigsRespWarningDataItem =
  RegionInstanceGroupManagersListInstanceConfigsRespWarningDataItem'
    { _rigmlicrwdiValue :: !(Maybe Text)
    , _rigmlicrwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupManagersListInstanceConfigsRespWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rigmlicrwdiValue'
--
-- * 'rigmlicrwdiKey'
regionInstanceGroupManagersListInstanceConfigsRespWarningDataItem
    :: RegionInstanceGroupManagersListInstanceConfigsRespWarningDataItem
regionInstanceGroupManagersListInstanceConfigsRespWarningDataItem =
  RegionInstanceGroupManagersListInstanceConfigsRespWarningDataItem'
    {_rigmlicrwdiValue = Nothing, _rigmlicrwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
rigmlicrwdiValue :: Lens' RegionInstanceGroupManagersListInstanceConfigsRespWarningDataItem (Maybe Text)
rigmlicrwdiValue
  = lens _rigmlicrwdiValue
      (\ s a -> s{_rigmlicrwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
rigmlicrwdiKey :: Lens' RegionInstanceGroupManagersListInstanceConfigsRespWarningDataItem (Maybe Text)
rigmlicrwdiKey
  = lens _rigmlicrwdiKey
      (\ s a -> s{_rigmlicrwdiKey = a})

instance FromJSON
           RegionInstanceGroupManagersListInstanceConfigsRespWarningDataItem
         where
        parseJSON
          = withObject
              "RegionInstanceGroupManagersListInstanceConfigsRespWarningDataItem"
              (\ o ->
                 RegionInstanceGroupManagersListInstanceConfigsRespWarningDataItem'
                   <$> (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           RegionInstanceGroupManagersListInstanceConfigsRespWarningDataItem
         where
        toJSON
          RegionInstanceGroupManagersListInstanceConfigsRespWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _rigmlicrwdiValue,
                  ("key" .=) <$> _rigmlicrwdiKey])

--
-- /See:/ 'targetPoolsAddInstanceRequest' smart constructor.
newtype TargetPoolsAddInstanceRequest =
  TargetPoolsAddInstanceRequest'
    { _tpairInstances :: Maybe [InstanceReference]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetPoolsAddInstanceRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tpairInstances'
targetPoolsAddInstanceRequest
    :: TargetPoolsAddInstanceRequest
targetPoolsAddInstanceRequest =
  TargetPoolsAddInstanceRequest' {_tpairInstances = Nothing}


-- | A full or partial URL to an instance to add to this target pool. This
-- can be a full or partial URL. For example, the following are valid URLs:
-- -
-- https:\/\/www.googleapis.com\/compute\/v1\/projects\/project-id\/zones\/zone\/instances\/instance-name
-- - projects\/project-id\/zones\/zone\/instances\/instance-name -
-- zones\/zone\/instances\/instance-name
tpairInstances :: Lens' TargetPoolsAddInstanceRequest [InstanceReference]
tpairInstances
  = lens _tpairInstances
      (\ s a -> s{_tpairInstances = a})
      . _Default
      . _Coerce

instance FromJSON TargetPoolsAddInstanceRequest where
        parseJSON
          = withObject "TargetPoolsAddInstanceRequest"
              (\ o ->
                 TargetPoolsAddInstanceRequest' <$>
                   (o .:? "instances" .!= mempty))

instance ToJSON TargetPoolsAddInstanceRequest where
        toJSON TargetPoolsAddInstanceRequest'{..}
          = object
              (catMaybes [("instances" .=) <$> _tpairInstances])

--
-- /See:/ 'nodeGroupsDeleteNodesRequest' smart constructor.
newtype NodeGroupsDeleteNodesRequest =
  NodeGroupsDeleteNodesRequest'
    { _ngdnrNodes :: Maybe [Text]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeGroupsDeleteNodesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ngdnrNodes'
nodeGroupsDeleteNodesRequest
    :: NodeGroupsDeleteNodesRequest
nodeGroupsDeleteNodesRequest =
  NodeGroupsDeleteNodesRequest' {_ngdnrNodes = Nothing}


-- | Names of the nodes to delete.
ngdnrNodes :: Lens' NodeGroupsDeleteNodesRequest [Text]
ngdnrNodes
  = lens _ngdnrNodes (\ s a -> s{_ngdnrNodes = a}) .
      _Default
      . _Coerce

instance FromJSON NodeGroupsDeleteNodesRequest where
        parseJSON
          = withObject "NodeGroupsDeleteNodesRequest"
              (\ o ->
                 NodeGroupsDeleteNodesRequest' <$>
                   (o .:? "nodes" .!= mempty))

instance ToJSON NodeGroupsDeleteNodesRequest where
        toJSON NodeGroupsDeleteNodesRequest'{..}
          = object (catMaybes [("nodes" .=) <$> _ngdnrNodes])

-- | Contains a list of autoscalers.
--
-- /See:/ 'regionAutoscalerList' smart constructor.
data RegionAutoscalerList =
  RegionAutoscalerList'
    { _rNextPageToken :: !(Maybe Text)
    , _rKind :: !Text
    , _rItems :: !(Maybe [Autoscaler])
    , _rSelfLink :: !(Maybe Text)
    , _rWarning :: !(Maybe RegionAutoscalerListWarning)
    , _rId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionAutoscalerList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rNextPageToken'
--
-- * 'rKind'
--
-- * 'rItems'
--
-- * 'rSelfLink'
--
-- * 'rWarning'
--
-- * 'rId'
regionAutoscalerList
    :: RegionAutoscalerList
regionAutoscalerList =
  RegionAutoscalerList'
    { _rNextPageToken = Nothing
    , _rKind = "compute#regionAutoscalerList"
    , _rItems = Nothing
    , _rSelfLink = Nothing
    , _rWarning = Nothing
    , _rId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
rNextPageToken :: Lens' RegionAutoscalerList (Maybe Text)
rNextPageToken
  = lens _rNextPageToken
      (\ s a -> s{_rNextPageToken = a})

-- | Type of resource.
rKind :: Lens' RegionAutoscalerList Text
rKind = lens _rKind (\ s a -> s{_rKind = a})

-- | A list of Autoscaler resources.
rItems :: Lens' RegionAutoscalerList [Autoscaler]
rItems
  = lens _rItems (\ s a -> s{_rItems = a}) . _Default .
      _Coerce

-- | [Output Only] Server-defined URL for this resource.
rSelfLink :: Lens' RegionAutoscalerList (Maybe Text)
rSelfLink
  = lens _rSelfLink (\ s a -> s{_rSelfLink = a})

-- | [Output Only] Informational warning message.
rWarning :: Lens' RegionAutoscalerList (Maybe RegionAutoscalerListWarning)
rWarning = lens _rWarning (\ s a -> s{_rWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
rId :: Lens' RegionAutoscalerList (Maybe Text)
rId = lens _rId (\ s a -> s{_rId = a})

instance FromJSON RegionAutoscalerList where
        parseJSON
          = withObject "RegionAutoscalerList"
              (\ o ->
                 RegionAutoscalerList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#regionAutoscalerList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON RegionAutoscalerList where
        toJSON RegionAutoscalerList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _rNextPageToken,
                  Just ("kind" .= _rKind), ("items" .=) <$> _rItems,
                  ("selfLink" .=) <$> _rSelfLink,
                  ("warning" .=) <$> _rWarning, ("id" .=) <$> _rId])

--
-- /See:/ 'healthCheckListWarningDataItem' smart constructor.
data HealthCheckListWarningDataItem =
  HealthCheckListWarningDataItem'
    { _hclwdiValue :: !(Maybe Text)
    , _hclwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HealthCheckListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hclwdiValue'
--
-- * 'hclwdiKey'
healthCheckListWarningDataItem
    :: HealthCheckListWarningDataItem
healthCheckListWarningDataItem =
  HealthCheckListWarningDataItem' {_hclwdiValue = Nothing, _hclwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
hclwdiValue :: Lens' HealthCheckListWarningDataItem (Maybe Text)
hclwdiValue
  = lens _hclwdiValue (\ s a -> s{_hclwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
hclwdiKey :: Lens' HealthCheckListWarningDataItem (Maybe Text)
hclwdiKey
  = lens _hclwdiKey (\ s a -> s{_hclwdiKey = a})

instance FromJSON HealthCheckListWarningDataItem
         where
        parseJSON
          = withObject "HealthCheckListWarningDataItem"
              (\ o ->
                 HealthCheckListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON HealthCheckListWarningDataItem where
        toJSON HealthCheckListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _hclwdiValue,
                  ("key" .=) <$> _hclwdiKey])

--
-- /See:/ 'vpnGatewaysScopedList' smart constructor.
data VPNGatewaysScopedList =
  VPNGatewaysScopedList'
    { _vgslVPNGateways :: !(Maybe [VPNGateway])
    , _vgslWarning :: !(Maybe VPNGatewaysScopedListWarning)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNGatewaysScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vgslVPNGateways'
--
-- * 'vgslWarning'
vpnGatewaysScopedList
    :: VPNGatewaysScopedList
vpnGatewaysScopedList =
  VPNGatewaysScopedList' {_vgslVPNGateways = Nothing, _vgslWarning = Nothing}


-- | [Output Only] A list of VPN gateways contained in this scope.
vgslVPNGateways :: Lens' VPNGatewaysScopedList [VPNGateway]
vgslVPNGateways
  = lens _vgslVPNGateways
      (\ s a -> s{_vgslVPNGateways = a})
      . _Default
      . _Coerce

-- | [Output Only] Informational warning which replaces the list of addresses
-- when the list is empty.
vgslWarning :: Lens' VPNGatewaysScopedList (Maybe VPNGatewaysScopedListWarning)
vgslWarning
  = lens _vgslWarning (\ s a -> s{_vgslWarning = a})

instance FromJSON VPNGatewaysScopedList where
        parseJSON
          = withObject "VPNGatewaysScopedList"
              (\ o ->
                 VPNGatewaysScopedList' <$>
                   (o .:? "vpnGateways" .!= mempty) <*>
                     (o .:? "warning"))

instance ToJSON VPNGatewaysScopedList where
        toJSON VPNGatewaysScopedList'{..}
          = object
              (catMaybes
                 [("vpnGateways" .=) <$> _vgslVPNGateways,
                  ("warning" .=) <$> _vgslWarning])

-- | An HttpRouteRule specifies how to match an HTTP request and the
-- corresponding routing action that load balancing proxies will perform.
--
-- /See:/ 'hTTPRouteRule' smart constructor.
data HTTPRouteRule =
  HTTPRouteRule'
    { _httprrPriority :: !(Maybe (Textual Int32))
    , _httprrService :: !(Maybe Text)
    , _httprrHeaderAction :: !(Maybe HTTPHeaderAction)
    , _httprrRouteAction :: !(Maybe HTTPRouteAction)
    , _httprrMatchRules :: !(Maybe [HTTPRouteRuleMatch])
    , _httprrDescription :: !(Maybe Text)
    , _httprrURLRedirect :: !(Maybe HTTPRedirectAction)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HTTPRouteRule' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'httprrPriority'
--
-- * 'httprrService'
--
-- * 'httprrHeaderAction'
--
-- * 'httprrRouteAction'
--
-- * 'httprrMatchRules'
--
-- * 'httprrDescription'
--
-- * 'httprrURLRedirect'
hTTPRouteRule
    :: HTTPRouteRule
hTTPRouteRule =
  HTTPRouteRule'
    { _httprrPriority = Nothing
    , _httprrService = Nothing
    , _httprrHeaderAction = Nothing
    , _httprrRouteAction = Nothing
    , _httprrMatchRules = Nothing
    , _httprrDescription = Nothing
    , _httprrURLRedirect = Nothing
    }


-- | For routeRules within a given pathMatcher, priority determines the order
-- in which load balancer will interpret routeRules. RouteRules are
-- evaluated in order of priority, from the lowest to highest number. The
-- priority of a rule decreases as its number increases (1, 2, 3, N+1). The
-- first rule that matches the request is applied. You cannot configure two
-- or more routeRules with the same priority. Priority for each rule must
-- be set to a number between 0 and 2147483647 inclusive. Priority numbers
-- can have gaps, which enable you to add or remove rules in the future
-- without affecting the rest of the rules. For example, 1, 2, 3, 4, 5, 9,
-- 12, 16 is a valid series of priority numbers to which you could add
-- rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the future without
-- any impact on existing rules.
httprrPriority :: Lens' HTTPRouteRule (Maybe Int32)
httprrPriority
  = lens _httprrPriority
      (\ s a -> s{_httprrPriority = a})
      . mapping _Coerce

-- | The full or partial URL of the backend service resource to which traffic
-- is directed if this rule is matched. If routeAction is additionally
-- specified, advanced routing actions like URL Rewrites, etc. take effect
-- prior to sending the request to the backend. However, if service is
-- specified, routeAction cannot contain any weightedBackendService s.
-- Conversely, if routeAction specifies any weightedBackendServices,
-- service must not be specified. Only one of urlRedirect, service or
-- routeAction.weightedBackendService must be set.
httprrService :: Lens' HTTPRouteRule (Maybe Text)
httprrService
  = lens _httprrService
      (\ s a -> s{_httprrService = a})

-- | Specifies changes to request and response headers that need to take
-- effect for the selected backendService. The headerAction specified here
-- are applied before the matching pathMatchers[].headerAction and after
-- pathMatchers[].routeRules[].routeAction.weightedBackendService.backendServiceWeightAction[].headerAction
-- Note that headerAction is not supported for Loadbalancers that have
-- their loadBalancingScheme set to EXTERNAL. Not supported when the URL
-- map is bound to target gRPC proxy that has validateForProxyless field
-- set to true.
httprrHeaderAction :: Lens' HTTPRouteRule (Maybe HTTPHeaderAction)
httprrHeaderAction
  = lens _httprrHeaderAction
      (\ s a -> s{_httprrHeaderAction = a})

-- | In response to a matching matchRule, the load balancer performs advanced
-- routing actions like URL rewrites, header transformations, etc. prior to
-- forwarding the request to the selected backend. If routeAction specifies
-- any weightedBackendServices, service must not be set. Conversely if
-- service is set, routeAction cannot contain any weightedBackendServices.
-- Only one of urlRedirect, service or routeAction.weightedBackendService
-- must be set. UrlMaps for external HTTP(S) load balancers support only
-- the urlRewrite action within a routeRule\'s routeAction.
httprrRouteAction :: Lens' HTTPRouteRule (Maybe HTTPRouteAction)
httprrRouteAction
  = lens _httprrRouteAction
      (\ s a -> s{_httprrRouteAction = a})

-- | The list of criteria for matching attributes of a request to this
-- routeRule. This list has OR semantics: the request matches this
-- routeRule when any of the matchRules are satisfied. However predicates
-- within a given matchRule have AND semantics. All predicates within a
-- matchRule must match for the request to match the rule.
httprrMatchRules :: Lens' HTTPRouteRule [HTTPRouteRuleMatch]
httprrMatchRules
  = lens _httprrMatchRules
      (\ s a -> s{_httprrMatchRules = a})
      . _Default
      . _Coerce

-- | The short description conveying the intent of this routeRule. The
-- description can have a maximum length of 1024 characters.
httprrDescription :: Lens' HTTPRouteRule (Maybe Text)
httprrDescription
  = lens _httprrDescription
      (\ s a -> s{_httprrDescription = a})

-- | When this rule is matched, the request is redirected to a URL specified
-- by urlRedirect. If urlRedirect is specified, service or routeAction must
-- not be set. Not supported when the URL map is bound to target gRPC
-- proxy.
httprrURLRedirect :: Lens' HTTPRouteRule (Maybe HTTPRedirectAction)
httprrURLRedirect
  = lens _httprrURLRedirect
      (\ s a -> s{_httprrURLRedirect = a})

instance FromJSON HTTPRouteRule where
        parseJSON
          = withObject "HTTPRouteRule"
              (\ o ->
                 HTTPRouteRule' <$>
                   (o .:? "priority") <*> (o .:? "service") <*>
                     (o .:? "headerAction")
                     <*> (o .:? "routeAction")
                     <*> (o .:? "matchRules" .!= mempty)
                     <*> (o .:? "description")
                     <*> (o .:? "urlRedirect"))

instance ToJSON HTTPRouteRule where
        toJSON HTTPRouteRule'{..}
          = object
              (catMaybes
                 [("priority" .=) <$> _httprrPriority,
                  ("service" .=) <$> _httprrService,
                  ("headerAction" .=) <$> _httprrHeaderAction,
                  ("routeAction" .=) <$> _httprrRouteAction,
                  ("matchRules" .=) <$> _httprrMatchRules,
                  ("description" .=) <$> _httprrDescription,
                  ("urlRedirect" .=) <$> _httprrURLRedirect])

--
-- /See:/ 'resourcePolicyListWarningDataItem' smart constructor.
data ResourcePolicyListWarningDataItem =
  ResourcePolicyListWarningDataItem'
    { _rplwdiValue :: !(Maybe Text)
    , _rplwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePolicyListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rplwdiValue'
--
-- * 'rplwdiKey'
resourcePolicyListWarningDataItem
    :: ResourcePolicyListWarningDataItem
resourcePolicyListWarningDataItem =
  ResourcePolicyListWarningDataItem'
    {_rplwdiValue = Nothing, _rplwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
rplwdiValue :: Lens' ResourcePolicyListWarningDataItem (Maybe Text)
rplwdiValue
  = lens _rplwdiValue (\ s a -> s{_rplwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
rplwdiKey :: Lens' ResourcePolicyListWarningDataItem (Maybe Text)
rplwdiKey
  = lens _rplwdiKey (\ s a -> s{_rplwdiKey = a})

instance FromJSON ResourcePolicyListWarningDataItem
         where
        parseJSON
          = withObject "ResourcePolicyListWarningDataItem"
              (\ o ->
                 ResourcePolicyListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON ResourcePolicyListWarningDataItem
         where
        toJSON ResourcePolicyListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _rplwdiValue,
                  ("key" .=) <$> _rplwdiKey])

--
-- /See:/ 'networksUpdatePeeringRequest' smart constructor.
newtype NetworksUpdatePeeringRequest =
  NetworksUpdatePeeringRequest'
    { _nuprNetworkPeering :: Maybe NetworkPeering
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworksUpdatePeeringRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nuprNetworkPeering'
networksUpdatePeeringRequest
    :: NetworksUpdatePeeringRequest
networksUpdatePeeringRequest =
  NetworksUpdatePeeringRequest' {_nuprNetworkPeering = Nothing}


nuprNetworkPeering :: Lens' NetworksUpdatePeeringRequest (Maybe NetworkPeering)
nuprNetworkPeering
  = lens _nuprNetworkPeering
      (\ s a -> s{_nuprNetworkPeering = a})

instance FromJSON NetworksUpdatePeeringRequest where
        parseJSON
          = withObject "NetworksUpdatePeeringRequest"
              (\ o ->
                 NetworksUpdatePeeringRequest' <$>
                   (o .:? "networkPeering"))

instance ToJSON NetworksUpdatePeeringRequest where
        toJSON NetworksUpdatePeeringRequest'{..}
          = object
              (catMaybes
                 [("networkPeering" .=) <$> _nuprNetworkPeering])

--
-- /See:/ 'nodeGroupAggregatedListWarningDataItem' smart constructor.
data NodeGroupAggregatedListWarningDataItem =
  NodeGroupAggregatedListWarningDataItem'
    { _ngalwdiValue :: !(Maybe Text)
    , _ngalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeGroupAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ngalwdiValue'
--
-- * 'ngalwdiKey'
nodeGroupAggregatedListWarningDataItem
    :: NodeGroupAggregatedListWarningDataItem
nodeGroupAggregatedListWarningDataItem =
  NodeGroupAggregatedListWarningDataItem'
    {_ngalwdiValue = Nothing, _ngalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
ngalwdiValue :: Lens' NodeGroupAggregatedListWarningDataItem (Maybe Text)
ngalwdiValue
  = lens _ngalwdiValue (\ s a -> s{_ngalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
ngalwdiKey :: Lens' NodeGroupAggregatedListWarningDataItem (Maybe Text)
ngalwdiKey
  = lens _ngalwdiKey (\ s a -> s{_ngalwdiKey = a})

instance FromJSON
           NodeGroupAggregatedListWarningDataItem
         where
        parseJSON
          = withObject "NodeGroupAggregatedListWarningDataItem"
              (\ o ->
                 NodeGroupAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           NodeGroupAggregatedListWarningDataItem
         where
        toJSON NodeGroupAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _ngalwdiValue,
                  ("key" .=) <$> _ngalwdiKey])

--
-- /See:/ 'instanceGroupsAddInstancesRequest' smart constructor.
newtype InstanceGroupsAddInstancesRequest =
  InstanceGroupsAddInstancesRequest'
    { _igairInstances :: Maybe [InstanceReference]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupsAddInstancesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igairInstances'
instanceGroupsAddInstancesRequest
    :: InstanceGroupsAddInstancesRequest
instanceGroupsAddInstancesRequest =
  InstanceGroupsAddInstancesRequest' {_igairInstances = Nothing}


-- | The list of instances to add to the instance group.
igairInstances :: Lens' InstanceGroupsAddInstancesRequest [InstanceReference]
igairInstances
  = lens _igairInstances
      (\ s a -> s{_igairInstances = a})
      . _Default
      . _Coerce

instance FromJSON InstanceGroupsAddInstancesRequest
         where
        parseJSON
          = withObject "InstanceGroupsAddInstancesRequest"
              (\ o ->
                 InstanceGroupsAddInstancesRequest' <$>
                   (o .:? "instances" .!= mempty))

instance ToJSON InstanceGroupsAddInstancesRequest
         where
        toJSON InstanceGroupsAddInstancesRequest'{..}
          = object
              (catMaybes [("instances" .=) <$> _igairInstances])

-- | A list of TargetHttpsProxiesScopedList resources.
--
-- /See:/ 'targetHTTPSProxyAggregatedListItems' smart constructor.
newtype TargetHTTPSProxyAggregatedListItems =
  TargetHTTPSProxyAggregatedListItems'
    { _thpaliAddtional :: HashMap Text TargetHTTPSProxiesScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetHTTPSProxyAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'thpaliAddtional'
targetHTTPSProxyAggregatedListItems
    :: HashMap Text TargetHTTPSProxiesScopedList -- ^ 'thpaliAddtional'
    -> TargetHTTPSProxyAggregatedListItems
targetHTTPSProxyAggregatedListItems pThpaliAddtional_ =
  TargetHTTPSProxyAggregatedListItems'
    {_thpaliAddtional = _Coerce # pThpaliAddtional_}


-- | Name of the scope containing this set of TargetHttpsProxies.
thpaliAddtional :: Lens' TargetHTTPSProxyAggregatedListItems (HashMap Text TargetHTTPSProxiesScopedList)
thpaliAddtional
  = lens _thpaliAddtional
      (\ s a -> s{_thpaliAddtional = a})
      . _Coerce

instance FromJSON TargetHTTPSProxyAggregatedListItems
         where
        parseJSON
          = withObject "TargetHTTPSProxyAggregatedListItems"
              (\ o ->
                 TargetHTTPSProxyAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON TargetHTTPSProxyAggregatedListItems
         where
        toJSON = toJSON . _thpaliAddtional

-- | Represents a Health-Check as a Service resource. (== resource_for
-- {$api_version}.regionHealthCheckServices ==)
--
-- /See:/ 'healthCheckService' smart constructor.
data HealthCheckService =
  HealthCheckService'
    { _hcsNotificationEndpoints :: !(Maybe [Text])
    , _hcsKind :: !Text
    , _hcsFingerprint :: !(Maybe Bytes)
    , _hcsNetworkEndpointGroups :: !(Maybe [Text])
    , _hcsHealthStatusAggregationPolicy :: !(Maybe HealthCheckServiceHealthStatusAggregationPolicy)
    , _hcsSelfLink :: !(Maybe Text)
    , _hcsName :: !(Maybe Text)
    , _hcsCreationTimestamp :: !(Maybe Text)
    , _hcsId :: !(Maybe (Textual Word64))
    , _hcsRegion :: !(Maybe Text)
    , _hcsDescription :: !(Maybe Text)
    , _hcsHealthChecks :: !(Maybe [Text])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HealthCheckService' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hcsNotificationEndpoints'
--
-- * 'hcsKind'
--
-- * 'hcsFingerprint'
--
-- * 'hcsNetworkEndpointGroups'
--
-- * 'hcsHealthStatusAggregationPolicy'
--
-- * 'hcsSelfLink'
--
-- * 'hcsName'
--
-- * 'hcsCreationTimestamp'
--
-- * 'hcsId'
--
-- * 'hcsRegion'
--
-- * 'hcsDescription'
--
-- * 'hcsHealthChecks'
healthCheckService
    :: HealthCheckService
healthCheckService =
  HealthCheckService'
    { _hcsNotificationEndpoints = Nothing
    , _hcsKind = "compute#healthCheckService"
    , _hcsFingerprint = Nothing
    , _hcsNetworkEndpointGroups = Nothing
    , _hcsHealthStatusAggregationPolicy = Nothing
    , _hcsSelfLink = Nothing
    , _hcsName = Nothing
    , _hcsCreationTimestamp = Nothing
    , _hcsId = Nothing
    , _hcsRegion = Nothing
    , _hcsDescription = Nothing
    , _hcsHealthChecks = Nothing
    }


-- | List of URLs to the NotificationEndpoint resources. Must not have more
-- than 10. A list of endpoints for receiving notifications of change in
-- health status. For regional HealthCheckService, NotificationEndpoint
-- must be regional and in the same region. For global HealthCheckService,
-- NotificationEndpoint must be global.
hcsNotificationEndpoints :: Lens' HealthCheckService [Text]
hcsNotificationEndpoints
  = lens _hcsNotificationEndpoints
      (\ s a -> s{_hcsNotificationEndpoints = a})
      . _Default
      . _Coerce

-- | [Output only] Type of the resource. Always compute#healthCheckServicefor
-- health check services.
hcsKind :: Lens' HealthCheckService Text
hcsKind = lens _hcsKind (\ s a -> s{_hcsKind = a})

-- | Fingerprint of this resource. A hash of the contents stored in this
-- object. This field is used in optimistic locking. This field will be
-- ignored when inserting a HealthCheckService. An up-to-date fingerprint
-- must be provided in order to patch\/update the HealthCheckService;
-- Otherwise, the request will fail with error 412 conditionNotMet. To see
-- the latest fingerprint, make a get() request to retrieve the
-- HealthCheckService.
hcsFingerprint :: Lens' HealthCheckService (Maybe ByteString)
hcsFingerprint
  = lens _hcsFingerprint
      (\ s a -> s{_hcsFingerprint = a})
      . mapping _Bytes

-- | List of URLs to the NetworkEndpointGroup resources. Must not have more
-- than 100. For regional HealthCheckService, NEGs must be in zones in the
-- region of the HealthCheckService.
hcsNetworkEndpointGroups :: Lens' HealthCheckService [Text]
hcsNetworkEndpointGroups
  = lens _hcsNetworkEndpointGroups
      (\ s a -> s{_hcsNetworkEndpointGroups = a})
      . _Default
      . _Coerce

-- | Optional. Policy for how the results from multiple health checks for the
-- same endpoint are aggregated. Defaults to NO_AGGREGATION if unspecified.
-- - NO_AGGREGATION. An EndpointHealth message is returned for each backend
-- in the health check service. - AND. If any backend\'s health check
-- reports UNHEALTHY, then UNHEALTHY is the HealthState of the entire
-- health check service. If all backend\'s are healthy, the HealthState of
-- the health check service is HEALTHY. .
hcsHealthStatusAggregationPolicy :: Lens' HealthCheckService (Maybe HealthCheckServiceHealthStatusAggregationPolicy)
hcsHealthStatusAggregationPolicy
  = lens _hcsHealthStatusAggregationPolicy
      (\ s a -> s{_hcsHealthStatusAggregationPolicy = a})

-- | [Output Only] Server-defined URL for the resource.
hcsSelfLink :: Lens' HealthCheckService (Maybe Text)
hcsSelfLink
  = lens _hcsSelfLink (\ s a -> s{_hcsSelfLink = a})

-- | Name of the resource. The name must be 1-63 characters long, and comply
-- with RFC1035. Specifically, the name must be 1-63 characters long and
-- match the regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means
-- the first character must be a lowercase letter, and all following
-- characters must be a dash, lowercase letter, or digit, except the last
-- character, which cannot be a dash.
hcsName :: Lens' HealthCheckService (Maybe Text)
hcsName = lens _hcsName (\ s a -> s{_hcsName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
hcsCreationTimestamp :: Lens' HealthCheckService (Maybe Text)
hcsCreationTimestamp
  = lens _hcsCreationTimestamp
      (\ s a -> s{_hcsCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
hcsId :: Lens' HealthCheckService (Maybe Word64)
hcsId
  = lens _hcsId (\ s a -> s{_hcsId = a}) .
      mapping _Coerce

-- | [Output Only] URL of the region where the health check service resides.
-- This field is not applicable to global health check services. You must
-- specify this field as part of the HTTP request URL. It is not settable
-- as a field in the request body.
hcsRegion :: Lens' HealthCheckService (Maybe Text)
hcsRegion
  = lens _hcsRegion (\ s a -> s{_hcsRegion = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource.
hcsDescription :: Lens' HealthCheckService (Maybe Text)
hcsDescription
  = lens _hcsDescription
      (\ s a -> s{_hcsDescription = a})

-- | List of URLs to the HealthCheck resources. Must have at least one
-- HealthCheck, and not more than 10. HealthCheck resources must have
-- portSpecification=USE_SERVING_PORT or portSpecification=USE_FIXED_PORT.
-- For regional HealthCheckService, the HealthCheck must be regional and in
-- the same region. For global HealthCheckService, HealthCheck must be
-- global. Mix of regional and global HealthChecks is not supported.
-- Multiple regional HealthChecks must belong to the same region. Regional
-- HealthChecks must belong to the same region as zones of NEGs.
hcsHealthChecks :: Lens' HealthCheckService [Text]
hcsHealthChecks
  = lens _hcsHealthChecks
      (\ s a -> s{_hcsHealthChecks = a})
      . _Default
      . _Coerce

instance FromJSON HealthCheckService where
        parseJSON
          = withObject "HealthCheckService"
              (\ o ->
                 HealthCheckService' <$>
                   (o .:? "notificationEndpoints" .!= mempty) <*>
                     (o .:? "kind" .!= "compute#healthCheckService")
                     <*> (o .:? "fingerprint")
                     <*> (o .:? "networkEndpointGroups" .!= mempty)
                     <*> (o .:? "healthStatusAggregationPolicy")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "region")
                     <*> (o .:? "description")
                     <*> (o .:? "healthChecks" .!= mempty))

instance ToJSON HealthCheckService where
        toJSON HealthCheckService'{..}
          = object
              (catMaybes
                 [("notificationEndpoints" .=) <$>
                    _hcsNotificationEndpoints,
                  Just ("kind" .= _hcsKind),
                  ("fingerprint" .=) <$> _hcsFingerprint,
                  ("networkEndpointGroups" .=) <$>
                    _hcsNetworkEndpointGroups,
                  ("healthStatusAggregationPolicy" .=) <$>
                    _hcsHealthStatusAggregationPolicy,
                  ("selfLink" .=) <$> _hcsSelfLink,
                  ("name" .=) <$> _hcsName,
                  ("creationTimestamp" .=) <$> _hcsCreationTimestamp,
                  ("id" .=) <$> _hcsId, ("region" .=) <$> _hcsRegion,
                  ("description" .=) <$> _hcsDescription,
                  ("healthChecks" .=) <$> _hcsHealthChecks])

--
-- /See:/ 'nodeGroupNode' smart constructor.
data NodeGroupNode =
  NodeGroupNode'
    { _ngnSatisfiesPzs :: !(Maybe Bool)
    , _ngnStatus :: !(Maybe NodeGroupNodeStatus)
    , _ngnServerId :: !(Maybe Text)
    , _ngnServerBinding :: !(Maybe ServerBinding)
    , _ngnAccelerators :: !(Maybe [AcceleratorConfig])
    , _ngnName :: !(Maybe Text)
    , _ngnInstances :: !(Maybe [Text])
    , _ngnNodeType :: !(Maybe Text)
    , _ngnDisks :: !(Maybe [LocalDisk])
    , _ngnCPUOvercommitType :: !(Maybe NodeGroupNodeCPUOvercommitType)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeGroupNode' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ngnSatisfiesPzs'
--
-- * 'ngnStatus'
--
-- * 'ngnServerId'
--
-- * 'ngnServerBinding'
--
-- * 'ngnAccelerators'
--
-- * 'ngnName'
--
-- * 'ngnInstances'
--
-- * 'ngnNodeType'
--
-- * 'ngnDisks'
--
-- * 'ngnCPUOvercommitType'
nodeGroupNode
    :: NodeGroupNode
nodeGroupNode =
  NodeGroupNode'
    { _ngnSatisfiesPzs = Nothing
    , _ngnStatus = Nothing
    , _ngnServerId = Nothing
    , _ngnServerBinding = Nothing
    , _ngnAccelerators = Nothing
    , _ngnName = Nothing
    , _ngnInstances = Nothing
    , _ngnNodeType = Nothing
    , _ngnDisks = Nothing
    , _ngnCPUOvercommitType = Nothing
    }


-- | [Output Only] Reserved for future use.
ngnSatisfiesPzs :: Lens' NodeGroupNode (Maybe Bool)
ngnSatisfiesPzs
  = lens _ngnSatisfiesPzs
      (\ s a -> s{_ngnSatisfiesPzs = a})

ngnStatus :: Lens' NodeGroupNode (Maybe NodeGroupNodeStatus)
ngnStatus
  = lens _ngnStatus (\ s a -> s{_ngnStatus = a})

-- | Server ID associated with this node.
ngnServerId :: Lens' NodeGroupNode (Maybe Text)
ngnServerId
  = lens _ngnServerId (\ s a -> s{_ngnServerId = a})

-- | Binding properties for the physical server.
ngnServerBinding :: Lens' NodeGroupNode (Maybe ServerBinding)
ngnServerBinding
  = lens _ngnServerBinding
      (\ s a -> s{_ngnServerBinding = a})

-- | Accelerators for this node.
ngnAccelerators :: Lens' NodeGroupNode [AcceleratorConfig]
ngnAccelerators
  = lens _ngnAccelerators
      (\ s a -> s{_ngnAccelerators = a})
      . _Default
      . _Coerce

-- | The name of the node.
ngnName :: Lens' NodeGroupNode (Maybe Text)
ngnName = lens _ngnName (\ s a -> s{_ngnName = a})

-- | Instances scheduled on this node.
ngnInstances :: Lens' NodeGroupNode [Text]
ngnInstances
  = lens _ngnInstances (\ s a -> s{_ngnInstances = a})
      . _Default
      . _Coerce

-- | The type of this node.
ngnNodeType :: Lens' NodeGroupNode (Maybe Text)
ngnNodeType
  = lens _ngnNodeType (\ s a -> s{_ngnNodeType = a})

-- | Local disk configurations.
ngnDisks :: Lens' NodeGroupNode [LocalDisk]
ngnDisks
  = lens _ngnDisks (\ s a -> s{_ngnDisks = a}) .
      _Default
      . _Coerce

-- | CPU overcommit.
ngnCPUOvercommitType :: Lens' NodeGroupNode (Maybe NodeGroupNodeCPUOvercommitType)
ngnCPUOvercommitType
  = lens _ngnCPUOvercommitType
      (\ s a -> s{_ngnCPUOvercommitType = a})

instance FromJSON NodeGroupNode where
        parseJSON
          = withObject "NodeGroupNode"
              (\ o ->
                 NodeGroupNode' <$>
                   (o .:? "satisfiesPzs") <*> (o .:? "status") <*>
                     (o .:? "serverId")
                     <*> (o .:? "serverBinding")
                     <*> (o .:? "accelerators" .!= mempty)
                     <*> (o .:? "name")
                     <*> (o .:? "instances" .!= mempty)
                     <*> (o .:? "nodeType")
                     <*> (o .:? "disks" .!= mempty)
                     <*> (o .:? "cpuOvercommitType"))

instance ToJSON NodeGroupNode where
        toJSON NodeGroupNode'{..}
          = object
              (catMaybes
                 [("satisfiesPzs" .=) <$> _ngnSatisfiesPzs,
                  ("status" .=) <$> _ngnStatus,
                  ("serverId" .=) <$> _ngnServerId,
                  ("serverBinding" .=) <$> _ngnServerBinding,
                  ("accelerators" .=) <$> _ngnAccelerators,
                  ("name" .=) <$> _ngnName,
                  ("instances" .=) <$> _ngnInstances,
                  ("nodeType" .=) <$> _ngnNodeType,
                  ("disks" .=) <$> _ngnDisks,
                  ("cpuOvercommitType" .=) <$> _ngnCPUOvercommitType])

-- | Contains a list of reservations.
--
-- /See:/ 'reservationAggregatedList' smart constructor.
data ReservationAggregatedList =
  ReservationAggregatedList'
    { _resUnreachables :: !(Maybe [Text])
    , _resNextPageToken :: !(Maybe Text)
    , _resKind :: !Text
    , _resItems :: !(Maybe ReservationAggregatedListItems)
    , _resSelfLink :: !(Maybe Text)
    , _resWarning :: !(Maybe ReservationAggregatedListWarning)
    , _resId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ReservationAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'resUnreachables'
--
-- * 'resNextPageToken'
--
-- * 'resKind'
--
-- * 'resItems'
--
-- * 'resSelfLink'
--
-- * 'resWarning'
--
-- * 'resId'
reservationAggregatedList
    :: ReservationAggregatedList
reservationAggregatedList =
  ReservationAggregatedList'
    { _resUnreachables = Nothing
    , _resNextPageToken = Nothing
    , _resKind = "compute#reservationAggregatedList"
    , _resItems = Nothing
    , _resSelfLink = Nothing
    , _resWarning = Nothing
    , _resId = Nothing
    }


-- | [Output Only] Unreachable resources.
resUnreachables :: Lens' ReservationAggregatedList [Text]
resUnreachables
  = lens _resUnreachables
      (\ s a -> s{_resUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
resNextPageToken :: Lens' ReservationAggregatedList (Maybe Text)
resNextPageToken
  = lens _resNextPageToken
      (\ s a -> s{_resNextPageToken = a})

-- | Type of resource.
resKind :: Lens' ReservationAggregatedList Text
resKind = lens _resKind (\ s a -> s{_resKind = a})

-- | A list of Allocation resources.
resItems :: Lens' ReservationAggregatedList (Maybe ReservationAggregatedListItems)
resItems = lens _resItems (\ s a -> s{_resItems = a})

-- | [Output Only] Server-defined URL for this resource.
resSelfLink :: Lens' ReservationAggregatedList (Maybe Text)
resSelfLink
  = lens _resSelfLink (\ s a -> s{_resSelfLink = a})

-- | [Output Only] Informational warning message.
resWarning :: Lens' ReservationAggregatedList (Maybe ReservationAggregatedListWarning)
resWarning
  = lens _resWarning (\ s a -> s{_resWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
resId :: Lens' ReservationAggregatedList (Maybe Text)
resId = lens _resId (\ s a -> s{_resId = a})

instance FromJSON ReservationAggregatedList where
        parseJSON
          = withObject "ReservationAggregatedList"
              (\ o ->
                 ReservationAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!=
                        "compute#reservationAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON ReservationAggregatedList where
        toJSON ReservationAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _resUnreachables,
                  ("nextPageToken" .=) <$> _resNextPageToken,
                  Just ("kind" .= _resKind),
                  ("items" .=) <$> _resItems,
                  ("selfLink" .=) <$> _resSelfLink,
                  ("warning" .=) <$> _resWarning,
                  ("id" .=) <$> _resId])

-- | [Output Only] A list of managed instance groups.
--
-- /See:/ 'instanceGroupManagerList' smart constructor.
data InstanceGroupManagerList =
  InstanceGroupManagerList'
    { _igmlNextPageToken :: !(Maybe Text)
    , _igmlKind :: !Text
    , _igmlItems :: !(Maybe [InstanceGroupManager])
    , _igmlSelfLink :: !(Maybe Text)
    , _igmlWarning :: !(Maybe InstanceGroupManagerListWarning)
    , _igmlId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagerList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmlNextPageToken'
--
-- * 'igmlKind'
--
-- * 'igmlItems'
--
-- * 'igmlSelfLink'
--
-- * 'igmlWarning'
--
-- * 'igmlId'
instanceGroupManagerList
    :: InstanceGroupManagerList
instanceGroupManagerList =
  InstanceGroupManagerList'
    { _igmlNextPageToken = Nothing
    , _igmlKind = "compute#instanceGroupManagerList"
    , _igmlItems = Nothing
    , _igmlSelfLink = Nothing
    , _igmlWarning = Nothing
    , _igmlId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
igmlNextPageToken :: Lens' InstanceGroupManagerList (Maybe Text)
igmlNextPageToken
  = lens _igmlNextPageToken
      (\ s a -> s{_igmlNextPageToken = a})

-- | [Output Only] The resource type, which is always
-- compute#instanceGroupManagerList for a list of managed instance groups.
igmlKind :: Lens' InstanceGroupManagerList Text
igmlKind = lens _igmlKind (\ s a -> s{_igmlKind = a})

-- | A list of InstanceGroupManager resources.
igmlItems :: Lens' InstanceGroupManagerList [InstanceGroupManager]
igmlItems
  = lens _igmlItems (\ s a -> s{_igmlItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
igmlSelfLink :: Lens' InstanceGroupManagerList (Maybe Text)
igmlSelfLink
  = lens _igmlSelfLink (\ s a -> s{_igmlSelfLink = a})

-- | [Output Only] Informational warning message.
igmlWarning :: Lens' InstanceGroupManagerList (Maybe InstanceGroupManagerListWarning)
igmlWarning
  = lens _igmlWarning (\ s a -> s{_igmlWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
igmlId :: Lens' InstanceGroupManagerList (Maybe Text)
igmlId = lens _igmlId (\ s a -> s{_igmlId = a})

instance FromJSON InstanceGroupManagerList where
        parseJSON
          = withObject "InstanceGroupManagerList"
              (\ o ->
                 InstanceGroupManagerList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#instanceGroupManagerList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON InstanceGroupManagerList where
        toJSON InstanceGroupManagerList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _igmlNextPageToken,
                  Just ("kind" .= _igmlKind),
                  ("items" .=) <$> _igmlItems,
                  ("selfLink" .=) <$> _igmlSelfLink,
                  ("warning" .=) <$> _igmlWarning,
                  ("id" .=) <$> _igmlId])

--
-- /See:/ 'instanceGroupManagerVersion' smart constructor.
data InstanceGroupManagerVersion =
  InstanceGroupManagerVersion'
    { _igmvInstanceTemplate :: !(Maybe Text)
    , _igmvTargetSize :: !(Maybe FixedOrPercent)
    , _igmvName :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagerVersion' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmvInstanceTemplate'
--
-- * 'igmvTargetSize'
--
-- * 'igmvName'
instanceGroupManagerVersion
    :: InstanceGroupManagerVersion
instanceGroupManagerVersion =
  InstanceGroupManagerVersion'
    { _igmvInstanceTemplate = Nothing
    , _igmvTargetSize = Nothing
    , _igmvName = Nothing
    }


-- | The URL of the instance template that is specified for this managed
-- instance group. The group uses this template to create new instances in
-- the managed instance group until the \`targetSize\` for this version is
-- reached. The templates for existing instances in the group do not change
-- unless you run recreateInstances, run applyUpdatesToInstances, or set
-- the group\'s updatePolicy.type to PROACTIVE; in those cases, existing
-- instances are updated until the \`targetSize\` for this version is
-- reached.
igmvInstanceTemplate :: Lens' InstanceGroupManagerVersion (Maybe Text)
igmvInstanceTemplate
  = lens _igmvInstanceTemplate
      (\ s a -> s{_igmvInstanceTemplate = a})

-- | Specifies the intended number of instances to be created from the
-- instanceTemplate. The final number of instances created from the
-- template will be equal to: - If expressed as a fixed number, the minimum
-- of either targetSize.fixed or instanceGroupManager.targetSize is used. -
-- if expressed as a percent, the targetSize would be
-- (targetSize.percent\/100 * InstanceGroupManager.targetSize) If there is
-- a remainder, the number is rounded. If unset, this version will update
-- any remaining instances not updated by another version. Read Starting a
-- canary update for more information.
igmvTargetSize :: Lens' InstanceGroupManagerVersion (Maybe FixedOrPercent)
igmvTargetSize
  = lens _igmvTargetSize
      (\ s a -> s{_igmvTargetSize = a})

-- | Name of the version. Unique among all versions in the scope of this
-- managed instance group.
igmvName :: Lens' InstanceGroupManagerVersion (Maybe Text)
igmvName = lens _igmvName (\ s a -> s{_igmvName = a})

instance FromJSON InstanceGroupManagerVersion where
        parseJSON
          = withObject "InstanceGroupManagerVersion"
              (\ o ->
                 InstanceGroupManagerVersion' <$>
                   (o .:? "instanceTemplate") <*> (o .:? "targetSize")
                     <*> (o .:? "name"))

instance ToJSON InstanceGroupManagerVersion where
        toJSON InstanceGroupManagerVersion'{..}
          = object
              (catMaybes
                 [("instanceTemplate" .=) <$> _igmvInstanceTemplate,
                  ("targetSize" .=) <$> _igmvTargetSize,
                  ("name" .=) <$> _igmvName])

-- | [Output Only] An informational warning that replaces the list of network
-- endpoint groups when the list is empty.
--
-- /See:/ 'networkEndpointGroupsScopedListWarning' smart constructor.
data NetworkEndpointGroupsScopedListWarning =
  NetworkEndpointGroupsScopedListWarning'
    { _negslwData :: !(Maybe [NetworkEndpointGroupsScopedListWarningDataItem])
    , _negslwCode :: !(Maybe NetworkEndpointGroupsScopedListWarningCode)
    , _negslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkEndpointGroupsScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'negslwData'
--
-- * 'negslwCode'
--
-- * 'negslwMessage'
networkEndpointGroupsScopedListWarning
    :: NetworkEndpointGroupsScopedListWarning
networkEndpointGroupsScopedListWarning =
  NetworkEndpointGroupsScopedListWarning'
    {_negslwData = Nothing, _negslwCode = Nothing, _negslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
negslwData :: Lens' NetworkEndpointGroupsScopedListWarning [NetworkEndpointGroupsScopedListWarningDataItem]
negslwData
  = lens _negslwData (\ s a -> s{_negslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
negslwCode :: Lens' NetworkEndpointGroupsScopedListWarning (Maybe NetworkEndpointGroupsScopedListWarningCode)
negslwCode
  = lens _negslwCode (\ s a -> s{_negslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
negslwMessage :: Lens' NetworkEndpointGroupsScopedListWarning (Maybe Text)
negslwMessage
  = lens _negslwMessage
      (\ s a -> s{_negslwMessage = a})

instance FromJSON
           NetworkEndpointGroupsScopedListWarning
         where
        parseJSON
          = withObject "NetworkEndpointGroupsScopedListWarning"
              (\ o ->
                 NetworkEndpointGroupsScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON
           NetworkEndpointGroupsScopedListWarning
         where
        toJSON NetworkEndpointGroupsScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _negslwData,
                  ("code" .=) <$> _negslwCode,
                  ("message" .=) <$> _negslwMessage])

-- | An informational warning that appears when the list of addresses is
-- empty.
--
-- /See:/ 'subnetworksScopedListWarning' smart constructor.
data SubnetworksScopedListWarning =
  SubnetworksScopedListWarning'
    { _sslwData :: !(Maybe [SubnetworksScopedListWarningDataItem])
    , _sslwCode :: !(Maybe SubnetworksScopedListWarningCode)
    , _sslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SubnetworksScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sslwData'
--
-- * 'sslwCode'
--
-- * 'sslwMessage'
subnetworksScopedListWarning
    :: SubnetworksScopedListWarning
subnetworksScopedListWarning =
  SubnetworksScopedListWarning'
    {_sslwData = Nothing, _sslwCode = Nothing, _sslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
sslwData :: Lens' SubnetworksScopedListWarning [SubnetworksScopedListWarningDataItem]
sslwData
  = lens _sslwData (\ s a -> s{_sslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
sslwCode :: Lens' SubnetworksScopedListWarning (Maybe SubnetworksScopedListWarningCode)
sslwCode = lens _sslwCode (\ s a -> s{_sslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
sslwMessage :: Lens' SubnetworksScopedListWarning (Maybe Text)
sslwMessage
  = lens _sslwMessage (\ s a -> s{_sslwMessage = a})

instance FromJSON SubnetworksScopedListWarning where
        parseJSON
          = withObject "SubnetworksScopedListWarning"
              (\ o ->
                 SubnetworksScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON SubnetworksScopedListWarning where
        toJSON SubnetworksScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _sslwData,
                  ("code" .=) <$> _sslwCode,
                  ("message" .=) <$> _sslwMessage])

--
-- /See:/ 'nodeGroupsSetNodeTemplateRequest' smart constructor.
newtype NodeGroupsSetNodeTemplateRequest =
  NodeGroupsSetNodeTemplateRequest'
    { _ngsntrNodeTemplate :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeGroupsSetNodeTemplateRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ngsntrNodeTemplate'
nodeGroupsSetNodeTemplateRequest
    :: NodeGroupsSetNodeTemplateRequest
nodeGroupsSetNodeTemplateRequest =
  NodeGroupsSetNodeTemplateRequest' {_ngsntrNodeTemplate = Nothing}


-- | Full or partial URL of the node template resource to be updated for this
-- node group.
ngsntrNodeTemplate :: Lens' NodeGroupsSetNodeTemplateRequest (Maybe Text)
ngsntrNodeTemplate
  = lens _ngsntrNodeTemplate
      (\ s a -> s{_ngsntrNodeTemplate = a})

instance FromJSON NodeGroupsSetNodeTemplateRequest
         where
        parseJSON
          = withObject "NodeGroupsSetNodeTemplateRequest"
              (\ o ->
                 NodeGroupsSetNodeTemplateRequest' <$>
                   (o .:? "nodeTemplate"))

instance ToJSON NodeGroupsSetNodeTemplateRequest
         where
        toJSON NodeGroupsSetNodeTemplateRequest'{..}
          = object
              (catMaybes
                 [("nodeTemplate" .=) <$> _ngsntrNodeTemplate])

-- | The available logging options for the load balancer traffic served by
-- this backend service.
--
-- /See:/ 'backendServiceLogConfig' smart constructor.
data BackendServiceLogConfig =
  BackendServiceLogConfig'
    { _bslcEnable :: !(Maybe Bool)
    , _bslcSampleRate :: !(Maybe (Textual Double))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendServiceLogConfig' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bslcEnable'
--
-- * 'bslcSampleRate'
backendServiceLogConfig
    :: BackendServiceLogConfig
backendServiceLogConfig =
  BackendServiceLogConfig' {_bslcEnable = Nothing, _bslcSampleRate = Nothing}


-- | This field denotes whether to enable logging for the load balancer
-- traffic served by this backend service.
bslcEnable :: Lens' BackendServiceLogConfig (Maybe Bool)
bslcEnable
  = lens _bslcEnable (\ s a -> s{_bslcEnable = a})

-- | This field can only be specified if logging is enabled for this backend
-- service. The value of the field must be in [0, 1]. This configures the
-- sampling rate of requests to the load balancer where 1.0 means all
-- logged requests are reported and 0.0 means no logged requests are
-- reported. The default value is 1.0.
bslcSampleRate :: Lens' BackendServiceLogConfig (Maybe Double)
bslcSampleRate
  = lens _bslcSampleRate
      (\ s a -> s{_bslcSampleRate = a})
      . mapping _Coerce

instance FromJSON BackendServiceLogConfig where
        parseJSON
          = withObject "BackendServiceLogConfig"
              (\ o ->
                 BackendServiceLogConfig' <$>
                   (o .:? "enable") <*> (o .:? "sampleRate"))

instance ToJSON BackendServiceLogConfig where
        toJSON BackendServiceLogConfig'{..}
          = object
              (catMaybes
                 [("enable" .=) <$> _bslcEnable,
                  ("sampleRate" .=) <$> _bslcSampleRate])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'acceleratorTypeListWarning' smart constructor.
data AcceleratorTypeListWarning =
  AcceleratorTypeListWarning'
    { _atlwData :: !(Maybe [AcceleratorTypeListWarningDataItem])
    , _atlwCode :: !(Maybe AcceleratorTypeListWarningCode)
    , _atlwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AcceleratorTypeListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'atlwData'
--
-- * 'atlwCode'
--
-- * 'atlwMessage'
acceleratorTypeListWarning
    :: AcceleratorTypeListWarning
acceleratorTypeListWarning =
  AcceleratorTypeListWarning'
    {_atlwData = Nothing, _atlwCode = Nothing, _atlwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
atlwData :: Lens' AcceleratorTypeListWarning [AcceleratorTypeListWarningDataItem]
atlwData
  = lens _atlwData (\ s a -> s{_atlwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
atlwCode :: Lens' AcceleratorTypeListWarning (Maybe AcceleratorTypeListWarningCode)
atlwCode = lens _atlwCode (\ s a -> s{_atlwCode = a})

-- | [Output Only] A human-readable description of the warning code.
atlwMessage :: Lens' AcceleratorTypeListWarning (Maybe Text)
atlwMessage
  = lens _atlwMessage (\ s a -> s{_atlwMessage = a})

instance FromJSON AcceleratorTypeListWarning where
        parseJSON
          = withObject "AcceleratorTypeListWarning"
              (\ o ->
                 AcceleratorTypeListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON AcceleratorTypeListWarning where
        toJSON AcceleratorTypeListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _atlwData,
                  ("code" .=) <$> _atlwCode,
                  ("message" .=) <$> _atlwMessage])

-- | Represents an Image resource. You can use images to create boot disks
-- for your VM instances. For more information, read Images. (==
-- resource_for {$api_version}.images ==)
--
-- /See:/ 'image' smart constructor.
data Image =
  Image'
    { _iSatisfiesPzs :: !(Maybe Bool)
    , _iStatus :: !(Maybe ImageStatus)
    , _iSourceSnapshotId :: !(Maybe Text)
    , _iImageEncryptionKey :: !(Maybe CustomerEncryptionKey)
    , _iSourceImage :: !(Maybe Text)
    , _iDiskSizeGb :: !(Maybe (Textual Int64))
    , _iSourceType :: !ImageSourceType
    , _iSourceDiskId :: !(Maybe Text)
    , _iKind :: !Text
    , _iSourceDiskEncryptionKey :: !(Maybe CustomerEncryptionKey)
    , _iGuestOSFeatures :: !(Maybe [GuestOSFeature])
    , _iArchiveSizeBytes :: !(Maybe (Textual Int64))
    , _iShieldedInstanceInitialState :: !(Maybe InitialStateConfig)
    , _iFamily :: !(Maybe Text)
    , _iRawDisk :: !(Maybe ImageRawDisk)
    , _iSelfLink :: !(Maybe Text)
    , _iName :: !(Maybe Text)
    , _iSourceImageId :: !(Maybe Text)
    , _iStorageLocations :: !(Maybe [Text])
    , _iCreationTimestamp :: !(Maybe Text)
    , _iSourceImageEncryptionKey :: !(Maybe CustomerEncryptionKey)
    , _iLicenseCodes :: !(Maybe [Textual Int64])
    , _iId :: !(Maybe (Textual Word64))
    , _iLabels :: !(Maybe ImageLabels)
    , _iLicenses :: !(Maybe [Text])
    , _iSourceDisk :: !(Maybe Text)
    , _iLabelFingerprint :: !(Maybe Bytes)
    , _iDescription :: !(Maybe Text)
    , _iSourceSnapshotEncryptionKey :: !(Maybe CustomerEncryptionKey)
    , _iDeprecated :: !(Maybe DeprecationStatus)
    , _iSourceSnapshot :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Image' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iSatisfiesPzs'
--
-- * 'iStatus'
--
-- * 'iSourceSnapshotId'
--
-- * 'iImageEncryptionKey'
--
-- * 'iSourceImage'
--
-- * 'iDiskSizeGb'
--
-- * 'iSourceType'
--
-- * 'iSourceDiskId'
--
-- * 'iKind'
--
-- * 'iSourceDiskEncryptionKey'
--
-- * 'iGuestOSFeatures'
--
-- * 'iArchiveSizeBytes'
--
-- * 'iShieldedInstanceInitialState'
--
-- * 'iFamily'
--
-- * 'iRawDisk'
--
-- * 'iSelfLink'
--
-- * 'iName'
--
-- * 'iSourceImageId'
--
-- * 'iStorageLocations'
--
-- * 'iCreationTimestamp'
--
-- * 'iSourceImageEncryptionKey'
--
-- * 'iLicenseCodes'
--
-- * 'iId'
--
-- * 'iLabels'
--
-- * 'iLicenses'
--
-- * 'iSourceDisk'
--
-- * 'iLabelFingerprint'
--
-- * 'iDescription'
--
-- * 'iSourceSnapshotEncryptionKey'
--
-- * 'iDeprecated'
--
-- * 'iSourceSnapshot'
image
    :: Image
image =
  Image'
    { _iSatisfiesPzs = Nothing
    , _iStatus = Nothing
    , _iSourceSnapshotId = Nothing
    , _iImageEncryptionKey = Nothing
    , _iSourceImage = Nothing
    , _iDiskSizeGb = Nothing
    , _iSourceType = Raw
    , _iSourceDiskId = Nothing
    , _iKind = "compute#image"
    , _iSourceDiskEncryptionKey = Nothing
    , _iGuestOSFeatures = Nothing
    , _iArchiveSizeBytes = Nothing
    , _iShieldedInstanceInitialState = Nothing
    , _iFamily = Nothing
    , _iRawDisk = Nothing
    , _iSelfLink = Nothing
    , _iName = Nothing
    , _iSourceImageId = Nothing
    , _iStorageLocations = Nothing
    , _iCreationTimestamp = Nothing
    , _iSourceImageEncryptionKey = Nothing
    , _iLicenseCodes = Nothing
    , _iId = Nothing
    , _iLabels = Nothing
    , _iLicenses = Nothing
    , _iSourceDisk = Nothing
    , _iLabelFingerprint = Nothing
    , _iDescription = Nothing
    , _iSourceSnapshotEncryptionKey = Nothing
    , _iDeprecated = Nothing
    , _iSourceSnapshot = Nothing
    }


-- | [Output Only] Reserved for future use.
iSatisfiesPzs :: Lens' Image (Maybe Bool)
iSatisfiesPzs
  = lens _iSatisfiesPzs
      (\ s a -> s{_iSatisfiesPzs = a})

-- | [Output Only] The status of the image. An image can be used to create
-- other resources, such as instances, only after the image has been
-- successfully created and the status is set to READY. Possible values are
-- FAILED, PENDING, or READY.
iStatus :: Lens' Image (Maybe ImageStatus)
iStatus = lens _iStatus (\ s a -> s{_iStatus = a})

-- | [Output Only] The ID value of the snapshot used to create this image.
-- This value may be used to determine whether the snapshot was taken from
-- the current or a previous instance of a given snapshot name.
iSourceSnapshotId :: Lens' Image (Maybe Text)
iSourceSnapshotId
  = lens _iSourceSnapshotId
      (\ s a -> s{_iSourceSnapshotId = a})

-- | Encrypts the image using a customer-supplied encryption key. After you
-- encrypt an image with a customer-supplied key, you must provide the same
-- key if you use the image later (e.g. to create a disk from the image).
-- Customer-supplied encryption keys do not protect access to metadata of
-- the disk. If you do not provide an encryption key when creating the
-- image, then the disk will be encrypted using an automatically generated
-- key and you do not need to provide a key to use the image later.
iImageEncryptionKey :: Lens' Image (Maybe CustomerEncryptionKey)
iImageEncryptionKey
  = lens _iImageEncryptionKey
      (\ s a -> s{_iImageEncryptionKey = a})

-- | URL of the source image used to create this image. In order to create an
-- image, you must provide the full or partial URL of one of the following:
-- - The rawDisk.source URL - The sourceDisk URL - The sourceImage URL -
-- The sourceSnapshot URL
iSourceImage :: Lens' Image (Maybe Text)
iSourceImage
  = lens _iSourceImage (\ s a -> s{_iSourceImage = a})

-- | Size of the image when restored onto a persistent disk (in GB).
iDiskSizeGb :: Lens' Image (Maybe Int64)
iDiskSizeGb
  = lens _iDiskSizeGb (\ s a -> s{_iDiskSizeGb = a}) .
      mapping _Coerce

-- | The type of the image used to create this disk. The default and only
-- value is RAW
iSourceType :: Lens' Image ImageSourceType
iSourceType
  = lens _iSourceType (\ s a -> s{_iSourceType = a})

-- | [Output Only] The ID value of the disk used to create this image. This
-- value may be used to determine whether the image was taken from the
-- current or a previous instance of a given disk name.
iSourceDiskId :: Lens' Image (Maybe Text)
iSourceDiskId
  = lens _iSourceDiskId
      (\ s a -> s{_iSourceDiskId = a})

-- | [Output Only] Type of the resource. Always compute#image for images.
iKind :: Lens' Image Text
iKind = lens _iKind (\ s a -> s{_iKind = a})

-- | The customer-supplied encryption key of the source disk. Required if the
-- source disk is protected by a customer-supplied encryption key.
iSourceDiskEncryptionKey :: Lens' Image (Maybe CustomerEncryptionKey)
iSourceDiskEncryptionKey
  = lens _iSourceDiskEncryptionKey
      (\ s a -> s{_iSourceDiskEncryptionKey = a})

-- | A list of features to enable on the guest operating system. Applicable
-- only for bootable images. Read Enabling guest operating system features
-- to see a list of available options.
iGuestOSFeatures :: Lens' Image [GuestOSFeature]
iGuestOSFeatures
  = lens _iGuestOSFeatures
      (\ s a -> s{_iGuestOSFeatures = a})
      . _Default
      . _Coerce

-- | Size of the image tar.gz archive stored in Google Cloud Storage (in
-- bytes).
iArchiveSizeBytes :: Lens' Image (Maybe Int64)
iArchiveSizeBytes
  = lens _iArchiveSizeBytes
      (\ s a -> s{_iArchiveSizeBytes = a})
      . mapping _Coerce

-- | Set the secure boot keys of shielded instance.
iShieldedInstanceInitialState :: Lens' Image (Maybe InitialStateConfig)
iShieldedInstanceInitialState
  = lens _iShieldedInstanceInitialState
      (\ s a -> s{_iShieldedInstanceInitialState = a})

-- | The name of the image family to which this image belongs. You can create
-- disks by specifying an image family instead of a specific image name.
-- The image family always returns its latest image that is not deprecated.
-- The name of the image family must comply with RFC1035.
iFamily :: Lens' Image (Maybe Text)
iFamily = lens _iFamily (\ s a -> s{_iFamily = a})

-- | The parameters of the raw disk image.
iRawDisk :: Lens' Image (Maybe ImageRawDisk)
iRawDisk = lens _iRawDisk (\ s a -> s{_iRawDisk = a})

-- | [Output Only] Server-defined URL for the resource.
iSelfLink :: Lens' Image (Maybe Text)
iSelfLink
  = lens _iSelfLink (\ s a -> s{_iSelfLink = a})

-- | Name of the resource; provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
iName :: Lens' Image (Maybe Text)
iName = lens _iName (\ s a -> s{_iName = a})

-- | [Output Only] The ID value of the image used to create this image. This
-- value may be used to determine whether the image was taken from the
-- current or a previous instance of a given image name.
iSourceImageId :: Lens' Image (Maybe Text)
iSourceImageId
  = lens _iSourceImageId
      (\ s a -> s{_iSourceImageId = a})

-- | Cloud Storage bucket storage location of the image (regional or
-- multi-regional).
iStorageLocations :: Lens' Image [Text]
iStorageLocations
  = lens _iStorageLocations
      (\ s a -> s{_iStorageLocations = a})
      . _Default
      . _Coerce

-- | [Output Only] Creation timestamp in RFC3339 text format.
iCreationTimestamp :: Lens' Image (Maybe Text)
iCreationTimestamp
  = lens _iCreationTimestamp
      (\ s a -> s{_iCreationTimestamp = a})

-- | The customer-supplied encryption key of the source image. Required if
-- the source image is protected by a customer-supplied encryption key.
iSourceImageEncryptionKey :: Lens' Image (Maybe CustomerEncryptionKey)
iSourceImageEncryptionKey
  = lens _iSourceImageEncryptionKey
      (\ s a -> s{_iSourceImageEncryptionKey = a})

-- | Integer license codes indicating which licenses are attached to this
-- image.
iLicenseCodes :: Lens' Image [Int64]
iLicenseCodes
  = lens _iLicenseCodes
      (\ s a -> s{_iLicenseCodes = a})
      . _Default
      . _Coerce

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
iId :: Lens' Image (Maybe Word64)
iId
  = lens _iId (\ s a -> s{_iId = a}) . mapping _Coerce

-- | Labels to apply to this image. These can be later modified by the
-- setLabels method.
iLabels :: Lens' Image (Maybe ImageLabels)
iLabels = lens _iLabels (\ s a -> s{_iLabels = a})

-- | Any applicable license URI.
iLicenses :: Lens' Image [Text]
iLicenses
  = lens _iLicenses (\ s a -> s{_iLicenses = a}) .
      _Default
      . _Coerce

-- | URL of the source disk used to create this image. For example, the
-- following are valid values: -
-- https:\/\/www.googleapis.com\/compute\/v1\/projects\/project\/zones\/zone\/disks\/disk
-- - projects\/project\/zones\/zone\/disks\/disk - zones\/zone\/disks\/disk
-- In order to create an image, you must provide the full or partial URL of
-- one of the following: - The rawDisk.source URL - The sourceDisk URL -
-- The sourceImage URL - The sourceSnapshot URL
iSourceDisk :: Lens' Image (Maybe Text)
iSourceDisk
  = lens _iSourceDisk (\ s a -> s{_iSourceDisk = a})

-- | A fingerprint for the labels being applied to this image, which is
-- essentially a hash of the labels used for optimistic locking. The
-- fingerprint is initially generated by Compute Engine and changes after
-- every request to modify or update labels. You must always provide an
-- up-to-date fingerprint hash in order to update or change labels,
-- otherwise the request will fail with error 412 conditionNotMet. To see
-- the latest fingerprint, make a get() request to retrieve an image.
iLabelFingerprint :: Lens' Image (Maybe ByteString)
iLabelFingerprint
  = lens _iLabelFingerprint
      (\ s a -> s{_iLabelFingerprint = a})
      . mapping _Bytes

-- | An optional description of this resource. Provide this property when you
-- create the resource.
iDescription :: Lens' Image (Maybe Text)
iDescription
  = lens _iDescription (\ s a -> s{_iDescription = a})

-- | The customer-supplied encryption key of the source snapshot. Required if
-- the source snapshot is protected by a customer-supplied encryption key.
iSourceSnapshotEncryptionKey :: Lens' Image (Maybe CustomerEncryptionKey)
iSourceSnapshotEncryptionKey
  = lens _iSourceSnapshotEncryptionKey
      (\ s a -> s{_iSourceSnapshotEncryptionKey = a})

-- | The deprecation status associated with this image.
iDeprecated :: Lens' Image (Maybe DeprecationStatus)
iDeprecated
  = lens _iDeprecated (\ s a -> s{_iDeprecated = a})

-- | URL of the source snapshot used to create this image. In order to create
-- an image, you must provide the full or partial URL of one of the
-- following: - The rawDisk.source URL - The sourceDisk URL - The
-- sourceImage URL - The sourceSnapshot URL
iSourceSnapshot :: Lens' Image (Maybe Text)
iSourceSnapshot
  = lens _iSourceSnapshot
      (\ s a -> s{_iSourceSnapshot = a})

instance FromJSON Image where
        parseJSON
          = withObject "Image"
              (\ o ->
                 Image' <$>
                   (o .:? "satisfiesPzs") <*> (o .:? "status") <*>
                     (o .:? "sourceSnapshotId")
                     <*> (o .:? "imageEncryptionKey")
                     <*> (o .:? "sourceImage")
                     <*> (o .:? "diskSizeGb")
                     <*> (o .:? "sourceType" .!= Raw)
                     <*> (o .:? "sourceDiskId")
                     <*> (o .:? "kind" .!= "compute#image")
                     <*> (o .:? "sourceDiskEncryptionKey")
                     <*> (o .:? "guestOsFeatures" .!= mempty)
                     <*> (o .:? "archiveSizeBytes")
                     <*> (o .:? "shieldedInstanceInitialState")
                     <*> (o .:? "family")
                     <*> (o .:? "rawDisk")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "sourceImageId")
                     <*> (o .:? "storageLocations" .!= mempty)
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "sourceImageEncryptionKey")
                     <*> (o .:? "licenseCodes" .!= mempty)
                     <*> (o .:? "id")
                     <*> (o .:? "labels")
                     <*> (o .:? "licenses" .!= mempty)
                     <*> (o .:? "sourceDisk")
                     <*> (o .:? "labelFingerprint")
                     <*> (o .:? "description")
                     <*> (o .:? "sourceSnapshotEncryptionKey")
                     <*> (o .:? "deprecated")
                     <*> (o .:? "sourceSnapshot"))

instance ToJSON Image where
        toJSON Image'{..}
          = object
              (catMaybes
                 [("satisfiesPzs" .=) <$> _iSatisfiesPzs,
                  ("status" .=) <$> _iStatus,
                  ("sourceSnapshotId" .=) <$> _iSourceSnapshotId,
                  ("imageEncryptionKey" .=) <$> _iImageEncryptionKey,
                  ("sourceImage" .=) <$> _iSourceImage,
                  ("diskSizeGb" .=) <$> _iDiskSizeGb,
                  Just ("sourceType" .= _iSourceType),
                  ("sourceDiskId" .=) <$> _iSourceDiskId,
                  Just ("kind" .= _iKind),
                  ("sourceDiskEncryptionKey" .=) <$>
                    _iSourceDiskEncryptionKey,
                  ("guestOsFeatures" .=) <$> _iGuestOSFeatures,
                  ("archiveSizeBytes" .=) <$> _iArchiveSizeBytes,
                  ("shieldedInstanceInitialState" .=) <$>
                    _iShieldedInstanceInitialState,
                  ("family" .=) <$> _iFamily,
                  ("rawDisk" .=) <$> _iRawDisk,
                  ("selfLink" .=) <$> _iSelfLink,
                  ("name" .=) <$> _iName,
                  ("sourceImageId" .=) <$> _iSourceImageId,
                  ("storageLocations" .=) <$> _iStorageLocations,
                  ("creationTimestamp" .=) <$> _iCreationTimestamp,
                  ("sourceImageEncryptionKey" .=) <$>
                    _iSourceImageEncryptionKey,
                  ("licenseCodes" .=) <$> _iLicenseCodes,
                  ("id" .=) <$> _iId, ("labels" .=) <$> _iLabels,
                  ("licenses" .=) <$> _iLicenses,
                  ("sourceDisk" .=) <$> _iSourceDisk,
                  ("labelFingerprint" .=) <$> _iLabelFingerprint,
                  ("description" .=) <$> _iDescription,
                  ("sourceSnapshotEncryptionKey" .=) <$>
                    _iSourceSnapshotEncryptionKey,
                  ("deprecated" .=) <$> _iDeprecated,
                  ("sourceSnapshot" .=) <$> _iSourceSnapshot])

--
-- /See:/ 'networksAddPeeringRequest' smart constructor.
data NetworksAddPeeringRequest =
  NetworksAddPeeringRequest'
    { _naprNetworkPeering :: !(Maybe NetworkPeering)
    , _naprPeerNetwork :: !(Maybe Text)
    , _naprName :: !(Maybe Text)
    , _naprAutoCreateRoutes :: !(Maybe Bool)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworksAddPeeringRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'naprNetworkPeering'
--
-- * 'naprPeerNetwork'
--
-- * 'naprName'
--
-- * 'naprAutoCreateRoutes'
networksAddPeeringRequest
    :: NetworksAddPeeringRequest
networksAddPeeringRequest =
  NetworksAddPeeringRequest'
    { _naprNetworkPeering = Nothing
    , _naprPeerNetwork = Nothing
    , _naprName = Nothing
    , _naprAutoCreateRoutes = Nothing
    }


-- | Network peering parameters. In order to specify route policies for
-- peering using import and export custom routes, you must specify all
-- peering related parameters (name, peer network, exchange_subnet_routes)
-- in the network_peering field. The corresponding fields in
-- NetworksAddPeeringRequest will be deprecated soon.
naprNetworkPeering :: Lens' NetworksAddPeeringRequest (Maybe NetworkPeering)
naprNetworkPeering
  = lens _naprNetworkPeering
      (\ s a -> s{_naprNetworkPeering = a})

-- | URL of the peer network. It can be either full URL or partial URL. The
-- peer network may belong to a different project. If the partial URL does
-- not contain project, it is assumed that the peer network is in the same
-- project as the current network.
naprPeerNetwork :: Lens' NetworksAddPeeringRequest (Maybe Text)
naprPeerNetwork
  = lens _naprPeerNetwork
      (\ s a -> s{_naprPeerNetwork = a})

-- | Name of the peering, which should conform to RFC1035.
naprName :: Lens' NetworksAddPeeringRequest (Maybe Text)
naprName = lens _naprName (\ s a -> s{_naprName = a})

-- | This field will be deprecated soon. Use exchange_subnet_routes in
-- network_peering instead. Indicates whether full mesh connectivity is
-- created and managed automatically between peered networks. Currently
-- this field should always be true since Google Compute Engine will
-- automatically create and manage subnetwork routes between two networks
-- when peering state is ACTIVE.
naprAutoCreateRoutes :: Lens' NetworksAddPeeringRequest (Maybe Bool)
naprAutoCreateRoutes
  = lens _naprAutoCreateRoutes
      (\ s a -> s{_naprAutoCreateRoutes = a})

instance FromJSON NetworksAddPeeringRequest where
        parseJSON
          = withObject "NetworksAddPeeringRequest"
              (\ o ->
                 NetworksAddPeeringRequest' <$>
                   (o .:? "networkPeering") <*> (o .:? "peerNetwork")
                     <*> (o .:? "name")
                     <*> (o .:? "autoCreateRoutes"))

instance ToJSON NetworksAddPeeringRequest where
        toJSON NetworksAddPeeringRequest'{..}
          = object
              (catMaybes
                 [("networkPeering" .=) <$> _naprNetworkPeering,
                  ("peerNetwork" .=) <$> _naprPeerNetwork,
                  ("name" .=) <$> _naprName,
                  ("autoCreateRoutes" .=) <$> _naprAutoCreateRoutes])

--
-- /See:/ 'publicAdvertisedPrefixListWarningDataItem' smart constructor.
data PublicAdvertisedPrefixListWarningDataItem =
  PublicAdvertisedPrefixListWarningDataItem'
    { _paplwdiValue :: !(Maybe Text)
    , _paplwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PublicAdvertisedPrefixListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'paplwdiValue'
--
-- * 'paplwdiKey'
publicAdvertisedPrefixListWarningDataItem
    :: PublicAdvertisedPrefixListWarningDataItem
publicAdvertisedPrefixListWarningDataItem =
  PublicAdvertisedPrefixListWarningDataItem'
    {_paplwdiValue = Nothing, _paplwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
paplwdiValue :: Lens' PublicAdvertisedPrefixListWarningDataItem (Maybe Text)
paplwdiValue
  = lens _paplwdiValue (\ s a -> s{_paplwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
paplwdiKey :: Lens' PublicAdvertisedPrefixListWarningDataItem (Maybe Text)
paplwdiKey
  = lens _paplwdiKey (\ s a -> s{_paplwdiKey = a})

instance FromJSON
           PublicAdvertisedPrefixListWarningDataItem
         where
        parseJSON
          = withObject
              "PublicAdvertisedPrefixListWarningDataItem"
              (\ o ->
                 PublicAdvertisedPrefixListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           PublicAdvertisedPrefixListWarningDataItem
         where
        toJSON PublicAdvertisedPrefixListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _paplwdiValue,
                  ("key" .=) <$> _paplwdiKey])

--
-- /See:/ 'nodeTemplatesScopedList' smart constructor.
data NodeTemplatesScopedList =
  NodeTemplatesScopedList'
    { _nNodeTemplates :: !(Maybe [NodeTemplate])
    , _nWarning :: !(Maybe NodeTemplatesScopedListWarning)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeTemplatesScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nNodeTemplates'
--
-- * 'nWarning'
nodeTemplatesScopedList
    :: NodeTemplatesScopedList
nodeTemplatesScopedList =
  NodeTemplatesScopedList' {_nNodeTemplates = Nothing, _nWarning = Nothing}


-- | [Output Only] A list of node templates contained in this scope.
nNodeTemplates :: Lens' NodeTemplatesScopedList [NodeTemplate]
nNodeTemplates
  = lens _nNodeTemplates
      (\ s a -> s{_nNodeTemplates = a})
      . _Default
      . _Coerce

-- | [Output Only] An informational warning that appears when the node
-- templates list is empty.
nWarning :: Lens' NodeTemplatesScopedList (Maybe NodeTemplatesScopedListWarning)
nWarning = lens _nWarning (\ s a -> s{_nWarning = a})

instance FromJSON NodeTemplatesScopedList where
        parseJSON
          = withObject "NodeTemplatesScopedList"
              (\ o ->
                 NodeTemplatesScopedList' <$>
                   (o .:? "nodeTemplates" .!= mempty) <*>
                     (o .:? "warning"))

instance ToJSON NodeTemplatesScopedList where
        toJSON NodeTemplatesScopedList'{..}
          = object
              (catMaybes
                 [("nodeTemplates" .=) <$> _nNodeTemplates,
                  ("warning" .=) <$> _nWarning])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'urlMapListWarning' smart constructor.
data URLMapListWarning =
  URLMapListWarning'
    { _umlwData :: !(Maybe [URLMapListWarningDataItem])
    , _umlwCode :: !(Maybe URLMapListWarningCode)
    , _umlwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'URLMapListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'umlwData'
--
-- * 'umlwCode'
--
-- * 'umlwMessage'
urlMapListWarning
    :: URLMapListWarning
urlMapListWarning =
  URLMapListWarning'
    {_umlwData = Nothing, _umlwCode = Nothing, _umlwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
umlwData :: Lens' URLMapListWarning [URLMapListWarningDataItem]
umlwData
  = lens _umlwData (\ s a -> s{_umlwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
umlwCode :: Lens' URLMapListWarning (Maybe URLMapListWarningCode)
umlwCode = lens _umlwCode (\ s a -> s{_umlwCode = a})

-- | [Output Only] A human-readable description of the warning code.
umlwMessage :: Lens' URLMapListWarning (Maybe Text)
umlwMessage
  = lens _umlwMessage (\ s a -> s{_umlwMessage = a})

instance FromJSON URLMapListWarning where
        parseJSON
          = withObject "URLMapListWarning"
              (\ o ->
                 URLMapListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON URLMapListWarning where
        toJSON URLMapListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _umlwData,
                  ("code" .=) <$> _umlwCode,
                  ("message" .=) <$> _umlwMessage])

--
-- /See:/ 'nodeGroupsScopedListWarningDataItem' smart constructor.
data NodeGroupsScopedListWarningDataItem =
  NodeGroupsScopedListWarningDataItem'
    { _ngslwdiValue :: !(Maybe Text)
    , _ngslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeGroupsScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ngslwdiValue'
--
-- * 'ngslwdiKey'
nodeGroupsScopedListWarningDataItem
    :: NodeGroupsScopedListWarningDataItem
nodeGroupsScopedListWarningDataItem =
  NodeGroupsScopedListWarningDataItem'
    {_ngslwdiValue = Nothing, _ngslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
ngslwdiValue :: Lens' NodeGroupsScopedListWarningDataItem (Maybe Text)
ngslwdiValue
  = lens _ngslwdiValue (\ s a -> s{_ngslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
ngslwdiKey :: Lens' NodeGroupsScopedListWarningDataItem (Maybe Text)
ngslwdiKey
  = lens _ngslwdiKey (\ s a -> s{_ngslwdiKey = a})

instance FromJSON NodeGroupsScopedListWarningDataItem
         where
        parseJSON
          = withObject "NodeGroupsScopedListWarningDataItem"
              (\ o ->
                 NodeGroupsScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON NodeGroupsScopedListWarningDataItem
         where
        toJSON NodeGroupsScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _ngslwdiValue,
                  ("key" .=) <$> _ngslwdiKey])

-- | Represents a URL Map resource. Google Compute Engine has two URL Map
-- resources: *
-- [Global](\/compute\/docs\/reference\/rest\/{$api_version}\/urlMaps) *
-- [Regional](\/compute\/docs\/reference\/rest\/{$api_version}\/regionUrlMaps)
-- A URL map resource is a component of certain types of GCP load balancers
-- and Traffic Director. * urlMaps are used by external HTTP(S) load
-- balancers and Traffic Director. * regionUrlMaps are used by internal
-- HTTP(S) load balancers. For a list of supported URL map features by load
-- balancer type, see the Load balancing features: Routing and traffic
-- management table. For a list of supported URL map features for Traffic
-- Director, see the Traffic Director features: Routing and traffic
-- management table. This resource defines mappings from host names and URL
-- paths to either a backend service or a backend bucket. To use the global
-- urlMaps resource, the backend service must have a loadBalancingScheme of
-- either EXTERNAL or INTERNAL_SELF_MANAGED. To use the regionUrlMaps
-- resource, the backend service must have a loadBalancingScheme of
-- INTERNAL_MANAGED. For more information, read URL Map Concepts.
--
-- /See:/ 'urlMap' smart constructor.
data URLMap =
  URLMap'
    { _umDefaultRouteAction :: !(Maybe HTTPRouteAction)
    , _umDefaultURLRedirect :: !(Maybe HTTPRedirectAction)
    , _umTests :: !(Maybe [URLMapTest])
    , _umKind :: !Text
    , _umFingerprint :: !(Maybe Bytes)
    , _umDefaultService :: !(Maybe Text)
    , _umHeaderAction :: !(Maybe HTTPHeaderAction)
    , _umSelfLink :: !(Maybe Text)
    , _umName :: !(Maybe Text)
    , _umCreationTimestamp :: !(Maybe Text)
    , _umPathMatchers :: !(Maybe [PathMatcher])
    , _umId :: !(Maybe (Textual Word64))
    , _umHostRules :: !(Maybe [HostRule])
    , _umRegion :: !(Maybe Text)
    , _umDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'URLMap' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'umDefaultRouteAction'
--
-- * 'umDefaultURLRedirect'
--
-- * 'umTests'
--
-- * 'umKind'
--
-- * 'umFingerprint'
--
-- * 'umDefaultService'
--
-- * 'umHeaderAction'
--
-- * 'umSelfLink'
--
-- * 'umName'
--
-- * 'umCreationTimestamp'
--
-- * 'umPathMatchers'
--
-- * 'umId'
--
-- * 'umHostRules'
--
-- * 'umRegion'
--
-- * 'umDescription'
urlMap
    :: URLMap
urlMap =
  URLMap'
    { _umDefaultRouteAction = Nothing
    , _umDefaultURLRedirect = Nothing
    , _umTests = Nothing
    , _umKind = "compute#urlMap"
    , _umFingerprint = Nothing
    , _umDefaultService = Nothing
    , _umHeaderAction = Nothing
    , _umSelfLink = Nothing
    , _umName = Nothing
    , _umCreationTimestamp = Nothing
    , _umPathMatchers = Nothing
    , _umId = Nothing
    , _umHostRules = Nothing
    , _umRegion = Nothing
    , _umDescription = Nothing
    }


-- | defaultRouteAction takes effect when none of the hostRules match. The
-- load balancer performs advanced routing actions like URL rewrites,
-- header transformations, etc. prior to forwarding the request to the
-- selected backend. If defaultRouteAction specifies any
-- weightedBackendServices, defaultService must not be set. Conversely if
-- defaultService is set, defaultRouteAction cannot contain any
-- weightedBackendServices. Only one of defaultRouteAction or
-- defaultUrlRedirect must be set. UrlMaps for external HTTP(S) load
-- balancers support only the urlRewrite action within defaultRouteAction.
-- defaultRouteAction has no effect when the URL map is bound to target
-- gRPC proxy that has validateForProxyless field set to true.
umDefaultRouteAction :: Lens' URLMap (Maybe HTTPRouteAction)
umDefaultRouteAction
  = lens _umDefaultRouteAction
      (\ s a -> s{_umDefaultRouteAction = a})

-- | When none of the specified hostRules match, the request is redirected to
-- a URL specified by defaultUrlRedirect. If defaultUrlRedirect is
-- specified, defaultService or defaultRouteAction must not be set. Not
-- supported when the URL map is bound to target gRPC proxy.
umDefaultURLRedirect :: Lens' URLMap (Maybe HTTPRedirectAction)
umDefaultURLRedirect
  = lens _umDefaultURLRedirect
      (\ s a -> s{_umDefaultURLRedirect = a})

-- | The list of expected URL mapping tests. Request to update this UrlMap
-- will succeed only if all of the test cases pass. You can specify a
-- maximum of 100 tests per UrlMap. Not supported when the URL map is bound
-- to target gRPC proxy that has validateForProxyless field set to true.
umTests :: Lens' URLMap [URLMapTest]
umTests
  = lens _umTests (\ s a -> s{_umTests = a}) . _Default
      . _Coerce

-- | [Output Only] Type of the resource. Always compute#urlMaps for url maps.
umKind :: Lens' URLMap Text
umKind = lens _umKind (\ s a -> s{_umKind = a})

-- | Fingerprint of this resource. A hash of the contents stored in this
-- object. This field is used in optimistic locking. This field will be
-- ignored when inserting a UrlMap. An up-to-date fingerprint must be
-- provided in order to update the UrlMap, otherwise the request will fail
-- with error 412 conditionNotMet. To see the latest fingerprint, make a
-- get() request to retrieve a UrlMap.
umFingerprint :: Lens' URLMap (Maybe ByteString)
umFingerprint
  = lens _umFingerprint
      (\ s a -> s{_umFingerprint = a})
      . mapping _Bytes

-- | The full or partial URL of the defaultService resource to which traffic
-- is directed if none of the hostRules match. If defaultRouteAction is
-- additionally specified, advanced routing actions like URL Rewrites, etc.
-- take effect prior to sending the request to the backend. However, if
-- defaultService is specified, defaultRouteAction cannot contain any
-- weightedBackendServices. Conversely, if routeAction specifies any
-- weightedBackendServices, service must not be specified. Only one of
-- defaultService, defaultUrlRedirect or
-- defaultRouteAction.weightedBackendService must be set. defaultService
-- has no effect when the URL map is bound to target gRPC proxy that has
-- validateForProxyless field set to true.
umDefaultService :: Lens' URLMap (Maybe Text)
umDefaultService
  = lens _umDefaultService
      (\ s a -> s{_umDefaultService = a})

-- | Specifies changes to request and response headers that need to take
-- effect for the selected backendService. The headerAction specified here
-- take effect after headerAction specified under pathMatcher. Note that
-- headerAction is not supported for Loadbalancers that have their
-- loadBalancingScheme set to EXTERNAL. Not supported when the URL map is
-- bound to target gRPC proxy that has validateForProxyless field set to
-- true.
umHeaderAction :: Lens' URLMap (Maybe HTTPHeaderAction)
umHeaderAction
  = lens _umHeaderAction
      (\ s a -> s{_umHeaderAction = a})

-- | [Output Only] Server-defined URL for the resource.
umSelfLink :: Lens' URLMap (Maybe Text)
umSelfLink
  = lens _umSelfLink (\ s a -> s{_umSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
umName :: Lens' URLMap (Maybe Text)
umName = lens _umName (\ s a -> s{_umName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
umCreationTimestamp :: Lens' URLMap (Maybe Text)
umCreationTimestamp
  = lens _umCreationTimestamp
      (\ s a -> s{_umCreationTimestamp = a})

-- | The list of named PathMatchers to use against the URL.
umPathMatchers :: Lens' URLMap [PathMatcher]
umPathMatchers
  = lens _umPathMatchers
      (\ s a -> s{_umPathMatchers = a})
      . _Default
      . _Coerce

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
umId :: Lens' URLMap (Maybe Word64)
umId
  = lens _umId (\ s a -> s{_umId = a}) .
      mapping _Coerce

-- | The list of HostRules to use against the URL.
umHostRules :: Lens' URLMap [HostRule]
umHostRules
  = lens _umHostRules (\ s a -> s{_umHostRules = a}) .
      _Default
      . _Coerce

-- | [Output Only] URL of the region where the regional URL map resides. This
-- field is not applicable to global URL maps. You must specify this field
-- as part of the HTTP request URL. It is not settable as a field in the
-- request body.
umRegion :: Lens' URLMap (Maybe Text)
umRegion = lens _umRegion (\ s a -> s{_umRegion = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource.
umDescription :: Lens' URLMap (Maybe Text)
umDescription
  = lens _umDescription
      (\ s a -> s{_umDescription = a})

instance FromJSON URLMap where
        parseJSON
          = withObject "URLMap"
              (\ o ->
                 URLMap' <$>
                   (o .:? "defaultRouteAction") <*>
                     (o .:? "defaultUrlRedirect")
                     <*> (o .:? "tests" .!= mempty)
                     <*> (o .:? "kind" .!= "compute#urlMap")
                     <*> (o .:? "fingerprint")
                     <*> (o .:? "defaultService")
                     <*> (o .:? "headerAction")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "pathMatchers" .!= mempty)
                     <*> (o .:? "id")
                     <*> (o .:? "hostRules" .!= mempty)
                     <*> (o .:? "region")
                     <*> (o .:? "description"))

instance ToJSON URLMap where
        toJSON URLMap'{..}
          = object
              (catMaybes
                 [("defaultRouteAction" .=) <$> _umDefaultRouteAction,
                  ("defaultUrlRedirect" .=) <$> _umDefaultURLRedirect,
                  ("tests" .=) <$> _umTests, Just ("kind" .= _umKind),
                  ("fingerprint" .=) <$> _umFingerprint,
                  ("defaultService" .=) <$> _umDefaultService,
                  ("headerAction" .=) <$> _umHeaderAction,
                  ("selfLink" .=) <$> _umSelfLink,
                  ("name" .=) <$> _umName,
                  ("creationTimestamp" .=) <$> _umCreationTimestamp,
                  ("pathMatchers" .=) <$> _umPathMatchers,
                  ("id" .=) <$> _umId,
                  ("hostRules" .=) <$> _umHostRules,
                  ("region" .=) <$> _umRegion,
                  ("description" .=) <$> _umDescription])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'resourcePolicyAggregatedListWarning' smart constructor.
data ResourcePolicyAggregatedListWarning =
  ResourcePolicyAggregatedListWarning'
    { _rpalwData :: !(Maybe [ResourcePolicyAggregatedListWarningDataItem])
    , _rpalwCode :: !(Maybe ResourcePolicyAggregatedListWarningCode)
    , _rpalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePolicyAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rpalwData'
--
-- * 'rpalwCode'
--
-- * 'rpalwMessage'
resourcePolicyAggregatedListWarning
    :: ResourcePolicyAggregatedListWarning
resourcePolicyAggregatedListWarning =
  ResourcePolicyAggregatedListWarning'
    {_rpalwData = Nothing, _rpalwCode = Nothing, _rpalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
rpalwData :: Lens' ResourcePolicyAggregatedListWarning [ResourcePolicyAggregatedListWarningDataItem]
rpalwData
  = lens _rpalwData (\ s a -> s{_rpalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
rpalwCode :: Lens' ResourcePolicyAggregatedListWarning (Maybe ResourcePolicyAggregatedListWarningCode)
rpalwCode
  = lens _rpalwCode (\ s a -> s{_rpalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
rpalwMessage :: Lens' ResourcePolicyAggregatedListWarning (Maybe Text)
rpalwMessage
  = lens _rpalwMessage (\ s a -> s{_rpalwMessage = a})

instance FromJSON ResourcePolicyAggregatedListWarning
         where
        parseJSON
          = withObject "ResourcePolicyAggregatedListWarning"
              (\ o ->
                 ResourcePolicyAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON ResourcePolicyAggregatedListWarning
         where
        toJSON ResourcePolicyAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _rpalwData,
                  ("code" .=) <$> _rpalwCode,
                  ("message" .=) <$> _rpalwMessage])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'imageListWarning' smart constructor.
data ImageListWarning =
  ImageListWarning'
    { _ilwData :: !(Maybe [ImageListWarningDataItem])
    , _ilwCode :: !(Maybe ImageListWarningCode)
    , _ilwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ImageListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ilwData'
--
-- * 'ilwCode'
--
-- * 'ilwMessage'
imageListWarning
    :: ImageListWarning
imageListWarning =
  ImageListWarning'
    {_ilwData = Nothing, _ilwCode = Nothing, _ilwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
ilwData :: Lens' ImageListWarning [ImageListWarningDataItem]
ilwData
  = lens _ilwData (\ s a -> s{_ilwData = a}) . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
ilwCode :: Lens' ImageListWarning (Maybe ImageListWarningCode)
ilwCode = lens _ilwCode (\ s a -> s{_ilwCode = a})

-- | [Output Only] A human-readable description of the warning code.
ilwMessage :: Lens' ImageListWarning (Maybe Text)
ilwMessage
  = lens _ilwMessage (\ s a -> s{_ilwMessage = a})

instance FromJSON ImageListWarning where
        parseJSON
          = withObject "ImageListWarning"
              (\ o ->
                 ImageListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON ImageListWarning where
        toJSON ImageListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _ilwData, ("code" .=) <$> _ilwCode,
                  ("message" .=) <$> _ilwMessage])

--
-- /See:/ 'urlMapsScopedListWarningDataItem' smart constructor.
data URLMapsScopedListWarningDataItem =
  URLMapsScopedListWarningDataItem'
    { _umslwdiValue :: !(Maybe Text)
    , _umslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'URLMapsScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'umslwdiValue'
--
-- * 'umslwdiKey'
urlMapsScopedListWarningDataItem
    :: URLMapsScopedListWarningDataItem
urlMapsScopedListWarningDataItem =
  URLMapsScopedListWarningDataItem'
    {_umslwdiValue = Nothing, _umslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
umslwdiValue :: Lens' URLMapsScopedListWarningDataItem (Maybe Text)
umslwdiValue
  = lens _umslwdiValue (\ s a -> s{_umslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
umslwdiKey :: Lens' URLMapsScopedListWarningDataItem (Maybe Text)
umslwdiKey
  = lens _umslwdiKey (\ s a -> s{_umslwdiKey = a})

instance FromJSON URLMapsScopedListWarningDataItem
         where
        parseJSON
          = withObject "URLMapsScopedListWarningDataItem"
              (\ o ->
                 URLMapsScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON URLMapsScopedListWarningDataItem
         where
        toJSON URLMapsScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _umslwdiValue,
                  ("key" .=) <$> _umslwdiKey])

-- | Represents a textual expression in the Common Expression Language (CEL)
-- syntax. CEL is a C-like expression language. The syntax and semantics of
-- CEL are documented at https:\/\/github.com\/google\/cel-spec. Example
-- (Comparison): title: \"Summary size limit\" description: \"Determines if
-- a summary is less than 100 chars\" expression: \"document.summary.size()
-- \< 100\" Example (Equality): title: \"Requestor is owner\" description:
-- \"Determines if requestor is the document owner\" expression:
-- \"document.owner == request.auth.claims.email\" Example (Logic): title:
-- \"Public documents\" description: \"Determine whether the document
-- should be publicly visible\" expression: \"document.type != \'private\'
-- && document.type != \'internal\'\" Example (Data Manipulation): title:
-- \"Notification string\" description: \"Create a notification string with
-- a timestamp.\" expression: \"\'New message received at \' +
-- string(document.create_time)\" The exact variables and functions that
-- may be referenced within an expression are determined by the service
-- that evaluates it. See the service documentation for additional
-- information.
--
-- /See:/ 'expr' smart constructor.
data Expr =
  Expr'
    { _eLocation :: !(Maybe Text)
    , _eExpression :: !(Maybe Text)
    , _eTitle :: !(Maybe Text)
    , _eDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Expr' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'eLocation'
--
-- * 'eExpression'
--
-- * 'eTitle'
--
-- * 'eDescription'
expr
    :: Expr
expr =
  Expr'
    { _eLocation = Nothing
    , _eExpression = Nothing
    , _eTitle = Nothing
    , _eDescription = Nothing
    }


-- | Optional. String indicating the location of the expression for error
-- reporting, e.g. a file name and a position in the file.
eLocation :: Lens' Expr (Maybe Text)
eLocation
  = lens _eLocation (\ s a -> s{_eLocation = a})

-- | Textual representation of an expression in Common Expression Language
-- syntax.
eExpression :: Lens' Expr (Maybe Text)
eExpression
  = lens _eExpression (\ s a -> s{_eExpression = a})

-- | Optional. Title for the expression, i.e. a short string describing its
-- purpose. This can be used e.g. in UIs which allow to enter the
-- expression.
eTitle :: Lens' Expr (Maybe Text)
eTitle = lens _eTitle (\ s a -> s{_eTitle = a})

-- | Optional. Description of the expression. This is a longer text which
-- describes the expression, e.g. when hovered over it in a UI.
eDescription :: Lens' Expr (Maybe Text)
eDescription
  = lens _eDescription (\ s a -> s{_eDescription = a})

instance FromJSON Expr where
        parseJSON
          = withObject "Expr"
              (\ o ->
                 Expr' <$>
                   (o .:? "location") <*> (o .:? "expression") <*>
                     (o .:? "title")
                     <*> (o .:? "description"))

instance ToJSON Expr where
        toJSON Expr'{..}
          = object
              (catMaybes
                 [("location" .=) <$> _eLocation,
                  ("expression" .=) <$> _eExpression,
                  ("title" .=) <$> _eTitle,
                  ("description" .=) <$> _eDescription])

--
-- /See:/ 'sslPolicyReference' smart constructor.
newtype SSLPolicyReference =
  SSLPolicyReference'
    { _sprSSLPolicy :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SSLPolicyReference' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sprSSLPolicy'
sslPolicyReference
    :: SSLPolicyReference
sslPolicyReference = SSLPolicyReference' {_sprSSLPolicy = Nothing}


-- | URL of the SSL policy resource. Set this to empty string to clear any
-- existing SSL policy associated with the target proxy resource.
sprSSLPolicy :: Lens' SSLPolicyReference (Maybe Text)
sprSSLPolicy
  = lens _sprSSLPolicy (\ s a -> s{_sprSSLPolicy = a})

instance FromJSON SSLPolicyReference where
        parseJSON
          = withObject "SSLPolicyReference"
              (\ o -> SSLPolicyReference' <$> (o .:? "sslPolicy"))

instance ToJSON SSLPolicyReference where
        toJSON SSLPolicyReference'{..}
          = object
              (catMaybes [("sslPolicy" .=) <$> _sprSSLPolicy])

-- | Time window specified for hourly operations.
--
-- /See:/ 'resourcePolicyHourlyCycle' smart constructor.
data ResourcePolicyHourlyCycle =
  ResourcePolicyHourlyCycle'
    { _rphcHoursInCycle :: !(Maybe (Textual Int32))
    , _rphcStartTime :: !(Maybe Text)
    , _rphcDuration :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePolicyHourlyCycle' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rphcHoursInCycle'
--
-- * 'rphcStartTime'
--
-- * 'rphcDuration'
resourcePolicyHourlyCycle
    :: ResourcePolicyHourlyCycle
resourcePolicyHourlyCycle =
  ResourcePolicyHourlyCycle'
    { _rphcHoursInCycle = Nothing
    , _rphcStartTime = Nothing
    , _rphcDuration = Nothing
    }


-- | Defines a schedule with units measured in hours. The value determines
-- how many hours pass between the start of each cycle.
rphcHoursInCycle :: Lens' ResourcePolicyHourlyCycle (Maybe Int32)
rphcHoursInCycle
  = lens _rphcHoursInCycle
      (\ s a -> s{_rphcHoursInCycle = a})
      . mapping _Coerce

-- | Time within the window to start the operations. It must be in format
-- \"HH:MM\", where HH : [00-23] and MM : [00-00] GMT.
rphcStartTime :: Lens' ResourcePolicyHourlyCycle (Maybe Text)
rphcStartTime
  = lens _rphcStartTime
      (\ s a -> s{_rphcStartTime = a})

-- | [Output only] Duration of the time window, automatically chosen to be
-- smallest possible in the given scenario.
rphcDuration :: Lens' ResourcePolicyHourlyCycle (Maybe Text)
rphcDuration
  = lens _rphcDuration (\ s a -> s{_rphcDuration = a})

instance FromJSON ResourcePolicyHourlyCycle where
        parseJSON
          = withObject "ResourcePolicyHourlyCycle"
              (\ o ->
                 ResourcePolicyHourlyCycle' <$>
                   (o .:? "hoursInCycle") <*> (o .:? "startTime") <*>
                     (o .:? "duration"))

instance ToJSON ResourcePolicyHourlyCycle where
        toJSON ResourcePolicyHourlyCycle'{..}
          = object
              (catMaybes
                 [("hoursInCycle" .=) <$> _rphcHoursInCycle,
                  ("startTime" .=) <$> _rphcStartTime,
                  ("duration" .=) <$> _rphcDuration])

-- | A list of InstanceGroupsScopedList resources.
--
-- /See:/ 'instanceGroupAggregatedListItems' smart constructor.
newtype InstanceGroupAggregatedListItems =
  InstanceGroupAggregatedListItems'
    { _igaliAddtional :: HashMap Text InstanceGroupsScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igaliAddtional'
instanceGroupAggregatedListItems
    :: HashMap Text InstanceGroupsScopedList -- ^ 'igaliAddtional'
    -> InstanceGroupAggregatedListItems
instanceGroupAggregatedListItems pIgaliAddtional_ =
  InstanceGroupAggregatedListItems'
    {_igaliAddtional = _Coerce # pIgaliAddtional_}


-- | The name of the scope that contains this set of instance groups.
igaliAddtional :: Lens' InstanceGroupAggregatedListItems (HashMap Text InstanceGroupsScopedList)
igaliAddtional
  = lens _igaliAddtional
      (\ s a -> s{_igaliAddtional = a})
      . _Coerce

instance FromJSON InstanceGroupAggregatedListItems
         where
        parseJSON
          = withObject "InstanceGroupAggregatedListItems"
              (\ o ->
                 InstanceGroupAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON InstanceGroupAggregatedListItems
         where
        toJSON = toJSON . _igaliAddtional

--
-- /See:/ 'publicDelegatedPrefixListWarningDataItem' smart constructor.
data PublicDelegatedPrefixListWarningDataItem =
  PublicDelegatedPrefixListWarningDataItem'
    { _pdplwdiValue :: !(Maybe Text)
    , _pdplwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PublicDelegatedPrefixListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pdplwdiValue'
--
-- * 'pdplwdiKey'
publicDelegatedPrefixListWarningDataItem
    :: PublicDelegatedPrefixListWarningDataItem
publicDelegatedPrefixListWarningDataItem =
  PublicDelegatedPrefixListWarningDataItem'
    {_pdplwdiValue = Nothing, _pdplwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
pdplwdiValue :: Lens' PublicDelegatedPrefixListWarningDataItem (Maybe Text)
pdplwdiValue
  = lens _pdplwdiValue (\ s a -> s{_pdplwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
pdplwdiKey :: Lens' PublicDelegatedPrefixListWarningDataItem (Maybe Text)
pdplwdiKey
  = lens _pdplwdiKey (\ s a -> s{_pdplwdiKey = a})

instance FromJSON
           PublicDelegatedPrefixListWarningDataItem
         where
        parseJSON
          = withObject
              "PublicDelegatedPrefixListWarningDataItem"
              (\ o ->
                 PublicDelegatedPrefixListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           PublicDelegatedPrefixListWarningDataItem
         where
        toJSON PublicDelegatedPrefixListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _pdplwdiValue,
                  ("key" .=) <$> _pdplwdiKey])

-- | Contains a list of TargetPool resources.
--
-- /See:/ 'targetPoolList' smart constructor.
data TargetPoolList =
  TargetPoolList'
    { _tplNextPageToken :: !(Maybe Text)
    , _tplKind :: !Text
    , _tplItems :: !(Maybe [TargetPool])
    , _tplSelfLink :: !(Maybe Text)
    , _tplWarning :: !(Maybe TargetPoolListWarning)
    , _tplId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetPoolList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tplNextPageToken'
--
-- * 'tplKind'
--
-- * 'tplItems'
--
-- * 'tplSelfLink'
--
-- * 'tplWarning'
--
-- * 'tplId'
targetPoolList
    :: TargetPoolList
targetPoolList =
  TargetPoolList'
    { _tplNextPageToken = Nothing
    , _tplKind = "compute#targetPoolList"
    , _tplItems = Nothing
    , _tplSelfLink = Nothing
    , _tplWarning = Nothing
    , _tplId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
tplNextPageToken :: Lens' TargetPoolList (Maybe Text)
tplNextPageToken
  = lens _tplNextPageToken
      (\ s a -> s{_tplNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#targetPoolList for lists
-- of target pools.
tplKind :: Lens' TargetPoolList Text
tplKind = lens _tplKind (\ s a -> s{_tplKind = a})

-- | A list of TargetPool resources.
tplItems :: Lens' TargetPoolList [TargetPool]
tplItems
  = lens _tplItems (\ s a -> s{_tplItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
tplSelfLink :: Lens' TargetPoolList (Maybe Text)
tplSelfLink
  = lens _tplSelfLink (\ s a -> s{_tplSelfLink = a})

-- | [Output Only] Informational warning message.
tplWarning :: Lens' TargetPoolList (Maybe TargetPoolListWarning)
tplWarning
  = lens _tplWarning (\ s a -> s{_tplWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
tplId :: Lens' TargetPoolList (Maybe Text)
tplId = lens _tplId (\ s a -> s{_tplId = a})

instance FromJSON TargetPoolList where
        parseJSON
          = withObject "TargetPoolList"
              (\ o ->
                 TargetPoolList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#targetPoolList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON TargetPoolList where
        toJSON TargetPoolList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _tplNextPageToken,
                  Just ("kind" .= _tplKind),
                  ("items" .=) <$> _tplItems,
                  ("selfLink" .=) <$> _tplSelfLink,
                  ("warning" .=) <$> _tplWarning,
                  ("id" .=) <$> _tplId])

-- | Represents an Accelerator Type resource. Google Cloud Platform provides
-- graphics processing units (accelerators) that you can add to VM
-- instances to improve or accelerate performance when working with
-- intensive workloads. For more information, read GPUs on Compute Engine.
-- (== resource_for {$api_version}.acceleratorTypes ==)
--
-- /See:/ 'acceleratorType' smart constructor.
data AcceleratorType =
  AcceleratorType'
    { _atKind :: !Text
    , _atZone :: !(Maybe Text)
    , _atMaximumCardsPerInstance :: !(Maybe (Textual Int32))
    , _atSelfLink :: !(Maybe Text)
    , _atName :: !(Maybe Text)
    , _atCreationTimestamp :: !(Maybe Text)
    , _atId :: !(Maybe (Textual Word64))
    , _atDescription :: !(Maybe Text)
    , _atDeprecated :: !(Maybe DeprecationStatus)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AcceleratorType' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'atKind'
--
-- * 'atZone'
--
-- * 'atMaximumCardsPerInstance'
--
-- * 'atSelfLink'
--
-- * 'atName'
--
-- * 'atCreationTimestamp'
--
-- * 'atId'
--
-- * 'atDescription'
--
-- * 'atDeprecated'
acceleratorType
    :: AcceleratorType
acceleratorType =
  AcceleratorType'
    { _atKind = "compute#acceleratorType"
    , _atZone = Nothing
    , _atMaximumCardsPerInstance = Nothing
    , _atSelfLink = Nothing
    , _atName = Nothing
    , _atCreationTimestamp = Nothing
    , _atId = Nothing
    , _atDescription = Nothing
    , _atDeprecated = Nothing
    }


-- | [Output Only] The type of the resource. Always compute#acceleratorType
-- for accelerator types.
atKind :: Lens' AcceleratorType Text
atKind = lens _atKind (\ s a -> s{_atKind = a})

-- | [Output Only] The name of the zone where the accelerator type resides,
-- such as us-central1-a. You must specify this field as part of the HTTP
-- request URL. It is not settable as a field in the request body.
atZone :: Lens' AcceleratorType (Maybe Text)
atZone = lens _atZone (\ s a -> s{_atZone = a})

-- | [Output Only] Maximum number of accelerator cards allowed per instance.
atMaximumCardsPerInstance :: Lens' AcceleratorType (Maybe Int32)
atMaximumCardsPerInstance
  = lens _atMaximumCardsPerInstance
      (\ s a -> s{_atMaximumCardsPerInstance = a})
      . mapping _Coerce

-- | [Output Only] Server-defined, fully qualified URL for this resource.
atSelfLink :: Lens' AcceleratorType (Maybe Text)
atSelfLink
  = lens _atSelfLink (\ s a -> s{_atSelfLink = a})

-- | [Output Only] Name of the resource.
atName :: Lens' AcceleratorType (Maybe Text)
atName = lens _atName (\ s a -> s{_atName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
atCreationTimestamp :: Lens' AcceleratorType (Maybe Text)
atCreationTimestamp
  = lens _atCreationTimestamp
      (\ s a -> s{_atCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
atId :: Lens' AcceleratorType (Maybe Word64)
atId
  = lens _atId (\ s a -> s{_atId = a}) .
      mapping _Coerce

-- | [Output Only] An optional textual description of the resource.
atDescription :: Lens' AcceleratorType (Maybe Text)
atDescription
  = lens _atDescription
      (\ s a -> s{_atDescription = a})

-- | [Output Only] The deprecation status associated with this accelerator
-- type.
atDeprecated :: Lens' AcceleratorType (Maybe DeprecationStatus)
atDeprecated
  = lens _atDeprecated (\ s a -> s{_atDeprecated = a})

instance FromJSON AcceleratorType where
        parseJSON
          = withObject "AcceleratorType"
              (\ o ->
                 AcceleratorType' <$>
                   (o .:? "kind" .!= "compute#acceleratorType") <*>
                     (o .:? "zone")
                     <*> (o .:? "maximumCardsPerInstance")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "description")
                     <*> (o .:? "deprecated"))

instance ToJSON AcceleratorType where
        toJSON AcceleratorType'{..}
          = object
              (catMaybes
                 [Just ("kind" .= _atKind), ("zone" .=) <$> _atZone,
                  ("maximumCardsPerInstance" .=) <$>
                    _atMaximumCardsPerInstance,
                  ("selfLink" .=) <$> _atSelfLink,
                  ("name" .=) <$> _atName,
                  ("creationTimestamp" .=) <$> _atCreationTimestamp,
                  ("id" .=) <$> _atId,
                  ("description" .=) <$> _atDescription,
                  ("deprecated" .=) <$> _atDeprecated])

--
-- /See:/ 'backendBucketListWarningDataItem' smart constructor.
data BackendBucketListWarningDataItem =
  BackendBucketListWarningDataItem'
    { _bblwdiValue :: !(Maybe Text)
    , _bblwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendBucketListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bblwdiValue'
--
-- * 'bblwdiKey'
backendBucketListWarningDataItem
    :: BackendBucketListWarningDataItem
backendBucketListWarningDataItem =
  BackendBucketListWarningDataItem'
    {_bblwdiValue = Nothing, _bblwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
bblwdiValue :: Lens' BackendBucketListWarningDataItem (Maybe Text)
bblwdiValue
  = lens _bblwdiValue (\ s a -> s{_bblwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
bblwdiKey :: Lens' BackendBucketListWarningDataItem (Maybe Text)
bblwdiKey
  = lens _bblwdiKey (\ s a -> s{_bblwdiKey = a})

instance FromJSON BackendBucketListWarningDataItem
         where
        parseJSON
          = withObject "BackendBucketListWarningDataItem"
              (\ o ->
                 BackendBucketListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON BackendBucketListWarningDataItem
         where
        toJSON BackendBucketListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _bblwdiValue,
                  ("key" .=) <$> _bblwdiKey])

--
-- /See:/ 'hTTPRouteAction' smart constructor.
data HTTPRouteAction =
  HTTPRouteAction'
    { _httpraFaultInjectionPolicy :: !(Maybe HTTPFaultInjection)
    , _httpraCORSPolicy :: !(Maybe CORSPolicy)
    , _httpraURLRewrite :: !(Maybe URLRewrite)
    , _httpraRequestMirrorPolicy :: !(Maybe RequestMirrorPolicy)
    , _httpraRetryPolicy :: !(Maybe HTTPRetryPolicy)
    , _httpraWeightedBackendServices :: !(Maybe [WeightedBackendService])
    , _httpraTimeout :: !(Maybe Duration)
    , _httpraMaxStreamDuration :: !(Maybe Duration)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HTTPRouteAction' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'httpraFaultInjectionPolicy'
--
-- * 'httpraCORSPolicy'
--
-- * 'httpraURLRewrite'
--
-- * 'httpraRequestMirrorPolicy'
--
-- * 'httpraRetryPolicy'
--
-- * 'httpraWeightedBackendServices'
--
-- * 'httpraTimeout'
--
-- * 'httpraMaxStreamDuration'
hTTPRouteAction
    :: HTTPRouteAction
hTTPRouteAction =
  HTTPRouteAction'
    { _httpraFaultInjectionPolicy = Nothing
    , _httpraCORSPolicy = Nothing
    , _httpraURLRewrite = Nothing
    , _httpraRequestMirrorPolicy = Nothing
    , _httpraRetryPolicy = Nothing
    , _httpraWeightedBackendServices = Nothing
    , _httpraTimeout = Nothing
    , _httpraMaxStreamDuration = Nothing
    }


-- | The specification for fault injection introduced into traffic to test
-- the resiliency of clients to backend service failure. As part of fault
-- injection, when clients send requests to a backend service, delays can
-- be introduced by Loadbalancer on a percentage of requests before sending
-- those request to the backend service. Similarly requests from clients
-- can be aborted by the Loadbalancer for a percentage of requests. For the
-- requests impacted by fault injection, timeout and retry_policy will be
-- ignored by clients that are configured with a fault_injection_policy.
httpraFaultInjectionPolicy :: Lens' HTTPRouteAction (Maybe HTTPFaultInjection)
httpraFaultInjectionPolicy
  = lens _httpraFaultInjectionPolicy
      (\ s a -> s{_httpraFaultInjectionPolicy = a})

-- | The specification for allowing client side cross-origin requests. Please
-- see W3C Recommendation for Cross Origin Resource Sharing Not supported
-- when the URL map is bound to target gRPC proxy.
httpraCORSPolicy :: Lens' HTTPRouteAction (Maybe CORSPolicy)
httpraCORSPolicy
  = lens _httpraCORSPolicy
      (\ s a -> s{_httpraCORSPolicy = a})

-- | The spec to modify the URL of the request, prior to forwarding the
-- request to the matched service. urlRewrite is the only action supported
-- in UrlMaps for external HTTP(S) load balancers. Not supported when the
-- URL map is bound to target gRPC proxy that has validateForProxyless
-- field set to true.
httpraURLRewrite :: Lens' HTTPRouteAction (Maybe URLRewrite)
httpraURLRewrite
  = lens _httpraURLRewrite
      (\ s a -> s{_httpraURLRewrite = a})

-- | Specifies the policy on how requests intended for the route\'s backends
-- are shadowed to a separate mirrored backend service. Loadbalancer does
-- not wait for responses from the shadow service. Prior to sending traffic
-- to the shadow service, the host \/ authority header is suffixed with
-- -shadow. Not supported when the URL map is bound to target gRPC proxy
-- that has validateForProxyless field set to true.
httpraRequestMirrorPolicy :: Lens' HTTPRouteAction (Maybe RequestMirrorPolicy)
httpraRequestMirrorPolicy
  = lens _httpraRequestMirrorPolicy
      (\ s a -> s{_httpraRequestMirrorPolicy = a})

-- | Specifies the retry policy associated with this route. Not supported
-- when the URL map is bound to target gRPC proxy that has
-- validateForProxyless field set to true.
httpraRetryPolicy :: Lens' HTTPRouteAction (Maybe HTTPRetryPolicy)
httpraRetryPolicy
  = lens _httpraRetryPolicy
      (\ s a -> s{_httpraRetryPolicy = a})

-- | A list of weighted backend services to send traffic to when a route
-- match occurs. The weights determine the fraction of traffic that flows
-- to their corresponding backend service. If all traffic needs to go to a
-- single backend service, there must be one weightedBackendService with
-- weight set to a non-zero number. Once a backendService is identified and
-- before forwarding the request to the backend service, advanced routing
-- actions such as URL rewrites and header transformations are applied
-- depending on additional settings specified in this HttpRouteAction.
httpraWeightedBackendServices :: Lens' HTTPRouteAction [WeightedBackendService]
httpraWeightedBackendServices
  = lens _httpraWeightedBackendServices
      (\ s a -> s{_httpraWeightedBackendServices = a})
      . _Default
      . _Coerce

-- | Specifies the timeout for the selected route. Timeout is computed from
-- the time the request has been fully processed (i.e. end-of-stream) up
-- until the response has been completely processed. Timeout includes all
-- retries. If not specified, will use the largest timeout among all
-- backend services associated with the route. Not supported when the URL
-- map is bound to target gRPC proxy that has validateForProxyless field
-- set to true.
httpraTimeout :: Lens' HTTPRouteAction (Maybe Duration)
httpraTimeout
  = lens _httpraTimeout
      (\ s a -> s{_httpraTimeout = a})

-- | Specifies the maximum duration (timeout) for streams on the selected
-- route. Unlike the timeout field where the timeout duration starts from
-- the time the request has been fully processed (i.e. end-of-stream), the
-- duration in this field is computed from the beginning of the stream
-- until the response has been completely processed, including all retries.
-- A stream that does not complete in this duration is closed. If not
-- specified, will use the largest maxStreamDuration among all backend
-- services associated with the route. This field is only allowed if the
-- Url map is used with backend services with loadBalancingScheme set to
-- INTERNAL_SELF_MANAGED.
httpraMaxStreamDuration :: Lens' HTTPRouteAction (Maybe Duration)
httpraMaxStreamDuration
  = lens _httpraMaxStreamDuration
      (\ s a -> s{_httpraMaxStreamDuration = a})

instance FromJSON HTTPRouteAction where
        parseJSON
          = withObject "HTTPRouteAction"
              (\ o ->
                 HTTPRouteAction' <$>
                   (o .:? "faultInjectionPolicy") <*>
                     (o .:? "corsPolicy")
                     <*> (o .:? "urlRewrite")
                     <*> (o .:? "requestMirrorPolicy")
                     <*> (o .:? "retryPolicy")
                     <*> (o .:? "weightedBackendServices" .!= mempty)
                     <*> (o .:? "timeout")
                     <*> (o .:? "maxStreamDuration"))

instance ToJSON HTTPRouteAction where
        toJSON HTTPRouteAction'{..}
          = object
              (catMaybes
                 [("faultInjectionPolicy" .=) <$>
                    _httpraFaultInjectionPolicy,
                  ("corsPolicy" .=) <$> _httpraCORSPolicy,
                  ("urlRewrite" .=) <$> _httpraURLRewrite,
                  ("requestMirrorPolicy" .=) <$>
                    _httpraRequestMirrorPolicy,
                  ("retryPolicy" .=) <$> _httpraRetryPolicy,
                  ("weightedBackendServices" .=) <$>
                    _httpraWeightedBackendServices,
                  ("timeout" .=) <$> _httpraTimeout,
                  ("maxStreamDuration" .=) <$>
                    _httpraMaxStreamDuration])

--
-- /See:/ 'acceleratorTypesScopedListWarningDataItem' smart constructor.
data AcceleratorTypesScopedListWarningDataItem =
  AcceleratorTypesScopedListWarningDataItem'
    { _atslwdiValue :: !(Maybe Text)
    , _atslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AcceleratorTypesScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'atslwdiValue'
--
-- * 'atslwdiKey'
acceleratorTypesScopedListWarningDataItem
    :: AcceleratorTypesScopedListWarningDataItem
acceleratorTypesScopedListWarningDataItem =
  AcceleratorTypesScopedListWarningDataItem'
    {_atslwdiValue = Nothing, _atslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
atslwdiValue :: Lens' AcceleratorTypesScopedListWarningDataItem (Maybe Text)
atslwdiValue
  = lens _atslwdiValue (\ s a -> s{_atslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
atslwdiKey :: Lens' AcceleratorTypesScopedListWarningDataItem (Maybe Text)
atslwdiKey
  = lens _atslwdiKey (\ s a -> s{_atslwdiKey = a})

instance FromJSON
           AcceleratorTypesScopedListWarningDataItem
         where
        parseJSON
          = withObject
              "AcceleratorTypesScopedListWarningDataItem"
              (\ o ->
                 AcceleratorTypesScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           AcceleratorTypesScopedListWarningDataItem
         where
        toJSON AcceleratorTypesScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _atslwdiValue,
                  ("key" .=) <$> _atslwdiKey])

--
-- /See:/ 'targetHTTPProxiesScopedList' smart constructor.
data TargetHTTPProxiesScopedList =
  TargetHTTPProxiesScopedList'
    { _thttppslTargetHTTPProxies :: !(Maybe [TargetHTTPProxy])
    , _thttppslWarning :: !(Maybe TargetHTTPProxiesScopedListWarning)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetHTTPProxiesScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'thttppslTargetHTTPProxies'
--
-- * 'thttppslWarning'
targetHTTPProxiesScopedList
    :: TargetHTTPProxiesScopedList
targetHTTPProxiesScopedList =
  TargetHTTPProxiesScopedList'
    {_thttppslTargetHTTPProxies = Nothing, _thttppslWarning = Nothing}


-- | A list of TargetHttpProxies contained in this scope.
thttppslTargetHTTPProxies :: Lens' TargetHTTPProxiesScopedList [TargetHTTPProxy]
thttppslTargetHTTPProxies
  = lens _thttppslTargetHTTPProxies
      (\ s a -> s{_thttppslTargetHTTPProxies = a})
      . _Default
      . _Coerce

-- | Informational warning which replaces the list of backend services when
-- the list is empty.
thttppslWarning :: Lens' TargetHTTPProxiesScopedList (Maybe TargetHTTPProxiesScopedListWarning)
thttppslWarning
  = lens _thttppslWarning
      (\ s a -> s{_thttppslWarning = a})

instance FromJSON TargetHTTPProxiesScopedList where
        parseJSON
          = withObject "TargetHTTPProxiesScopedList"
              (\ o ->
                 TargetHTTPProxiesScopedList' <$>
                   (o .:? "targetHttpProxies" .!= mempty) <*>
                     (o .:? "warning"))

instance ToJSON TargetHTTPProxiesScopedList where
        toJSON TargetHTTPProxiesScopedList'{..}
          = object
              (catMaybes
                 [("targetHttpProxies" .=) <$>
                    _thttppslTargetHTTPProxies,
                  ("warning" .=) <$> _thttppslWarning])

--
-- /See:/ 'regionDiskTypeList' smart constructor.
data RegionDiskTypeList =
  RegionDiskTypeList'
    { _rdtlNextPageToken :: !(Maybe Text)
    , _rdtlKind :: !Text
    , _rdtlItems :: !(Maybe [DiskType])
    , _rdtlSelfLink :: !(Maybe Text)
    , _rdtlWarning :: !(Maybe RegionDiskTypeListWarning)
    , _rdtlId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionDiskTypeList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rdtlNextPageToken'
--
-- * 'rdtlKind'
--
-- * 'rdtlItems'
--
-- * 'rdtlSelfLink'
--
-- * 'rdtlWarning'
--
-- * 'rdtlId'
regionDiskTypeList
    :: RegionDiskTypeList
regionDiskTypeList =
  RegionDiskTypeList'
    { _rdtlNextPageToken = Nothing
    , _rdtlKind = "compute#regionDiskTypeList"
    , _rdtlItems = Nothing
    , _rdtlSelfLink = Nothing
    , _rdtlWarning = Nothing
    , _rdtlId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
rdtlNextPageToken :: Lens' RegionDiskTypeList (Maybe Text)
rdtlNextPageToken
  = lens _rdtlNextPageToken
      (\ s a -> s{_rdtlNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#regionDiskTypeList for
-- region disk types.
rdtlKind :: Lens' RegionDiskTypeList Text
rdtlKind = lens _rdtlKind (\ s a -> s{_rdtlKind = a})

-- | A list of DiskType resources.
rdtlItems :: Lens' RegionDiskTypeList [DiskType]
rdtlItems
  = lens _rdtlItems (\ s a -> s{_rdtlItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
rdtlSelfLink :: Lens' RegionDiskTypeList (Maybe Text)
rdtlSelfLink
  = lens _rdtlSelfLink (\ s a -> s{_rdtlSelfLink = a})

-- | [Output Only] Informational warning message.
rdtlWarning :: Lens' RegionDiskTypeList (Maybe RegionDiskTypeListWarning)
rdtlWarning
  = lens _rdtlWarning (\ s a -> s{_rdtlWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
rdtlId :: Lens' RegionDiskTypeList (Maybe Text)
rdtlId = lens _rdtlId (\ s a -> s{_rdtlId = a})

instance FromJSON RegionDiskTypeList where
        parseJSON
          = withObject "RegionDiskTypeList"
              (\ o ->
                 RegionDiskTypeList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#regionDiskTypeList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON RegionDiskTypeList where
        toJSON RegionDiskTypeList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _rdtlNextPageToken,
                  Just ("kind" .= _rdtlKind),
                  ("items" .=) <$> _rdtlItems,
                  ("selfLink" .=) <$> _rdtlSelfLink,
                  ("warning" .=) <$> _rdtlWarning,
                  ("id" .=) <$> _rdtlId])

--
-- /See:/ 'targetInstanceAggregatedList' smart constructor.
data TargetInstanceAggregatedList =
  TargetInstanceAggregatedList'
    { _tialUnreachables :: !(Maybe [Text])
    , _tialNextPageToken :: !(Maybe Text)
    , _tialKind :: !Text
    , _tialItems :: !(Maybe TargetInstanceAggregatedListItems)
    , _tialSelfLink :: !(Maybe Text)
    , _tialWarning :: !(Maybe TargetInstanceAggregatedListWarning)
    , _tialId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetInstanceAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tialUnreachables'
--
-- * 'tialNextPageToken'
--
-- * 'tialKind'
--
-- * 'tialItems'
--
-- * 'tialSelfLink'
--
-- * 'tialWarning'
--
-- * 'tialId'
targetInstanceAggregatedList
    :: TargetInstanceAggregatedList
targetInstanceAggregatedList =
  TargetInstanceAggregatedList'
    { _tialUnreachables = Nothing
    , _tialNextPageToken = Nothing
    , _tialKind = "compute#targetInstanceAggregatedList"
    , _tialItems = Nothing
    , _tialSelfLink = Nothing
    , _tialWarning = Nothing
    , _tialId = Nothing
    }


-- | [Output Only] Unreachable resources.
tialUnreachables :: Lens' TargetInstanceAggregatedList [Text]
tialUnreachables
  = lens _tialUnreachables
      (\ s a -> s{_tialUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
tialNextPageToken :: Lens' TargetInstanceAggregatedList (Maybe Text)
tialNextPageToken
  = lens _tialNextPageToken
      (\ s a -> s{_tialNextPageToken = a})

-- | Type of resource.
tialKind :: Lens' TargetInstanceAggregatedList Text
tialKind = lens _tialKind (\ s a -> s{_tialKind = a})

-- | A list of TargetInstance resources.
tialItems :: Lens' TargetInstanceAggregatedList (Maybe TargetInstanceAggregatedListItems)
tialItems
  = lens _tialItems (\ s a -> s{_tialItems = a})

-- | [Output Only] Server-defined URL for this resource.
tialSelfLink :: Lens' TargetInstanceAggregatedList (Maybe Text)
tialSelfLink
  = lens _tialSelfLink (\ s a -> s{_tialSelfLink = a})

-- | [Output Only] Informational warning message.
tialWarning :: Lens' TargetInstanceAggregatedList (Maybe TargetInstanceAggregatedListWarning)
tialWarning
  = lens _tialWarning (\ s a -> s{_tialWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
tialId :: Lens' TargetInstanceAggregatedList (Maybe Text)
tialId = lens _tialId (\ s a -> s{_tialId = a})

instance FromJSON TargetInstanceAggregatedList where
        parseJSON
          = withObject "TargetInstanceAggregatedList"
              (\ o ->
                 TargetInstanceAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!=
                        "compute#targetInstanceAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON TargetInstanceAggregatedList where
        toJSON TargetInstanceAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _tialUnreachables,
                  ("nextPageToken" .=) <$> _tialNextPageToken,
                  Just ("kind" .= _tialKind),
                  ("items" .=) <$> _tialItems,
                  ("selfLink" .=) <$> _tialSelfLink,
                  ("warning" .=) <$> _tialWarning,
                  ("id" .=) <$> _tialId])

--
-- /See:/ 'nodeGroupsListNodesWarningDataItem' smart constructor.
data NodeGroupsListNodesWarningDataItem =
  NodeGroupsListNodesWarningDataItem'
    { _nglnwdiValue :: !(Maybe Text)
    , _nglnwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeGroupsListNodesWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nglnwdiValue'
--
-- * 'nglnwdiKey'
nodeGroupsListNodesWarningDataItem
    :: NodeGroupsListNodesWarningDataItem
nodeGroupsListNodesWarningDataItem =
  NodeGroupsListNodesWarningDataItem'
    {_nglnwdiValue = Nothing, _nglnwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
nglnwdiValue :: Lens' NodeGroupsListNodesWarningDataItem (Maybe Text)
nglnwdiValue
  = lens _nglnwdiValue (\ s a -> s{_nglnwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
nglnwdiKey :: Lens' NodeGroupsListNodesWarningDataItem (Maybe Text)
nglnwdiKey
  = lens _nglnwdiKey (\ s a -> s{_nglnwdiKey = a})

instance FromJSON NodeGroupsListNodesWarningDataItem
         where
        parseJSON
          = withObject "NodeGroupsListNodesWarningDataItem"
              (\ o ->
                 NodeGroupsListNodesWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON NodeGroupsListNodesWarningDataItem
         where
        toJSON NodeGroupsListNodesWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _nglnwdiValue,
                  ("key" .=) <$> _nglnwdiKey])

--
-- /See:/ 'usableSubnetworksAggregatedList' smart constructor.
data UsableSubnetworksAggregatedList =
  UsableSubnetworksAggregatedList'
    { _usalNextPageToken :: !(Maybe Text)
    , _usalKind :: !Text
    , _usalItems :: !(Maybe [UsableSubnetwork])
    , _usalSelfLink :: !(Maybe Text)
    , _usalWarning :: !(Maybe UsableSubnetworksAggregatedListWarning)
    , _usalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'UsableSubnetworksAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'usalNextPageToken'
--
-- * 'usalKind'
--
-- * 'usalItems'
--
-- * 'usalSelfLink'
--
-- * 'usalWarning'
--
-- * 'usalId'
usableSubnetworksAggregatedList
    :: UsableSubnetworksAggregatedList
usableSubnetworksAggregatedList =
  UsableSubnetworksAggregatedList'
    { _usalNextPageToken = Nothing
    , _usalKind = "compute#usableSubnetworksAggregatedList"
    , _usalItems = Nothing
    , _usalSelfLink = Nothing
    , _usalWarning = Nothing
    , _usalId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results. In special cases
-- listUsable may return 0 subnetworks and nextPageToken which still should
-- be used to get the next page of results.
usalNextPageToken :: Lens' UsableSubnetworksAggregatedList (Maybe Text)
usalNextPageToken
  = lens _usalNextPageToken
      (\ s a -> s{_usalNextPageToken = a})

-- | [Output Only] Type of resource. Always
-- compute#usableSubnetworksAggregatedList for aggregated lists of usable
-- subnetworks.
usalKind :: Lens' UsableSubnetworksAggregatedList Text
usalKind = lens _usalKind (\ s a -> s{_usalKind = a})

-- | [Output] A list of usable subnetwork URLs.
usalItems :: Lens' UsableSubnetworksAggregatedList [UsableSubnetwork]
usalItems
  = lens _usalItems (\ s a -> s{_usalItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
usalSelfLink :: Lens' UsableSubnetworksAggregatedList (Maybe Text)
usalSelfLink
  = lens _usalSelfLink (\ s a -> s{_usalSelfLink = a})

-- | [Output Only] Informational warning message.
usalWarning :: Lens' UsableSubnetworksAggregatedList (Maybe UsableSubnetworksAggregatedListWarning)
usalWarning
  = lens _usalWarning (\ s a -> s{_usalWarning = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
usalId :: Lens' UsableSubnetworksAggregatedList (Maybe Text)
usalId = lens _usalId (\ s a -> s{_usalId = a})

instance FromJSON UsableSubnetworksAggregatedList
         where
        parseJSON
          = withObject "UsableSubnetworksAggregatedList"
              (\ o ->
                 UsableSubnetworksAggregatedList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!=
                        "compute#usableSubnetworksAggregatedList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON UsableSubnetworksAggregatedList where
        toJSON UsableSubnetworksAggregatedList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _usalNextPageToken,
                  Just ("kind" .= _usalKind),
                  ("items" .=) <$> _usalItems,
                  ("selfLink" .=) <$> _usalSelfLink,
                  ("warning" .=) <$> _usalWarning,
                  ("id" .=) <$> _usalId])

--
-- /See:/ 'reservationList' smart constructor.
data ReservationList =
  ReservationList'
    { _rlNextPageToken :: !(Maybe Text)
    , _rlKind :: !Text
    , _rlItems :: !(Maybe [Reservation])
    , _rlSelfLink :: !(Maybe Text)
    , _rlWarning :: !(Maybe ReservationListWarning)
    , _rlId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ReservationList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rlNextPageToken'
--
-- * 'rlKind'
--
-- * 'rlItems'
--
-- * 'rlSelfLink'
--
-- * 'rlWarning'
--
-- * 'rlId'
reservationList
    :: ReservationList
reservationList =
  ReservationList'
    { _rlNextPageToken = Nothing
    , _rlKind = "compute#reservationList"
    , _rlItems = Nothing
    , _rlSelfLink = Nothing
    , _rlWarning = Nothing
    , _rlId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
rlNextPageToken :: Lens' ReservationList (Maybe Text)
rlNextPageToken
  = lens _rlNextPageToken
      (\ s a -> s{_rlNextPageToken = a})

-- | [Output Only] Type of resource.Always compute#reservationsList for
-- listsof reservations
rlKind :: Lens' ReservationList Text
rlKind = lens _rlKind (\ s a -> s{_rlKind = a})

-- | [Output Only] A list of Allocation resources.
rlItems :: Lens' ReservationList [Reservation]
rlItems
  = lens _rlItems (\ s a -> s{_rlItems = a}) . _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
rlSelfLink :: Lens' ReservationList (Maybe Text)
rlSelfLink
  = lens _rlSelfLink (\ s a -> s{_rlSelfLink = a})

-- | [Output Only] Informational warning message.
rlWarning :: Lens' ReservationList (Maybe ReservationListWarning)
rlWarning
  = lens _rlWarning (\ s a -> s{_rlWarning = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
rlId :: Lens' ReservationList (Maybe Text)
rlId = lens _rlId (\ s a -> s{_rlId = a})

instance FromJSON ReservationList where
        parseJSON
          = withObject "ReservationList"
              (\ o ->
                 ReservationList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#reservationList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON ReservationList where
        toJSON ReservationList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _rlNextPageToken,
                  Just ("kind" .= _rlKind), ("items" .=) <$> _rlItems,
                  ("selfLink" .=) <$> _rlSelfLink,
                  ("warning" .=) <$> _rlWarning, ("id" .=) <$> _rlId])

--
-- /See:/ 'disksScopedList' smart constructor.
data DisksScopedList =
  DisksScopedList'
    { _dslWarning :: !(Maybe DisksScopedListWarning)
    , _dslDisks :: !(Maybe [Disk])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DisksScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dslWarning'
--
-- * 'dslDisks'
disksScopedList
    :: DisksScopedList
disksScopedList = DisksScopedList' {_dslWarning = Nothing, _dslDisks = Nothing}


-- | [Output Only] Informational warning which replaces the list of disks
-- when the list is empty.
dslWarning :: Lens' DisksScopedList (Maybe DisksScopedListWarning)
dslWarning
  = lens _dslWarning (\ s a -> s{_dslWarning = a})

-- | [Output Only] A list of disks contained in this scope.
dslDisks :: Lens' DisksScopedList [Disk]
dslDisks
  = lens _dslDisks (\ s a -> s{_dslDisks = a}) .
      _Default
      . _Coerce

instance FromJSON DisksScopedList where
        parseJSON
          = withObject "DisksScopedList"
              (\ o ->
                 DisksScopedList' <$>
                   (o .:? "warning") <*> (o .:? "disks" .!= mempty))

instance ToJSON DisksScopedList where
        toJSON DisksScopedList'{..}
          = object
              (catMaybes
                 [("warning" .=) <$> _dslWarning,
                  ("disks" .=) <$> _dslDisks])

--
-- /See:/ 'interconnectLocationListWarningDataItem' smart constructor.
data InterconnectLocationListWarningDataItem =
  InterconnectLocationListWarningDataItem'
    { _illwdiValue :: !(Maybe Text)
    , _illwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectLocationListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'illwdiValue'
--
-- * 'illwdiKey'
interconnectLocationListWarningDataItem
    :: InterconnectLocationListWarningDataItem
interconnectLocationListWarningDataItem =
  InterconnectLocationListWarningDataItem'
    {_illwdiValue = Nothing, _illwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
illwdiValue :: Lens' InterconnectLocationListWarningDataItem (Maybe Text)
illwdiValue
  = lens _illwdiValue (\ s a -> s{_illwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
illwdiKey :: Lens' InterconnectLocationListWarningDataItem (Maybe Text)
illwdiKey
  = lens _illwdiKey (\ s a -> s{_illwdiKey = a})

instance FromJSON
           InterconnectLocationListWarningDataItem
         where
        parseJSON
          = withObject
              "InterconnectLocationListWarningDataItem"
              (\ o ->
                 InterconnectLocationListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           InterconnectLocationListWarningDataItem
         where
        toJSON InterconnectLocationListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _illwdiValue,
                  ("key" .=) <$> _illwdiKey])

--
-- /See:/ 'instanceGroupManagersScopedList' smart constructor.
data InstanceGroupManagersScopedList =
  InstanceGroupManagersScopedList'
    { _igmslWarning :: !(Maybe InstanceGroupManagersScopedListWarning)
    , _igmslInstanceGroupManagers :: !(Maybe [InstanceGroupManager])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagersScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmslWarning'
--
-- * 'igmslInstanceGroupManagers'
instanceGroupManagersScopedList
    :: InstanceGroupManagersScopedList
instanceGroupManagersScopedList =
  InstanceGroupManagersScopedList'
    {_igmslWarning = Nothing, _igmslInstanceGroupManagers = Nothing}


-- | [Output Only] The warning that replaces the list of managed instance
-- groups when the list is empty.
igmslWarning :: Lens' InstanceGroupManagersScopedList (Maybe InstanceGroupManagersScopedListWarning)
igmslWarning
  = lens _igmslWarning (\ s a -> s{_igmslWarning = a})

-- | [Output Only] The list of managed instance groups that are contained in
-- the specified project and zone.
igmslInstanceGroupManagers :: Lens' InstanceGroupManagersScopedList [InstanceGroupManager]
igmslInstanceGroupManagers
  = lens _igmslInstanceGroupManagers
      (\ s a -> s{_igmslInstanceGroupManagers = a})
      . _Default
      . _Coerce

instance FromJSON InstanceGroupManagersScopedList
         where
        parseJSON
          = withObject "InstanceGroupManagersScopedList"
              (\ o ->
                 InstanceGroupManagersScopedList' <$>
                   (o .:? "warning") <*>
                     (o .:? "instanceGroupManagers" .!= mempty))

instance ToJSON InstanceGroupManagersScopedList where
        toJSON InstanceGroupManagersScopedList'{..}
          = object
              (catMaybes
                 [("warning" .=) <$> _igmslWarning,
                  ("instanceGroupManagers" .=) <$>
                    _igmslInstanceGroupManagers])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'subnetworkListWarning' smart constructor.
data SubnetworkListWarning =
  SubnetworkListWarning'
    { _slwData :: !(Maybe [SubnetworkListWarningDataItem])
    , _slwCode :: !(Maybe SubnetworkListWarningCode)
    , _slwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SubnetworkListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'slwData'
--
-- * 'slwCode'
--
-- * 'slwMessage'
subnetworkListWarning
    :: SubnetworkListWarning
subnetworkListWarning =
  SubnetworkListWarning'
    {_slwData = Nothing, _slwCode = Nothing, _slwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
slwData :: Lens' SubnetworkListWarning [SubnetworkListWarningDataItem]
slwData
  = lens _slwData (\ s a -> s{_slwData = a}) . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
slwCode :: Lens' SubnetworkListWarning (Maybe SubnetworkListWarningCode)
slwCode = lens _slwCode (\ s a -> s{_slwCode = a})

-- | [Output Only] A human-readable description of the warning code.
slwMessage :: Lens' SubnetworkListWarning (Maybe Text)
slwMessage
  = lens _slwMessage (\ s a -> s{_slwMessage = a})

instance FromJSON SubnetworkListWarning where
        parseJSON
          = withObject "SubnetworkListWarning"
              (\ o ->
                 SubnetworkListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON SubnetworkListWarning where
        toJSON SubnetworkListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _slwData, ("code" .=) <$> _slwCode,
                  ("message" .=) <$> _slwMessage])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'networkEndpointGroupListWarning' smart constructor.
data NetworkEndpointGroupListWarning =
  NetworkEndpointGroupListWarning'
    { _neglwData :: !(Maybe [NetworkEndpointGroupListWarningDataItem])
    , _neglwCode :: !(Maybe NetworkEndpointGroupListWarningCode)
    , _neglwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkEndpointGroupListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'neglwData'
--
-- * 'neglwCode'
--
-- * 'neglwMessage'
networkEndpointGroupListWarning
    :: NetworkEndpointGroupListWarning
networkEndpointGroupListWarning =
  NetworkEndpointGroupListWarning'
    {_neglwData = Nothing, _neglwCode = Nothing, _neglwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
neglwData :: Lens' NetworkEndpointGroupListWarning [NetworkEndpointGroupListWarningDataItem]
neglwData
  = lens _neglwData (\ s a -> s{_neglwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
neglwCode :: Lens' NetworkEndpointGroupListWarning (Maybe NetworkEndpointGroupListWarningCode)
neglwCode
  = lens _neglwCode (\ s a -> s{_neglwCode = a})

-- | [Output Only] A human-readable description of the warning code.
neglwMessage :: Lens' NetworkEndpointGroupListWarning (Maybe Text)
neglwMessage
  = lens _neglwMessage (\ s a -> s{_neglwMessage = a})

instance FromJSON NetworkEndpointGroupListWarning
         where
        parseJSON
          = withObject "NetworkEndpointGroupListWarning"
              (\ o ->
                 NetworkEndpointGroupListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON NetworkEndpointGroupListWarning where
        toJSON NetworkEndpointGroupListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _neglwData,
                  ("code" .=) <$> _neglwCode,
                  ("message" .=) <$> _neglwMessage])

-- | Represents a Resource Policy resource. You can use resource policies to
-- schedule actions for some Compute Engine resources. For example, you can
-- use them to schedule persistent disk snapshots. (== resource_for
-- {$api_version}.resourcePolicies ==)
--
-- /See:/ 'resourcePolicy' smart constructor.
data ResourcePolicy =
  ResourcePolicy'
    { _rpInstanceSchedulePolicy :: !(Maybe ResourcePolicyInstanceSchedulePolicy)
    , _rpStatus :: !(Maybe ResourcePolicyStatus)
    , _rpKind :: !Text
    , _rpResourceStatus :: !(Maybe ResourcePolicyResourceStatus)
    , _rpGroupPlacementPolicy :: !(Maybe ResourcePolicyGroupPlacementPolicy)
    , _rpSelfLink :: !(Maybe Text)
    , _rpName :: !(Maybe Text)
    , _rpCreationTimestamp :: !(Maybe Text)
    , _rpId :: !(Maybe (Textual Word64))
    , _rpRegion :: !(Maybe Text)
    , _rpDescription :: !(Maybe Text)
    , _rpSnapshotSchedulePolicy :: !(Maybe ResourcePolicySnapshotSchedulePolicy)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rpInstanceSchedulePolicy'
--
-- * 'rpStatus'
--
-- * 'rpKind'
--
-- * 'rpResourceStatus'
--
-- * 'rpGroupPlacementPolicy'
--
-- * 'rpSelfLink'
--
-- * 'rpName'
--
-- * 'rpCreationTimestamp'
--
-- * 'rpId'
--
-- * 'rpRegion'
--
-- * 'rpDescription'
--
-- * 'rpSnapshotSchedulePolicy'
resourcePolicy
    :: ResourcePolicy
resourcePolicy =
  ResourcePolicy'
    { _rpInstanceSchedulePolicy = Nothing
    , _rpStatus = Nothing
    , _rpKind = "compute#resourcePolicy"
    , _rpResourceStatus = Nothing
    , _rpGroupPlacementPolicy = Nothing
    , _rpSelfLink = Nothing
    , _rpName = Nothing
    , _rpCreationTimestamp = Nothing
    , _rpId = Nothing
    , _rpRegion = Nothing
    , _rpDescription = Nothing
    , _rpSnapshotSchedulePolicy = Nothing
    }


-- | Resource policy for scheduling instance operations.
rpInstanceSchedulePolicy :: Lens' ResourcePolicy (Maybe ResourcePolicyInstanceSchedulePolicy)
rpInstanceSchedulePolicy
  = lens _rpInstanceSchedulePolicy
      (\ s a -> s{_rpInstanceSchedulePolicy = a})

-- | [Output Only] The status of resource policy creation.
rpStatus :: Lens' ResourcePolicy (Maybe ResourcePolicyStatus)
rpStatus = lens _rpStatus (\ s a -> s{_rpStatus = a})

-- | [Output Only] Type of the resource. Always compute#resource_policies for
-- resource policies.
rpKind :: Lens' ResourcePolicy Text
rpKind = lens _rpKind (\ s a -> s{_rpKind = a})

-- | [Output Only] The system status of the resource policy.
rpResourceStatus :: Lens' ResourcePolicy (Maybe ResourcePolicyResourceStatus)
rpResourceStatus
  = lens _rpResourceStatus
      (\ s a -> s{_rpResourceStatus = a})

-- | Resource policy for instances for placement configuration.
rpGroupPlacementPolicy :: Lens' ResourcePolicy (Maybe ResourcePolicyGroupPlacementPolicy)
rpGroupPlacementPolicy
  = lens _rpGroupPlacementPolicy
      (\ s a -> s{_rpGroupPlacementPolicy = a})

-- | [Output Only] Server-defined fully-qualified URL for this resource.
rpSelfLink :: Lens' ResourcePolicy (Maybe Text)
rpSelfLink
  = lens _rpSelfLink (\ s a -> s{_rpSelfLink = a})

-- | The name of the resource, provided by the client when initially creating
-- the resource. The resource name must be 1-63 characters long, and comply
-- with RFC1035. Specifically, the name must be 1-63 characters long and
-- match the regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means
-- the first character must be a lowercase letter, and all following
-- characters must be a dash, lowercase letter, or digit, except the last
-- character, which cannot be a dash.
rpName :: Lens' ResourcePolicy (Maybe Text)
rpName = lens _rpName (\ s a -> s{_rpName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
rpCreationTimestamp :: Lens' ResourcePolicy (Maybe Text)
rpCreationTimestamp
  = lens _rpCreationTimestamp
      (\ s a -> s{_rpCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
rpId :: Lens' ResourcePolicy (Maybe Word64)
rpId
  = lens _rpId (\ s a -> s{_rpId = a}) .
      mapping _Coerce

rpRegion :: Lens' ResourcePolicy (Maybe Text)
rpRegion = lens _rpRegion (\ s a -> s{_rpRegion = a})

rpDescription :: Lens' ResourcePolicy (Maybe Text)
rpDescription
  = lens _rpDescription
      (\ s a -> s{_rpDescription = a})

-- | Resource policy for persistent disks for creating snapshots.
rpSnapshotSchedulePolicy :: Lens' ResourcePolicy (Maybe ResourcePolicySnapshotSchedulePolicy)
rpSnapshotSchedulePolicy
  = lens _rpSnapshotSchedulePolicy
      (\ s a -> s{_rpSnapshotSchedulePolicy = a})

instance FromJSON ResourcePolicy where
        parseJSON
          = withObject "ResourcePolicy"
              (\ o ->
                 ResourcePolicy' <$>
                   (o .:? "instanceSchedulePolicy") <*> (o .:? "status")
                     <*> (o .:? "kind" .!= "compute#resourcePolicy")
                     <*> (o .:? "resourceStatus")
                     <*> (o .:? "groupPlacementPolicy")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "region")
                     <*> (o .:? "description")
                     <*> (o .:? "snapshotSchedulePolicy"))

instance ToJSON ResourcePolicy where
        toJSON ResourcePolicy'{..}
          = object
              (catMaybes
                 [("instanceSchedulePolicy" .=) <$>
                    _rpInstanceSchedulePolicy,
                  ("status" .=) <$> _rpStatus,
                  Just ("kind" .= _rpKind),
                  ("resourceStatus" .=) <$> _rpResourceStatus,
                  ("groupPlacementPolicy" .=) <$>
                    _rpGroupPlacementPolicy,
                  ("selfLink" .=) <$> _rpSelfLink,
                  ("name" .=) <$> _rpName,
                  ("creationTimestamp" .=) <$> _rpCreationTimestamp,
                  ("id" .=) <$> _rpId, ("region" .=) <$> _rpRegion,
                  ("description" .=) <$> _rpDescription,
                  ("snapshotSchedulePolicy" .=) <$>
                    _rpSnapshotSchedulePolicy])

-- | Represents a Health Check resource. Google Compute Engine has two Health
-- Check resources: *
-- [Global](\/compute\/docs\/reference\/rest\/{$api_version}\/healthChecks)
-- *
-- [Regional](\/compute\/docs\/reference\/rest\/{$api_version}\/regionHealthChecks)
-- Internal HTTP(S) load balancers must use regional health checks
-- (\`compute.v1.regionHealthChecks\`). Traffic Director must use global
-- health checks (\`compute.v1.HealthChecks\`). Internal TCP\/UDP load
-- balancers can use either regional or global health checks
-- (\`compute.v1.regionHealthChecks\` or \`compute.v1.HealthChecks\`).
-- External HTTP(S), TCP proxy, and SSL proxy load balancers as well as
-- managed instance group auto-healing must use global health checks
-- (\`compute.v1.HealthChecks\`). Network load balancers must use legacy
-- HTTP health checks (httpHealthChecks). For more information, see Health
-- checks overview.
--
-- /See:/ 'healthCheck' smart constructor.
data HealthCheck =
  HealthCheck'
    { _hcHealthyThreshold :: !(Maybe (Textual Int32))
    , _hcTCPHealthCheck :: !(Maybe TCPHealthCheck)
    , _hcHTTP2HealthCheck :: !(Maybe HTTP2HealthCheck)
    , _hcKind :: !Text
    , _hcSSLHealthCheck :: !(Maybe SSLHealthCheck)
    , _hcGrpcHealthCheck :: !(Maybe GRPCHealthCheck)
    , _hcSelfLink :: !(Maybe Text)
    , _hcCheckIntervalSec :: !(Maybe (Textual Int32))
    , _hcName :: !(Maybe Text)
    , _hcCreationTimestamp :: !(Maybe Text)
    , _hcHTTPHealthCheck :: !(Maybe HTTPHealthCheck)
    , _hcId :: !(Maybe (Textual Word64))
    , _hcRegion :: !(Maybe Text)
    , _hcType :: !(Maybe HealthCheckType)
    , _hcTimeoutSec :: !(Maybe (Textual Int32))
    , _hcLogConfig :: !(Maybe HealthCheckLogConfig)
    , _hcDescription :: !(Maybe Text)
    , _hcUnhealthyThreshold :: !(Maybe (Textual Int32))
    , _hcHTTPSHealthCheck :: !(Maybe HTTPSHealthCheck)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HealthCheck' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hcHealthyThreshold'
--
-- * 'hcTCPHealthCheck'
--
-- * 'hcHTTP2HealthCheck'
--
-- * 'hcKind'
--
-- * 'hcSSLHealthCheck'
--
-- * 'hcGrpcHealthCheck'
--
-- * 'hcSelfLink'
--
-- * 'hcCheckIntervalSec'
--
-- * 'hcName'
--
-- * 'hcCreationTimestamp'
--
-- * 'hcHTTPHealthCheck'
--
-- * 'hcId'
--
-- * 'hcRegion'
--
-- * 'hcType'
--
-- * 'hcTimeoutSec'
--
-- * 'hcLogConfig'
--
-- * 'hcDescription'
--
-- * 'hcUnhealthyThreshold'
--
-- * 'hcHTTPSHealthCheck'
healthCheck
    :: HealthCheck
healthCheck =
  HealthCheck'
    { _hcHealthyThreshold = Nothing
    , _hcTCPHealthCheck = Nothing
    , _hcHTTP2HealthCheck = Nothing
    , _hcKind = "compute#healthCheck"
    , _hcSSLHealthCheck = Nothing
    , _hcGrpcHealthCheck = Nothing
    , _hcSelfLink = Nothing
    , _hcCheckIntervalSec = Nothing
    , _hcName = Nothing
    , _hcCreationTimestamp = Nothing
    , _hcHTTPHealthCheck = Nothing
    , _hcId = Nothing
    , _hcRegion = Nothing
    , _hcType = Nothing
    , _hcTimeoutSec = Nothing
    , _hcLogConfig = Nothing
    , _hcDescription = Nothing
    , _hcUnhealthyThreshold = Nothing
    , _hcHTTPSHealthCheck = Nothing
    }


-- | A so-far unhealthy instance will be marked healthy after this many
-- consecutive successes. The default value is 2.
hcHealthyThreshold :: Lens' HealthCheck (Maybe Int32)
hcHealthyThreshold
  = lens _hcHealthyThreshold
      (\ s a -> s{_hcHealthyThreshold = a})
      . mapping _Coerce

hcTCPHealthCheck :: Lens' HealthCheck (Maybe TCPHealthCheck)
hcTCPHealthCheck
  = lens _hcTCPHealthCheck
      (\ s a -> s{_hcTCPHealthCheck = a})

hcHTTP2HealthCheck :: Lens' HealthCheck (Maybe HTTP2HealthCheck)
hcHTTP2HealthCheck
  = lens _hcHTTP2HealthCheck
      (\ s a -> s{_hcHTTP2HealthCheck = a})

-- | Type of the resource.
hcKind :: Lens' HealthCheck Text
hcKind = lens _hcKind (\ s a -> s{_hcKind = a})

hcSSLHealthCheck :: Lens' HealthCheck (Maybe SSLHealthCheck)
hcSSLHealthCheck
  = lens _hcSSLHealthCheck
      (\ s a -> s{_hcSSLHealthCheck = a})

hcGrpcHealthCheck :: Lens' HealthCheck (Maybe GRPCHealthCheck)
hcGrpcHealthCheck
  = lens _hcGrpcHealthCheck
      (\ s a -> s{_hcGrpcHealthCheck = a})

-- | [Output Only] Server-defined URL for the resource.
hcSelfLink :: Lens' HealthCheck (Maybe Text)
hcSelfLink
  = lens _hcSelfLink (\ s a -> s{_hcSelfLink = a})

-- | How often (in seconds) to send a health check. The default value is 5
-- seconds.
hcCheckIntervalSec :: Lens' HealthCheck (Maybe Int32)
hcCheckIntervalSec
  = lens _hcCheckIntervalSec
      (\ s a -> s{_hcCheckIntervalSec = a})
      . mapping _Coerce

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- For example, a name that is 1-63 characters long, matches the regular
-- expression \`[a-z]([-a-z0-9]*[a-z0-9])?\`, and otherwise complies with
-- RFC1035. This regular expression describes a name where the first
-- character is a lowercase letter, and all following characters are a
-- dash, lowercase letter, or digit, except the last character, which
-- isn\'t a dash.
hcName :: Lens' HealthCheck (Maybe Text)
hcName = lens _hcName (\ s a -> s{_hcName = a})

-- | [Output Only] Creation timestamp in 3339 text format.
hcCreationTimestamp :: Lens' HealthCheck (Maybe Text)
hcCreationTimestamp
  = lens _hcCreationTimestamp
      (\ s a -> s{_hcCreationTimestamp = a})

hcHTTPHealthCheck :: Lens' HealthCheck (Maybe HTTPHealthCheck)
hcHTTPHealthCheck
  = lens _hcHTTPHealthCheck
      (\ s a -> s{_hcHTTPHealthCheck = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
hcId :: Lens' HealthCheck (Maybe Word64)
hcId
  = lens _hcId (\ s a -> s{_hcId = a}) .
      mapping _Coerce

-- | [Output Only] Region where the health check resides. Not applicable to
-- global health checks.
hcRegion :: Lens' HealthCheck (Maybe Text)
hcRegion = lens _hcRegion (\ s a -> s{_hcRegion = a})

-- | Specifies the type of the healthCheck, either TCP, SSL, HTTP, HTTPS or
-- HTTP2. If not specified, the default is TCP. Exactly one of the
-- protocol-specific health check field must be specified, which must match
-- type field.
hcType :: Lens' HealthCheck (Maybe HealthCheckType)
hcType = lens _hcType (\ s a -> s{_hcType = a})

-- | How long (in seconds) to wait before claiming failure. The default value
-- is 5 seconds. It is invalid for timeoutSec to have greater value than
-- checkIntervalSec.
hcTimeoutSec :: Lens' HealthCheck (Maybe Int32)
hcTimeoutSec
  = lens _hcTimeoutSec (\ s a -> s{_hcTimeoutSec = a})
      . mapping _Coerce

-- | Configure logging on this health check.
hcLogConfig :: Lens' HealthCheck (Maybe HealthCheckLogConfig)
hcLogConfig
  = lens _hcLogConfig (\ s a -> s{_hcLogConfig = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource.
hcDescription :: Lens' HealthCheck (Maybe Text)
hcDescription
  = lens _hcDescription
      (\ s a -> s{_hcDescription = a})

-- | A so-far healthy instance will be marked unhealthy after this many
-- consecutive failures. The default value is 2.
hcUnhealthyThreshold :: Lens' HealthCheck (Maybe Int32)
hcUnhealthyThreshold
  = lens _hcUnhealthyThreshold
      (\ s a -> s{_hcUnhealthyThreshold = a})
      . mapping _Coerce

hcHTTPSHealthCheck :: Lens' HealthCheck (Maybe HTTPSHealthCheck)
hcHTTPSHealthCheck
  = lens _hcHTTPSHealthCheck
      (\ s a -> s{_hcHTTPSHealthCheck = a})

instance FromJSON HealthCheck where
        parseJSON
          = withObject "HealthCheck"
              (\ o ->
                 HealthCheck' <$>
                   (o .:? "healthyThreshold") <*>
                     (o .:? "tcpHealthCheck")
                     <*> (o .:? "http2HealthCheck")
                     <*> (o .:? "kind" .!= "compute#healthCheck")
                     <*> (o .:? "sslHealthCheck")
                     <*> (o .:? "grpcHealthCheck")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "checkIntervalSec")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "httpHealthCheck")
                     <*> (o .:? "id")
                     <*> (o .:? "region")
                     <*> (o .:? "type")
                     <*> (o .:? "timeoutSec")
                     <*> (o .:? "logConfig")
                     <*> (o .:? "description")
                     <*> (o .:? "unhealthyThreshold")
                     <*> (o .:? "httpsHealthCheck"))

instance ToJSON HealthCheck where
        toJSON HealthCheck'{..}
          = object
              (catMaybes
                 [("healthyThreshold" .=) <$> _hcHealthyThreshold,
                  ("tcpHealthCheck" .=) <$> _hcTCPHealthCheck,
                  ("http2HealthCheck" .=) <$> _hcHTTP2HealthCheck,
                  Just ("kind" .= _hcKind),
                  ("sslHealthCheck" .=) <$> _hcSSLHealthCheck,
                  ("grpcHealthCheck" .=) <$> _hcGrpcHealthCheck,
                  ("selfLink" .=) <$> _hcSelfLink,
                  ("checkIntervalSec" .=) <$> _hcCheckIntervalSec,
                  ("name" .=) <$> _hcName,
                  ("creationTimestamp" .=) <$> _hcCreationTimestamp,
                  ("httpHealthCheck" .=) <$> _hcHTTPHealthCheck,
                  ("id" .=) <$> _hcId, ("region" .=) <$> _hcRegion,
                  ("type" .=) <$> _hcType,
                  ("timeoutSec" .=) <$> _hcTimeoutSec,
                  ("logConfig" .=) <$> _hcLogConfig,
                  ("description" .=) <$> _hcDescription,
                  ("unhealthyThreshold" .=) <$> _hcUnhealthyThreshold,
                  ("httpsHealthCheck" .=) <$> _hcHTTPSHealthCheck])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'hTTPHealthCheckListWarning' smart constructor.
data HTTPHealthCheckListWarning =
  HTTPHealthCheckListWarning'
    { _httphclwData :: !(Maybe [HTTPHealthCheckListWarningDataItem])
    , _httphclwCode :: !(Maybe HTTPHealthCheckListWarningCode)
    , _httphclwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HTTPHealthCheckListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'httphclwData'
--
-- * 'httphclwCode'
--
-- * 'httphclwMessage'
hTTPHealthCheckListWarning
    :: HTTPHealthCheckListWarning
hTTPHealthCheckListWarning =
  HTTPHealthCheckListWarning'
    { _httphclwData = Nothing
    , _httphclwCode = Nothing
    , _httphclwMessage = Nothing
    }


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
httphclwData :: Lens' HTTPHealthCheckListWarning [HTTPHealthCheckListWarningDataItem]
httphclwData
  = lens _httphclwData (\ s a -> s{_httphclwData = a})
      . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
httphclwCode :: Lens' HTTPHealthCheckListWarning (Maybe HTTPHealthCheckListWarningCode)
httphclwCode
  = lens _httphclwCode (\ s a -> s{_httphclwCode = a})

-- | [Output Only] A human-readable description of the warning code.
httphclwMessage :: Lens' HTTPHealthCheckListWarning (Maybe Text)
httphclwMessage
  = lens _httphclwMessage
      (\ s a -> s{_httphclwMessage = a})

instance FromJSON HTTPHealthCheckListWarning where
        parseJSON
          = withObject "HTTPHealthCheckListWarning"
              (\ o ->
                 HTTPHealthCheckListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON HTTPHealthCheckListWarning where
        toJSON HTTPHealthCheckListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _httphclwData,
                  ("code" .=) <$> _httphclwCode,
                  ("message" .=) <$> _httphclwMessage])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'sslPoliciesListWarning' smart constructor.
data SSLPoliciesListWarning =
  SSLPoliciesListWarning'
    { _splwData :: !(Maybe [SSLPoliciesListWarningDataItem])
    , _splwCode :: !(Maybe SSLPoliciesListWarningCode)
    , _splwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SSLPoliciesListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'splwData'
--
-- * 'splwCode'
--
-- * 'splwMessage'
sslPoliciesListWarning
    :: SSLPoliciesListWarning
sslPoliciesListWarning =
  SSLPoliciesListWarning'
    {_splwData = Nothing, _splwCode = Nothing, _splwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
splwData :: Lens' SSLPoliciesListWarning [SSLPoliciesListWarningDataItem]
splwData
  = lens _splwData (\ s a -> s{_splwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
splwCode :: Lens' SSLPoliciesListWarning (Maybe SSLPoliciesListWarningCode)
splwCode = lens _splwCode (\ s a -> s{_splwCode = a})

-- | [Output Only] A human-readable description of the warning code.
splwMessage :: Lens' SSLPoliciesListWarning (Maybe Text)
splwMessage
  = lens _splwMessage (\ s a -> s{_splwMessage = a})

instance FromJSON SSLPoliciesListWarning where
        parseJSON
          = withObject "SSLPoliciesListWarning"
              (\ o ->
                 SSLPoliciesListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON SSLPoliciesListWarning where
        toJSON SSLPoliciesListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _splwData,
                  ("code" .=) <$> _splwCode,
                  ("message" .=) <$> _splwMessage])

-- | A list of CommitmentsScopedList resources.
--
-- /See:/ 'commitmentAggregatedListItems' smart constructor.
newtype CommitmentAggregatedListItems =
  CommitmentAggregatedListItems'
    { _caliAddtional :: HashMap Text CommitmentsScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'CommitmentAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'caliAddtional'
commitmentAggregatedListItems
    :: HashMap Text CommitmentsScopedList -- ^ 'caliAddtional'
    -> CommitmentAggregatedListItems
commitmentAggregatedListItems pCaliAddtional_ =
  CommitmentAggregatedListItems' {_caliAddtional = _Coerce # pCaliAddtional_}


-- | [Output Only] Name of the scope containing this set of commitments.
caliAddtional :: Lens' CommitmentAggregatedListItems (HashMap Text CommitmentsScopedList)
caliAddtional
  = lens _caliAddtional
      (\ s a -> s{_caliAddtional = a})
      . _Coerce

instance FromJSON CommitmentAggregatedListItems where
        parseJSON
          = withObject "CommitmentAggregatedListItems"
              (\ o ->
                 CommitmentAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON CommitmentAggregatedListItems where
        toJSON = toJSON . _caliAddtional

--
-- /See:/ 'diskAggregatedList' smart constructor.
data DiskAggregatedList =
  DiskAggregatedList'
    { _dalUnreachables :: !(Maybe [Text])
    , _dalNextPageToken :: !(Maybe Text)
    , _dalKind :: !Text
    , _dalItems :: !(Maybe DiskAggregatedListItems)
    , _dalSelfLink :: !(Maybe Text)
    , _dalWarning :: !(Maybe DiskAggregatedListWarning)
    , _dalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DiskAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dalUnreachables'
--
-- * 'dalNextPageToken'
--
-- * 'dalKind'
--
-- * 'dalItems'
--
-- * 'dalSelfLink'
--
-- * 'dalWarning'
--
-- * 'dalId'
diskAggregatedList
    :: DiskAggregatedList
diskAggregatedList =
  DiskAggregatedList'
    { _dalUnreachables = Nothing
    , _dalNextPageToken = Nothing
    , _dalKind = "compute#diskAggregatedList"
    , _dalItems = Nothing
    , _dalSelfLink = Nothing
    , _dalWarning = Nothing
    , _dalId = Nothing
    }


-- | [Output Only] Unreachable resources.
dalUnreachables :: Lens' DiskAggregatedList [Text]
dalUnreachables
  = lens _dalUnreachables
      (\ s a -> s{_dalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
dalNextPageToken :: Lens' DiskAggregatedList (Maybe Text)
dalNextPageToken
  = lens _dalNextPageToken
      (\ s a -> s{_dalNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#diskAggregatedList for
-- aggregated lists of persistent disks.
dalKind :: Lens' DiskAggregatedList Text
dalKind = lens _dalKind (\ s a -> s{_dalKind = a})

-- | A list of DisksScopedList resources.
dalItems :: Lens' DiskAggregatedList (Maybe DiskAggregatedListItems)
dalItems = lens _dalItems (\ s a -> s{_dalItems = a})

-- | [Output Only] Server-defined URL for this resource.
dalSelfLink :: Lens' DiskAggregatedList (Maybe Text)
dalSelfLink
  = lens _dalSelfLink (\ s a -> s{_dalSelfLink = a})

-- | [Output Only] Informational warning message.
dalWarning :: Lens' DiskAggregatedList (Maybe DiskAggregatedListWarning)
dalWarning
  = lens _dalWarning (\ s a -> s{_dalWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
dalId :: Lens' DiskAggregatedList (Maybe Text)
dalId = lens _dalId (\ s a -> s{_dalId = a})

instance FromJSON DiskAggregatedList where
        parseJSON
          = withObject "DiskAggregatedList"
              (\ o ->
                 DiskAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*> (o .:? "kind" .!= "compute#diskAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON DiskAggregatedList where
        toJSON DiskAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _dalUnreachables,
                  ("nextPageToken" .=) <$> _dalNextPageToken,
                  Just ("kind" .= _dalKind),
                  ("items" .=) <$> _dalItems,
                  ("selfLink" .=) <$> _dalSelfLink,
                  ("warning" .=) <$> _dalWarning,
                  ("id" .=) <$> _dalId])

--
-- /See:/ 'instanceGroupsListInstancesWarningDataItem' smart constructor.
data InstanceGroupsListInstancesWarningDataItem =
  InstanceGroupsListInstancesWarningDataItem'
    { _igliwdiValue :: !(Maybe Text)
    , _igliwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupsListInstancesWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igliwdiValue'
--
-- * 'igliwdiKey'
instanceGroupsListInstancesWarningDataItem
    :: InstanceGroupsListInstancesWarningDataItem
instanceGroupsListInstancesWarningDataItem =
  InstanceGroupsListInstancesWarningDataItem'
    {_igliwdiValue = Nothing, _igliwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
igliwdiValue :: Lens' InstanceGroupsListInstancesWarningDataItem (Maybe Text)
igliwdiValue
  = lens _igliwdiValue (\ s a -> s{_igliwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
igliwdiKey :: Lens' InstanceGroupsListInstancesWarningDataItem (Maybe Text)
igliwdiKey
  = lens _igliwdiKey (\ s a -> s{_igliwdiKey = a})

instance FromJSON
           InstanceGroupsListInstancesWarningDataItem
         where
        parseJSON
          = withObject
              "InstanceGroupsListInstancesWarningDataItem"
              (\ o ->
                 InstanceGroupsListInstancesWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           InstanceGroupsListInstancesWarningDataItem
         where
        toJSON
          InstanceGroupsListInstancesWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _igliwdiValue,
                  ("key" .=) <$> _igliwdiKey])

-- | Scaling based on user-defined schedule. The message describes a single
-- scaling schedule. A scaling schedule changes the minimum number of VM
-- instances an autoscaler can recommend, which can trigger scaling out.
--
-- /See:/ 'autoscalingPolicyScalingSchedule' smart constructor.
data AutoscalingPolicyScalingSchedule =
  AutoscalingPolicyScalingSchedule'
    { _apssSchedule :: !(Maybe Text)
    , _apssDisabled :: !(Maybe Bool)
    , _apssMinRequiredReplicas :: !(Maybe (Textual Int32))
    , _apssDurationSec :: !(Maybe (Textual Int32))
    , _apssTimeZone :: !(Maybe Text)
    , _apssDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AutoscalingPolicyScalingSchedule' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'apssSchedule'
--
-- * 'apssDisabled'
--
-- * 'apssMinRequiredReplicas'
--
-- * 'apssDurationSec'
--
-- * 'apssTimeZone'
--
-- * 'apssDescription'
autoscalingPolicyScalingSchedule
    :: AutoscalingPolicyScalingSchedule
autoscalingPolicyScalingSchedule =
  AutoscalingPolicyScalingSchedule'
    { _apssSchedule = Nothing
    , _apssDisabled = Nothing
    , _apssMinRequiredReplicas = Nothing
    , _apssDurationSec = Nothing
    , _apssTimeZone = Nothing
    , _apssDescription = Nothing
    }


-- | The start timestamps of time intervals when this scaling schedule is to
-- provide a scaling signal. This field uses the extended cron format (with
-- an optional year field). The expression can describe a single timestamp
-- if the optional year is set, in which case the scaling schedule runs
-- once. The schedule is interpreted with respect to time_zone. This field
-- is required. Note: These timestamps only describe when autoscaler starts
-- providing the scaling signal. The VMs need additional time to become
-- serving.
apssSchedule :: Lens' AutoscalingPolicyScalingSchedule (Maybe Text)
apssSchedule
  = lens _apssSchedule (\ s a -> s{_apssSchedule = a})

-- | A boolean value that specifies whether a scaling schedule can influence
-- autoscaler recommendations. If set to true, then a scaling schedule has
-- no effect. This field is optional, and its value is false by default.
apssDisabled :: Lens' AutoscalingPolicyScalingSchedule (Maybe Bool)
apssDisabled
  = lens _apssDisabled (\ s a -> s{_apssDisabled = a})

-- | The minimum number of VM instances that the autoscaler will recommend in
-- time intervals starting according to schedule. This field is required.
apssMinRequiredReplicas :: Lens' AutoscalingPolicyScalingSchedule (Maybe Int32)
apssMinRequiredReplicas
  = lens _apssMinRequiredReplicas
      (\ s a -> s{_apssMinRequiredReplicas = a})
      . mapping _Coerce

-- | The duration of time intervals, in seconds, for which this scaling
-- schedule is to run. The minimum allowed value is 300. This field is
-- required.
apssDurationSec :: Lens' AutoscalingPolicyScalingSchedule (Maybe Int32)
apssDurationSec
  = lens _apssDurationSec
      (\ s a -> s{_apssDurationSec = a})
      . mapping _Coerce

-- | The time zone to use when interpreting the schedule. The value of this
-- field must be a time zone name from the tz database:
-- http:\/\/en.wikipedia.org\/wiki\/Tz_database. This field is assigned a
-- default value of ?UTC? if left empty.
apssTimeZone :: Lens' AutoscalingPolicyScalingSchedule (Maybe Text)
apssTimeZone
  = lens _apssTimeZone (\ s a -> s{_apssTimeZone = a})

-- | A description of a scaling schedule.
apssDescription :: Lens' AutoscalingPolicyScalingSchedule (Maybe Text)
apssDescription
  = lens _apssDescription
      (\ s a -> s{_apssDescription = a})

instance FromJSON AutoscalingPolicyScalingSchedule
         where
        parseJSON
          = withObject "AutoscalingPolicyScalingSchedule"
              (\ o ->
                 AutoscalingPolicyScalingSchedule' <$>
                   (o .:? "schedule") <*> (o .:? "disabled") <*>
                     (o .:? "minRequiredReplicas")
                     <*> (o .:? "durationSec")
                     <*> (o .:? "timeZone")
                     <*> (o .:? "description"))

instance ToJSON AutoscalingPolicyScalingSchedule
         where
        toJSON AutoscalingPolicyScalingSchedule'{..}
          = object
              (catMaybes
                 [("schedule" .=) <$> _apssSchedule,
                  ("disabled" .=) <$> _apssDisabled,
                  ("minRequiredReplicas" .=) <$>
                    _apssMinRequiredReplicas,
                  ("durationSec" .=) <$> _apssDurationSec,
                  ("timeZone" .=) <$> _apssTimeZone,
                  ("description" .=) <$> _apssDescription])

--
-- /See:/ 'instanceWithNamedPorts' smart constructor.
data InstanceWithNamedPorts =
  InstanceWithNamedPorts'
    { _iwnpStatus :: !(Maybe InstanceWithNamedPortsStatus)
    , _iwnpNamedPorts :: !(Maybe [NamedPort])
    , _iwnpInstance :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceWithNamedPorts' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iwnpStatus'
--
-- * 'iwnpNamedPorts'
--
-- * 'iwnpInstance'
instanceWithNamedPorts
    :: InstanceWithNamedPorts
instanceWithNamedPorts =
  InstanceWithNamedPorts'
    {_iwnpStatus = Nothing, _iwnpNamedPorts = Nothing, _iwnpInstance = Nothing}


-- | [Output Only] The status of the instance.
iwnpStatus :: Lens' InstanceWithNamedPorts (Maybe InstanceWithNamedPortsStatus)
iwnpStatus
  = lens _iwnpStatus (\ s a -> s{_iwnpStatus = a})

-- | [Output Only] The named ports that belong to this instance group.
iwnpNamedPorts :: Lens' InstanceWithNamedPorts [NamedPort]
iwnpNamedPorts
  = lens _iwnpNamedPorts
      (\ s a -> s{_iwnpNamedPorts = a})
      . _Default
      . _Coerce

-- | [Output Only] The URL of the instance.
iwnpInstance :: Lens' InstanceWithNamedPorts (Maybe Text)
iwnpInstance
  = lens _iwnpInstance (\ s a -> s{_iwnpInstance = a})

instance FromJSON InstanceWithNamedPorts where
        parseJSON
          = withObject "InstanceWithNamedPorts"
              (\ o ->
                 InstanceWithNamedPorts' <$>
                   (o .:? "status") <*> (o .:? "namedPorts" .!= mempty)
                     <*> (o .:? "instance"))

instance ToJSON InstanceWithNamedPorts where
        toJSON InstanceWithNamedPorts'{..}
          = object
              (catMaybes
                 [("status" .=) <$> _iwnpStatus,
                  ("namedPorts" .=) <$> _iwnpNamedPorts,
                  ("instance" .=) <$> _iwnpInstance])

-- | A set of Display Device options
--
-- /See:/ 'displayDevice' smart constructor.
newtype DisplayDevice =
  DisplayDevice'
    { _ddEnableDisplay :: Maybe Bool
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DisplayDevice' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ddEnableDisplay'
displayDevice
    :: DisplayDevice
displayDevice = DisplayDevice' {_ddEnableDisplay = Nothing}


-- | Defines whether the instance has Display enabled.
ddEnableDisplay :: Lens' DisplayDevice (Maybe Bool)
ddEnableDisplay
  = lens _ddEnableDisplay
      (\ s a -> s{_ddEnableDisplay = a})

instance FromJSON DisplayDevice where
        parseJSON
          = withObject "DisplayDevice"
              (\ o -> DisplayDevice' <$> (o .:? "enableDisplay"))

instance ToJSON DisplayDevice where
        toJSON DisplayDevice'{..}
          = object
              (catMaybes
                 [("enableDisplay" .=) <$> _ddEnableDisplay])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'interconnectListWarning' smart constructor.
data InterconnectListWarning =
  InterconnectListWarning'
    { _iData :: !(Maybe [InterconnectListWarningDataItem])
    , _iCode :: !(Maybe InterconnectListWarningCode)
    , _iMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iData'
--
-- * 'iCode'
--
-- * 'iMessage'
interconnectListWarning
    :: InterconnectListWarning
interconnectListWarning =
  InterconnectListWarning'
    {_iData = Nothing, _iCode = Nothing, _iMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
iData :: Lens' InterconnectListWarning [InterconnectListWarningDataItem]
iData
  = lens _iData (\ s a -> s{_iData = a}) . _Default .
      _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
iCode :: Lens' InterconnectListWarning (Maybe InterconnectListWarningCode)
iCode = lens _iCode (\ s a -> s{_iCode = a})

-- | [Output Only] A human-readable description of the warning code.
iMessage :: Lens' InterconnectListWarning (Maybe Text)
iMessage = lens _iMessage (\ s a -> s{_iMessage = a})

instance FromJSON InterconnectListWarning where
        parseJSON
          = withObject "InterconnectListWarning"
              (\ o ->
                 InterconnectListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON InterconnectListWarning where
        toJSON InterconnectListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _iData, ("code" .=) <$> _iCode,
                  ("message" .=) <$> _iMessage])

--
-- /See:/ 'regionDisksAddResourcePoliciesRequest' smart constructor.
newtype RegionDisksAddResourcePoliciesRequest =
  RegionDisksAddResourcePoliciesRequest'
    { _rdarprResourcePolicies :: Maybe [Text]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionDisksAddResourcePoliciesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rdarprResourcePolicies'
regionDisksAddResourcePoliciesRequest
    :: RegionDisksAddResourcePoliciesRequest
regionDisksAddResourcePoliciesRequest =
  RegionDisksAddResourcePoliciesRequest' {_rdarprResourcePolicies = Nothing}


-- | Resource policies to be added to this disk.
rdarprResourcePolicies :: Lens' RegionDisksAddResourcePoliciesRequest [Text]
rdarprResourcePolicies
  = lens _rdarprResourcePolicies
      (\ s a -> s{_rdarprResourcePolicies = a})
      . _Default
      . _Coerce

instance FromJSON
           RegionDisksAddResourcePoliciesRequest
         where
        parseJSON
          = withObject "RegionDisksAddResourcePoliciesRequest"
              (\ o ->
                 RegionDisksAddResourcePoliciesRequest' <$>
                   (o .:? "resourcePolicies" .!= mempty))

instance ToJSON RegionDisksAddResourcePoliciesRequest
         where
        toJSON RegionDisksAddResourcePoliciesRequest'{..}
          = object
              (catMaybes
                 [("resourcePolicies" .=) <$>
                    _rdarprResourcePolicies])

--
-- /See:/ 'forwardingRulesScopedList' smart constructor.
data ForwardingRulesScopedList =
  ForwardingRulesScopedList'
    { _frslWarning :: !(Maybe ForwardingRulesScopedListWarning)
    , _frslForwardingRules :: !(Maybe [ForwardingRule])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ForwardingRulesScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'frslWarning'
--
-- * 'frslForwardingRules'
forwardingRulesScopedList
    :: ForwardingRulesScopedList
forwardingRulesScopedList =
  ForwardingRulesScopedList'
    {_frslWarning = Nothing, _frslForwardingRules = Nothing}


-- | Informational warning which replaces the list of forwarding rules when
-- the list is empty.
frslWarning :: Lens' ForwardingRulesScopedList (Maybe ForwardingRulesScopedListWarning)
frslWarning
  = lens _frslWarning (\ s a -> s{_frslWarning = a})

-- | A list of forwarding rules contained in this scope.
frslForwardingRules :: Lens' ForwardingRulesScopedList [ForwardingRule]
frslForwardingRules
  = lens _frslForwardingRules
      (\ s a -> s{_frslForwardingRules = a})
      . _Default
      . _Coerce

instance FromJSON ForwardingRulesScopedList where
        parseJSON
          = withObject "ForwardingRulesScopedList"
              (\ o ->
                 ForwardingRulesScopedList' <$>
                   (o .:? "warning") <*>
                     (o .:? "forwardingRules" .!= mempty))

instance ToJSON ForwardingRulesScopedList where
        toJSON ForwardingRulesScopedList'{..}
          = object
              (catMaybes
                 [("warning" .=) <$> _frslWarning,
                  ("forwardingRules" .=) <$> _frslForwardingRules])

--
-- /See:/ 'instanceReference' smart constructor.
newtype InstanceReference =
  InstanceReference'
    { _iInstance :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceReference' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iInstance'
instanceReference
    :: InstanceReference
instanceReference = InstanceReference' {_iInstance = Nothing}


-- | The URL for a specific instance.
iInstance :: Lens' InstanceReference (Maybe Text)
iInstance
  = lens _iInstance (\ s a -> s{_iInstance = a})

instance FromJSON InstanceReference where
        parseJSON
          = withObject "InstanceReference"
              (\ o -> InstanceReference' <$> (o .:? "instance"))

instance ToJSON InstanceReference where
        toJSON InstanceReference'{..}
          = object (catMaybes [("instance" .=) <$> _iInstance])

--
-- /See:/ 'operationAggregatedList' smart constructor.
data OperationAggregatedList =
  OperationAggregatedList'
    { _oalUnreachables :: !(Maybe [Text])
    , _oalNextPageToken :: !(Maybe Text)
    , _oalKind :: !Text
    , _oalItems :: !(Maybe OperationAggregatedListItems)
    , _oalSelfLink :: !(Maybe Text)
    , _oalWarning :: !(Maybe OperationAggregatedListWarning)
    , _oalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'OperationAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'oalUnreachables'
--
-- * 'oalNextPageToken'
--
-- * 'oalKind'
--
-- * 'oalItems'
--
-- * 'oalSelfLink'
--
-- * 'oalWarning'
--
-- * 'oalId'
operationAggregatedList
    :: OperationAggregatedList
operationAggregatedList =
  OperationAggregatedList'
    { _oalUnreachables = Nothing
    , _oalNextPageToken = Nothing
    , _oalKind = "compute#operationAggregatedList"
    , _oalItems = Nothing
    , _oalSelfLink = Nothing
    , _oalWarning = Nothing
    , _oalId = Nothing
    }


-- | [Output Only] Unreachable resources.
oalUnreachables :: Lens' OperationAggregatedList [Text]
oalUnreachables
  = lens _oalUnreachables
      (\ s a -> s{_oalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than \`maxResults\`,
-- use the \`nextPageToken\` as a value for the query parameter
-- \`pageToken\` in the next list request. Subsequent list requests will
-- have their own \`nextPageToken\` to continue paging through the results.
oalNextPageToken :: Lens' OperationAggregatedList (Maybe Text)
oalNextPageToken
  = lens _oalNextPageToken
      (\ s a -> s{_oalNextPageToken = a})

-- | [Output Only] Type of resource. Always
-- \`compute#operationAggregatedList\` for aggregated lists of operations.
oalKind :: Lens' OperationAggregatedList Text
oalKind = lens _oalKind (\ s a -> s{_oalKind = a})

-- | [Output Only] A map of scoped operation lists.
oalItems :: Lens' OperationAggregatedList (Maybe OperationAggregatedListItems)
oalItems = lens _oalItems (\ s a -> s{_oalItems = a})

-- | [Output Only] Server-defined URL for this resource.
oalSelfLink :: Lens' OperationAggregatedList (Maybe Text)
oalSelfLink
  = lens _oalSelfLink (\ s a -> s{_oalSelfLink = a})

-- | [Output Only] Informational warning message.
oalWarning :: Lens' OperationAggregatedList (Maybe OperationAggregatedListWarning)
oalWarning
  = lens _oalWarning (\ s a -> s{_oalWarning = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
oalId :: Lens' OperationAggregatedList (Maybe Text)
oalId = lens _oalId (\ s a -> s{_oalId = a})

instance FromJSON OperationAggregatedList where
        parseJSON
          = withObject "OperationAggregatedList"
              (\ o ->
                 OperationAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!= "compute#operationAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON OperationAggregatedList where
        toJSON OperationAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _oalUnreachables,
                  ("nextPageToken" .=) <$> _oalNextPageToken,
                  Just ("kind" .= _oalKind),
                  ("items" .=) <$> _oalItems,
                  ("selfLink" .=) <$> _oalSelfLink,
                  ("warning" .=) <$> _oalWarning,
                  ("id" .=) <$> _oalId])

--
-- /See:/ 'operationsScopedList' smart constructor.
data OperationsScopedList =
  OperationsScopedList'
    { _oslWarning :: !(Maybe OperationsScopedListWarning)
    , _oslOperations :: !(Maybe [Operation])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'OperationsScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'oslWarning'
--
-- * 'oslOperations'
operationsScopedList
    :: OperationsScopedList
operationsScopedList =
  OperationsScopedList' {_oslWarning = Nothing, _oslOperations = Nothing}


-- | [Output Only] Informational warning which replaces the list of
-- operations when the list is empty.
oslWarning :: Lens' OperationsScopedList (Maybe OperationsScopedListWarning)
oslWarning
  = lens _oslWarning (\ s a -> s{_oslWarning = a})

-- | [Output Only] A list of operations contained in this scope.
oslOperations :: Lens' OperationsScopedList [Operation]
oslOperations
  = lens _oslOperations
      (\ s a -> s{_oslOperations = a})
      . _Default
      . _Coerce

instance FromJSON OperationsScopedList where
        parseJSON
          = withObject "OperationsScopedList"
              (\ o ->
                 OperationsScopedList' <$>
                   (o .:? "warning") <*>
                     (o .:? "operations" .!= mempty))

instance ToJSON OperationsScopedList where
        toJSON OperationsScopedList'{..}
          = object
              (catMaybes
                 [("warning" .=) <$> _oslWarning,
                  ("operations" .=) <$> _oslOperations])

-- | The named port. For example: .
--
-- /See:/ 'namedPort' smart constructor.
data NamedPort =
  NamedPort'
    { _npName :: !(Maybe Text)
    , _npPort :: !(Maybe (Textual Int32))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NamedPort' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'npName'
--
-- * 'npPort'
namedPort
    :: NamedPort
namedPort = NamedPort' {_npName = Nothing, _npPort = Nothing}


-- | The name for this named port. The name must be 1-63 characters long, and
-- comply with RFC1035.
npName :: Lens' NamedPort (Maybe Text)
npName = lens _npName (\ s a -> s{_npName = a})

-- | The port number, which can be a value between 1 and 65535.
npPort :: Lens' NamedPort (Maybe Int32)
npPort
  = lens _npPort (\ s a -> s{_npPort = a}) .
      mapping _Coerce

instance FromJSON NamedPort where
        parseJSON
          = withObject "NamedPort"
              (\ o ->
                 NamedPort' <$> (o .:? "name") <*> (o .:? "port"))

instance ToJSON NamedPort where
        toJSON NamedPort'{..}
          = object
              (catMaybes
                 [("name" .=) <$> _npName, ("port" .=) <$> _npPort])

--
-- /See:/ 'healthChecksScopedListWarningDataItem' smart constructor.
data HealthChecksScopedListWarningDataItem =
  HealthChecksScopedListWarningDataItem'
    { _hcslwdiValue :: !(Maybe Text)
    , _hcslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HealthChecksScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hcslwdiValue'
--
-- * 'hcslwdiKey'
healthChecksScopedListWarningDataItem
    :: HealthChecksScopedListWarningDataItem
healthChecksScopedListWarningDataItem =
  HealthChecksScopedListWarningDataItem'
    {_hcslwdiValue = Nothing, _hcslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
hcslwdiValue :: Lens' HealthChecksScopedListWarningDataItem (Maybe Text)
hcslwdiValue
  = lens _hcslwdiValue (\ s a -> s{_hcslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
hcslwdiKey :: Lens' HealthChecksScopedListWarningDataItem (Maybe Text)
hcslwdiKey
  = lens _hcslwdiKey (\ s a -> s{_hcslwdiKey = a})

instance FromJSON
           HealthChecksScopedListWarningDataItem
         where
        parseJSON
          = withObject "HealthChecksScopedListWarningDataItem"
              (\ o ->
                 HealthChecksScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON HealthChecksScopedListWarningDataItem
         where
        toJSON HealthChecksScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _hcslwdiValue,
                  ("key" .=) <$> _hcslwdiKey])

--
-- /See:/ 'networkEndpointGroupsListEndpointsRequest' smart constructor.
newtype NetworkEndpointGroupsListEndpointsRequest =
  NetworkEndpointGroupsListEndpointsRequest'
    { _neglerHealthStatus :: Maybe NetworkEndpointGroupsListEndpointsRequestHealthStatus
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkEndpointGroupsListEndpointsRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'neglerHealthStatus'
networkEndpointGroupsListEndpointsRequest
    :: NetworkEndpointGroupsListEndpointsRequest
networkEndpointGroupsListEndpointsRequest =
  NetworkEndpointGroupsListEndpointsRequest' {_neglerHealthStatus = Nothing}


-- | Optional query parameter for showing the health status of each network
-- endpoint. Valid options are SKIP or SHOW. If you don\'t specify this
-- parameter, the health status of network endpoints will not be provided.
neglerHealthStatus :: Lens' NetworkEndpointGroupsListEndpointsRequest (Maybe NetworkEndpointGroupsListEndpointsRequestHealthStatus)
neglerHealthStatus
  = lens _neglerHealthStatus
      (\ s a -> s{_neglerHealthStatus = a})

instance FromJSON
           NetworkEndpointGroupsListEndpointsRequest
         where
        parseJSON
          = withObject
              "NetworkEndpointGroupsListEndpointsRequest"
              (\ o ->
                 NetworkEndpointGroupsListEndpointsRequest' <$>
                   (o .:? "healthStatus"))

instance ToJSON
           NetworkEndpointGroupsListEndpointsRequest
         where
        toJSON NetworkEndpointGroupsListEndpointsRequest'{..}
          = object
              (catMaybes
                 [("healthStatus" .=) <$> _neglerHealthStatus])

--
-- /See:/ 'subnetworkAggregatedListWarningDataItem' smart constructor.
data SubnetworkAggregatedListWarningDataItem =
  SubnetworkAggregatedListWarningDataItem'
    { _salwdiValue :: !(Maybe Text)
    , _salwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SubnetworkAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'salwdiValue'
--
-- * 'salwdiKey'
subnetworkAggregatedListWarningDataItem
    :: SubnetworkAggregatedListWarningDataItem
subnetworkAggregatedListWarningDataItem =
  SubnetworkAggregatedListWarningDataItem'
    {_salwdiValue = Nothing, _salwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
salwdiValue :: Lens' SubnetworkAggregatedListWarningDataItem (Maybe Text)
salwdiValue
  = lens _salwdiValue (\ s a -> s{_salwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
salwdiKey :: Lens' SubnetworkAggregatedListWarningDataItem (Maybe Text)
salwdiKey
  = lens _salwdiKey (\ s a -> s{_salwdiKey = a})

instance FromJSON
           SubnetworkAggregatedListWarningDataItem
         where
        parseJSON
          = withObject
              "SubnetworkAggregatedListWarningDataItem"
              (\ o ->
                 SubnetworkAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           SubnetworkAggregatedListWarningDataItem
         where
        toJSON SubnetworkAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _salwdiValue,
                  ("key" .=) <$> _salwdiKey])

--
-- /See:/ 'interconnectDiagnosticsLinkStatus' smart constructor.
data InterconnectDiagnosticsLinkStatus =
  InterconnectDiagnosticsLinkStatus'
    { _idlsLacpStatus :: !(Maybe InterconnectDiagnosticsLinkLACPStatus)
    , _idlsReceivingOpticalPower :: !(Maybe InterconnectDiagnosticsLinkOpticalPower)
    , _idlsGoogleDemarc :: !(Maybe Text)
    , _idlsCircuitId :: !(Maybe Text)
    , _idlsArpCaches :: !(Maybe [InterconnectDiagnosticsARPEntry])
    , _idlsTransmittingOpticalPower :: !(Maybe InterconnectDiagnosticsLinkOpticalPower)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectDiagnosticsLinkStatus' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'idlsLacpStatus'
--
-- * 'idlsReceivingOpticalPower'
--
-- * 'idlsGoogleDemarc'
--
-- * 'idlsCircuitId'
--
-- * 'idlsArpCaches'
--
-- * 'idlsTransmittingOpticalPower'
interconnectDiagnosticsLinkStatus
    :: InterconnectDiagnosticsLinkStatus
interconnectDiagnosticsLinkStatus =
  InterconnectDiagnosticsLinkStatus'
    { _idlsLacpStatus = Nothing
    , _idlsReceivingOpticalPower = Nothing
    , _idlsGoogleDemarc = Nothing
    , _idlsCircuitId = Nothing
    , _idlsArpCaches = Nothing
    , _idlsTransmittingOpticalPower = Nothing
    }


idlsLacpStatus :: Lens' InterconnectDiagnosticsLinkStatus (Maybe InterconnectDiagnosticsLinkLACPStatus)
idlsLacpStatus
  = lens _idlsLacpStatus
      (\ s a -> s{_idlsLacpStatus = a})

-- | An InterconnectDiagnostics.LinkOpticalPower object, describing the
-- current value and status of the received light level.
idlsReceivingOpticalPower :: Lens' InterconnectDiagnosticsLinkStatus (Maybe InterconnectDiagnosticsLinkOpticalPower)
idlsReceivingOpticalPower
  = lens _idlsReceivingOpticalPower
      (\ s a -> s{_idlsReceivingOpticalPower = a})

-- | The Demarc address assigned by Google and provided in the LoA.
idlsGoogleDemarc :: Lens' InterconnectDiagnosticsLinkStatus (Maybe Text)
idlsGoogleDemarc
  = lens _idlsGoogleDemarc
      (\ s a -> s{_idlsGoogleDemarc = a})

-- | The unique ID for this link assigned during turn up by Google.
idlsCircuitId :: Lens' InterconnectDiagnosticsLinkStatus (Maybe Text)
idlsCircuitId
  = lens _idlsCircuitId
      (\ s a -> s{_idlsCircuitId = a})

-- | A list of InterconnectDiagnostics.ARPEntry objects, describing the ARP
-- neighbor entries seen on this link. This will be empty if the link is
-- bundled
idlsArpCaches :: Lens' InterconnectDiagnosticsLinkStatus [InterconnectDiagnosticsARPEntry]
idlsArpCaches
  = lens _idlsArpCaches
      (\ s a -> s{_idlsArpCaches = a})
      . _Default
      . _Coerce

-- | An InterconnectDiagnostics.LinkOpticalPower object, describing the
-- current value and status of the transmitted light level.
idlsTransmittingOpticalPower :: Lens' InterconnectDiagnosticsLinkStatus (Maybe InterconnectDiagnosticsLinkOpticalPower)
idlsTransmittingOpticalPower
  = lens _idlsTransmittingOpticalPower
      (\ s a -> s{_idlsTransmittingOpticalPower = a})

instance FromJSON InterconnectDiagnosticsLinkStatus
         where
        parseJSON
          = withObject "InterconnectDiagnosticsLinkStatus"
              (\ o ->
                 InterconnectDiagnosticsLinkStatus' <$>
                   (o .:? "lacpStatus") <*>
                     (o .:? "receivingOpticalPower")
                     <*> (o .:? "googleDemarc")
                     <*> (o .:? "circuitId")
                     <*> (o .:? "arpCaches" .!= mempty)
                     <*> (o .:? "transmittingOpticalPower"))

instance ToJSON InterconnectDiagnosticsLinkStatus
         where
        toJSON InterconnectDiagnosticsLinkStatus'{..}
          = object
              (catMaybes
                 [("lacpStatus" .=) <$> _idlsLacpStatus,
                  ("receivingOpticalPower" .=) <$>
                    _idlsReceivingOpticalPower,
                  ("googleDemarc" .=) <$> _idlsGoogleDemarc,
                  ("circuitId" .=) <$> _idlsCircuitId,
                  ("arpCaches" .=) <$> _idlsArpCaches,
                  ("transmittingOpticalPower" .=) <$>
                    _idlsTransmittingOpticalPower])

--
-- /See:/ 'backendServiceReference' smart constructor.
newtype BackendServiceReference =
  BackendServiceReference'
    { _bsrBackendService :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendServiceReference' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bsrBackendService'
backendServiceReference
    :: BackendServiceReference
backendServiceReference =
  BackendServiceReference' {_bsrBackendService = Nothing}


bsrBackendService :: Lens' BackendServiceReference (Maybe Text)
bsrBackendService
  = lens _bsrBackendService
      (\ s a -> s{_bsrBackendService = a})

instance FromJSON BackendServiceReference where
        parseJSON
          = withObject "BackendServiceReference"
              (\ o ->
                 BackendServiceReference' <$>
                   (o .:? "backendService"))

instance ToJSON BackendServiceReference where
        toJSON BackendServiceReference'{..}
          = object
              (catMaybes
                 [("backendService" .=) <$> _bsrBackendService])

--
-- /See:/ 'networkEndpointGroupAggregatedListWarningDataItem' smart constructor.
data NetworkEndpointGroupAggregatedListWarningDataItem =
  NetworkEndpointGroupAggregatedListWarningDataItem'
    { _negalwdiValue :: !(Maybe Text)
    , _negalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkEndpointGroupAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'negalwdiValue'
--
-- * 'negalwdiKey'
networkEndpointGroupAggregatedListWarningDataItem
    :: NetworkEndpointGroupAggregatedListWarningDataItem
networkEndpointGroupAggregatedListWarningDataItem =
  NetworkEndpointGroupAggregatedListWarningDataItem'
    {_negalwdiValue = Nothing, _negalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
negalwdiValue :: Lens' NetworkEndpointGroupAggregatedListWarningDataItem (Maybe Text)
negalwdiValue
  = lens _negalwdiValue
      (\ s a -> s{_negalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
negalwdiKey :: Lens' NetworkEndpointGroupAggregatedListWarningDataItem (Maybe Text)
negalwdiKey
  = lens _negalwdiKey (\ s a -> s{_negalwdiKey = a})

instance FromJSON
           NetworkEndpointGroupAggregatedListWarningDataItem
         where
        parseJSON
          = withObject
              "NetworkEndpointGroupAggregatedListWarningDataItem"
              (\ o ->
                 NetworkEndpointGroupAggregatedListWarningDataItem'
                   <$> (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           NetworkEndpointGroupAggregatedListWarningDataItem
         where
        toJSON
          NetworkEndpointGroupAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _negalwdiValue,
                  ("key" .=) <$> _negalwdiKey])

-- | Contains a list of TargetInstance resources.
--
-- /See:/ 'targetInstanceList' smart constructor.
data TargetInstanceList =
  TargetInstanceList'
    { _tilNextPageToken :: !(Maybe Text)
    , _tilKind :: !Text
    , _tilItems :: !(Maybe [TargetInstance])
    , _tilSelfLink :: !(Maybe Text)
    , _tilWarning :: !(Maybe TargetInstanceListWarning)
    , _tilId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetInstanceList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tilNextPageToken'
--
-- * 'tilKind'
--
-- * 'tilItems'
--
-- * 'tilSelfLink'
--
-- * 'tilWarning'
--
-- * 'tilId'
targetInstanceList
    :: TargetInstanceList
targetInstanceList =
  TargetInstanceList'
    { _tilNextPageToken = Nothing
    , _tilKind = "compute#targetInstanceList"
    , _tilItems = Nothing
    , _tilSelfLink = Nothing
    , _tilWarning = Nothing
    , _tilId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
tilNextPageToken :: Lens' TargetInstanceList (Maybe Text)
tilNextPageToken
  = lens _tilNextPageToken
      (\ s a -> s{_tilNextPageToken = a})

-- | Type of resource.
tilKind :: Lens' TargetInstanceList Text
tilKind = lens _tilKind (\ s a -> s{_tilKind = a})

-- | A list of TargetInstance resources.
tilItems :: Lens' TargetInstanceList [TargetInstance]
tilItems
  = lens _tilItems (\ s a -> s{_tilItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
tilSelfLink :: Lens' TargetInstanceList (Maybe Text)
tilSelfLink
  = lens _tilSelfLink (\ s a -> s{_tilSelfLink = a})

-- | [Output Only] Informational warning message.
tilWarning :: Lens' TargetInstanceList (Maybe TargetInstanceListWarning)
tilWarning
  = lens _tilWarning (\ s a -> s{_tilWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
tilId :: Lens' TargetInstanceList (Maybe Text)
tilId = lens _tilId (\ s a -> s{_tilId = a})

instance FromJSON TargetInstanceList where
        parseJSON
          = withObject "TargetInstanceList"
              (\ o ->
                 TargetInstanceList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#targetInstanceList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON TargetInstanceList where
        toJSON TargetInstanceList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _tilNextPageToken,
                  Just ("kind" .= _tilKind),
                  ("items" .=) <$> _tilItems,
                  ("selfLink" .=) <$> _tilSelfLink,
                  ("warning" .=) <$> _tilWarning,
                  ("id" .=) <$> _tilId])

-- | A PublicDelegatedPrefix resource represents an IP block within a
-- PublicAdvertisedPrefix that is configured within a single cloud scope
-- (global or region). IPs in the block can be allocated to resources
-- within that scope. Public delegated prefixes may be further broken up
-- into smaller IP blocks in the same scope as the parent block.
--
-- /See:/ 'publicDelegatedPrefix' smart constructor.
data PublicDelegatedPrefix =
  PublicDelegatedPrefix'
    { _pdpParentPrefix :: !(Maybe Text)
    , _pdpStatus :: !(Maybe PublicDelegatedPrefixStatus)
    , _pdpKind :: !Text
    , _pdpFingerprint :: !(Maybe Bytes)
    , _pdpSelfLink :: !(Maybe Text)
    , _pdpName :: !(Maybe Text)
    , _pdpCreationTimestamp :: !(Maybe Text)
    , _pdpIPCIdRRange :: !(Maybe Text)
    , _pdpPublicDelegatedSubPrefixs :: !(Maybe [PublicDelegatedPrefixPublicDelegatedSubPrefix])
    , _pdpId :: !(Maybe (Textual Word64))
    , _pdpRegion :: !(Maybe Text)
    , _pdpIsLiveMigration :: !(Maybe Bool)
    , _pdpDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PublicDelegatedPrefix' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pdpParentPrefix'
--
-- * 'pdpStatus'
--
-- * 'pdpKind'
--
-- * 'pdpFingerprint'
--
-- * 'pdpSelfLink'
--
-- * 'pdpName'
--
-- * 'pdpCreationTimestamp'
--
-- * 'pdpIPCIdRRange'
--
-- * 'pdpPublicDelegatedSubPrefixs'
--
-- * 'pdpId'
--
-- * 'pdpRegion'
--
-- * 'pdpIsLiveMigration'
--
-- * 'pdpDescription'
publicDelegatedPrefix
    :: PublicDelegatedPrefix
publicDelegatedPrefix =
  PublicDelegatedPrefix'
    { _pdpParentPrefix = Nothing
    , _pdpStatus = Nothing
    , _pdpKind = "compute#publicDelegatedPrefix"
    , _pdpFingerprint = Nothing
    , _pdpSelfLink = Nothing
    , _pdpName = Nothing
    , _pdpCreationTimestamp = Nothing
    , _pdpIPCIdRRange = Nothing
    , _pdpPublicDelegatedSubPrefixs = Nothing
    , _pdpId = Nothing
    , _pdpRegion = Nothing
    , _pdpIsLiveMigration = Nothing
    , _pdpDescription = Nothing
    }


-- | The URL of parent prefix. Either PublicAdvertisedPrefix or
-- PublicDelegatedPrefix.
pdpParentPrefix :: Lens' PublicDelegatedPrefix (Maybe Text)
pdpParentPrefix
  = lens _pdpParentPrefix
      (\ s a -> s{_pdpParentPrefix = a})

-- | [Output Only] The status of the public delegated prefix.
pdpStatus :: Lens' PublicDelegatedPrefix (Maybe PublicDelegatedPrefixStatus)
pdpStatus
  = lens _pdpStatus (\ s a -> s{_pdpStatus = a})

-- | [Output Only] Type of the resource. Always compute#publicDelegatedPrefix
-- for public delegated prefixes.
pdpKind :: Lens' PublicDelegatedPrefix Text
pdpKind = lens _pdpKind (\ s a -> s{_pdpKind = a})

-- | Fingerprint of this resource. A hash of the contents stored in this
-- object. This field is used in optimistic locking. This field will be
-- ignored when inserting a new PublicDelegatedPrefix. An up-to-date
-- fingerprint must be provided in order to update the
-- PublicDelegatedPrefix, otherwise the request will fail with error 412
-- conditionNotMet. To see the latest fingerprint, make a get() request to
-- retrieve a PublicDelegatedPrefix.
pdpFingerprint :: Lens' PublicDelegatedPrefix (Maybe ByteString)
pdpFingerprint
  = lens _pdpFingerprint
      (\ s a -> s{_pdpFingerprint = a})
      . mapping _Bytes

-- | [Output Only] Server-defined URL for the resource.
pdpSelfLink :: Lens' PublicDelegatedPrefix (Maybe Text)
pdpSelfLink
  = lens _pdpSelfLink (\ s a -> s{_pdpSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
pdpName :: Lens' PublicDelegatedPrefix (Maybe Text)
pdpName = lens _pdpName (\ s a -> s{_pdpName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
pdpCreationTimestamp :: Lens' PublicDelegatedPrefix (Maybe Text)
pdpCreationTimestamp
  = lens _pdpCreationTimestamp
      (\ s a -> s{_pdpCreationTimestamp = a})

-- | The IPv4 address range, in CIDR format, represented by this public
-- delegated prefix.
pdpIPCIdRRange :: Lens' PublicDelegatedPrefix (Maybe Text)
pdpIPCIdRRange
  = lens _pdpIPCIdRRange
      (\ s a -> s{_pdpIPCIdRRange = a})

-- | The list of sub public delegated prefixes that exist for this public
-- delegated prefix.
pdpPublicDelegatedSubPrefixs :: Lens' PublicDelegatedPrefix [PublicDelegatedPrefixPublicDelegatedSubPrefix]
pdpPublicDelegatedSubPrefixs
  = lens _pdpPublicDelegatedSubPrefixs
      (\ s a -> s{_pdpPublicDelegatedSubPrefixs = a})
      . _Default
      . _Coerce

-- | [Output Only] The unique identifier for the resource type. The server
-- generates this identifier.
pdpId :: Lens' PublicDelegatedPrefix (Maybe Word64)
pdpId
  = lens _pdpId (\ s a -> s{_pdpId = a}) .
      mapping _Coerce

-- | [Output Only] URL of the region where the public delegated prefix
-- resides. This field applies only to the region resource. You must
-- specify this field as part of the HTTP request URL. It is not settable
-- as a field in the request body.
pdpRegion :: Lens' PublicDelegatedPrefix (Maybe Text)
pdpRegion
  = lens _pdpRegion (\ s a -> s{_pdpRegion = a})

-- | If true, the prefix will be live migrated.
pdpIsLiveMigration :: Lens' PublicDelegatedPrefix (Maybe Bool)
pdpIsLiveMigration
  = lens _pdpIsLiveMigration
      (\ s a -> s{_pdpIsLiveMigration = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource.
pdpDescription :: Lens' PublicDelegatedPrefix (Maybe Text)
pdpDescription
  = lens _pdpDescription
      (\ s a -> s{_pdpDescription = a})

instance FromJSON PublicDelegatedPrefix where
        parseJSON
          = withObject "PublicDelegatedPrefix"
              (\ o ->
                 PublicDelegatedPrefix' <$>
                   (o .:? "parentPrefix") <*> (o .:? "status") <*>
                     (o .:? "kind" .!= "compute#publicDelegatedPrefix")
                     <*> (o .:? "fingerprint")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "ipCidrRange")
                     <*> (o .:? "publicDelegatedSubPrefixs" .!= mempty)
                     <*> (o .:? "id")
                     <*> (o .:? "region")
                     <*> (o .:? "isLiveMigration")
                     <*> (o .:? "description"))

instance ToJSON PublicDelegatedPrefix where
        toJSON PublicDelegatedPrefix'{..}
          = object
              (catMaybes
                 [("parentPrefix" .=) <$> _pdpParentPrefix,
                  ("status" .=) <$> _pdpStatus,
                  Just ("kind" .= _pdpKind),
                  ("fingerprint" .=) <$> _pdpFingerprint,
                  ("selfLink" .=) <$> _pdpSelfLink,
                  ("name" .=) <$> _pdpName,
                  ("creationTimestamp" .=) <$> _pdpCreationTimestamp,
                  ("ipCidrRange" .=) <$> _pdpIPCIdRRange,
                  ("publicDelegatedSubPrefixs" .=) <$>
                    _pdpPublicDelegatedSubPrefixs,
                  ("id" .=) <$> _pdpId, ("region" .=) <$> _pdpRegion,
                  ("isLiveMigration" .=) <$> _pdpIsLiveMigration,
                  ("description" .=) <$> _pdpDescription])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'targetTCPProxyListWarning' smart constructor.
data TargetTCPProxyListWarning =
  TargetTCPProxyListWarning'
    { _ttplwData :: !(Maybe [TargetTCPProxyListWarningDataItem])
    , _ttplwCode :: !(Maybe TargetTCPProxyListWarningCode)
    , _ttplwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetTCPProxyListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ttplwData'
--
-- * 'ttplwCode'
--
-- * 'ttplwMessage'
targetTCPProxyListWarning
    :: TargetTCPProxyListWarning
targetTCPProxyListWarning =
  TargetTCPProxyListWarning'
    {_ttplwData = Nothing, _ttplwCode = Nothing, _ttplwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
ttplwData :: Lens' TargetTCPProxyListWarning [TargetTCPProxyListWarningDataItem]
ttplwData
  = lens _ttplwData (\ s a -> s{_ttplwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
ttplwCode :: Lens' TargetTCPProxyListWarning (Maybe TargetTCPProxyListWarningCode)
ttplwCode
  = lens _ttplwCode (\ s a -> s{_ttplwCode = a})

-- | [Output Only] A human-readable description of the warning code.
ttplwMessage :: Lens' TargetTCPProxyListWarning (Maybe Text)
ttplwMessage
  = lens _ttplwMessage (\ s a -> s{_ttplwMessage = a})

instance FromJSON TargetTCPProxyListWarning where
        parseJSON
          = withObject "TargetTCPProxyListWarning"
              (\ o ->
                 TargetTCPProxyListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON TargetTCPProxyListWarning where
        toJSON TargetTCPProxyListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _ttplwData,
                  ("code" .=) <$> _ttplwCode,
                  ("message" .=) <$> _ttplwMessage])

--
-- /See:/ 'instanceGroupManagerAggregatedList' smart constructor.
data InstanceGroupManagerAggregatedList =
  InstanceGroupManagerAggregatedList'
    { _igmalUnreachables :: !(Maybe [Text])
    , _igmalNextPageToken :: !(Maybe Text)
    , _igmalKind :: !Text
    , _igmalItems :: !(Maybe InstanceGroupManagerAggregatedListItems)
    , _igmalSelfLink :: !(Maybe Text)
    , _igmalWarning :: !(Maybe InstanceGroupManagerAggregatedListWarning)
    , _igmalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagerAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmalUnreachables'
--
-- * 'igmalNextPageToken'
--
-- * 'igmalKind'
--
-- * 'igmalItems'
--
-- * 'igmalSelfLink'
--
-- * 'igmalWarning'
--
-- * 'igmalId'
instanceGroupManagerAggregatedList
    :: InstanceGroupManagerAggregatedList
instanceGroupManagerAggregatedList =
  InstanceGroupManagerAggregatedList'
    { _igmalUnreachables = Nothing
    , _igmalNextPageToken = Nothing
    , _igmalKind = "compute#instanceGroupManagerAggregatedList"
    , _igmalItems = Nothing
    , _igmalSelfLink = Nothing
    , _igmalWarning = Nothing
    , _igmalId = Nothing
    }


-- | [Output Only] Unreachable resources.
igmalUnreachables :: Lens' InstanceGroupManagerAggregatedList [Text]
igmalUnreachables
  = lens _igmalUnreachables
      (\ s a -> s{_igmalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
igmalNextPageToken :: Lens' InstanceGroupManagerAggregatedList (Maybe Text)
igmalNextPageToken
  = lens _igmalNextPageToken
      (\ s a -> s{_igmalNextPageToken = a})

-- | [Output Only] The resource type, which is always
-- compute#instanceGroupManagerAggregatedList for an aggregated list of
-- managed instance groups.
igmalKind :: Lens' InstanceGroupManagerAggregatedList Text
igmalKind
  = lens _igmalKind (\ s a -> s{_igmalKind = a})

-- | A list of InstanceGroupManagersScopedList resources.
igmalItems :: Lens' InstanceGroupManagerAggregatedList (Maybe InstanceGroupManagerAggregatedListItems)
igmalItems
  = lens _igmalItems (\ s a -> s{_igmalItems = a})

-- | [Output Only] Server-defined URL for this resource.
igmalSelfLink :: Lens' InstanceGroupManagerAggregatedList (Maybe Text)
igmalSelfLink
  = lens _igmalSelfLink
      (\ s a -> s{_igmalSelfLink = a})

-- | [Output Only] Informational warning message.
igmalWarning :: Lens' InstanceGroupManagerAggregatedList (Maybe InstanceGroupManagerAggregatedListWarning)
igmalWarning
  = lens _igmalWarning (\ s a -> s{_igmalWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
igmalId :: Lens' InstanceGroupManagerAggregatedList (Maybe Text)
igmalId = lens _igmalId (\ s a -> s{_igmalId = a})

instance FromJSON InstanceGroupManagerAggregatedList
         where
        parseJSON
          = withObject "InstanceGroupManagerAggregatedList"
              (\ o ->
                 InstanceGroupManagerAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!=
                        "compute#instanceGroupManagerAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON InstanceGroupManagerAggregatedList
         where
        toJSON InstanceGroupManagerAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _igmalUnreachables,
                  ("nextPageToken" .=) <$> _igmalNextPageToken,
                  Just ("kind" .= _igmalKind),
                  ("items" .=) <$> _igmalItems,
                  ("selfLink" .=) <$> _igmalSelfLink,
                  ("warning" .=) <$> _igmalWarning,
                  ("id" .=) <$> _igmalId])

-- | Represents a Cloud Storage Bucket resource. This Cloud Storage bucket
-- resource is referenced by a URL map of a load balancer. For more
-- information, read Backend Buckets.
--
-- /See:/ 'backendBucket' smart constructor.
data BackendBucket =
  BackendBucket'
    { _bbKind :: !Text
    , _bbEnableCdn :: !(Maybe Bool)
    , _bbBucketName :: !(Maybe Text)
    , _bbCdnPolicy :: !(Maybe BackendBucketCdnPolicy)
    , _bbCustomResponseHeaders :: !(Maybe [Text])
    , _bbSelfLink :: !(Maybe Text)
    , _bbName :: !(Maybe Text)
    , _bbCreationTimestamp :: !(Maybe Text)
    , _bbId :: !(Maybe (Textual Word64))
    , _bbDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendBucket' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bbKind'
--
-- * 'bbEnableCdn'
--
-- * 'bbBucketName'
--
-- * 'bbCdnPolicy'
--
-- * 'bbCustomResponseHeaders'
--
-- * 'bbSelfLink'
--
-- * 'bbName'
--
-- * 'bbCreationTimestamp'
--
-- * 'bbId'
--
-- * 'bbDescription'
backendBucket
    :: BackendBucket
backendBucket =
  BackendBucket'
    { _bbKind = "compute#backendBucket"
    , _bbEnableCdn = Nothing
    , _bbBucketName = Nothing
    , _bbCdnPolicy = Nothing
    , _bbCustomResponseHeaders = Nothing
    , _bbSelfLink = Nothing
    , _bbName = Nothing
    , _bbCreationTimestamp = Nothing
    , _bbId = Nothing
    , _bbDescription = Nothing
    }


-- | Type of the resource.
bbKind :: Lens' BackendBucket Text
bbKind = lens _bbKind (\ s a -> s{_bbKind = a})

-- | If true, enable Cloud CDN for this BackendBucket.
bbEnableCdn :: Lens' BackendBucket (Maybe Bool)
bbEnableCdn
  = lens _bbEnableCdn (\ s a -> s{_bbEnableCdn = a})

-- | Cloud Storage bucket name.
bbBucketName :: Lens' BackendBucket (Maybe Text)
bbBucketName
  = lens _bbBucketName (\ s a -> s{_bbBucketName = a})

-- | Cloud CDN configuration for this BackendBucket.
bbCdnPolicy :: Lens' BackendBucket (Maybe BackendBucketCdnPolicy)
bbCdnPolicy
  = lens _bbCdnPolicy (\ s a -> s{_bbCdnPolicy = a})

-- | Headers that the HTTP\/S load balancer should add to proxied responses.
bbCustomResponseHeaders :: Lens' BackendBucket [Text]
bbCustomResponseHeaders
  = lens _bbCustomResponseHeaders
      (\ s a -> s{_bbCustomResponseHeaders = a})
      . _Default
      . _Coerce

-- | [Output Only] Server-defined URL for the resource.
bbSelfLink :: Lens' BackendBucket (Maybe Text)
bbSelfLink
  = lens _bbSelfLink (\ s a -> s{_bbSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
bbName :: Lens' BackendBucket (Maybe Text)
bbName = lens _bbName (\ s a -> s{_bbName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
bbCreationTimestamp :: Lens' BackendBucket (Maybe Text)
bbCreationTimestamp
  = lens _bbCreationTimestamp
      (\ s a -> s{_bbCreationTimestamp = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
bbId :: Lens' BackendBucket (Maybe Word64)
bbId
  = lens _bbId (\ s a -> s{_bbId = a}) .
      mapping _Coerce

-- | An optional textual description of the resource; provided by the client
-- when the resource is created.
bbDescription :: Lens' BackendBucket (Maybe Text)
bbDescription
  = lens _bbDescription
      (\ s a -> s{_bbDescription = a})

instance FromJSON BackendBucket where
        parseJSON
          = withObject "BackendBucket"
              (\ o ->
                 BackendBucket' <$>
                   (o .:? "kind" .!= "compute#backendBucket") <*>
                     (o .:? "enableCdn")
                     <*> (o .:? "bucketName")
                     <*> (o .:? "cdnPolicy")
                     <*> (o .:? "customResponseHeaders" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "description"))

instance ToJSON BackendBucket where
        toJSON BackendBucket'{..}
          = object
              (catMaybes
                 [Just ("kind" .= _bbKind),
                  ("enableCdn" .=) <$> _bbEnableCdn,
                  ("bucketName" .=) <$> _bbBucketName,
                  ("cdnPolicy" .=) <$> _bbCdnPolicy,
                  ("customResponseHeaders" .=) <$>
                    _bbCustomResponseHeaders,
                  ("selfLink" .=) <$> _bbSelfLink,
                  ("name" .=) <$> _bbName,
                  ("creationTimestamp" .=) <$> _bbCreationTimestamp,
                  ("id" .=) <$> _bbId,
                  ("description" .=) <$> _bbDescription])

-- | [Output Only] Informational warning which replaces the list of public
-- delegated prefixes when the list is empty.
--
-- /See:/ 'publicDelegatedPrefixesScopedListWarning' smart constructor.
data PublicDelegatedPrefixesScopedListWarning =
  PublicDelegatedPrefixesScopedListWarning'
    { _pdpslwData :: !(Maybe [PublicDelegatedPrefixesScopedListWarningDataItem])
    , _pdpslwCode :: !(Maybe PublicDelegatedPrefixesScopedListWarningCode)
    , _pdpslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PublicDelegatedPrefixesScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pdpslwData'
--
-- * 'pdpslwCode'
--
-- * 'pdpslwMessage'
publicDelegatedPrefixesScopedListWarning
    :: PublicDelegatedPrefixesScopedListWarning
publicDelegatedPrefixesScopedListWarning =
  PublicDelegatedPrefixesScopedListWarning'
    {_pdpslwData = Nothing, _pdpslwCode = Nothing, _pdpslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
pdpslwData :: Lens' PublicDelegatedPrefixesScopedListWarning [PublicDelegatedPrefixesScopedListWarningDataItem]
pdpslwData
  = lens _pdpslwData (\ s a -> s{_pdpslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
pdpslwCode :: Lens' PublicDelegatedPrefixesScopedListWarning (Maybe PublicDelegatedPrefixesScopedListWarningCode)
pdpslwCode
  = lens _pdpslwCode (\ s a -> s{_pdpslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
pdpslwMessage :: Lens' PublicDelegatedPrefixesScopedListWarning (Maybe Text)
pdpslwMessage
  = lens _pdpslwMessage
      (\ s a -> s{_pdpslwMessage = a})

instance FromJSON
           PublicDelegatedPrefixesScopedListWarning
         where
        parseJSON
          = withObject
              "PublicDelegatedPrefixesScopedListWarning"
              (\ o ->
                 PublicDelegatedPrefixesScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON
           PublicDelegatedPrefixesScopedListWarning
         where
        toJSON PublicDelegatedPrefixesScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _pdpslwData,
                  ("code" .=) <$> _pdpslwCode,
                  ("message" .=) <$> _pdpslwMessage])

--
-- /See:/ 'projectsEnableXpnResourceRequest' smart constructor.
newtype ProjectsEnableXpnResourceRequest =
  ProjectsEnableXpnResourceRequest'
    { _pexrrXpnResource :: Maybe XpnResourceId
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ProjectsEnableXpnResourceRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pexrrXpnResource'
projectsEnableXpnResourceRequest
    :: ProjectsEnableXpnResourceRequest
projectsEnableXpnResourceRequest =
  ProjectsEnableXpnResourceRequest' {_pexrrXpnResource = Nothing}


-- | Service resource (a.k.a service project) ID.
pexrrXpnResource :: Lens' ProjectsEnableXpnResourceRequest (Maybe XpnResourceId)
pexrrXpnResource
  = lens _pexrrXpnResource
      (\ s a -> s{_pexrrXpnResource = a})

instance FromJSON ProjectsEnableXpnResourceRequest
         where
        parseJSON
          = withObject "ProjectsEnableXpnResourceRequest"
              (\ o ->
                 ProjectsEnableXpnResourceRequest' <$>
                   (o .:? "xpnResource"))

instance ToJSON ProjectsEnableXpnResourceRequest
         where
        toJSON ProjectsEnableXpnResourceRequest'{..}
          = object
              (catMaybes
                 [("xpnResource" .=) <$> _pexrrXpnResource])

-- | A public advertised prefix represents an aggregated IP prefix or
-- netblock which customers bring to cloud. The IP prefix is a single unit
-- of route advertisement and is announced globally to the internet.
--
-- /See:/ 'publicAdvertisedPrefix' smart constructor.
data PublicAdvertisedPrefix =
  PublicAdvertisedPrefix'
    { _papStatus :: !(Maybe PublicAdvertisedPrefixStatus)
    , _papKind :: !Text
    , _papFingerprint :: !(Maybe Bytes)
    , _papDNSVerificationIP :: !(Maybe Text)
    , _papSelfLink :: !(Maybe Text)
    , _papSharedSecret :: !(Maybe Text)
    , _papName :: !(Maybe Text)
    , _papCreationTimestamp :: !(Maybe Text)
    , _papIPCIdRRange :: !(Maybe Text)
    , _papId :: !(Maybe (Textual Word64))
    , _papDescription :: !(Maybe Text)
    , _papPublicDelegatedPrefixs :: !(Maybe [PublicAdvertisedPrefixPublicDelegatedPrefix])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PublicAdvertisedPrefix' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'papStatus'
--
-- * 'papKind'
--
-- * 'papFingerprint'
--
-- * 'papDNSVerificationIP'
--
-- * 'papSelfLink'
--
-- * 'papSharedSecret'
--
-- * 'papName'
--
-- * 'papCreationTimestamp'
--
-- * 'papIPCIdRRange'
--
-- * 'papId'
--
-- * 'papDescription'
--
-- * 'papPublicDelegatedPrefixs'
publicAdvertisedPrefix
    :: PublicAdvertisedPrefix
publicAdvertisedPrefix =
  PublicAdvertisedPrefix'
    { _papStatus = Nothing
    , _papKind = "compute#publicAdvertisedPrefix"
    , _papFingerprint = Nothing
    , _papDNSVerificationIP = Nothing
    , _papSelfLink = Nothing
    , _papSharedSecret = Nothing
    , _papName = Nothing
    , _papCreationTimestamp = Nothing
    , _papIPCIdRRange = Nothing
    , _papId = Nothing
    , _papDescription = Nothing
    , _papPublicDelegatedPrefixs = Nothing
    }


-- | The status of the public advertised prefix.
papStatus :: Lens' PublicAdvertisedPrefix (Maybe PublicAdvertisedPrefixStatus)
papStatus
  = lens _papStatus (\ s a -> s{_papStatus = a})

-- | [Output Only] Type of the resource. Always
-- compute#publicAdvertisedPrefix for public advertised prefixes.
papKind :: Lens' PublicAdvertisedPrefix Text
papKind = lens _papKind (\ s a -> s{_papKind = a})

-- | Fingerprint of this resource. A hash of the contents stored in this
-- object. This field is used in optimistic locking. This field will be
-- ignored when inserting a new PublicAdvertisedPrefix. An up-to-date
-- fingerprint must be provided in order to update the
-- PublicAdvertisedPrefix, otherwise the request will fail with error 412
-- conditionNotMet. To see the latest fingerprint, make a get() request to
-- retrieve a PublicAdvertisedPrefix.
papFingerprint :: Lens' PublicAdvertisedPrefix (Maybe ByteString)
papFingerprint
  = lens _papFingerprint
      (\ s a -> s{_papFingerprint = a})
      . mapping _Bytes

-- | The IPv4 address to be used for reverse DNS verification.
papDNSVerificationIP :: Lens' PublicAdvertisedPrefix (Maybe Text)
papDNSVerificationIP
  = lens _papDNSVerificationIP
      (\ s a -> s{_papDNSVerificationIP = a})

-- | [Output Only] Server-defined URL for the resource.
papSelfLink :: Lens' PublicAdvertisedPrefix (Maybe Text)
papSelfLink
  = lens _papSelfLink (\ s a -> s{_papSelfLink = a})

-- | [Output Only] The shared secret to be used for reverse DNS verification.
papSharedSecret :: Lens' PublicAdvertisedPrefix (Maybe Text)
papSharedSecret
  = lens _papSharedSecret
      (\ s a -> s{_papSharedSecret = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
papName :: Lens' PublicAdvertisedPrefix (Maybe Text)
papName = lens _papName (\ s a -> s{_papName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
papCreationTimestamp :: Lens' PublicAdvertisedPrefix (Maybe Text)
papCreationTimestamp
  = lens _papCreationTimestamp
      (\ s a -> s{_papCreationTimestamp = a})

-- | The IPv4 address range, in CIDR format, represented by this public
-- advertised prefix.
papIPCIdRRange :: Lens' PublicAdvertisedPrefix (Maybe Text)
papIPCIdRRange
  = lens _papIPCIdRRange
      (\ s a -> s{_papIPCIdRRange = a})

-- | [Output Only] The unique identifier for the resource type. The server
-- generates this identifier.
papId :: Lens' PublicAdvertisedPrefix (Maybe Word64)
papId
  = lens _papId (\ s a -> s{_papId = a}) .
      mapping _Coerce

-- | An optional description of this resource. Provide this property when you
-- create the resource.
papDescription :: Lens' PublicAdvertisedPrefix (Maybe Text)
papDescription
  = lens _papDescription
      (\ s a -> s{_papDescription = a})

-- | [Output Only] The list of public delegated prefixes that exist for this
-- public advertised prefix.
papPublicDelegatedPrefixs :: Lens' PublicAdvertisedPrefix [PublicAdvertisedPrefixPublicDelegatedPrefix]
papPublicDelegatedPrefixs
  = lens _papPublicDelegatedPrefixs
      (\ s a -> s{_papPublicDelegatedPrefixs = a})
      . _Default
      . _Coerce

instance FromJSON PublicAdvertisedPrefix where
        parseJSON
          = withObject "PublicAdvertisedPrefix"
              (\ o ->
                 PublicAdvertisedPrefix' <$>
                   (o .:? "status") <*>
                     (o .:? "kind" .!= "compute#publicAdvertisedPrefix")
                     <*> (o .:? "fingerprint")
                     <*> (o .:? "dnsVerificationIp")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "sharedSecret")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "ipCidrRange")
                     <*> (o .:? "id")
                     <*> (o .:? "description")
                     <*> (o .:? "publicDelegatedPrefixs" .!= mempty))

instance ToJSON PublicAdvertisedPrefix where
        toJSON PublicAdvertisedPrefix'{..}
          = object
              (catMaybes
                 [("status" .=) <$> _papStatus,
                  Just ("kind" .= _papKind),
                  ("fingerprint" .=) <$> _papFingerprint,
                  ("dnsVerificationIp" .=) <$> _papDNSVerificationIP,
                  ("selfLink" .=) <$> _papSelfLink,
                  ("sharedSecret" .=) <$> _papSharedSecret,
                  ("name" .=) <$> _papName,
                  ("creationTimestamp" .=) <$> _papCreationTimestamp,
                  ("ipCidrRange" .=) <$> _papIPCIdRRange,
                  ("id" .=) <$> _papId,
                  ("description" .=) <$> _papDescription,
                  ("publicDelegatedPrefixs" .=) <$>
                    _papPublicDelegatedPrefixs])

-- | Specify CDN TTLs for response error codes.
--
-- /See:/ 'backendServiceCdnPolicyNegativeCachingPolicy' smart constructor.
data BackendServiceCdnPolicyNegativeCachingPolicy =
  BackendServiceCdnPolicyNegativeCachingPolicy'
    { _bscpncpTtl :: !(Maybe (Textual Int32))
    , _bscpncpCode :: !(Maybe (Textual Int32))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendServiceCdnPolicyNegativeCachingPolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bscpncpTtl'
--
-- * 'bscpncpCode'
backendServiceCdnPolicyNegativeCachingPolicy
    :: BackendServiceCdnPolicyNegativeCachingPolicy
backendServiceCdnPolicyNegativeCachingPolicy =
  BackendServiceCdnPolicyNegativeCachingPolicy'
    {_bscpncpTtl = Nothing, _bscpncpCode = Nothing}


-- | The TTL (in seconds) for which to cache responses with the corresponding
-- status code. The maximum allowed value is 1800s (30 minutes), noting
-- that infrequently accessed objects may be evicted from the cache before
-- the defined TTL.
bscpncpTtl :: Lens' BackendServiceCdnPolicyNegativeCachingPolicy (Maybe Int32)
bscpncpTtl
  = lens _bscpncpTtl (\ s a -> s{_bscpncpTtl = a}) .
      mapping _Coerce

-- | The HTTP status code to define a TTL against. Only HTTP status codes
-- 300, 301, 302, 307, 308, 404, 405, 410, 421, 451 and 501 are can be
-- specified as values, and you cannot specify a status code more than
-- once.
bscpncpCode :: Lens' BackendServiceCdnPolicyNegativeCachingPolicy (Maybe Int32)
bscpncpCode
  = lens _bscpncpCode (\ s a -> s{_bscpncpCode = a}) .
      mapping _Coerce

instance FromJSON
           BackendServiceCdnPolicyNegativeCachingPolicy
         where
        parseJSON
          = withObject
              "BackendServiceCdnPolicyNegativeCachingPolicy"
              (\ o ->
                 BackendServiceCdnPolicyNegativeCachingPolicy' <$>
                   (o .:? "ttl") <*> (o .:? "code"))

instance ToJSON
           BackendServiceCdnPolicyNegativeCachingPolicy
         where
        toJSON
          BackendServiceCdnPolicyNegativeCachingPolicy'{..}
          = object
              (catMaybes
                 [("ttl" .=) <$> _bscpncpTtl,
                  ("code" .=) <$> _bscpncpCode])

--
-- /See:/ 'targetPoolsScopedList' smart constructor.
data TargetPoolsScopedList =
  TargetPoolsScopedList'
    { _tpslWarning :: !(Maybe TargetPoolsScopedListWarning)
    , _tpslTargetPools :: !(Maybe [TargetPool])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetPoolsScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tpslWarning'
--
-- * 'tpslTargetPools'
targetPoolsScopedList
    :: TargetPoolsScopedList
targetPoolsScopedList =
  TargetPoolsScopedList' {_tpslWarning = Nothing, _tpslTargetPools = Nothing}


-- | Informational warning which replaces the list of addresses when the list
-- is empty.
tpslWarning :: Lens' TargetPoolsScopedList (Maybe TargetPoolsScopedListWarning)
tpslWarning
  = lens _tpslWarning (\ s a -> s{_tpslWarning = a})

-- | A list of target pools contained in this scope.
tpslTargetPools :: Lens' TargetPoolsScopedList [TargetPool]
tpslTargetPools
  = lens _tpslTargetPools
      (\ s a -> s{_tpslTargetPools = a})
      . _Default
      . _Coerce

instance FromJSON TargetPoolsScopedList where
        parseJSON
          = withObject "TargetPoolsScopedList"
              (\ o ->
                 TargetPoolsScopedList' <$>
                   (o .:? "warning") <*>
                     (o .:? "targetPools" .!= mempty))

instance ToJSON TargetPoolsScopedList where
        toJSON TargetPoolsScopedList'{..}
          = object
              (catMaybes
                 [("warning" .=) <$> _tpslWarning,
                  ("targetPools" .=) <$> _tpslTargetPools])

-- | A list of InterconnectAttachmentsScopedList resources.
--
-- /See:/ 'interconnectAttachmentAggregatedListItems' smart constructor.
newtype InterconnectAttachmentAggregatedListItems =
  InterconnectAttachmentAggregatedListItems'
    { _iaaliAddtional :: HashMap Text InterconnectAttachmentsScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectAttachmentAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iaaliAddtional'
interconnectAttachmentAggregatedListItems
    :: HashMap Text InterconnectAttachmentsScopedList -- ^ 'iaaliAddtional'
    -> InterconnectAttachmentAggregatedListItems
interconnectAttachmentAggregatedListItems pIaaliAddtional_ =
  InterconnectAttachmentAggregatedListItems'
    {_iaaliAddtional = _Coerce # pIaaliAddtional_}


-- | Name of the scope containing this set of interconnect attachments.
iaaliAddtional :: Lens' InterconnectAttachmentAggregatedListItems (HashMap Text InterconnectAttachmentsScopedList)
iaaliAddtional
  = lens _iaaliAddtional
      (\ s a -> s{_iaaliAddtional = a})
      . _Coerce

instance FromJSON
           InterconnectAttachmentAggregatedListItems
         where
        parseJSON
          = withObject
              "InterconnectAttachmentAggregatedListItems"
              (\ o ->
                 InterconnectAttachmentAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON
           InterconnectAttachmentAggregatedListItems
         where
        toJSON = toJSON . _iaaliAddtional

-- |
--
-- /See:/ 'instanceGroupManagerAutoHealingPolicy' smart constructor.
data InstanceGroupManagerAutoHealingPolicy =
  InstanceGroupManagerAutoHealingPolicy'
    { _igmahpHealthCheck :: !(Maybe Text)
    , _igmahpInitialDelaySec :: !(Maybe (Textual Int32))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagerAutoHealingPolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmahpHealthCheck'
--
-- * 'igmahpInitialDelaySec'
instanceGroupManagerAutoHealingPolicy
    :: InstanceGroupManagerAutoHealingPolicy
instanceGroupManagerAutoHealingPolicy =
  InstanceGroupManagerAutoHealingPolicy'
    {_igmahpHealthCheck = Nothing, _igmahpInitialDelaySec = Nothing}


-- | The URL for the health check that signals autohealing.
igmahpHealthCheck :: Lens' InstanceGroupManagerAutoHealingPolicy (Maybe Text)
igmahpHealthCheck
  = lens _igmahpHealthCheck
      (\ s a -> s{_igmahpHealthCheck = a})

-- | The number of seconds that the managed instance group waits before it
-- applies autohealing policies to new instances or recently recreated
-- instances. This initial delay allows instances to initialize and run
-- their startup scripts before the instance group determines that they are
-- UNHEALTHY. This prevents the managed instance group from recreating its
-- instances prematurely. This value must be from range [0, 3600].
igmahpInitialDelaySec :: Lens' InstanceGroupManagerAutoHealingPolicy (Maybe Int32)
igmahpInitialDelaySec
  = lens _igmahpInitialDelaySec
      (\ s a -> s{_igmahpInitialDelaySec = a})
      . mapping _Coerce

instance FromJSON
           InstanceGroupManagerAutoHealingPolicy
         where
        parseJSON
          = withObject "InstanceGroupManagerAutoHealingPolicy"
              (\ o ->
                 InstanceGroupManagerAutoHealingPolicy' <$>
                   (o .:? "healthCheck") <*> (o .:? "initialDelaySec"))

instance ToJSON InstanceGroupManagerAutoHealingPolicy
         where
        toJSON InstanceGroupManagerAutoHealingPolicy'{..}
          = object
              (catMaybes
                 [("healthCheck" .=) <$> _igmahpHealthCheck,
                  ("initialDelaySec" .=) <$> _igmahpInitialDelaySec])

-- | Increment a streamz counter with the specified metric and field names.
-- Metric names should start with a \'\/\', generally be lowercase-only,
-- and end in \"_count\". Field names should not contain an initial slash.
-- The actual exported metric names will have \"\/iam\/policy\" prepended.
-- Field names correspond to IAM request parameters and field values are
-- their respective values. Supported field names: - \"authority\", which
-- is \"[token]\" if IAMContext.token is present, otherwise the value of
-- IAMContext.authority_selector if present, and otherwise a representation
-- of IAMContext.principal; or - \"iam_principal\", a representation of
-- IAMContext.principal even if a token or authority selector is present;
-- or - \"\" (empty string), resulting in a counter with no fields.
-- Examples: counter { metric: \"\/debug_access_count\" field:
-- \"iam_principal\" } ==> increment counter
-- \/iam\/policy\/debug_access_count {iam_principal=[value of
-- IAMContext.principal]}
--
-- /See:/ 'logConfigCounterOptions' smart constructor.
data LogConfigCounterOptions =
  LogConfigCounterOptions'
    { _lccoField :: !(Maybe Text)
    , _lccoMetric :: !(Maybe Text)
    , _lccoCustomFields :: !(Maybe [LogConfigCounterOptionsCustomField])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'LogConfigCounterOptions' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'lccoField'
--
-- * 'lccoMetric'
--
-- * 'lccoCustomFields'
logConfigCounterOptions
    :: LogConfigCounterOptions
logConfigCounterOptions =
  LogConfigCounterOptions'
    {_lccoField = Nothing, _lccoMetric = Nothing, _lccoCustomFields = Nothing}


-- | The field value to attribute.
lccoField :: Lens' LogConfigCounterOptions (Maybe Text)
lccoField
  = lens _lccoField (\ s a -> s{_lccoField = a})

-- | The metric to update.
lccoMetric :: Lens' LogConfigCounterOptions (Maybe Text)
lccoMetric
  = lens _lccoMetric (\ s a -> s{_lccoMetric = a})

-- | Custom fields.
lccoCustomFields :: Lens' LogConfigCounterOptions [LogConfigCounterOptionsCustomField]
lccoCustomFields
  = lens _lccoCustomFields
      (\ s a -> s{_lccoCustomFields = a})
      . _Default
      . _Coerce

instance FromJSON LogConfigCounterOptions where
        parseJSON
          = withObject "LogConfigCounterOptions"
              (\ o ->
                 LogConfigCounterOptions' <$>
                   (o .:? "field") <*> (o .:? "metric") <*>
                     (o .:? "customFields" .!= mempty))

instance ToJSON LogConfigCounterOptions where
        toJSON LogConfigCounterOptions'{..}
          = object
              (catMaybes
                 [("field" .=) <$> _lccoField,
                  ("metric" .=) <$> _lccoMetric,
                  ("customFields" .=) <$> _lccoCustomFields])

--
-- /See:/ 'exchangedPeeringRoutesListWarningDataItem' smart constructor.
data ExchangedPeeringRoutesListWarningDataItem =
  ExchangedPeeringRoutesListWarningDataItem'
    { _eprlwdiValue :: !(Maybe Text)
    , _eprlwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ExchangedPeeringRoutesListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'eprlwdiValue'
--
-- * 'eprlwdiKey'
exchangedPeeringRoutesListWarningDataItem
    :: ExchangedPeeringRoutesListWarningDataItem
exchangedPeeringRoutesListWarningDataItem =
  ExchangedPeeringRoutesListWarningDataItem'
    {_eprlwdiValue = Nothing, _eprlwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
eprlwdiValue :: Lens' ExchangedPeeringRoutesListWarningDataItem (Maybe Text)
eprlwdiValue
  = lens _eprlwdiValue (\ s a -> s{_eprlwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
eprlwdiKey :: Lens' ExchangedPeeringRoutesListWarningDataItem (Maybe Text)
eprlwdiKey
  = lens _eprlwdiKey (\ s a -> s{_eprlwdiKey = a})

instance FromJSON
           ExchangedPeeringRoutesListWarningDataItem
         where
        parseJSON
          = withObject
              "ExchangedPeeringRoutesListWarningDataItem"
              (\ o ->
                 ExchangedPeeringRoutesListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           ExchangedPeeringRoutesListWarningDataItem
         where
        toJSON ExchangedPeeringRoutesListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _eprlwdiValue,
                  ("key" .=) <$> _eprlwdiKey])

-- | Bypass the cache when the specified request headers are present, e.g.
-- Pragma or Authorization headers. Values are case insensitive. The
-- presence of such a header overrides the cache_mode setting.
--
-- /See:/ 'backendBucketCdnPolicyBypassCacheOnRequestHeader' smart constructor.
newtype BackendBucketCdnPolicyBypassCacheOnRequestHeader =
  BackendBucketCdnPolicyBypassCacheOnRequestHeader'
    { _bbcpbcorhHeaderName :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendBucketCdnPolicyBypassCacheOnRequestHeader' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bbcpbcorhHeaderName'
backendBucketCdnPolicyBypassCacheOnRequestHeader
    :: BackendBucketCdnPolicyBypassCacheOnRequestHeader
backendBucketCdnPolicyBypassCacheOnRequestHeader =
  BackendBucketCdnPolicyBypassCacheOnRequestHeader'
    {_bbcpbcorhHeaderName = Nothing}


-- | The header field name to match on when bypassing cache. Values are
-- case-insensitive.
bbcpbcorhHeaderName :: Lens' BackendBucketCdnPolicyBypassCacheOnRequestHeader (Maybe Text)
bbcpbcorhHeaderName
  = lens _bbcpbcorhHeaderName
      (\ s a -> s{_bbcpbcorhHeaderName = a})

instance FromJSON
           BackendBucketCdnPolicyBypassCacheOnRequestHeader
         where
        parseJSON
          = withObject
              "BackendBucketCdnPolicyBypassCacheOnRequestHeader"
              (\ o ->
                 BackendBucketCdnPolicyBypassCacheOnRequestHeader' <$>
                   (o .:? "headerName"))

instance ToJSON
           BackendBucketCdnPolicyBypassCacheOnRequestHeader
         where
        toJSON
          BackendBucketCdnPolicyBypassCacheOnRequestHeader'{..}
          = object
              (catMaybes
                 [("headerName" .=) <$> _bbcpbcorhHeaderName])

--
-- /See:/ 'instancesSetMinCPUPlatformRequest' smart constructor.
newtype InstancesSetMinCPUPlatformRequest =
  InstancesSetMinCPUPlatformRequest'
    { _ismcprMinCPUPlatform :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstancesSetMinCPUPlatformRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ismcprMinCPUPlatform'
instancesSetMinCPUPlatformRequest
    :: InstancesSetMinCPUPlatformRequest
instancesSetMinCPUPlatformRequest =
  InstancesSetMinCPUPlatformRequest' {_ismcprMinCPUPlatform = Nothing}


-- | Minimum cpu\/platform this instance should be started at.
ismcprMinCPUPlatform :: Lens' InstancesSetMinCPUPlatformRequest (Maybe Text)
ismcprMinCPUPlatform
  = lens _ismcprMinCPUPlatform
      (\ s a -> s{_ismcprMinCPUPlatform = a})

instance FromJSON InstancesSetMinCPUPlatformRequest
         where
        parseJSON
          = withObject "InstancesSetMinCPUPlatformRequest"
              (\ o ->
                 InstancesSetMinCPUPlatformRequest' <$>
                   (o .:? "minCpuPlatform"))

instance ToJSON InstancesSetMinCPUPlatformRequest
         where
        toJSON InstancesSetMinCPUPlatformRequest'{..}
          = object
              (catMaybes
                 [("minCpuPlatform" .=) <$> _ismcprMinCPUPlatform])

--
-- /See:/ 'vpnGatewaysGetStatusResponse' smart constructor.
newtype VPNGatewaysGetStatusResponse =
  VPNGatewaysGetStatusResponse'
    { _vggsrResult :: Maybe VPNGatewayStatus
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNGatewaysGetStatusResponse' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vggsrResult'
vpnGatewaysGetStatusResponse
    :: VPNGatewaysGetStatusResponse
vpnGatewaysGetStatusResponse =
  VPNGatewaysGetStatusResponse' {_vggsrResult = Nothing}


vggsrResult :: Lens' VPNGatewaysGetStatusResponse (Maybe VPNGatewayStatus)
vggsrResult
  = lens _vggsrResult (\ s a -> s{_vggsrResult = a})

instance FromJSON VPNGatewaysGetStatusResponse where
        parseJSON
          = withObject "VPNGatewaysGetStatusResponse"
              (\ o ->
                 VPNGatewaysGetStatusResponse' <$> (o .:? "result"))

instance ToJSON VPNGatewaysGetStatusResponse where
        toJSON VPNGatewaysGetStatusResponse'{..}
          = object (catMaybes [("result" .=) <$> _vggsrResult])

--
-- /See:/ 'forwardingRuleAggregatedList' smart constructor.
data ForwardingRuleAggregatedList =
  ForwardingRuleAggregatedList'
    { _fralUnreachables :: !(Maybe [Text])
    , _fralNextPageToken :: !(Maybe Text)
    , _fralKind :: !Text
    , _fralItems :: !(Maybe ForwardingRuleAggregatedListItems)
    , _fralSelfLink :: !(Maybe Text)
    , _fralWarning :: !(Maybe ForwardingRuleAggregatedListWarning)
    , _fralId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ForwardingRuleAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'fralUnreachables'
--
-- * 'fralNextPageToken'
--
-- * 'fralKind'
--
-- * 'fralItems'
--
-- * 'fralSelfLink'
--
-- * 'fralWarning'
--
-- * 'fralId'
forwardingRuleAggregatedList
    :: ForwardingRuleAggregatedList
forwardingRuleAggregatedList =
  ForwardingRuleAggregatedList'
    { _fralUnreachables = Nothing
    , _fralNextPageToken = Nothing
    , _fralKind = "compute#forwardingRuleAggregatedList"
    , _fralItems = Nothing
    , _fralSelfLink = Nothing
    , _fralWarning = Nothing
    , _fralId = Nothing
    }


-- | [Output Only] Unreachable resources.
fralUnreachables :: Lens' ForwardingRuleAggregatedList [Text]
fralUnreachables
  = lens _fralUnreachables
      (\ s a -> s{_fralUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
fralNextPageToken :: Lens' ForwardingRuleAggregatedList (Maybe Text)
fralNextPageToken
  = lens _fralNextPageToken
      (\ s a -> s{_fralNextPageToken = a})

-- | [Output Only] Type of resource. Always
-- compute#forwardingRuleAggregatedList for lists of forwarding rules.
fralKind :: Lens' ForwardingRuleAggregatedList Text
fralKind = lens _fralKind (\ s a -> s{_fralKind = a})

-- | A list of ForwardingRulesScopedList resources.
fralItems :: Lens' ForwardingRuleAggregatedList (Maybe ForwardingRuleAggregatedListItems)
fralItems
  = lens _fralItems (\ s a -> s{_fralItems = a})

-- | [Output Only] Server-defined URL for this resource.
fralSelfLink :: Lens' ForwardingRuleAggregatedList (Maybe Text)
fralSelfLink
  = lens _fralSelfLink (\ s a -> s{_fralSelfLink = a})

-- | [Output Only] Informational warning message.
fralWarning :: Lens' ForwardingRuleAggregatedList (Maybe ForwardingRuleAggregatedListWarning)
fralWarning
  = lens _fralWarning (\ s a -> s{_fralWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
fralId :: Lens' ForwardingRuleAggregatedList (Maybe Text)
fralId = lens _fralId (\ s a -> s{_fralId = a})

instance FromJSON ForwardingRuleAggregatedList where
        parseJSON
          = withObject "ForwardingRuleAggregatedList"
              (\ o ->
                 ForwardingRuleAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!=
                        "compute#forwardingRuleAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON ForwardingRuleAggregatedList where
        toJSON ForwardingRuleAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _fralUnreachables,
                  ("nextPageToken" .=) <$> _fralNextPageToken,
                  Just ("kind" .= _fralKind),
                  ("items" .=) <$> _fralItems,
                  ("selfLink" .=) <$> _fralSelfLink,
                  ("warning" .=) <$> _fralWarning,
                  ("id" .=) <$> _fralId])

-- | Informational warning which replaces the list of resourcePolicies when
-- the list is empty.
--
-- /See:/ 'resourcePoliciesScopedListWarning' smart constructor.
data ResourcePoliciesScopedListWarning =
  ResourcePoliciesScopedListWarning'
    { _rpslwData :: !(Maybe [ResourcePoliciesScopedListWarningDataItem])
    , _rpslwCode :: !(Maybe ResourcePoliciesScopedListWarningCode)
    , _rpslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePoliciesScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rpslwData'
--
-- * 'rpslwCode'
--
-- * 'rpslwMessage'
resourcePoliciesScopedListWarning
    :: ResourcePoliciesScopedListWarning
resourcePoliciesScopedListWarning =
  ResourcePoliciesScopedListWarning'
    {_rpslwData = Nothing, _rpslwCode = Nothing, _rpslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
rpslwData :: Lens' ResourcePoliciesScopedListWarning [ResourcePoliciesScopedListWarningDataItem]
rpslwData
  = lens _rpslwData (\ s a -> s{_rpslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
rpslwCode :: Lens' ResourcePoliciesScopedListWarning (Maybe ResourcePoliciesScopedListWarningCode)
rpslwCode
  = lens _rpslwCode (\ s a -> s{_rpslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
rpslwMessage :: Lens' ResourcePoliciesScopedListWarning (Maybe Text)
rpslwMessage
  = lens _rpslwMessage (\ s a -> s{_rpslwMessage = a})

instance FromJSON ResourcePoliciesScopedListWarning
         where
        parseJSON
          = withObject "ResourcePoliciesScopedListWarning"
              (\ o ->
                 ResourcePoliciesScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON ResourcePoliciesScopedListWarning
         where
        toJSON ResourcePoliciesScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _rpslwData,
                  ("code" .=) <$> _rpslwCode,
                  ("message" .=) <$> _rpslwMessage])

-- | Specifies the reservations that this instance can consume from.
--
-- /See:/ 'reservationAffinity' smart constructor.
data ReservationAffinity =
  ReservationAffinity'
    { _raConsumeReservationType :: !(Maybe ReservationAffinityConsumeReservationType)
    , _raValues :: !(Maybe [Text])
    , _raKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ReservationAffinity' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'raConsumeReservationType'
--
-- * 'raValues'
--
-- * 'raKey'
reservationAffinity
    :: ReservationAffinity
reservationAffinity =
  ReservationAffinity'
    {_raConsumeReservationType = Nothing, _raValues = Nothing, _raKey = Nothing}


-- | Specifies the type of reservation from which this instance can consume
-- resources: ANY_RESERVATION (default), SPECIFIC_RESERVATION, or
-- NO_RESERVATION. See Consuming reserved instances for examples.
raConsumeReservationType :: Lens' ReservationAffinity (Maybe ReservationAffinityConsumeReservationType)
raConsumeReservationType
  = lens _raConsumeReservationType
      (\ s a -> s{_raConsumeReservationType = a})

-- | Corresponds to the label values of a reservation resource. This can be
-- either a name to a reservation in the same project or
-- \"projects\/different-project\/reservations\/some-reservation-name\" to
-- target a shared reservation in the same zone but in a different project.
raValues :: Lens' ReservationAffinity [Text]
raValues
  = lens _raValues (\ s a -> s{_raValues = a}) .
      _Default
      . _Coerce

-- | Corresponds to the label key of a reservation resource. To target a
-- SPECIFIC_RESERVATION by name, specify googleapis.com\/reservation-name
-- as the key and specify the name of your reservation as its value.
raKey :: Lens' ReservationAffinity (Maybe Text)
raKey = lens _raKey (\ s a -> s{_raKey = a})

instance FromJSON ReservationAffinity where
        parseJSON
          = withObject "ReservationAffinity"
              (\ o ->
                 ReservationAffinity' <$>
                   (o .:? "consumeReservationType") <*>
                     (o .:? "values" .!= mempty)
                     <*> (o .:? "key"))

instance ToJSON ReservationAffinity where
        toJSON ReservationAffinity'{..}
          = object
              (catMaybes
                 [("consumeReservationType" .=) <$>
                    _raConsumeReservationType,
                  ("values" .=) <$> _raValues, ("key" .=) <$> _raKey])

--
-- /See:/ 'targetReference' smart constructor.
newtype TargetReference =
  TargetReference'
    { _trTarget :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetReference' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'trTarget'
targetReference
    :: TargetReference
targetReference = TargetReference' {_trTarget = Nothing}


trTarget :: Lens' TargetReference (Maybe Text)
trTarget = lens _trTarget (\ s a -> s{_trTarget = a})

instance FromJSON TargetReference where
        parseJSON
          = withObject "TargetReference"
              (\ o -> TargetReference' <$> (o .:? "target"))

instance ToJSON TargetReference where
        toJSON TargetReference'{..}
          = object (catMaybes [("target" .=) <$> _trTarget])

--
-- /See:/ 'targetPoolAggregatedList' smart constructor.
data TargetPoolAggregatedList =
  TargetPoolAggregatedList'
    { _tpalUnreachables :: !(Maybe [Text])
    , _tpalNextPageToken :: !(Maybe Text)
    , _tpalKind :: !Text
    , _tpalItems :: !(Maybe TargetPoolAggregatedListItems)
    , _tpalSelfLink :: !(Maybe Text)
    , _tpalWarning :: !(Maybe TargetPoolAggregatedListWarning)
    , _tpalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetPoolAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tpalUnreachables'
--
-- * 'tpalNextPageToken'
--
-- * 'tpalKind'
--
-- * 'tpalItems'
--
-- * 'tpalSelfLink'
--
-- * 'tpalWarning'
--
-- * 'tpalId'
targetPoolAggregatedList
    :: TargetPoolAggregatedList
targetPoolAggregatedList =
  TargetPoolAggregatedList'
    { _tpalUnreachables = Nothing
    , _tpalNextPageToken = Nothing
    , _tpalKind = "compute#targetPoolAggregatedList"
    , _tpalItems = Nothing
    , _tpalSelfLink = Nothing
    , _tpalWarning = Nothing
    , _tpalId = Nothing
    }


-- | [Output Only] Unreachable resources.
tpalUnreachables :: Lens' TargetPoolAggregatedList [Text]
tpalUnreachables
  = lens _tpalUnreachables
      (\ s a -> s{_tpalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
tpalNextPageToken :: Lens' TargetPoolAggregatedList (Maybe Text)
tpalNextPageToken
  = lens _tpalNextPageToken
      (\ s a -> s{_tpalNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#targetPoolAggregatedList
-- for aggregated lists of target pools.
tpalKind :: Lens' TargetPoolAggregatedList Text
tpalKind = lens _tpalKind (\ s a -> s{_tpalKind = a})

-- | A list of TargetPool resources.
tpalItems :: Lens' TargetPoolAggregatedList (Maybe TargetPoolAggregatedListItems)
tpalItems
  = lens _tpalItems (\ s a -> s{_tpalItems = a})

-- | [Output Only] Server-defined URL for this resource.
tpalSelfLink :: Lens' TargetPoolAggregatedList (Maybe Text)
tpalSelfLink
  = lens _tpalSelfLink (\ s a -> s{_tpalSelfLink = a})

-- | [Output Only] Informational warning message.
tpalWarning :: Lens' TargetPoolAggregatedList (Maybe TargetPoolAggregatedListWarning)
tpalWarning
  = lens _tpalWarning (\ s a -> s{_tpalWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
tpalId :: Lens' TargetPoolAggregatedList (Maybe Text)
tpalId = lens _tpalId (\ s a -> s{_tpalId = a})

instance FromJSON TargetPoolAggregatedList where
        parseJSON
          = withObject "TargetPoolAggregatedList"
              (\ o ->
                 TargetPoolAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!= "compute#targetPoolAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON TargetPoolAggregatedList where
        toJSON TargetPoolAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _tpalUnreachables,
                  ("nextPageToken" .=) <$> _tpalNextPageToken,
                  Just ("kind" .= _tpalKind),
                  ("items" .=) <$> _tpalItems,
                  ("selfLink" .=) <$> _tpalSelfLink,
                  ("warning" .=) <$> _tpalWarning,
                  ("id" .=) <$> _tpalId])

--
-- /See:/ 'operationsScopedListWarningDataItem' smart constructor.
data OperationsScopedListWarningDataItem =
  OperationsScopedListWarningDataItem'
    { _oslwdiValue :: !(Maybe Text)
    , _oslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'OperationsScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'oslwdiValue'
--
-- * 'oslwdiKey'
operationsScopedListWarningDataItem
    :: OperationsScopedListWarningDataItem
operationsScopedListWarningDataItem =
  OperationsScopedListWarningDataItem'
    {_oslwdiValue = Nothing, _oslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
oslwdiValue :: Lens' OperationsScopedListWarningDataItem (Maybe Text)
oslwdiValue
  = lens _oslwdiValue (\ s a -> s{_oslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
oslwdiKey :: Lens' OperationsScopedListWarningDataItem (Maybe Text)
oslwdiKey
  = lens _oslwdiKey (\ s a -> s{_oslwdiKey = a})

instance FromJSON OperationsScopedListWarningDataItem
         where
        parseJSON
          = withObject "OperationsScopedListWarningDataItem"
              (\ o ->
                 OperationsScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON OperationsScopedListWarningDataItem
         where
        toJSON OperationsScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _oslwdiValue,
                  ("key" .=) <$> _oslwdiKey])

--
-- /See:/ 'globalSetLabelsRequest' smart constructor.
data GlobalSetLabelsRequest =
  GlobalSetLabelsRequest'
    { _gslrLabels :: !(Maybe GlobalSetLabelsRequestLabels)
    , _gslrLabelFingerprint :: !(Maybe Bytes)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'GlobalSetLabelsRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'gslrLabels'
--
-- * 'gslrLabelFingerprint'
globalSetLabelsRequest
    :: GlobalSetLabelsRequest
globalSetLabelsRequest =
  GlobalSetLabelsRequest'
    {_gslrLabels = Nothing, _gslrLabelFingerprint = Nothing}


-- | A list of labels to apply for this resource. Each label key & value must
-- comply with RFC1035. Specifically, the name must be 1-63 characters long
-- and match the regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which
-- means the first character must be a lowercase letter, and all following
-- characters must be a dash, lowercase letter, or digit, except the last
-- character, which cannot be a dash. For example, \"webserver-frontend\":
-- \"images\". A label value can also be empty (e.g. \"my-label\": \"\").
gslrLabels :: Lens' GlobalSetLabelsRequest (Maybe GlobalSetLabelsRequestLabels)
gslrLabels
  = lens _gslrLabels (\ s a -> s{_gslrLabels = a})

-- | The fingerprint of the previous set of labels for this resource, used to
-- detect conflicts. The fingerprint is initially generated by Compute
-- Engine and changes after every request to modify or update labels. You
-- must always provide an up-to-date fingerprint hash when updating or
-- changing labels, otherwise the request will fail with error 412
-- conditionNotMet. Make a get() request to the resource to get the latest
-- fingerprint.
gslrLabelFingerprint :: Lens' GlobalSetLabelsRequest (Maybe ByteString)
gslrLabelFingerprint
  = lens _gslrLabelFingerprint
      (\ s a -> s{_gslrLabelFingerprint = a})
      . mapping _Bytes

instance FromJSON GlobalSetLabelsRequest where
        parseJSON
          = withObject "GlobalSetLabelsRequest"
              (\ o ->
                 GlobalSetLabelsRequest' <$>
                   (o .:? "labels") <*> (o .:? "labelFingerprint"))

instance ToJSON GlobalSetLabelsRequest where
        toJSON GlobalSetLabelsRequest'{..}
          = object
              (catMaybes
                 [("labels" .=) <$> _gslrLabels,
                  ("labelFingerprint" .=) <$> _gslrLabelFingerprint])

-- | The specification for fault injection introduced into traffic to test
-- the resiliency of clients to backend service failure. As part of fault
-- injection, when clients send requests to a backend service, delays can
-- be introduced by Loadbalancer on a percentage of requests before sending
-- those request to the backend service. Similarly requests from clients
-- can be aborted by the Loadbalancer for a percentage of requests.
--
-- /See:/ 'hTTPFaultInjection' smart constructor.
data HTTPFaultInjection =
  HTTPFaultInjection'
    { _httpfiAbort :: !(Maybe HTTPFaultAbort)
    , _httpfiDelay :: !(Maybe HTTPFaultDelay)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HTTPFaultInjection' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'httpfiAbort'
--
-- * 'httpfiDelay'
hTTPFaultInjection
    :: HTTPFaultInjection
hTTPFaultInjection =
  HTTPFaultInjection' {_httpfiAbort = Nothing, _httpfiDelay = Nothing}


-- | The specification for how client requests are aborted as part of fault
-- injection.
httpfiAbort :: Lens' HTTPFaultInjection (Maybe HTTPFaultAbort)
httpfiAbort
  = lens _httpfiAbort (\ s a -> s{_httpfiAbort = a})

-- | The specification for how client requests are delayed as part of fault
-- injection, before being sent to a backend service.
httpfiDelay :: Lens' HTTPFaultInjection (Maybe HTTPFaultDelay)
httpfiDelay
  = lens _httpfiDelay (\ s a -> s{_httpfiDelay = a})

instance FromJSON HTTPFaultInjection where
        parseJSON
          = withObject "HTTPFaultInjection"
              (\ o ->
                 HTTPFaultInjection' <$>
                   (o .:? "abort") <*> (o .:? "delay"))

instance ToJSON HTTPFaultInjection where
        toJSON HTTPFaultInjection'{..}
          = object
              (catMaybes
                 [("abort" .=) <$> _httpfiAbort,
                  ("delay" .=) <$> _httpfiDelay])

-- | Represents a Target Pool resource. Target pools are used for network
-- TCP\/UDP load balancing. A target pool references member instances, an
-- associated legacy HttpHealthCheck resource, and, optionally, a backup
-- target pool. For more information, read Using target pools. (==
-- resource_for {$api_version}.targetPools ==)
--
-- /See:/ 'targetPool' smart constructor.
data TargetPool =
  TargetPool'
    { _tpSessionAffinity :: !(Maybe TargetPoolSessionAffinity)
    , _tpBackupPool :: !(Maybe Text)
    , _tpKind :: !Text
    , _tpSelfLink :: !(Maybe Text)
    , _tpName :: !(Maybe Text)
    , _tpCreationTimestamp :: !(Maybe Text)
    , _tpInstances :: !(Maybe [Text])
    , _tpId :: !(Maybe (Textual Word64))
    , _tpFailoverRatio :: !(Maybe (Textual Double))
    , _tpRegion :: !(Maybe Text)
    , _tpDescription :: !(Maybe Text)
    , _tpHealthChecks :: !(Maybe [Text])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetPool' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tpSessionAffinity'
--
-- * 'tpBackupPool'
--
-- * 'tpKind'
--
-- * 'tpSelfLink'
--
-- * 'tpName'
--
-- * 'tpCreationTimestamp'
--
-- * 'tpInstances'
--
-- * 'tpId'
--
-- * 'tpFailoverRatio'
--
-- * 'tpRegion'
--
-- * 'tpDescription'
--
-- * 'tpHealthChecks'
targetPool
    :: TargetPool
targetPool =
  TargetPool'
    { _tpSessionAffinity = Nothing
    , _tpBackupPool = Nothing
    , _tpKind = "compute#targetPool"
    , _tpSelfLink = Nothing
    , _tpName = Nothing
    , _tpCreationTimestamp = Nothing
    , _tpInstances = Nothing
    , _tpId = Nothing
    , _tpFailoverRatio = Nothing
    , _tpRegion = Nothing
    , _tpDescription = Nothing
    , _tpHealthChecks = Nothing
    }


-- | Session affinity option, must be one of the following values: NONE:
-- Connections from the same client IP may go to any instance in the pool.
-- CLIENT_IP: Connections from the same client IP will go to the same
-- instance in the pool while that instance remains healthy.
-- CLIENT_IP_PROTO: Connections from the same client IP with the same IP
-- protocol will go to the same instance in the pool while that instance
-- remains healthy.
tpSessionAffinity :: Lens' TargetPool (Maybe TargetPoolSessionAffinity)
tpSessionAffinity
  = lens _tpSessionAffinity
      (\ s a -> s{_tpSessionAffinity = a})

-- | The server-defined URL for the resource. This field is applicable only
-- when the containing target pool is serving a forwarding rule as the
-- primary pool, and its failoverRatio field is properly set to a value
-- between [0, 1]. backupPool and failoverRatio together define the
-- fallback behavior of the primary target pool: if the ratio of the
-- healthy instances in the primary pool is at or below failoverRatio,
-- traffic arriving at the load-balanced IP will be directed to the backup
-- pool. In case where failoverRatio and backupPool are not set, or all the
-- instances in the backup pool are unhealthy, the traffic will be directed
-- back to the primary pool in the \"force\" mode, where traffic will be
-- spread to the healthy instances with the best effort, or to all
-- instances when no instance is healthy.
tpBackupPool :: Lens' TargetPool (Maybe Text)
tpBackupPool
  = lens _tpBackupPool (\ s a -> s{_tpBackupPool = a})

-- | [Output Only] Type of the resource. Always compute#targetPool for target
-- pools.
tpKind :: Lens' TargetPool Text
tpKind = lens _tpKind (\ s a -> s{_tpKind = a})

-- | [Output Only] Server-defined URL for the resource.
tpSelfLink :: Lens' TargetPool (Maybe Text)
tpSelfLink
  = lens _tpSelfLink (\ s a -> s{_tpSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
tpName :: Lens' TargetPool (Maybe Text)
tpName = lens _tpName (\ s a -> s{_tpName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
tpCreationTimestamp :: Lens' TargetPool (Maybe Text)
tpCreationTimestamp
  = lens _tpCreationTimestamp
      (\ s a -> s{_tpCreationTimestamp = a})

-- | A list of resource URLs to the virtual machine instances serving this
-- pool. They must live in zones contained in the same region as this pool.
tpInstances :: Lens' TargetPool [Text]
tpInstances
  = lens _tpInstances (\ s a -> s{_tpInstances = a}) .
      _Default
      . _Coerce

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
tpId :: Lens' TargetPool (Maybe Word64)
tpId
  = lens _tpId (\ s a -> s{_tpId = a}) .
      mapping _Coerce

-- | This field is applicable only when the containing target pool is serving
-- a forwarding rule as the primary pool (i.e., not as a backup pool to
-- some other target pool). The value of the field must be in [0, 1]. If
-- set, backupPool must also be set. They together define the fallback
-- behavior of the primary target pool: if the ratio of the healthy
-- instances in the primary pool is at or below this number, traffic
-- arriving at the load-balanced IP will be directed to the backup pool. In
-- case where failoverRatio is not set or all the instances in the backup
-- pool are unhealthy, the traffic will be directed back to the primary
-- pool in the \"force\" mode, where traffic will be spread to the healthy
-- instances with the best effort, or to all instances when no instance is
-- healthy.
tpFailoverRatio :: Lens' TargetPool (Maybe Double)
tpFailoverRatio
  = lens _tpFailoverRatio
      (\ s a -> s{_tpFailoverRatio = a})
      . mapping _Coerce

-- | [Output Only] URL of the region where the target pool resides.
tpRegion :: Lens' TargetPool (Maybe Text)
tpRegion = lens _tpRegion (\ s a -> s{_tpRegion = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource.
tpDescription :: Lens' TargetPool (Maybe Text)
tpDescription
  = lens _tpDescription
      (\ s a -> s{_tpDescription = a})

-- | The URL of the HttpHealthCheck resource. A member instance in this pool
-- is considered healthy if and only if the health checks pass. Only legacy
-- HttpHealthChecks are supported. Only one health check may be specified.
tpHealthChecks :: Lens' TargetPool [Text]
tpHealthChecks
  = lens _tpHealthChecks
      (\ s a -> s{_tpHealthChecks = a})
      . _Default
      . _Coerce

instance FromJSON TargetPool where
        parseJSON
          = withObject "TargetPool"
              (\ o ->
                 TargetPool' <$>
                   (o .:? "sessionAffinity") <*> (o .:? "backupPool")
                     <*> (o .:? "kind" .!= "compute#targetPool")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "instances" .!= mempty)
                     <*> (o .:? "id")
                     <*> (o .:? "failoverRatio")
                     <*> (o .:? "region")
                     <*> (o .:? "description")
                     <*> (o .:? "healthChecks" .!= mempty))

instance ToJSON TargetPool where
        toJSON TargetPool'{..}
          = object
              (catMaybes
                 [("sessionAffinity" .=) <$> _tpSessionAffinity,
                  ("backupPool" .=) <$> _tpBackupPool,
                  Just ("kind" .= _tpKind),
                  ("selfLink" .=) <$> _tpSelfLink,
                  ("name" .=) <$> _tpName,
                  ("creationTimestamp" .=) <$> _tpCreationTimestamp,
                  ("instances" .=) <$> _tpInstances,
                  ("id" .=) <$> _tpId,
                  ("failoverRatio" .=) <$> _tpFailoverRatio,
                  ("region" .=) <$> _tpRegion,
                  ("description" .=) <$> _tpDescription,
                  ("healthChecks" .=) <$> _tpHealthChecks])

-- | Contains a list of images.
--
-- /See:/ 'imageList' smart constructor.
data ImageList =
  ImageList'
    { _ilNextPageToken :: !(Maybe Text)
    , _ilKind :: !Text
    , _ilItems :: !(Maybe [Image])
    , _ilSelfLink :: !(Maybe Text)
    , _ilWarning :: !(Maybe ImageListWarning)
    , _ilId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ImageList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ilNextPageToken'
--
-- * 'ilKind'
--
-- * 'ilItems'
--
-- * 'ilSelfLink'
--
-- * 'ilWarning'
--
-- * 'ilId'
imageList
    :: ImageList
imageList =
  ImageList'
    { _ilNextPageToken = Nothing
    , _ilKind = "compute#imageList"
    , _ilItems = Nothing
    , _ilSelfLink = Nothing
    , _ilWarning = Nothing
    , _ilId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
ilNextPageToken :: Lens' ImageList (Maybe Text)
ilNextPageToken
  = lens _ilNextPageToken
      (\ s a -> s{_ilNextPageToken = a})

-- | Type of resource.
ilKind :: Lens' ImageList Text
ilKind = lens _ilKind (\ s a -> s{_ilKind = a})

-- | A list of Image resources.
ilItems :: Lens' ImageList [Image]
ilItems
  = lens _ilItems (\ s a -> s{_ilItems = a}) . _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
ilSelfLink :: Lens' ImageList (Maybe Text)
ilSelfLink
  = lens _ilSelfLink (\ s a -> s{_ilSelfLink = a})

-- | [Output Only] Informational warning message.
ilWarning :: Lens' ImageList (Maybe ImageListWarning)
ilWarning
  = lens _ilWarning (\ s a -> s{_ilWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
ilId :: Lens' ImageList (Maybe Text)
ilId = lens _ilId (\ s a -> s{_ilId = a})

instance FromJSON ImageList where
        parseJSON
          = withObject "ImageList"
              (\ o ->
                 ImageList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#imageList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON ImageList where
        toJSON ImageList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _ilNextPageToken,
                  Just ("kind" .= _ilKind), ("items" .=) <$> _ilItems,
                  ("selfLink" .=) <$> _ilSelfLink,
                  ("warning" .=) <$> _ilWarning, ("id" .=) <$> _ilId])

--
-- /See:/ 'operationAggregatedListWarningDataItem' smart constructor.
data OperationAggregatedListWarningDataItem =
  OperationAggregatedListWarningDataItem'
    { _oalwdiValue :: !(Maybe Text)
    , _oalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'OperationAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'oalwdiValue'
--
-- * 'oalwdiKey'
operationAggregatedListWarningDataItem
    :: OperationAggregatedListWarningDataItem
operationAggregatedListWarningDataItem =
  OperationAggregatedListWarningDataItem'
    {_oalwdiValue = Nothing, _oalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
oalwdiValue :: Lens' OperationAggregatedListWarningDataItem (Maybe Text)
oalwdiValue
  = lens _oalwdiValue (\ s a -> s{_oalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
oalwdiKey :: Lens' OperationAggregatedListWarningDataItem (Maybe Text)
oalwdiKey
  = lens _oalwdiKey (\ s a -> s{_oalwdiKey = a})

instance FromJSON
           OperationAggregatedListWarningDataItem
         where
        parseJSON
          = withObject "OperationAggregatedListWarningDataItem"
              (\ o ->
                 OperationAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           OperationAggregatedListWarningDataItem
         where
        toJSON OperationAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _oalwdiValue,
                  ("key" .=) <$> _oalwdiKey])

-- | Contains a list of resourcePolicies.
--
-- /See:/ 'resourcePolicyAggregatedList' smart constructor.
data ResourcePolicyAggregatedList =
  ResourcePolicyAggregatedList'
    { _rpalEtag :: !(Maybe Text)
    , _rpalUnreachables :: !(Maybe [Text])
    , _rpalNextPageToken :: !(Maybe Text)
    , _rpalKind :: !Text
    , _rpalItems :: !(Maybe ResourcePolicyAggregatedListItems)
    , _rpalSelfLink :: !(Maybe Text)
    , _rpalWarning :: !(Maybe ResourcePolicyAggregatedListWarning)
    , _rpalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePolicyAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rpalEtag'
--
-- * 'rpalUnreachables'
--
-- * 'rpalNextPageToken'
--
-- * 'rpalKind'
--
-- * 'rpalItems'
--
-- * 'rpalSelfLink'
--
-- * 'rpalWarning'
--
-- * 'rpalId'
resourcePolicyAggregatedList
    :: ResourcePolicyAggregatedList
resourcePolicyAggregatedList =
  ResourcePolicyAggregatedList'
    { _rpalEtag = Nothing
    , _rpalUnreachables = Nothing
    , _rpalNextPageToken = Nothing
    , _rpalKind = "compute#resourcePolicyAggregatedList"
    , _rpalItems = Nothing
    , _rpalSelfLink = Nothing
    , _rpalWarning = Nothing
    , _rpalId = Nothing
    }


rpalEtag :: Lens' ResourcePolicyAggregatedList (Maybe Text)
rpalEtag = lens _rpalEtag (\ s a -> s{_rpalEtag = a})

-- | [Output Only] Unreachable resources.
rpalUnreachables :: Lens' ResourcePolicyAggregatedList [Text]
rpalUnreachables
  = lens _rpalUnreachables
      (\ s a -> s{_rpalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
rpalNextPageToken :: Lens' ResourcePolicyAggregatedList (Maybe Text)
rpalNextPageToken
  = lens _rpalNextPageToken
      (\ s a -> s{_rpalNextPageToken = a})

-- | Type of resource.
rpalKind :: Lens' ResourcePolicyAggregatedList Text
rpalKind = lens _rpalKind (\ s a -> s{_rpalKind = a})

-- | A list of ResourcePolicy resources.
rpalItems :: Lens' ResourcePolicyAggregatedList (Maybe ResourcePolicyAggregatedListItems)
rpalItems
  = lens _rpalItems (\ s a -> s{_rpalItems = a})

-- | [Output Only] Server-defined URL for this resource.
rpalSelfLink :: Lens' ResourcePolicyAggregatedList (Maybe Text)
rpalSelfLink
  = lens _rpalSelfLink (\ s a -> s{_rpalSelfLink = a})

-- | [Output Only] Informational warning message.
rpalWarning :: Lens' ResourcePolicyAggregatedList (Maybe ResourcePolicyAggregatedListWarning)
rpalWarning
  = lens _rpalWarning (\ s a -> s{_rpalWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
rpalId :: Lens' ResourcePolicyAggregatedList (Maybe Text)
rpalId = lens _rpalId (\ s a -> s{_rpalId = a})

instance FromJSON ResourcePolicyAggregatedList where
        parseJSON
          = withObject "ResourcePolicyAggregatedList"
              (\ o ->
                 ResourcePolicyAggregatedList' <$>
                   (o .:? "etag") <*> (o .:? "unreachables" .!= mempty)
                     <*> (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!=
                        "compute#resourcePolicyAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON ResourcePolicyAggregatedList where
        toJSON ResourcePolicyAggregatedList'{..}
          = object
              (catMaybes
                 [("etag" .=) <$> _rpalEtag,
                  ("unreachables" .=) <$> _rpalUnreachables,
                  ("nextPageToken" .=) <$> _rpalNextPageToken,
                  Just ("kind" .= _rpalKind),
                  ("items" .=) <$> _rpalItems,
                  ("selfLink" .=) <$> _rpalSelfLink,
                  ("warning" .=) <$> _rpalWarning,
                  ("id" .=) <$> _rpalId])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'forwardingRuleListWarning' smart constructor.
data ForwardingRuleListWarning =
  ForwardingRuleListWarning'
    { _frlwData :: !(Maybe [ForwardingRuleListWarningDataItem])
    , _frlwCode :: !(Maybe ForwardingRuleListWarningCode)
    , _frlwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ForwardingRuleListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'frlwData'
--
-- * 'frlwCode'
--
-- * 'frlwMessage'
forwardingRuleListWarning
    :: ForwardingRuleListWarning
forwardingRuleListWarning =
  ForwardingRuleListWarning'
    {_frlwData = Nothing, _frlwCode = Nothing, _frlwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
frlwData :: Lens' ForwardingRuleListWarning [ForwardingRuleListWarningDataItem]
frlwData
  = lens _frlwData (\ s a -> s{_frlwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
frlwCode :: Lens' ForwardingRuleListWarning (Maybe ForwardingRuleListWarningCode)
frlwCode = lens _frlwCode (\ s a -> s{_frlwCode = a})

-- | [Output Only] A human-readable description of the warning code.
frlwMessage :: Lens' ForwardingRuleListWarning (Maybe Text)
frlwMessage
  = lens _frlwMessage (\ s a -> s{_frlwMessage = a})

instance FromJSON ForwardingRuleListWarning where
        parseJSON
          = withObject "ForwardingRuleListWarning"
              (\ o ->
                 ForwardingRuleListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON ForwardingRuleListWarning where
        toJSON ForwardingRuleListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _frlwData,
                  ("code" .=) <$> _frlwCode,
                  ("message" .=) <$> _frlwMessage])

-- | Informational warning which replaces the list of addresses when the list
-- is empty.
--
-- /See:/ 'vpnTunnelsScopedListWarning' smart constructor.
data VPNTunnelsScopedListWarning =
  VPNTunnelsScopedListWarning'
    { _vtslwData :: !(Maybe [VPNTunnelsScopedListWarningDataItem])
    , _vtslwCode :: !(Maybe VPNTunnelsScopedListWarningCode)
    , _vtslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNTunnelsScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vtslwData'
--
-- * 'vtslwCode'
--
-- * 'vtslwMessage'
vpnTunnelsScopedListWarning
    :: VPNTunnelsScopedListWarning
vpnTunnelsScopedListWarning =
  VPNTunnelsScopedListWarning'
    {_vtslwData = Nothing, _vtslwCode = Nothing, _vtslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
vtslwData :: Lens' VPNTunnelsScopedListWarning [VPNTunnelsScopedListWarningDataItem]
vtslwData
  = lens _vtslwData (\ s a -> s{_vtslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
vtslwCode :: Lens' VPNTunnelsScopedListWarning (Maybe VPNTunnelsScopedListWarningCode)
vtslwCode
  = lens _vtslwCode (\ s a -> s{_vtslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
vtslwMessage :: Lens' VPNTunnelsScopedListWarning (Maybe Text)
vtslwMessage
  = lens _vtslwMessage (\ s a -> s{_vtslwMessage = a})

instance FromJSON VPNTunnelsScopedListWarning where
        parseJSON
          = withObject "VPNTunnelsScopedListWarning"
              (\ o ->
                 VPNTunnelsScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON VPNTunnelsScopedListWarning where
        toJSON VPNTunnelsScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _vtslwData,
                  ("code" .=) <$> _vtslwCode,
                  ("message" .=) <$> _vtslwMessage])

--
-- /See:/ 'regionDisksResizeRequest' smart constructor.
newtype RegionDisksResizeRequest =
  RegionDisksResizeRequest'
    { _rdrrSizeGb :: Maybe (Textual Int64)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionDisksResizeRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rdrrSizeGb'
regionDisksResizeRequest
    :: RegionDisksResizeRequest
regionDisksResizeRequest = RegionDisksResizeRequest' {_rdrrSizeGb = Nothing}


-- | The new size of the regional persistent disk, which is specified in GB.
rdrrSizeGb :: Lens' RegionDisksResizeRequest (Maybe Int64)
rdrrSizeGb
  = lens _rdrrSizeGb (\ s a -> s{_rdrrSizeGb = a}) .
      mapping _Coerce

instance FromJSON RegionDisksResizeRequest where
        parseJSON
          = withObject "RegionDisksResizeRequest"
              (\ o ->
                 RegionDisksResizeRequest' <$> (o .:? "sizeGb"))

instance ToJSON RegionDisksResizeRequest where
        toJSON RegionDisksResizeRequest'{..}
          = object (catMaybes [("sizeGb" .=) <$> _rdrrSizeGb])

-- | [Output Only] An informational warning that appears when the node types
-- list is empty.
--
-- /See:/ 'nodeTypesScopedListWarning' smart constructor.
data NodeTypesScopedListWarning =
  NodeTypesScopedListWarning'
    { _ntslwData :: !(Maybe [NodeTypesScopedListWarningDataItem])
    , _ntslwCode :: !(Maybe NodeTypesScopedListWarningCode)
    , _ntslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeTypesScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ntslwData'
--
-- * 'ntslwCode'
--
-- * 'ntslwMessage'
nodeTypesScopedListWarning
    :: NodeTypesScopedListWarning
nodeTypesScopedListWarning =
  NodeTypesScopedListWarning'
    {_ntslwData = Nothing, _ntslwCode = Nothing, _ntslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
ntslwData :: Lens' NodeTypesScopedListWarning [NodeTypesScopedListWarningDataItem]
ntslwData
  = lens _ntslwData (\ s a -> s{_ntslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
ntslwCode :: Lens' NodeTypesScopedListWarning (Maybe NodeTypesScopedListWarningCode)
ntslwCode
  = lens _ntslwCode (\ s a -> s{_ntslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
ntslwMessage :: Lens' NodeTypesScopedListWarning (Maybe Text)
ntslwMessage
  = lens _ntslwMessage (\ s a -> s{_ntslwMessage = a})

instance FromJSON NodeTypesScopedListWarning where
        parseJSON
          = withObject "NodeTypesScopedListWarning"
              (\ o ->
                 NodeTypesScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON NodeTypesScopedListWarning where
        toJSON NodeTypesScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _ntslwData,
                  ("code" .=) <$> _ntslwCode,
                  ("message" .=) <$> _ntslwMessage])

-- | Informational warning which replaces the list of backend services when
-- the list is empty.
--
-- /See:/ 'targetHTTPProxiesScopedListWarning' smart constructor.
data TargetHTTPProxiesScopedListWarning =
  TargetHTTPProxiesScopedListWarning'
    { _thttppslwData :: !(Maybe [TargetHTTPProxiesScopedListWarningDataItem])
    , _thttppslwCode :: !(Maybe TargetHTTPProxiesScopedListWarningCode)
    , _thttppslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetHTTPProxiesScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'thttppslwData'
--
-- * 'thttppslwCode'
--
-- * 'thttppslwMessage'
targetHTTPProxiesScopedListWarning
    :: TargetHTTPProxiesScopedListWarning
targetHTTPProxiesScopedListWarning =
  TargetHTTPProxiesScopedListWarning'
    { _thttppslwData = Nothing
    , _thttppslwCode = Nothing
    , _thttppslwMessage = Nothing
    }


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
thttppslwData :: Lens' TargetHTTPProxiesScopedListWarning [TargetHTTPProxiesScopedListWarningDataItem]
thttppslwData
  = lens _thttppslwData
      (\ s a -> s{_thttppslwData = a})
      . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
thttppslwCode :: Lens' TargetHTTPProxiesScopedListWarning (Maybe TargetHTTPProxiesScopedListWarningCode)
thttppslwCode
  = lens _thttppslwCode
      (\ s a -> s{_thttppslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
thttppslwMessage :: Lens' TargetHTTPProxiesScopedListWarning (Maybe Text)
thttppslwMessage
  = lens _thttppslwMessage
      (\ s a -> s{_thttppslwMessage = a})

instance FromJSON TargetHTTPProxiesScopedListWarning
         where
        parseJSON
          = withObject "TargetHTTPProxiesScopedListWarning"
              (\ o ->
                 TargetHTTPProxiesScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON TargetHTTPProxiesScopedListWarning
         where
        toJSON TargetHTTPProxiesScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _thttppslwData,
                  ("code" .=) <$> _thttppslwCode,
                  ("message" .=) <$> _thttppslwMessage])

-- | A list of UrlMapsScopedList resources.
--
-- /See:/ 'urlMapsAggregatedListItems' smart constructor.
newtype URLMapsAggregatedListItems =
  URLMapsAggregatedListItems'
    { _umaliAddtional :: HashMap Text URLMapsScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'URLMapsAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'umaliAddtional'
urlMapsAggregatedListItems
    :: HashMap Text URLMapsScopedList -- ^ 'umaliAddtional'
    -> URLMapsAggregatedListItems
urlMapsAggregatedListItems pUmaliAddtional_ =
  URLMapsAggregatedListItems' {_umaliAddtional = _Coerce # pUmaliAddtional_}


-- | Name of the scope containing this set of UrlMaps.
umaliAddtional :: Lens' URLMapsAggregatedListItems (HashMap Text URLMapsScopedList)
umaliAddtional
  = lens _umaliAddtional
      (\ s a -> s{_umaliAddtional = a})
      . _Coerce

instance FromJSON URLMapsAggregatedListItems where
        parseJSON
          = withObject "URLMapsAggregatedListItems"
              (\ o ->
                 URLMapsAggregatedListItems' <$> (parseJSONObject o))

instance ToJSON URLMapsAggregatedListItems where
        toJSON = toJSON . _umaliAddtional

--
-- /See:/ 'nodeTemplateNodeTypeFlexibility' smart constructor.
data NodeTemplateNodeTypeFlexibility =
  NodeTemplateNodeTypeFlexibility'
    { _ntntfMemory :: !(Maybe Text)
    , _ntntfCPUs :: !(Maybe Text)
    , _ntntfLocalSsd :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeTemplateNodeTypeFlexibility' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ntntfMemory'
--
-- * 'ntntfCPUs'
--
-- * 'ntntfLocalSsd'
nodeTemplateNodeTypeFlexibility
    :: NodeTemplateNodeTypeFlexibility
nodeTemplateNodeTypeFlexibility =
  NodeTemplateNodeTypeFlexibility'
    {_ntntfMemory = Nothing, _ntntfCPUs = Nothing, _ntntfLocalSsd = Nothing}


ntntfMemory :: Lens' NodeTemplateNodeTypeFlexibility (Maybe Text)
ntntfMemory
  = lens _ntntfMemory (\ s a -> s{_ntntfMemory = a})

ntntfCPUs :: Lens' NodeTemplateNodeTypeFlexibility (Maybe Text)
ntntfCPUs
  = lens _ntntfCPUs (\ s a -> s{_ntntfCPUs = a})

ntntfLocalSsd :: Lens' NodeTemplateNodeTypeFlexibility (Maybe Text)
ntntfLocalSsd
  = lens _ntntfLocalSsd
      (\ s a -> s{_ntntfLocalSsd = a})

instance FromJSON NodeTemplateNodeTypeFlexibility
         where
        parseJSON
          = withObject "NodeTemplateNodeTypeFlexibility"
              (\ o ->
                 NodeTemplateNodeTypeFlexibility' <$>
                   (o .:? "memory") <*> (o .:? "cpus") <*>
                     (o .:? "localSsd"))

instance ToJSON NodeTemplateNodeTypeFlexibility where
        toJSON NodeTemplateNodeTypeFlexibility'{..}
          = object
              (catMaybes
                 [("memory" .=) <$> _ntntfMemory,
                  ("cpus" .=) <$> _ntntfCPUs,
                  ("localSsd" .=) <$> _ntntfLocalSsd])

--
-- /See:/ 'licenseResourceRequirements' smart constructor.
data LicenseResourceRequirements =
  LicenseResourceRequirements'
    { _lrrMinMemoryMb :: !(Maybe (Textual Int32))
    , _lrrMinGuestCPUCount :: !(Maybe (Textual Int32))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'LicenseResourceRequirements' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'lrrMinMemoryMb'
--
-- * 'lrrMinGuestCPUCount'
licenseResourceRequirements
    :: LicenseResourceRequirements
licenseResourceRequirements =
  LicenseResourceRequirements'
    {_lrrMinMemoryMb = Nothing, _lrrMinGuestCPUCount = Nothing}


-- | Minimum memory required to use the Instance. Enforced at Instance
-- creation and Instance start.
lrrMinMemoryMb :: Lens' LicenseResourceRequirements (Maybe Int32)
lrrMinMemoryMb
  = lens _lrrMinMemoryMb
      (\ s a -> s{_lrrMinMemoryMb = a})
      . mapping _Coerce

-- | Minimum number of guest cpus required to use the Instance. Enforced at
-- Instance creation and Instance start.
lrrMinGuestCPUCount :: Lens' LicenseResourceRequirements (Maybe Int32)
lrrMinGuestCPUCount
  = lens _lrrMinGuestCPUCount
      (\ s a -> s{_lrrMinGuestCPUCount = a})
      . mapping _Coerce

instance FromJSON LicenseResourceRequirements where
        parseJSON
          = withObject "LicenseResourceRequirements"
              (\ o ->
                 LicenseResourceRequirements' <$>
                   (o .:? "minMemoryMb") <*> (o .:? "minGuestCpuCount"))

instance ToJSON LicenseResourceRequirements where
        toJSON LicenseResourceRequirements'{..}
          = object
              (catMaybes
                 [("minMemoryMb" .=) <$> _lrrMinMemoryMb,
                  ("minGuestCpuCount" .=) <$> _lrrMinGuestCPUCount])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'regionDiskTypeListWarning' smart constructor.
data RegionDiskTypeListWarning =
  RegionDiskTypeListWarning'
    { _rdtlwData :: !(Maybe [RegionDiskTypeListWarningDataItem])
    , _rdtlwCode :: !(Maybe RegionDiskTypeListWarningCode)
    , _rdtlwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionDiskTypeListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rdtlwData'
--
-- * 'rdtlwCode'
--
-- * 'rdtlwMessage'
regionDiskTypeListWarning
    :: RegionDiskTypeListWarning
regionDiskTypeListWarning =
  RegionDiskTypeListWarning'
    {_rdtlwData = Nothing, _rdtlwCode = Nothing, _rdtlwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
rdtlwData :: Lens' RegionDiskTypeListWarning [RegionDiskTypeListWarningDataItem]
rdtlwData
  = lens _rdtlwData (\ s a -> s{_rdtlwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
rdtlwCode :: Lens' RegionDiskTypeListWarning (Maybe RegionDiskTypeListWarningCode)
rdtlwCode
  = lens _rdtlwCode (\ s a -> s{_rdtlwCode = a})

-- | [Output Only] A human-readable description of the warning code.
rdtlwMessage :: Lens' RegionDiskTypeListWarning (Maybe Text)
rdtlwMessage
  = lens _rdtlwMessage (\ s a -> s{_rdtlwMessage = a})

instance FromJSON RegionDiskTypeListWarning where
        parseJSON
          = withObject "RegionDiskTypeListWarning"
              (\ o ->
                 RegionDiskTypeListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON RegionDiskTypeListWarning where
        toJSON RegionDiskTypeListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _rdtlwData,
                  ("code" .=) <$> _rdtlwCode,
                  ("message" .=) <$> _rdtlwMessage])

-- | Disks created on the instances that will be preserved on instance
-- delete, update, etc. This map is keyed with the device names of the
-- disks.
--
-- /See:/ 'statefulPolicyPreservedStateDisks' smart constructor.
newtype StatefulPolicyPreservedStateDisks =
  StatefulPolicyPreservedStateDisks'
    { _sppsdAddtional :: HashMap Text StatefulPolicyPreservedStateDiskDevice
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'StatefulPolicyPreservedStateDisks' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sppsdAddtional'
statefulPolicyPreservedStateDisks
    :: HashMap Text StatefulPolicyPreservedStateDiskDevice -- ^ 'sppsdAddtional'
    -> StatefulPolicyPreservedStateDisks
statefulPolicyPreservedStateDisks pSppsdAddtional_ =
  StatefulPolicyPreservedStateDisks'
    {_sppsdAddtional = _Coerce # pSppsdAddtional_}


sppsdAddtional :: Lens' StatefulPolicyPreservedStateDisks (HashMap Text StatefulPolicyPreservedStateDiskDevice)
sppsdAddtional
  = lens _sppsdAddtional
      (\ s a -> s{_sppsdAddtional = a})
      . _Coerce

instance FromJSON StatefulPolicyPreservedStateDisks
         where
        parseJSON
          = withObject "StatefulPolicyPreservedStateDisks"
              (\ o ->
                 StatefulPolicyPreservedStateDisks' <$>
                   (parseJSONObject o))

instance ToJSON StatefulPolicyPreservedStateDisks
         where
        toJSON = toJSON . _sppsdAddtional

--
-- /See:/ 'targetSSLProxiesSetBackendServiceRequest' smart constructor.
newtype TargetSSLProxiesSetBackendServiceRequest =
  TargetSSLProxiesSetBackendServiceRequest'
    { _tspsbsrService :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetSSLProxiesSetBackendServiceRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tspsbsrService'
targetSSLProxiesSetBackendServiceRequest
    :: TargetSSLProxiesSetBackendServiceRequest
targetSSLProxiesSetBackendServiceRequest =
  TargetSSLProxiesSetBackendServiceRequest' {_tspsbsrService = Nothing}


-- | The URL of the new BackendService resource for the targetSslProxy.
tspsbsrService :: Lens' TargetSSLProxiesSetBackendServiceRequest (Maybe Text)
tspsbsrService
  = lens _tspsbsrService
      (\ s a -> s{_tspsbsrService = a})

instance FromJSON
           TargetSSLProxiesSetBackendServiceRequest
         where
        parseJSON
          = withObject
              "TargetSSLProxiesSetBackendServiceRequest"
              (\ o ->
                 TargetSSLProxiesSetBackendServiceRequest' <$>
                   (o .:? "service"))

instance ToJSON
           TargetSSLProxiesSetBackendServiceRequest
         where
        toJSON TargetSSLProxiesSetBackendServiceRequest'{..}
          = object
              (catMaybes [("service" .=) <$> _tspsbsrService])

-- | Represents a Forwarding Rule resource. Forwarding rule resources in GCP
-- can be either regional or global in scope: *
-- [Global](\/compute\/docs\/reference\/rest\/{$api_version}\/globalForwardingRules)
-- *
-- [Regional](\/compute\/docs\/reference\/rest\/{$api_version}\/forwardingRules)
-- A forwarding rule and its corresponding IP address represent the
-- frontend configuration of a Google Cloud Platform load balancer.
-- Forwarding rules can also reference target instances and Cloud VPN
-- Classic gateways (targetVpnGateway). For more information, read
-- Forwarding rule concepts and Using protocol forwarding. (== resource_for
-- {$api_version}.forwardingRules ==) (== resource_for
-- {$api_version}.globalForwardingRules ==) (== resource_for
-- {$api_version}.regionForwardingRules ==)
--
-- /See:/ 'forwardingRule' smart constructor.
data ForwardingRule =
  ForwardingRule'
    { _frNetworkTier :: !(Maybe ForwardingRuleNetworkTier)
    , _frIPAddress :: !(Maybe Text)
    , _frLoadBalancingScheme :: !(Maybe ForwardingRuleLoadBalancingScheme)
    , _frKind :: !Text
    , _frIsMirroringCollector :: !(Maybe Bool)
    , _frFingerprint :: !(Maybe Bytes)
    , _frIPVersion :: !(Maybe ForwardingRuleIPVersion)
    , _frAllPorts :: !(Maybe Bool)
    , _frAllowGlobalAccess :: !(Maybe Bool)
    , _frNetwork :: !(Maybe Text)
    , _frPortRange :: !(Maybe Text)
    , _frServiceDirectoryRegistrations :: !(Maybe [ForwardingRuleServiceDirectoryRegistration])
    , _frSelfLink :: !(Maybe Text)
    , _frName :: !(Maybe Text)
    , _frIPProtocol :: !(Maybe ForwardingRuleIPProtocol)
    , _frCreationTimestamp :: !(Maybe Text)
    , _frServiceName :: !(Maybe Text)
    , _frSubnetwork :: !(Maybe Text)
    , _frPorts :: !(Maybe [Text])
    , _frId :: !(Maybe (Textual Word64))
    , _frLabels :: !(Maybe ForwardingRuleLabels)
    , _frRegion :: !(Maybe Text)
    , _frPscConnectionId :: !(Maybe (Textual Word64))
    , _frServiceLabel :: !(Maybe Text)
    , _frMetadataFilters :: !(Maybe [MetadataFilter])
    , _frLabelFingerprint :: !(Maybe Bytes)
    , _frDescription :: !(Maybe Text)
    , _frTarget :: !(Maybe Text)
    , _frBackendService :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ForwardingRule' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'frNetworkTier'
--
-- * 'frIPAddress'
--
-- * 'frLoadBalancingScheme'
--
-- * 'frKind'
--
-- * 'frIsMirroringCollector'
--
-- * 'frFingerprint'
--
-- * 'frIPVersion'
--
-- * 'frAllPorts'
--
-- * 'frAllowGlobalAccess'
--
-- * 'frNetwork'
--
-- * 'frPortRange'
--
-- * 'frServiceDirectoryRegistrations'
--
-- * 'frSelfLink'
--
-- * 'frName'
--
-- * 'frIPProtocol'
--
-- * 'frCreationTimestamp'
--
-- * 'frServiceName'
--
-- * 'frSubnetwork'
--
-- * 'frPorts'
--
-- * 'frId'
--
-- * 'frLabels'
--
-- * 'frRegion'
--
-- * 'frPscConnectionId'
--
-- * 'frServiceLabel'
--
-- * 'frMetadataFilters'
--
-- * 'frLabelFingerprint'
--
-- * 'frDescription'
--
-- * 'frTarget'
--
-- * 'frBackendService'
forwardingRule
    :: ForwardingRule
forwardingRule =
  ForwardingRule'
    { _frNetworkTier = Nothing
    , _frIPAddress = Nothing
    , _frLoadBalancingScheme = Nothing
    , _frKind = "compute#forwardingRule"
    , _frIsMirroringCollector = Nothing
    , _frFingerprint = Nothing
    , _frIPVersion = Nothing
    , _frAllPorts = Nothing
    , _frAllowGlobalAccess = Nothing
    , _frNetwork = Nothing
    , _frPortRange = Nothing
    , _frServiceDirectoryRegistrations = Nothing
    , _frSelfLink = Nothing
    , _frName = Nothing
    , _frIPProtocol = Nothing
    , _frCreationTimestamp = Nothing
    , _frServiceName = Nothing
    , _frSubnetwork = Nothing
    , _frPorts = Nothing
    , _frId = Nothing
    , _frLabels = Nothing
    , _frRegion = Nothing
    , _frPscConnectionId = Nothing
    , _frServiceLabel = Nothing
    , _frMetadataFilters = Nothing
    , _frLabelFingerprint = Nothing
    , _frDescription = Nothing
    , _frTarget = Nothing
    , _frBackendService = Nothing
    }


-- | This signifies the networking tier used for configuring this load
-- balancer and can only take the following values: PREMIUM, STANDARD. For
-- regional ForwardingRule, the valid values are PREMIUM and STANDARD. For
-- GlobalForwardingRule, the valid value is PREMIUM. If this field is not
-- specified, it is assumed to be PREMIUM. If IPAddress is specified, this
-- value must be equal to the networkTier of the Address.
frNetworkTier :: Lens' ForwardingRule (Maybe ForwardingRuleNetworkTier)
frNetworkTier
  = lens _frNetworkTier
      (\ s a -> s{_frNetworkTier = a})

-- | IP address that this forwarding rule serves. When a client sends traffic
-- to this IP address, the forwarding rule directs the traffic to the
-- target that you specify in the forwarding rule. If you don\'t specify a
-- reserved IP address, an ephemeral IP address is assigned. Methods for
-- specifying an IP address: * IPv4 dotted decimal, as in \`100.1.2.3\` *
-- Full URL, as in
-- https:\/\/www.googleapis.com\/compute\/v1\/projects\/project_id\/regions\/region\/addresses\/address-name
-- * Partial URL or by name, as in: -
-- projects\/project_id\/regions\/region\/addresses\/address-name -
-- regions\/region\/addresses\/address-name -
-- global\/addresses\/address-name - address-name The loadBalancingScheme
-- and the forwarding rule\'s target determine the type of IP address that
-- you can use. For detailed information, refer to [IP address
-- specifications](\/load-balancing\/docs\/forwarding-rule-concepts#ip_address_specifications).
-- Must be set to \`0.0.0.0\` when the target is targetGrpcProxy that has
-- validateForProxyless field set to true. For Private Service Connect
-- forwarding rules that forward traffic to Google APIs, IP address must be
-- provided.
frIPAddress :: Lens' ForwardingRule (Maybe Text)
frIPAddress
  = lens _frIPAddress (\ s a -> s{_frIPAddress = a})

-- | Specifies the forwarding rule type. - EXTERNAL is used for: - Classic
-- Cloud VPN gateways - Protocol forwarding to VMs from an external IP
-- address - HTTP(S), SSL Proxy, TCP Proxy, and Network Load Balancing -
-- INTERNAL is used for: - Protocol forwarding to VMs from an internal IP
-- address - Internal TCP\/UDP Load Balancing - INTERNAL_MANAGED is used
-- for: - Internal HTTP(S) Load Balancing - INTERNAL_SELF_MANAGED is used
-- for: - Traffic Director For more information about forwarding rules,
-- refer to Forwarding rule concepts.
frLoadBalancingScheme :: Lens' ForwardingRule (Maybe ForwardingRuleLoadBalancingScheme)
frLoadBalancingScheme
  = lens _frLoadBalancingScheme
      (\ s a -> s{_frLoadBalancingScheme = a})

-- | [Output Only] Type of the resource. Always compute#forwardingRule for
-- Forwarding Rule resources.
frKind :: Lens' ForwardingRule Text
frKind = lens _frKind (\ s a -> s{_frKind = a})

-- | Indicates whether or not this load balancer can be used as a collector
-- for packet mirroring. To prevent mirroring loops, instances behind this
-- load balancer will not have their traffic mirrored even if a
-- PacketMirroring rule applies to them. This can only be set to true for
-- load balancers that have their loadBalancingScheme set to INTERNAL.
frIsMirroringCollector :: Lens' ForwardingRule (Maybe Bool)
frIsMirroringCollector
  = lens _frIsMirroringCollector
      (\ s a -> s{_frIsMirroringCollector = a})

-- | Fingerprint of this resource. A hash of the contents stored in this
-- object. This field is used in optimistic locking. This field will be
-- ignored when inserting a ForwardingRule. Include the fingerprint in
-- patch request to ensure that you do not overwrite changes that were
-- applied from another concurrent request. To see the latest fingerprint,
-- make a get() request to retrieve a ForwardingRule.
frFingerprint :: Lens' ForwardingRule (Maybe ByteString)
frFingerprint
  = lens _frFingerprint
      (\ s a -> s{_frFingerprint = a})
      . mapping _Bytes

-- | The IP Version that will be used by this forwarding rule. Valid options
-- are IPV4 or IPV6. This can only be specified for an external global
-- forwarding rule.
frIPVersion :: Lens' ForwardingRule (Maybe ForwardingRuleIPVersion)
frIPVersion
  = lens _frIPVersion (\ s a -> s{_frIPVersion = a})

-- | This field is used along with the backend_service field for Internal
-- TCP\/UDP Load Balancing or Network Load Balancing, or with the target
-- field for internal and external TargetInstance. You can only use one of
-- ports and port_range, or allPorts. The three are mutually exclusive. For
-- TCP, UDP and SCTP traffic, packets addressed to any ports will be
-- forwarded to the target or backendService.
frAllPorts :: Lens' ForwardingRule (Maybe Bool)
frAllPorts
  = lens _frAllPorts (\ s a -> s{_frAllPorts = a})

-- | This field is used along with the backend_service field for internal
-- load balancing or with the target field for internal TargetInstance. If
-- the field is set to TRUE, clients can access ILB from all regions.
-- Otherwise only allows access from clients in the same region as the
-- internal load balancer.
frAllowGlobalAccess :: Lens' ForwardingRule (Maybe Bool)
frAllowGlobalAccess
  = lens _frAllowGlobalAccess
      (\ s a -> s{_frAllowGlobalAccess = a})

-- | This field is not used for external load balancing. For Internal
-- TCP\/UDP Load Balancing, this field identifies the network that the load
-- balanced IP should belong to for this Forwarding Rule. If this field is
-- not specified, the default network will be used. For Private Service
-- Connect forwarding rules that forward traffic to Google APIs, a network
-- must be provided.
frNetwork :: Lens' ForwardingRule (Maybe Text)
frNetwork
  = lens _frNetwork (\ s a -> s{_frNetwork = a})

-- | This field can be used only if: - Load balancing scheme is one of
-- EXTERNAL, INTERNAL_SELF_MANAGED or INTERNAL_MANAGED - IPProtocol is one
-- of TCP, UDP, or SCTP. Packets addressed to ports in the specified range
-- will be forwarded to target or backend_service. You can only use one of
-- ports, port_range, or allPorts. The three are mutually exclusive.
-- Forwarding rules with the same [IPAddress, IPProtocol] pair must have
-- disjoint ports. Some types of forwarding target have constraints on the
-- acceptable ports: - TargetHttpProxy: 80, 8080 - TargetHttpsProxy: 443 -
-- TargetGrpcProxy: no constraints - TargetTcpProxy: 25, 43, 110, 143, 195,
-- 443, 465, 587, 700, 993, 995, 1688, 1883, 5222 - TargetSslProxy: 25, 43,
-- 110, 143, 195, 443, 465, 587, 700, 993, 995, 1688, 1883, 5222 -
-- TargetVpnGateway: 500, 4500
frPortRange :: Lens' ForwardingRule (Maybe Text)
frPortRange
  = lens _frPortRange (\ s a -> s{_frPortRange = a})

-- | Service Directory resources to register this forwarding rule with.
-- Currently, only supports a single Service Directory resource. It is only
-- supported for Internal TCP\/UDP Load Balancing and Internal HTTP(S) Load
-- Balancing.
frServiceDirectoryRegistrations :: Lens' ForwardingRule [ForwardingRuleServiceDirectoryRegistration]
frServiceDirectoryRegistrations
  = lens _frServiceDirectoryRegistrations
      (\ s a -> s{_frServiceDirectoryRegistrations = a})
      . _Default
      . _Coerce

-- | [Output Only] Server-defined URL for the resource.
frSelfLink :: Lens' ForwardingRule (Maybe Text)
frSelfLink
  = lens _frSelfLink (\ s a -> s{_frSelfLink = a})

-- | Name of the resource; provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
frName :: Lens' ForwardingRule (Maybe Text)
frName = lens _frName (\ s a -> s{_frName = a})

-- | The IP protocol to which this rule applies. For protocol forwarding,
-- valid options are TCP, UDP, ESP, AH, SCTP, ICMP and L3_DEFAULT. The
-- valid IP protocols are different for different load balancing products:
-- - Internal TCP\/UDP Load Balancing: The load balancing scheme is
-- INTERNAL, and one of TCP, UDP or L3_DEFAULT is valid. - Traffic
-- Director: The load balancing scheme is INTERNAL_SELF_MANAGED, and only
-- TCP is valid. - Internal HTTP(S) Load Balancing: The load balancing
-- scheme is INTERNAL_MANAGED, and only TCP is valid. - HTTP(S), SSL Proxy,
-- and TCP Proxy Load Balancing: The load balancing scheme is EXTERNAL and
-- only TCP is valid. - Network Load Balancing: The load balancing scheme
-- is EXTERNAL, and one of TCP, UDP or L3_DEFAULT is valid.
frIPProtocol :: Lens' ForwardingRule (Maybe ForwardingRuleIPProtocol)
frIPProtocol
  = lens _frIPProtocol (\ s a -> s{_frIPProtocol = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
frCreationTimestamp :: Lens' ForwardingRule (Maybe Text)
frCreationTimestamp
  = lens _frCreationTimestamp
      (\ s a -> s{_frCreationTimestamp = a})

-- | [Output Only] The internal fully qualified service name for this
-- Forwarding Rule. This field is only used for internal load balancing.
frServiceName :: Lens' ForwardingRule (Maybe Text)
frServiceName
  = lens _frServiceName
      (\ s a -> s{_frServiceName = a})

-- | This field is only used for internal load balancing. For internal load
-- balancing, this field identifies the subnetwork that the load balanced
-- IP should belong to for this Forwarding Rule. If the network specified
-- is in auto subnet mode, this field is optional. However, if the network
-- is in custom subnet mode, a subnetwork must be specified.
frSubnetwork :: Lens' ForwardingRule (Maybe Text)
frSubnetwork
  = lens _frSubnetwork (\ s a -> s{_frSubnetwork = a})

-- | The ports field is only supported when the forwarding rule references a
-- backend_service directly. Supported load balancing products are Internal
-- TCP\/UDP Load Balancing and Network Load Balancing. Only packets
-- addressed to the specified list of ports are forwarded to backends. You
-- can only use one of ports and port_range, or allPorts. The three are
-- mutually exclusive. You can specify a list of up to five ports, which
-- can be non-contiguous. Forwarding rules with the same [IPAddress,
-- IPProtocol] pair must have disjoint ports. For more information, see
-- [Port
-- specifications](\/load-balancing\/docs\/forwarding-rule-concepts#port_specifications).
frPorts :: Lens' ForwardingRule [Text]
frPorts
  = lens _frPorts (\ s a -> s{_frPorts = a}) . _Default
      . _Coerce

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
frId :: Lens' ForwardingRule (Maybe Word64)
frId
  = lens _frId (\ s a -> s{_frId = a}) .
      mapping _Coerce

-- | Labels for this resource. These can only be added or modified by the
-- setLabels method. Each label key\/value pair must comply with RFC1035.
-- Label values may be empty.
frLabels :: Lens' ForwardingRule (Maybe ForwardingRuleLabels)
frLabels = lens _frLabels (\ s a -> s{_frLabels = a})

-- | [Output Only] URL of the region where the regional forwarding rule
-- resides. This field is not applicable to global forwarding rules. You
-- must specify this field as part of the HTTP request URL. It is not
-- settable as a field in the request body.
frRegion :: Lens' ForwardingRule (Maybe Text)
frRegion = lens _frRegion (\ s a -> s{_frRegion = a})

-- | [Output Only] The PSC connection id of the PSC Forwarding Rule.
frPscConnectionId :: Lens' ForwardingRule (Maybe Word64)
frPscConnectionId
  = lens _frPscConnectionId
      (\ s a -> s{_frPscConnectionId = a})
      . mapping _Coerce

-- | An optional prefix to the service name for this Forwarding Rule. If
-- specified, the prefix is the first label of the fully qualified service
-- name. The label must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the label must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash. This field is only used for internal load balancing.
frServiceLabel :: Lens' ForwardingRule (Maybe Text)
frServiceLabel
  = lens _frServiceLabel
      (\ s a -> s{_frServiceLabel = a})

-- | Opaque filter criteria used by Loadbalancer to restrict routing
-- configuration to a limited set of xDS compliant clients. In their xDS
-- requests to Loadbalancer, xDS clients present node metadata. When there
-- is a match, the relevant configuration is made available to those
-- proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap)
-- referenced by the ForwardingRule will not be visible to those proxies.
-- For each metadataFilter in this list, if its filterMatchCriteria is set
-- to MATCH_ANY, at least one of the filterLabels must match the
-- corresponding label provided in the metadata. If its filterMatchCriteria
-- is set to MATCH_ALL, then all of its filterLabels must match with
-- corresponding labels provided in the metadata. If multiple
-- metadataFilters are specified, all of them need to be satisfied in order
-- to be considered a match. metadataFilters specified here will be
-- applifed before those specified in the UrlMap that this ForwardingRule
-- references. metadataFilters only applies to Loadbalancers that have
-- their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
frMetadataFilters :: Lens' ForwardingRule [MetadataFilter]
frMetadataFilters
  = lens _frMetadataFilters
      (\ s a -> s{_frMetadataFilters = a})
      . _Default
      . _Coerce

-- | A fingerprint for the labels being applied to this resource, which is
-- essentially a hash of the labels set used for optimistic locking. The
-- fingerprint is initially generated by Compute Engine and changes after
-- every request to modify or update labels. You must always provide an
-- up-to-date fingerprint hash in order to update or change labels,
-- otherwise the request will fail with error 412 conditionNotMet. To see
-- the latest fingerprint, make a get() request to retrieve a
-- ForwardingRule.
frLabelFingerprint :: Lens' ForwardingRule (Maybe ByteString)
frLabelFingerprint
  = lens _frLabelFingerprint
      (\ s a -> s{_frLabelFingerprint = a})
      . mapping _Bytes

-- | An optional description of this resource. Provide this property when you
-- create the resource.
frDescription :: Lens' ForwardingRule (Maybe Text)
frDescription
  = lens _frDescription
      (\ s a -> s{_frDescription = a})

frTarget :: Lens' ForwardingRule (Maybe Text)
frTarget = lens _frTarget (\ s a -> s{_frTarget = a})

-- | Identifies the backend service to which the forwarding rule sends
-- traffic. Required for Internal TCP\/UDP Load Balancing and Network Load
-- Balancing; must be omitted for all other load balancer types.
frBackendService :: Lens' ForwardingRule (Maybe Text)
frBackendService
  = lens _frBackendService
      (\ s a -> s{_frBackendService = a})

instance FromJSON ForwardingRule where
        parseJSON
          = withObject "ForwardingRule"
              (\ o ->
                 ForwardingRule' <$>
                   (o .:? "networkTier") <*> (o .:? "IPAddress") <*>
                     (o .:? "loadBalancingScheme")
                     <*> (o .:? "kind" .!= "compute#forwardingRule")
                     <*> (o .:? "isMirroringCollector")
                     <*> (o .:? "fingerprint")
                     <*> (o .:? "ipVersion")
                     <*> (o .:? "allPorts")
                     <*> (o .:? "allowGlobalAccess")
                     <*> (o .:? "network")
                     <*> (o .:? "portRange")
                     <*>
                     (o .:? "serviceDirectoryRegistrations" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "IPProtocol")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "serviceName")
                     <*> (o .:? "subnetwork")
                     <*> (o .:? "ports" .!= mempty)
                     <*> (o .:? "id")
                     <*> (o .:? "labels")
                     <*> (o .:? "region")
                     <*> (o .:? "pscConnectionId")
                     <*> (o .:? "serviceLabel")
                     <*> (o .:? "metadataFilters" .!= mempty)
                     <*> (o .:? "labelFingerprint")
                     <*> (o .:? "description")
                     <*> (o .:? "target")
                     <*> (o .:? "backendService"))

instance ToJSON ForwardingRule where
        toJSON ForwardingRule'{..}
          = object
              (catMaybes
                 [("networkTier" .=) <$> _frNetworkTier,
                  ("IPAddress" .=) <$> _frIPAddress,
                  ("loadBalancingScheme" .=) <$>
                    _frLoadBalancingScheme,
                  Just ("kind" .= _frKind),
                  ("isMirroringCollector" .=) <$>
                    _frIsMirroringCollector,
                  ("fingerprint" .=) <$> _frFingerprint,
                  ("ipVersion" .=) <$> _frIPVersion,
                  ("allPorts" .=) <$> _frAllPorts,
                  ("allowGlobalAccess" .=) <$> _frAllowGlobalAccess,
                  ("network" .=) <$> _frNetwork,
                  ("portRange" .=) <$> _frPortRange,
                  ("serviceDirectoryRegistrations" .=) <$>
                    _frServiceDirectoryRegistrations,
                  ("selfLink" .=) <$> _frSelfLink,
                  ("name" .=) <$> _frName,
                  ("IPProtocol" .=) <$> _frIPProtocol,
                  ("creationTimestamp" .=) <$> _frCreationTimestamp,
                  ("serviceName" .=) <$> _frServiceName,
                  ("subnetwork" .=) <$> _frSubnetwork,
                  ("ports" .=) <$> _frPorts, ("id" .=) <$> _frId,
                  ("labels" .=) <$> _frLabels,
                  ("region" .=) <$> _frRegion,
                  ("pscConnectionId" .=) <$> _frPscConnectionId,
                  ("serviceLabel" .=) <$> _frServiceLabel,
                  ("metadataFilters" .=) <$> _frMetadataFilters,
                  ("labelFingerprint" .=) <$> _frLabelFingerprint,
                  ("description" .=) <$> _frDescription,
                  ("target" .=) <$> _frTarget,
                  ("backendService" .=) <$> _frBackendService])

-- | Contains a list of UrlMap resources.
--
-- /See:/ 'urlMapList' smart constructor.
data URLMapList =
  URLMapList'
    { _umlNextPageToken :: !(Maybe Text)
    , _umlKind :: !Text
    , _umlItems :: !(Maybe [URLMap])
    , _umlSelfLink :: !(Maybe Text)
    , _umlWarning :: !(Maybe URLMapListWarning)
    , _umlId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'URLMapList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'umlNextPageToken'
--
-- * 'umlKind'
--
-- * 'umlItems'
--
-- * 'umlSelfLink'
--
-- * 'umlWarning'
--
-- * 'umlId'
urlMapList
    :: URLMapList
urlMapList =
  URLMapList'
    { _umlNextPageToken = Nothing
    , _umlKind = "compute#urlMapList"
    , _umlItems = Nothing
    , _umlSelfLink = Nothing
    , _umlWarning = Nothing
    , _umlId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
umlNextPageToken :: Lens' URLMapList (Maybe Text)
umlNextPageToken
  = lens _umlNextPageToken
      (\ s a -> s{_umlNextPageToken = a})

-- | Type of resource.
umlKind :: Lens' URLMapList Text
umlKind = lens _umlKind (\ s a -> s{_umlKind = a})

-- | A list of UrlMap resources.
umlItems :: Lens' URLMapList [URLMap]
umlItems
  = lens _umlItems (\ s a -> s{_umlItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
umlSelfLink :: Lens' URLMapList (Maybe Text)
umlSelfLink
  = lens _umlSelfLink (\ s a -> s{_umlSelfLink = a})

-- | [Output Only] Informational warning message.
umlWarning :: Lens' URLMapList (Maybe URLMapListWarning)
umlWarning
  = lens _umlWarning (\ s a -> s{_umlWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
umlId :: Lens' URLMapList (Maybe Text)
umlId = lens _umlId (\ s a -> s{_umlId = a})

instance FromJSON URLMapList where
        parseJSON
          = withObject "URLMapList"
              (\ o ->
                 URLMapList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#urlMapList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON URLMapList where
        toJSON URLMapList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _umlNextPageToken,
                  Just ("kind" .= _umlKind),
                  ("items" .=) <$> _umlItems,
                  ("selfLink" .=) <$> _umlSelfLink,
                  ("warning" .=) <$> _umlWarning,
                  ("id" .=) <$> _umlId])

--
-- /See:/ 'forwardingRulesScopedListWarningDataItem' smart constructor.
data ForwardingRulesScopedListWarningDataItem =
  ForwardingRulesScopedListWarningDataItem'
    { _frslwdiValue :: !(Maybe Text)
    , _frslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ForwardingRulesScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'frslwdiValue'
--
-- * 'frslwdiKey'
forwardingRulesScopedListWarningDataItem
    :: ForwardingRulesScopedListWarningDataItem
forwardingRulesScopedListWarningDataItem =
  ForwardingRulesScopedListWarningDataItem'
    {_frslwdiValue = Nothing, _frslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
frslwdiValue :: Lens' ForwardingRulesScopedListWarningDataItem (Maybe Text)
frslwdiValue
  = lens _frslwdiValue (\ s a -> s{_frslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
frslwdiKey :: Lens' ForwardingRulesScopedListWarningDataItem (Maybe Text)
frslwdiKey
  = lens _frslwdiKey (\ s a -> s{_frslwdiKey = a})

instance FromJSON
           ForwardingRulesScopedListWarningDataItem
         where
        parseJSON
          = withObject
              "ForwardingRulesScopedListWarningDataItem"
              (\ o ->
                 ForwardingRulesScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           ForwardingRulesScopedListWarningDataItem
         where
        toJSON ForwardingRulesScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _frslwdiValue,
                  ("key" .=) <$> _frslwdiKey])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'targetInstanceAggregatedListWarning' smart constructor.
data TargetInstanceAggregatedListWarning =
  TargetInstanceAggregatedListWarning'
    { _tialwData :: !(Maybe [TargetInstanceAggregatedListWarningDataItem])
    , _tialwCode :: !(Maybe TargetInstanceAggregatedListWarningCode)
    , _tialwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetInstanceAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tialwData'
--
-- * 'tialwCode'
--
-- * 'tialwMessage'
targetInstanceAggregatedListWarning
    :: TargetInstanceAggregatedListWarning
targetInstanceAggregatedListWarning =
  TargetInstanceAggregatedListWarning'
    {_tialwData = Nothing, _tialwCode = Nothing, _tialwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
tialwData :: Lens' TargetInstanceAggregatedListWarning [TargetInstanceAggregatedListWarningDataItem]
tialwData
  = lens _tialwData (\ s a -> s{_tialwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
tialwCode :: Lens' TargetInstanceAggregatedListWarning (Maybe TargetInstanceAggregatedListWarningCode)
tialwCode
  = lens _tialwCode (\ s a -> s{_tialwCode = a})

-- | [Output Only] A human-readable description of the warning code.
tialwMessage :: Lens' TargetInstanceAggregatedListWarning (Maybe Text)
tialwMessage
  = lens _tialwMessage (\ s a -> s{_tialwMessage = a})

instance FromJSON TargetInstanceAggregatedListWarning
         where
        parseJSON
          = withObject "TargetInstanceAggregatedListWarning"
              (\ o ->
                 TargetInstanceAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON TargetInstanceAggregatedListWarning
         where
        toJSON TargetInstanceAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _tialwData,
                  ("code" .=) <$> _tialwCode,
                  ("message" .=) <$> _tialwMessage])

--
-- /See:/ 'instanceGroupManagersScopedListWarningDataItem' smart constructor.
data InstanceGroupManagersScopedListWarningDataItem =
  InstanceGroupManagersScopedListWarningDataItem'
    { _igmslwdiValue :: !(Maybe Text)
    , _igmslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagersScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmslwdiValue'
--
-- * 'igmslwdiKey'
instanceGroupManagersScopedListWarningDataItem
    :: InstanceGroupManagersScopedListWarningDataItem
instanceGroupManagersScopedListWarningDataItem =
  InstanceGroupManagersScopedListWarningDataItem'
    {_igmslwdiValue = Nothing, _igmslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
igmslwdiValue :: Lens' InstanceGroupManagersScopedListWarningDataItem (Maybe Text)
igmslwdiValue
  = lens _igmslwdiValue
      (\ s a -> s{_igmslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
igmslwdiKey :: Lens' InstanceGroupManagersScopedListWarningDataItem (Maybe Text)
igmslwdiKey
  = lens _igmslwdiKey (\ s a -> s{_igmslwdiKey = a})

instance FromJSON
           InstanceGroupManagersScopedListWarningDataItem
         where
        parseJSON
          = withObject
              "InstanceGroupManagersScopedListWarningDataItem"
              (\ o ->
                 InstanceGroupManagersScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           InstanceGroupManagersScopedListWarningDataItem
         where
        toJSON
          InstanceGroupManagersScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _igmslwdiValue,
                  ("key" .=) <$> _igmslwdiKey])

--
-- /See:/ 'subnetworksScopedList' smart constructor.
data SubnetworksScopedList =
  SubnetworksScopedList'
    { _sslSubnetworks :: !(Maybe [Subnetwork])
    , _sslWarning :: !(Maybe SubnetworksScopedListWarning)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SubnetworksScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sslSubnetworks'
--
-- * 'sslWarning'
subnetworksScopedList
    :: SubnetworksScopedList
subnetworksScopedList =
  SubnetworksScopedList' {_sslSubnetworks = Nothing, _sslWarning = Nothing}


-- | A list of subnetworks contained in this scope.
sslSubnetworks :: Lens' SubnetworksScopedList [Subnetwork]
sslSubnetworks
  = lens _sslSubnetworks
      (\ s a -> s{_sslSubnetworks = a})
      . _Default
      . _Coerce

-- | An informational warning that appears when the list of addresses is
-- empty.
sslWarning :: Lens' SubnetworksScopedList (Maybe SubnetworksScopedListWarning)
sslWarning
  = lens _sslWarning (\ s a -> s{_sslWarning = a})

instance FromJSON SubnetworksScopedList where
        parseJSON
          = withObject "SubnetworksScopedList"
              (\ o ->
                 SubnetworksScopedList' <$>
                   (o .:? "subnetworks" .!= mempty) <*>
                     (o .:? "warning"))

instance ToJSON SubnetworksScopedList where
        toJSON SubnetworksScopedList'{..}
          = object
              (catMaybes
                 [("subnetworks" .=) <$> _sslSubnetworks,
                  ("warning" .=) <$> _sslWarning])

-- | The specification for allowing client side cross-origin requests. Please
-- see W3C Recommendation for Cross Origin Resource Sharing
--
-- /See:/ 'corsPolicy' smart constructor.
data CORSPolicy =
  CORSPolicy'
    { _cpMaxAge :: !(Maybe (Textual Int32))
    , _cpAllowMethods :: !(Maybe [Text])
    , _cpAllowHeaders :: !(Maybe [Text])
    , _cpDisabled :: !(Maybe Bool)
    , _cpExposeHeaders :: !(Maybe [Text])
    , _cpAllowOriginRegexes :: !(Maybe [Text])
    , _cpAllowOrigins :: !(Maybe [Text])
    , _cpAllowCredentials :: !(Maybe Bool)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'CORSPolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'cpMaxAge'
--
-- * 'cpAllowMethods'
--
-- * 'cpAllowHeaders'
--
-- * 'cpDisabled'
--
-- * 'cpExposeHeaders'
--
-- * 'cpAllowOriginRegexes'
--
-- * 'cpAllowOrigins'
--
-- * 'cpAllowCredentials'
corsPolicy
    :: CORSPolicy
corsPolicy =
  CORSPolicy'
    { _cpMaxAge = Nothing
    , _cpAllowMethods = Nothing
    , _cpAllowHeaders = Nothing
    , _cpDisabled = Nothing
    , _cpExposeHeaders = Nothing
    , _cpAllowOriginRegexes = Nothing
    , _cpAllowOrigins = Nothing
    , _cpAllowCredentials = Nothing
    }


-- | Specifies how long results of a preflight request can be cached in
-- seconds. This translates to the Access-Control-Max-Age header.
cpMaxAge :: Lens' CORSPolicy (Maybe Int32)
cpMaxAge
  = lens _cpMaxAge (\ s a -> s{_cpMaxAge = a}) .
      mapping _Coerce

-- | Specifies the content for the Access-Control-Allow-Methods header.
cpAllowMethods :: Lens' CORSPolicy [Text]
cpAllowMethods
  = lens _cpAllowMethods
      (\ s a -> s{_cpAllowMethods = a})
      . _Default
      . _Coerce

-- | Specifies the content for the Access-Control-Allow-Headers header.
cpAllowHeaders :: Lens' CORSPolicy [Text]
cpAllowHeaders
  = lens _cpAllowHeaders
      (\ s a -> s{_cpAllowHeaders = a})
      . _Default
      . _Coerce

-- | If true, specifies the CORS policy is disabled. The default value of
-- false, which indicates that the CORS policy is in effect.
cpDisabled :: Lens' CORSPolicy (Maybe Bool)
cpDisabled
  = lens _cpDisabled (\ s a -> s{_cpDisabled = a})

-- | Specifies the content for the Access-Control-Expose-Headers header.
cpExposeHeaders :: Lens' CORSPolicy [Text]
cpExposeHeaders
  = lens _cpExposeHeaders
      (\ s a -> s{_cpExposeHeaders = a})
      . _Default
      . _Coerce

-- | Specifies the regualar expression patterns that match allowed origins.
-- For regular expression grammar please see
-- github.com\/google\/re2\/wiki\/Syntax An origin is allowed if it matches
-- either an item in allowOrigins or an item in allowOriginRegexes.
cpAllowOriginRegexes :: Lens' CORSPolicy [Text]
cpAllowOriginRegexes
  = lens _cpAllowOriginRegexes
      (\ s a -> s{_cpAllowOriginRegexes = a})
      . _Default
      . _Coerce

-- | Specifies the list of origins that will be allowed to do CORS requests.
-- An origin is allowed if it matches either an item in allowOrigins or an
-- item in allowOriginRegexes.
cpAllowOrigins :: Lens' CORSPolicy [Text]
cpAllowOrigins
  = lens _cpAllowOrigins
      (\ s a -> s{_cpAllowOrigins = a})
      . _Default
      . _Coerce

-- | In response to a preflight request, setting this to true indicates that
-- the actual request can include user credentials. This translates to the
-- Access-Control-Allow-Credentials header. Default is false.
cpAllowCredentials :: Lens' CORSPolicy (Maybe Bool)
cpAllowCredentials
  = lens _cpAllowCredentials
      (\ s a -> s{_cpAllowCredentials = a})

instance FromJSON CORSPolicy where
        parseJSON
          = withObject "CORSPolicy"
              (\ o ->
                 CORSPolicy' <$>
                   (o .:? "maxAge") <*>
                     (o .:? "allowMethods" .!= mempty)
                     <*> (o .:? "allowHeaders" .!= mempty)
                     <*> (o .:? "disabled")
                     <*> (o .:? "exposeHeaders" .!= mempty)
                     <*> (o .:? "allowOriginRegexes" .!= mempty)
                     <*> (o .:? "allowOrigins" .!= mempty)
                     <*> (o .:? "allowCredentials"))

instance ToJSON CORSPolicy where
        toJSON CORSPolicy'{..}
          = object
              (catMaybes
                 [("maxAge" .=) <$> _cpMaxAge,
                  ("allowMethods" .=) <$> _cpAllowMethods,
                  ("allowHeaders" .=) <$> _cpAllowHeaders,
                  ("disabled" .=) <$> _cpDisabled,
                  ("exposeHeaders" .=) <$> _cpExposeHeaders,
                  ("allowOriginRegexes" .=) <$> _cpAllowOriginRegexes,
                  ("allowOrigins" .=) <$> _cpAllowOrigins,
                  ("allowCredentials" .=) <$> _cpAllowCredentials])

--
-- /See:/ 'networkEndpointGroupsScopedList' smart constructor.
data NetworkEndpointGroupsScopedList =
  NetworkEndpointGroupsScopedList'
    { _negslNetworkEndpointGroups :: !(Maybe [NetworkEndpointGroup])
    , _negslWarning :: !(Maybe NetworkEndpointGroupsScopedListWarning)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkEndpointGroupsScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'negslNetworkEndpointGroups'
--
-- * 'negslWarning'
networkEndpointGroupsScopedList
    :: NetworkEndpointGroupsScopedList
networkEndpointGroupsScopedList =
  NetworkEndpointGroupsScopedList'
    {_negslNetworkEndpointGroups = Nothing, _negslWarning = Nothing}


-- | [Output Only] The list of network endpoint groups that are contained in
-- this scope.
negslNetworkEndpointGroups :: Lens' NetworkEndpointGroupsScopedList [NetworkEndpointGroup]
negslNetworkEndpointGroups
  = lens _negslNetworkEndpointGroups
      (\ s a -> s{_negslNetworkEndpointGroups = a})
      . _Default
      . _Coerce

-- | [Output Only] An informational warning that replaces the list of network
-- endpoint groups when the list is empty.
negslWarning :: Lens' NetworkEndpointGroupsScopedList (Maybe NetworkEndpointGroupsScopedListWarning)
negslWarning
  = lens _negslWarning (\ s a -> s{_negslWarning = a})

instance FromJSON NetworkEndpointGroupsScopedList
         where
        parseJSON
          = withObject "NetworkEndpointGroupsScopedList"
              (\ o ->
                 NetworkEndpointGroupsScopedList' <$>
                   (o .:? "networkEndpointGroups" .!= mempty) <*>
                     (o .:? "warning"))

instance ToJSON NetworkEndpointGroupsScopedList where
        toJSON NetworkEndpointGroupsScopedList'{..}
          = object
              (catMaybes
                 [("networkEndpointGroups" .=) <$>
                    _negslNetworkEndpointGroups,
                  ("warning" .=) <$> _negslWarning])

-- | Represents a gRPC setting that describes one gRPC notification endpoint
-- and the retry duration attempting to send notification to this endpoint.
--
-- /See:/ 'notificationEndpointGrpcSettings' smart constructor.
data NotificationEndpointGrpcSettings =
  NotificationEndpointGrpcSettings'
    { _negsResendInterval :: !(Maybe Duration)
    , _negsRetryDurationSec :: !(Maybe (Textual Word32))
    , _negsPayloadName :: !(Maybe Text)
    , _negsEndpoint :: !(Maybe Text)
    , _negsAuthority :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NotificationEndpointGrpcSettings' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'negsResendInterval'
--
-- * 'negsRetryDurationSec'
--
-- * 'negsPayloadName'
--
-- * 'negsEndpoint'
--
-- * 'negsAuthority'
notificationEndpointGrpcSettings
    :: NotificationEndpointGrpcSettings
notificationEndpointGrpcSettings =
  NotificationEndpointGrpcSettings'
    { _negsResendInterval = Nothing
    , _negsRetryDurationSec = Nothing
    , _negsPayloadName = Nothing
    , _negsEndpoint = Nothing
    , _negsAuthority = Nothing
    }


-- | Optional. This field is used to configure how often to send a full
-- update of all non-healthy backends. If unspecified, full updates are not
-- sent. If specified, must be in the range between 600 seconds to 3600
-- seconds. Nanos are disallowed.
negsResendInterval :: Lens' NotificationEndpointGrpcSettings (Maybe Duration)
negsResendInterval
  = lens _negsResendInterval
      (\ s a -> s{_negsResendInterval = a})

-- | How much time (in seconds) is spent attempting notification retries
-- until a successful response is received. Default is 30s. Limit is 20m
-- (1200s). Must be a positive number.
negsRetryDurationSec :: Lens' NotificationEndpointGrpcSettings (Maybe Word32)
negsRetryDurationSec
  = lens _negsRetryDurationSec
      (\ s a -> s{_negsRetryDurationSec = a})
      . mapping _Coerce

-- | Optional. If specified, this field is used to populate the \"name\"
-- field in gRPC requests.
negsPayloadName :: Lens' NotificationEndpointGrpcSettings (Maybe Text)
negsPayloadName
  = lens _negsPayloadName
      (\ s a -> s{_negsPayloadName = a})

-- | Endpoint to which gRPC notifications are sent. This must be a valid
-- gRPCLB DNS name.
negsEndpoint :: Lens' NotificationEndpointGrpcSettings (Maybe Text)
negsEndpoint
  = lens _negsEndpoint (\ s a -> s{_negsEndpoint = a})

-- | Optional. If specified, this field is used to set the authority header
-- by the sender of notifications. See
-- https:\/\/tools.ietf.org\/html\/rfc7540#section-8.1.2.3
negsAuthority :: Lens' NotificationEndpointGrpcSettings (Maybe Text)
negsAuthority
  = lens _negsAuthority
      (\ s a -> s{_negsAuthority = a})

instance FromJSON NotificationEndpointGrpcSettings
         where
        parseJSON
          = withObject "NotificationEndpointGrpcSettings"
              (\ o ->
                 NotificationEndpointGrpcSettings' <$>
                   (o .:? "resendInterval") <*>
                     (o .:? "retryDurationSec")
                     <*> (o .:? "payloadName")
                     <*> (o .:? "endpoint")
                     <*> (o .:? "authority"))

instance ToJSON NotificationEndpointGrpcSettings
         where
        toJSON NotificationEndpointGrpcSettings'{..}
          = object
              (catMaybes
                 [("resendInterval" .=) <$> _negsResendInterval,
                  ("retryDurationSec" .=) <$> _negsRetryDurationSec,
                  ("payloadName" .=) <$> _negsPayloadName,
                  ("endpoint" .=) <$> _negsEndpoint,
                  ("authority" .=) <$> _negsAuthority])

-- | Contains a list of accelerator types.
--
-- /See:/ 'acceleratorTypeList' smart constructor.
data AcceleratorTypeList =
  AcceleratorTypeList'
    { _atlNextPageToken :: !(Maybe Text)
    , _atlKind :: !Text
    , _atlItems :: !(Maybe [AcceleratorType])
    , _atlSelfLink :: !(Maybe Text)
    , _atlWarning :: !(Maybe AcceleratorTypeListWarning)
    , _atlId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AcceleratorTypeList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'atlNextPageToken'
--
-- * 'atlKind'
--
-- * 'atlItems'
--
-- * 'atlSelfLink'
--
-- * 'atlWarning'
--
-- * 'atlId'
acceleratorTypeList
    :: AcceleratorTypeList
acceleratorTypeList =
  AcceleratorTypeList'
    { _atlNextPageToken = Nothing
    , _atlKind = "compute#acceleratorTypeList"
    , _atlItems = Nothing
    , _atlSelfLink = Nothing
    , _atlWarning = Nothing
    , _atlId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
atlNextPageToken :: Lens' AcceleratorTypeList (Maybe Text)
atlNextPageToken
  = lens _atlNextPageToken
      (\ s a -> s{_atlNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#acceleratorTypeList for
-- lists of accelerator types.
atlKind :: Lens' AcceleratorTypeList Text
atlKind = lens _atlKind (\ s a -> s{_atlKind = a})

-- | A list of AcceleratorType resources.
atlItems :: Lens' AcceleratorTypeList [AcceleratorType]
atlItems
  = lens _atlItems (\ s a -> s{_atlItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
atlSelfLink :: Lens' AcceleratorTypeList (Maybe Text)
atlSelfLink
  = lens _atlSelfLink (\ s a -> s{_atlSelfLink = a})

-- | [Output Only] Informational warning message.
atlWarning :: Lens' AcceleratorTypeList (Maybe AcceleratorTypeListWarning)
atlWarning
  = lens _atlWarning (\ s a -> s{_atlWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
atlId :: Lens' AcceleratorTypeList (Maybe Text)
atlId = lens _atlId (\ s a -> s{_atlId = a})

instance FromJSON AcceleratorTypeList where
        parseJSON
          = withObject "AcceleratorTypeList"
              (\ o ->
                 AcceleratorTypeList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#acceleratorTypeList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON AcceleratorTypeList where
        toJSON AcceleratorTypeList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _atlNextPageToken,
                  Just ("kind" .= _atlKind),
                  ("items" .=) <$> _atlItems,
                  ("selfLink" .=) <$> _atlSelfLink,
                  ("warning" .=) <$> _atlWarning,
                  ("id" .=) <$> _atlId])

--
-- /See:/ 'diskAggregatedListWarningDataItem' smart constructor.
data DiskAggregatedListWarningDataItem =
  DiskAggregatedListWarningDataItem'
    { _dalwdiValue :: !(Maybe Text)
    , _dalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DiskAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dalwdiValue'
--
-- * 'dalwdiKey'
diskAggregatedListWarningDataItem
    :: DiskAggregatedListWarningDataItem
diskAggregatedListWarningDataItem =
  DiskAggregatedListWarningDataItem'
    {_dalwdiValue = Nothing, _dalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
dalwdiValue :: Lens' DiskAggregatedListWarningDataItem (Maybe Text)
dalwdiValue
  = lens _dalwdiValue (\ s a -> s{_dalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
dalwdiKey :: Lens' DiskAggregatedListWarningDataItem (Maybe Text)
dalwdiKey
  = lens _dalwdiKey (\ s a -> s{_dalwdiKey = a})

instance FromJSON DiskAggregatedListWarningDataItem
         where
        parseJSON
          = withObject "DiskAggregatedListWarningDataItem"
              (\ o ->
                 DiskAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON DiskAggregatedListWarningDataItem
         where
        toJSON DiskAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _dalwdiValue,
                  ("key" .=) <$> _dalwdiKey])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'targetPoolListWarning' smart constructor.
data TargetPoolListWarning =
  TargetPoolListWarning'
    { _tplwData :: !(Maybe [TargetPoolListWarningDataItem])
    , _tplwCode :: !(Maybe TargetPoolListWarningCode)
    , _tplwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetPoolListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tplwData'
--
-- * 'tplwCode'
--
-- * 'tplwMessage'
targetPoolListWarning
    :: TargetPoolListWarning
targetPoolListWarning =
  TargetPoolListWarning'
    {_tplwData = Nothing, _tplwCode = Nothing, _tplwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
tplwData :: Lens' TargetPoolListWarning [TargetPoolListWarningDataItem]
tplwData
  = lens _tplwData (\ s a -> s{_tplwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
tplwCode :: Lens' TargetPoolListWarning (Maybe TargetPoolListWarningCode)
tplwCode = lens _tplwCode (\ s a -> s{_tplwCode = a})

-- | [Output Only] A human-readable description of the warning code.
tplwMessage :: Lens' TargetPoolListWarning (Maybe Text)
tplwMessage
  = lens _tplwMessage (\ s a -> s{_tplwMessage = a})

instance FromJSON TargetPoolListWarning where
        parseJSON
          = withObject "TargetPoolListWarning"
              (\ o ->
                 TargetPoolListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON TargetPoolListWarning where
        toJSON TargetPoolListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _tplwData,
                  ("code" .=) <$> _tplwCode,
                  ("message" .=) <$> _tplwMessage])

-- | Per-instance properties to be set on individual instances. Keys of this
-- map specify requested instance names. Can be empty if name_pattern is
-- used.
--
-- /See:/ 'bulkInsertInstanceResourceSchema' smart constructor.
newtype BulkInsertInstanceResourceSchema =
  BulkInsertInstanceResourceSchema'
    { _biirsAddtional :: HashMap Text BulkInsertInstanceResourcePerInstanceProperties
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BulkInsertInstanceResourceSchema' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'biirsAddtional'
bulkInsertInstanceResourceSchema
    :: HashMap Text BulkInsertInstanceResourcePerInstanceProperties -- ^ 'biirsAddtional'
    -> BulkInsertInstanceResourceSchema
bulkInsertInstanceResourceSchema pBiirsAddtional_ =
  BulkInsertInstanceResourceSchema'
    {_biirsAddtional = _Coerce # pBiirsAddtional_}


biirsAddtional :: Lens' BulkInsertInstanceResourceSchema (HashMap Text BulkInsertInstanceResourcePerInstanceProperties)
biirsAddtional
  = lens _biirsAddtional
      (\ s a -> s{_biirsAddtional = a})
      . _Coerce

instance FromJSON BulkInsertInstanceResourceSchema
         where
        parseJSON
          = withObject "BulkInsertInstanceResourceSchema"
              (\ o ->
                 BulkInsertInstanceResourceSchema' <$>
                   (parseJSONObject o))

instance ToJSON BulkInsertInstanceResourceSchema
         where
        toJSON = toJSON . _biirsAddtional

-- | [Output Only] An informational warning that appears when the node
-- templates list is empty.
--
-- /See:/ 'nodeTemplatesScopedListWarning' smart constructor.
data NodeTemplatesScopedListWarning =
  NodeTemplatesScopedListWarning'
    { _nData :: !(Maybe [NodeTemplatesScopedListWarningDataItem])
    , _nCode :: !(Maybe NodeTemplatesScopedListWarningCode)
    , _nMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeTemplatesScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nData'
--
-- * 'nCode'
--
-- * 'nMessage'
nodeTemplatesScopedListWarning
    :: NodeTemplatesScopedListWarning
nodeTemplatesScopedListWarning =
  NodeTemplatesScopedListWarning'
    {_nData = Nothing, _nCode = Nothing, _nMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
nData :: Lens' NodeTemplatesScopedListWarning [NodeTemplatesScopedListWarningDataItem]
nData
  = lens _nData (\ s a -> s{_nData = a}) . _Default .
      _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
nCode :: Lens' NodeTemplatesScopedListWarning (Maybe NodeTemplatesScopedListWarningCode)
nCode = lens _nCode (\ s a -> s{_nCode = a})

-- | [Output Only] A human-readable description of the warning code.
nMessage :: Lens' NodeTemplatesScopedListWarning (Maybe Text)
nMessage = lens _nMessage (\ s a -> s{_nMessage = a})

instance FromJSON NodeTemplatesScopedListWarning
         where
        parseJSON
          = withObject "NodeTemplatesScopedListWarning"
              (\ o ->
                 NodeTemplatesScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON NodeTemplatesScopedListWarning where
        toJSON NodeTemplatesScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _nData, ("code" .=) <$> _nCode,
                  ("message" .=) <$> _nMessage])

--
-- /See:/ 'targetPoolAggregatedListWarningDataItem' smart constructor.
data TargetPoolAggregatedListWarningDataItem =
  TargetPoolAggregatedListWarningDataItem'
    { _tpalwdiValue :: !(Maybe Text)
    , _tpalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetPoolAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tpalwdiValue'
--
-- * 'tpalwdiKey'
targetPoolAggregatedListWarningDataItem
    :: TargetPoolAggregatedListWarningDataItem
targetPoolAggregatedListWarningDataItem =
  TargetPoolAggregatedListWarningDataItem'
    {_tpalwdiValue = Nothing, _tpalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
tpalwdiValue :: Lens' TargetPoolAggregatedListWarningDataItem (Maybe Text)
tpalwdiValue
  = lens _tpalwdiValue (\ s a -> s{_tpalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
tpalwdiKey :: Lens' TargetPoolAggregatedListWarningDataItem (Maybe Text)
tpalwdiKey
  = lens _tpalwdiKey (\ s a -> s{_tpalwdiKey = a})

instance FromJSON
           TargetPoolAggregatedListWarningDataItem
         where
        parseJSON
          = withObject
              "TargetPoolAggregatedListWarningDataItem"
              (\ o ->
                 TargetPoolAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           TargetPoolAggregatedListWarningDataItem
         where
        toJSON TargetPoolAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _tpalwdiValue,
                  ("key" .=) <$> _tpalwdiKey])

-- | Represents a Project resource. A project is used to organize resources
-- in a Google Cloud Platform environment. For more information, read about
-- the Resource Hierarchy. (== resource_for {$api_version}.projects ==)
--
-- /See:/ 'project' smart constructor.
data Project =
  Project'
    { _pXpnProjectStatus :: !(Maybe ProjectXpnProjectStatus)
    , _pKind :: !Text
    , _pUsageExportLocation :: !(Maybe UsageExportLocation)
    , _pSelfLink :: !(Maybe Text)
    , _pName :: !(Maybe Text)
    , _pDefaultServiceAccount :: !(Maybe Text)
    , _pDefaultNetworkTier :: !(Maybe ProjectDefaultNetworkTier)
    , _pCreationTimestamp :: !(Maybe Text)
    , _pEnabledFeatures :: !(Maybe [Text])
    , _pQuotas :: !(Maybe [Quota])
    , _pId :: !(Maybe (Textual Word64))
    , _pDescription :: !(Maybe Text)
    , _pCommonInstanceMetadata :: !(Maybe Metadata)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Project' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pXpnProjectStatus'
--
-- * 'pKind'
--
-- * 'pUsageExportLocation'
--
-- * 'pSelfLink'
--
-- * 'pName'
--
-- * 'pDefaultServiceAccount'
--
-- * 'pDefaultNetworkTier'
--
-- * 'pCreationTimestamp'
--
-- * 'pEnabledFeatures'
--
-- * 'pQuotas'
--
-- * 'pId'
--
-- * 'pDescription'
--
-- * 'pCommonInstanceMetadata'
project
    :: Project
project =
  Project'
    { _pXpnProjectStatus = Nothing
    , _pKind = "compute#project"
    , _pUsageExportLocation = Nothing
    , _pSelfLink = Nothing
    , _pName = Nothing
    , _pDefaultServiceAccount = Nothing
    , _pDefaultNetworkTier = Nothing
    , _pCreationTimestamp = Nothing
    , _pEnabledFeatures = Nothing
    , _pQuotas = Nothing
    , _pId = Nothing
    , _pDescription = Nothing
    , _pCommonInstanceMetadata = Nothing
    }


-- | [Output Only] The role this project has in a shared VPC configuration.
-- Currently, only projects with the host role, which is specified by the
-- value HOST, are differentiated.
pXpnProjectStatus :: Lens' Project (Maybe ProjectXpnProjectStatus)
pXpnProjectStatus
  = lens _pXpnProjectStatus
      (\ s a -> s{_pXpnProjectStatus = a})

-- | [Output Only] Type of the resource. Always compute#project for projects.
pKind :: Lens' Project Text
pKind = lens _pKind (\ s a -> s{_pKind = a})

-- | The naming prefix for daily usage reports and the Google Cloud Storage
-- bucket where they are stored.
pUsageExportLocation :: Lens' Project (Maybe UsageExportLocation)
pUsageExportLocation
  = lens _pUsageExportLocation
      (\ s a -> s{_pUsageExportLocation = a})

-- | [Output Only] Server-defined URL for the resource.
pSelfLink :: Lens' Project (Maybe Text)
pSelfLink
  = lens _pSelfLink (\ s a -> s{_pSelfLink = a})

-- | The project ID. For example: my-example-project. Use the project ID to
-- make requests to Compute Engine.
pName :: Lens' Project (Maybe Text)
pName = lens _pName (\ s a -> s{_pName = a})

-- | [Output Only] Default service account used by VMs running in this
-- project.
pDefaultServiceAccount :: Lens' Project (Maybe Text)
pDefaultServiceAccount
  = lens _pDefaultServiceAccount
      (\ s a -> s{_pDefaultServiceAccount = a})

-- | This signifies the default network tier used for configuring resources
-- of the project and can only take the following values: PREMIUM,
-- STANDARD. Initially the default network tier is PREMIUM.
pDefaultNetworkTier :: Lens' Project (Maybe ProjectDefaultNetworkTier)
pDefaultNetworkTier
  = lens _pDefaultNetworkTier
      (\ s a -> s{_pDefaultNetworkTier = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
pCreationTimestamp :: Lens' Project (Maybe Text)
pCreationTimestamp
  = lens _pCreationTimestamp
      (\ s a -> s{_pCreationTimestamp = a})

-- | Restricted features enabled for use on this project.
pEnabledFeatures :: Lens' Project [Text]
pEnabledFeatures
  = lens _pEnabledFeatures
      (\ s a -> s{_pEnabledFeatures = a})
      . _Default
      . _Coerce

-- | [Output Only] Quotas assigned to this project.
pQuotas :: Lens' Project [Quota]
pQuotas
  = lens _pQuotas (\ s a -> s{_pQuotas = a}) . _Default
      . _Coerce

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server. This is not the project ID, and is just a unique
-- ID used by Compute Engine to identify resources.
pId :: Lens' Project (Maybe Word64)
pId
  = lens _pId (\ s a -> s{_pId = a}) . mapping _Coerce

-- | An optional textual description of the resource.
pDescription :: Lens' Project (Maybe Text)
pDescription
  = lens _pDescription (\ s a -> s{_pDescription = a})

-- | Metadata key\/value pairs available to all instances contained in this
-- project. See Custom metadata for more information.
pCommonInstanceMetadata :: Lens' Project (Maybe Metadata)
pCommonInstanceMetadata
  = lens _pCommonInstanceMetadata
      (\ s a -> s{_pCommonInstanceMetadata = a})

instance FromJSON Project where
        parseJSON
          = withObject "Project"
              (\ o ->
                 Project' <$>
                   (o .:? "xpnProjectStatus") <*>
                     (o .:? "kind" .!= "compute#project")
                     <*> (o .:? "usageExportLocation")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "defaultServiceAccount")
                     <*> (o .:? "defaultNetworkTier")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "enabledFeatures" .!= mempty)
                     <*> (o .:? "quotas" .!= mempty)
                     <*> (o .:? "id")
                     <*> (o .:? "description")
                     <*> (o .:? "commonInstanceMetadata"))

instance ToJSON Project where
        toJSON Project'{..}
          = object
              (catMaybes
                 [("xpnProjectStatus" .=) <$> _pXpnProjectStatus,
                  Just ("kind" .= _pKind),
                  ("usageExportLocation" .=) <$> _pUsageExportLocation,
                  ("selfLink" .=) <$> _pSelfLink,
                  ("name" .=) <$> _pName,
                  ("defaultServiceAccount" .=) <$>
                    _pDefaultServiceAccount,
                  ("defaultNetworkTier" .=) <$> _pDefaultNetworkTier,
                  ("creationTimestamp" .=) <$> _pCreationTimestamp,
                  ("enabledFeatures" .=) <$> _pEnabledFeatures,
                  ("quotas" .=) <$> _pQuotas, ("id" .=) <$> _pId,
                  ("description" .=) <$> _pDescription,
                  ("commonInstanceMetadata" .=) <$>
                    _pCommonInstanceMetadata])

--
-- /See:/ 'regionInstanceGroupManagersListInstancesResponse' smart constructor.
data RegionInstanceGroupManagersListInstancesResponse =
  RegionInstanceGroupManagersListInstancesResponse'
    { _rigmlirNextPageToken :: !(Maybe Text)
    , _rigmlirManagedInstances :: !(Maybe [ManagedInstance])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupManagersListInstancesResponse' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rigmlirNextPageToken'
--
-- * 'rigmlirManagedInstances'
regionInstanceGroupManagersListInstancesResponse
    :: RegionInstanceGroupManagersListInstancesResponse
regionInstanceGroupManagersListInstancesResponse =
  RegionInstanceGroupManagersListInstancesResponse'
    {_rigmlirNextPageToken = Nothing, _rigmlirManagedInstances = Nothing}


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
rigmlirNextPageToken :: Lens' RegionInstanceGroupManagersListInstancesResponse (Maybe Text)
rigmlirNextPageToken
  = lens _rigmlirNextPageToken
      (\ s a -> s{_rigmlirNextPageToken = a})

-- | A list of managed instances.
rigmlirManagedInstances :: Lens' RegionInstanceGroupManagersListInstancesResponse [ManagedInstance]
rigmlirManagedInstances
  = lens _rigmlirManagedInstances
      (\ s a -> s{_rigmlirManagedInstances = a})
      . _Default
      . _Coerce

instance FromJSON
           RegionInstanceGroupManagersListInstancesResponse
         where
        parseJSON
          = withObject
              "RegionInstanceGroupManagersListInstancesResponse"
              (\ o ->
                 RegionInstanceGroupManagersListInstancesResponse' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "managedInstances" .!= mempty))

instance ToJSON
           RegionInstanceGroupManagersListInstancesResponse
         where
        toJSON
          RegionInstanceGroupManagersListInstancesResponse'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _rigmlirNextPageToken,
                  ("managedInstances" .=) <$>
                    _rigmlirManagedInstances])

-- | Labels for this resource. These can only be added or modified by the
-- setLabels method. Each label key\/value pair must comply with RFC1035.
-- Label values may be empty.
--
-- /See:/ 'vpnGatewayLabels' smart constructor.
newtype VPNGatewayLabels =
  VPNGatewayLabels'
    { _vglAddtional :: HashMap Text Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNGatewayLabels' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vglAddtional'
vpnGatewayLabels
    :: HashMap Text Text -- ^ 'vglAddtional'
    -> VPNGatewayLabels
vpnGatewayLabels pVglAddtional_ =
  VPNGatewayLabels' {_vglAddtional = _Coerce # pVglAddtional_}


vglAddtional :: Lens' VPNGatewayLabels (HashMap Text Text)
vglAddtional
  = lens _vglAddtional (\ s a -> s{_vglAddtional = a})
      . _Coerce

instance FromJSON VPNGatewayLabels where
        parseJSON
          = withObject "VPNGatewayLabels"
              (\ o -> VPNGatewayLabels' <$> (parseJSONObject o))

instance ToJSON VPNGatewayLabels where
        toJSON = toJSON . _vglAddtional

--
-- /See:/ 'nodeGroupAutoscalingPolicy' smart constructor.
data NodeGroupAutoscalingPolicy =
  NodeGroupAutoscalingPolicy'
    { _ngapMode :: !(Maybe NodeGroupAutoscalingPolicyMode)
    , _ngapMinNodes :: !(Maybe (Textual Int32))
    , _ngapMaxNodes :: !(Maybe (Textual Int32))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeGroupAutoscalingPolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ngapMode'
--
-- * 'ngapMinNodes'
--
-- * 'ngapMaxNodes'
nodeGroupAutoscalingPolicy
    :: NodeGroupAutoscalingPolicy
nodeGroupAutoscalingPolicy =
  NodeGroupAutoscalingPolicy'
    {_ngapMode = Nothing, _ngapMinNodes = Nothing, _ngapMaxNodes = Nothing}


-- | The autoscaling mode. Set to one of: ON, OFF, or ONLY_SCALE_OUT. For
-- more information, see Autoscaler modes.
ngapMode :: Lens' NodeGroupAutoscalingPolicy (Maybe NodeGroupAutoscalingPolicyMode)
ngapMode = lens _ngapMode (\ s a -> s{_ngapMode = a})

-- | The minimum number of nodes that the group should have.
ngapMinNodes :: Lens' NodeGroupAutoscalingPolicy (Maybe Int32)
ngapMinNodes
  = lens _ngapMinNodes (\ s a -> s{_ngapMinNodes = a})
      . mapping _Coerce

-- | The maximum number of nodes that the group should have. Must be set if
-- autoscaling is enabled. Maximum value allowed is 100.
ngapMaxNodes :: Lens' NodeGroupAutoscalingPolicy (Maybe Int32)
ngapMaxNodes
  = lens _ngapMaxNodes (\ s a -> s{_ngapMaxNodes = a})
      . mapping _Coerce

instance FromJSON NodeGroupAutoscalingPolicy where
        parseJSON
          = withObject "NodeGroupAutoscalingPolicy"
              (\ o ->
                 NodeGroupAutoscalingPolicy' <$>
                   (o .:? "mode") <*> (o .:? "minNodes") <*>
                     (o .:? "maxNodes"))

instance ToJSON NodeGroupAutoscalingPolicy where
        toJSON NodeGroupAutoscalingPolicy'{..}
          = object
              (catMaybes
                 [("mode" .=) <$> _ngapMode,
                  ("minNodes" .=) <$> _ngapMinNodes,
                  ("maxNodes" .=) <$> _ngapMaxNodes])

-- | Represents an Operation resource. Google Compute Engine has three
-- Operation resources: *
-- [Global](\/compute\/docs\/reference\/rest\/{$api_version}\/globalOperations)
-- *
-- [Regional](\/compute\/docs\/reference\/rest\/{$api_version}\/regionOperations)
-- *
-- [Zonal](\/compute\/docs\/reference\/rest\/{$api_version}\/zoneOperations)
-- You can use an operation resource to manage asynchronous API requests.
-- For more information, read Handling API responses. Operations can be
-- global, regional or zonal. - For global operations, use the
-- \`globalOperations\` resource. - For regional operations, use the
-- \`regionOperations\` resource. - For zonal operations, use the
-- \`zonalOperations\` resource. For more information, read Global,
-- Regional, and Zonal Resources. (== resource_for
-- {$api_version}.globalOperations ==) (== resource_for
-- {$api_version}.regionOperations ==) (== resource_for
-- {$api_version}.zoneOperations ==)
--
-- /See:/ 'operation' smart constructor.
data Operation =
  Operation'
    { _oTargetId :: !(Maybe (Textual Word64))
    , _oStatus :: !(Maybe OperationStatus)
    , _oOperationGroupId :: !(Maybe Text)
    , _oInsertTime :: !(Maybe Text)
    , _oProgress :: !(Maybe (Textual Int32))
    , _oStartTime :: !(Maybe Text)
    , _oKind :: !Text
    , _oError :: !(Maybe OperationError)
    , _oHTTPErrorMessage :: !(Maybe Text)
    , _oZone :: !(Maybe Text)
    , _oWarnings :: !(Maybe [OperationWarningsItem])
    , _oHTTPErrorStatusCode :: !(Maybe (Textual Int32))
    , _oUser :: !(Maybe Text)
    , _oSelfLink :: !(Maybe Text)
    , _oName :: !(Maybe Text)
    , _oStatusMessage :: !(Maybe Text)
    , _oCreationTimestamp :: !(Maybe Text)
    , _oEndTime :: !(Maybe Text)
    , _oId :: !(Maybe (Textual Word64))
    , _oOperationType :: !(Maybe Text)
    , _oRegion :: !(Maybe Text)
    , _oDescription :: !(Maybe Text)
    , _oTargetLink :: !(Maybe Text)
    , _oClientOperationId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Operation' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'oTargetId'
--
-- * 'oStatus'
--
-- * 'oOperationGroupId'
--
-- * 'oInsertTime'
--
-- * 'oProgress'
--
-- * 'oStartTime'
--
-- * 'oKind'
--
-- * 'oError'
--
-- * 'oHTTPErrorMessage'
--
-- * 'oZone'
--
-- * 'oWarnings'
--
-- * 'oHTTPErrorStatusCode'
--
-- * 'oUser'
--
-- * 'oSelfLink'
--
-- * 'oName'
--
-- * 'oStatusMessage'
--
-- * 'oCreationTimestamp'
--
-- * 'oEndTime'
--
-- * 'oId'
--
-- * 'oOperationType'
--
-- * 'oRegion'
--
-- * 'oDescription'
--
-- * 'oTargetLink'
--
-- * 'oClientOperationId'
operation
    :: Operation
operation =
  Operation'
    { _oTargetId = Nothing
    , _oStatus = Nothing
    , _oOperationGroupId = Nothing
    , _oInsertTime = Nothing
    , _oProgress = Nothing
    , _oStartTime = Nothing
    , _oKind = "compute#operation"
    , _oError = Nothing
    , _oHTTPErrorMessage = Nothing
    , _oZone = Nothing
    , _oWarnings = Nothing
    , _oHTTPErrorStatusCode = Nothing
    , _oUser = Nothing
    , _oSelfLink = Nothing
    , _oName = Nothing
    , _oStatusMessage = Nothing
    , _oCreationTimestamp = Nothing
    , _oEndTime = Nothing
    , _oId = Nothing
    , _oOperationType = Nothing
    , _oRegion = Nothing
    , _oDescription = Nothing
    , _oTargetLink = Nothing
    , _oClientOperationId = Nothing
    }


-- | [Output Only] The unique target ID, which identifies a specific
-- incarnation of the target resource.
oTargetId :: Lens' Operation (Maybe Word64)
oTargetId
  = lens _oTargetId (\ s a -> s{_oTargetId = a}) .
      mapping _Coerce

-- | [Output Only] The status of the operation, which can be one of the
-- following: \`PENDING\`, \`RUNNING\`, or \`DONE\`.
oStatus :: Lens' Operation (Maybe OperationStatus)
oStatus = lens _oStatus (\ s a -> s{_oStatus = a})

-- | [Output Only] An ID that represents a group of operations, such as when
-- a group of operations results from a \`bulkInsert\` API request.
oOperationGroupId :: Lens' Operation (Maybe Text)
oOperationGroupId
  = lens _oOperationGroupId
      (\ s a -> s{_oOperationGroupId = a})

-- | [Output Only] The time that this operation was requested. This value is
-- in RFC3339 text format.
oInsertTime :: Lens' Operation (Maybe Text)
oInsertTime
  = lens _oInsertTime (\ s a -> s{_oInsertTime = a})

-- | [Output Only] An optional progress indicator that ranges from 0 to 100.
-- There is no requirement that this be linear or support any granularity
-- of operations. This should not be used to guess when the operation will
-- be complete. This number should monotonically increase as the operation
-- progresses.
oProgress :: Lens' Operation (Maybe Int32)
oProgress
  = lens _oProgress (\ s a -> s{_oProgress = a}) .
      mapping _Coerce

-- | [Output Only] The time that this operation was started by the server.
-- This value is in RFC3339 text format.
oStartTime :: Lens' Operation (Maybe Text)
oStartTime
  = lens _oStartTime (\ s a -> s{_oStartTime = a})

-- | [Output Only] Type of the resource. Always \`compute#operation\` for
-- Operation resources.
oKind :: Lens' Operation Text
oKind = lens _oKind (\ s a -> s{_oKind = a})

-- | [Output Only] If errors are generated during processing of the
-- operation, this field will be populated.
oError :: Lens' Operation (Maybe OperationError)
oError = lens _oError (\ s a -> s{_oError = a})

-- | [Output Only] If the operation fails, this field contains the HTTP error
-- message that was returned, such as \`NOT FOUND\`.
oHTTPErrorMessage :: Lens' Operation (Maybe Text)
oHTTPErrorMessage
  = lens _oHTTPErrorMessage
      (\ s a -> s{_oHTTPErrorMessage = a})

-- | [Output Only] The URL of the zone where the operation resides. Only
-- applicable when performing per-zone operations.
oZone :: Lens' Operation (Maybe Text)
oZone = lens _oZone (\ s a -> s{_oZone = a})

-- | [Output Only] If warning messages are generated during processing of the
-- operation, this field will be populated.
oWarnings :: Lens' Operation [OperationWarningsItem]
oWarnings
  = lens _oWarnings (\ s a -> s{_oWarnings = a}) .
      _Default
      . _Coerce

-- | [Output Only] If the operation fails, this field contains the HTTP error
-- status code that was returned. For example, a \`404\` means the resource
-- was not found.
oHTTPErrorStatusCode :: Lens' Operation (Maybe Int32)
oHTTPErrorStatusCode
  = lens _oHTTPErrorStatusCode
      (\ s a -> s{_oHTTPErrorStatusCode = a})
      . mapping _Coerce

-- | [Output Only] User who requested the operation, for example:
-- \`user\'example.com\`.
oUser :: Lens' Operation (Maybe Text)
oUser = lens _oUser (\ s a -> s{_oUser = a})

-- | [Output Only] Server-defined URL for the resource.
oSelfLink :: Lens' Operation (Maybe Text)
oSelfLink
  = lens _oSelfLink (\ s a -> s{_oSelfLink = a})

-- | [Output Only] Name of the operation.
oName :: Lens' Operation (Maybe Text)
oName = lens _oName (\ s a -> s{_oName = a})

-- | [Output Only] An optional textual description of the current status of
-- the operation.
oStatusMessage :: Lens' Operation (Maybe Text)
oStatusMessage
  = lens _oStatusMessage
      (\ s a -> s{_oStatusMessage = a})

-- | [Deprecated] This field is deprecated.
oCreationTimestamp :: Lens' Operation (Maybe Text)
oCreationTimestamp
  = lens _oCreationTimestamp
      (\ s a -> s{_oCreationTimestamp = a})

-- | [Output Only] The time that this operation was completed. This value is
-- in RFC3339 text format.
oEndTime :: Lens' Operation (Maybe Text)
oEndTime = lens _oEndTime (\ s a -> s{_oEndTime = a})

-- | [Output Only] The unique identifier for the operation. This identifier
-- is defined by the server.
oId :: Lens' Operation (Maybe Word64)
oId
  = lens _oId (\ s a -> s{_oId = a}) . mapping _Coerce

-- | [Output Only] The type of operation, such as \`insert\`, \`update\`, or
-- \`delete\`, and so on.
oOperationType :: Lens' Operation (Maybe Text)
oOperationType
  = lens _oOperationType
      (\ s a -> s{_oOperationType = a})

-- | [Output Only] The URL of the region where the operation resides. Only
-- applicable when performing regional operations.
oRegion :: Lens' Operation (Maybe Text)
oRegion = lens _oRegion (\ s a -> s{_oRegion = a})

-- | [Output Only] A textual description of the operation, which is set when
-- the operation is created.
oDescription :: Lens' Operation (Maybe Text)
oDescription
  = lens _oDescription (\ s a -> s{_oDescription = a})

-- | [Output Only] The URL of the resource that the operation modifies. For
-- operations related to creating a snapshot, this points to the persistent
-- disk that the snapshot was created from.
oTargetLink :: Lens' Operation (Maybe Text)
oTargetLink
  = lens _oTargetLink (\ s a -> s{_oTargetLink = a})

-- | [Output Only] The value of \`requestId\` if you provided it in the
-- request. Not present otherwise.
oClientOperationId :: Lens' Operation (Maybe Text)
oClientOperationId
  = lens _oClientOperationId
      (\ s a -> s{_oClientOperationId = a})

instance FromJSON Operation where
        parseJSON
          = withObject "Operation"
              (\ o ->
                 Operation' <$>
                   (o .:? "targetId") <*> (o .:? "status") <*>
                     (o .:? "operationGroupId")
                     <*> (o .:? "insertTime")
                     <*> (o .:? "progress")
                     <*> (o .:? "startTime")
                     <*> (o .:? "kind" .!= "compute#operation")
                     <*> (o .:? "error")
                     <*> (o .:? "httpErrorMessage")
                     <*> (o .:? "zone")
                     <*> (o .:? "warnings" .!= mempty)
                     <*> (o .:? "httpErrorStatusCode")
                     <*> (o .:? "user")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "statusMessage")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "endTime")
                     <*> (o .:? "id")
                     <*> (o .:? "operationType")
                     <*> (o .:? "region")
                     <*> (o .:? "description")
                     <*> (o .:? "targetLink")
                     <*> (o .:? "clientOperationId"))

instance ToJSON Operation where
        toJSON Operation'{..}
          = object
              (catMaybes
                 [("targetId" .=) <$> _oTargetId,
                  ("status" .=) <$> _oStatus,
                  ("operationGroupId" .=) <$> _oOperationGroupId,
                  ("insertTime" .=) <$> _oInsertTime,
                  ("progress" .=) <$> _oProgress,
                  ("startTime" .=) <$> _oStartTime,
                  Just ("kind" .= _oKind), ("error" .=) <$> _oError,
                  ("httpErrorMessage" .=) <$> _oHTTPErrorMessage,
                  ("zone" .=) <$> _oZone,
                  ("warnings" .=) <$> _oWarnings,
                  ("httpErrorStatusCode" .=) <$> _oHTTPErrorStatusCode,
                  ("user" .=) <$> _oUser,
                  ("selfLink" .=) <$> _oSelfLink,
                  ("name" .=) <$> _oName,
                  ("statusMessage" .=) <$> _oStatusMessage,
                  ("creationTimestamp" .=) <$> _oCreationTimestamp,
                  ("endTime" .=) <$> _oEndTime, ("id" .=) <$> _oId,
                  ("operationType" .=) <$> _oOperationType,
                  ("region" .=) <$> _oRegion,
                  ("description" .=) <$> _oDescription,
                  ("targetLink" .=) <$> _oTargetLink,
                  ("clientOperationId" .=) <$> _oClientOperationId])

-- | The network endpoint.
--
-- /See:/ 'networkEndpoint' smart constructor.
data NetworkEndpoint =
  NetworkEndpoint'
    { _neAnnotations :: !(Maybe NetworkEndpointAnnotations)
    , _neIPAddress :: !(Maybe Text)
    , _neFqdn :: !(Maybe Text)
    , _nePort :: !(Maybe (Textual Int32))
    , _neInstance :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkEndpoint' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'neAnnotations'
--
-- * 'neIPAddress'
--
-- * 'neFqdn'
--
-- * 'nePort'
--
-- * 'neInstance'
networkEndpoint
    :: NetworkEndpoint
networkEndpoint =
  NetworkEndpoint'
    { _neAnnotations = Nothing
    , _neIPAddress = Nothing
    , _neFqdn = Nothing
    , _nePort = Nothing
    , _neInstance = Nothing
    }


-- | Metadata defined as annotations on the network endpoint.
neAnnotations :: Lens' NetworkEndpoint (Maybe NetworkEndpointAnnotations)
neAnnotations
  = lens _neAnnotations
      (\ s a -> s{_neAnnotations = a})

-- | Optional IPv4 address of network endpoint. The IP address must belong to
-- a VM in Compute Engine (either the primary IP or as part of an aliased
-- IP range). If the IP address is not specified, then the primary IP
-- address for the VM instance in the network that the network endpoint
-- group belongs to will be used.
neIPAddress :: Lens' NetworkEndpoint (Maybe Text)
neIPAddress
  = lens _neIPAddress (\ s a -> s{_neIPAddress = a})

-- | Optional fully qualified domain name of network endpoint. This can only
-- be specified when NetworkEndpointGroup.network_endpoint_type is
-- NON_GCP_FQDN_PORT.
neFqdn :: Lens' NetworkEndpoint (Maybe Text)
neFqdn = lens _neFqdn (\ s a -> s{_neFqdn = a})

-- | Optional port number of network endpoint. If not specified, the
-- defaultPort for the network endpoint group will be used.
nePort :: Lens' NetworkEndpoint (Maybe Int32)
nePort
  = lens _nePort (\ s a -> s{_nePort = a}) .
      mapping _Coerce

-- | The name for a specific VM instance that the IP address belongs to. This
-- is required for network endpoints of type GCE_VM_IP_PORT. The instance
-- must be in the same zone of network endpoint group. The name must be
-- 1-63 characters long, and comply with RFC1035.
neInstance :: Lens' NetworkEndpoint (Maybe Text)
neInstance
  = lens _neInstance (\ s a -> s{_neInstance = a})

instance FromJSON NetworkEndpoint where
        parseJSON
          = withObject "NetworkEndpoint"
              (\ o ->
                 NetworkEndpoint' <$>
                   (o .:? "annotations") <*> (o .:? "ipAddress") <*>
                     (o .:? "fqdn")
                     <*> (o .:? "port")
                     <*> (o .:? "instance"))

instance ToJSON NetworkEndpoint where
        toJSON NetworkEndpoint'{..}
          = object
              (catMaybes
                 [("annotations" .=) <$> _neAnnotations,
                  ("ipAddress" .=) <$> _neIPAddress,
                  ("fqdn" .=) <$> _neFqdn, ("port" .=) <$> _nePort,
                  ("instance" .=) <$> _neInstance])

--
-- /See:/ 'disksScopedListWarningDataItem' smart constructor.
data DisksScopedListWarningDataItem =
  DisksScopedListWarningDataItem'
    { _dslwdiValue :: !(Maybe Text)
    , _dslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DisksScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dslwdiValue'
--
-- * 'dslwdiKey'
disksScopedListWarningDataItem
    :: DisksScopedListWarningDataItem
disksScopedListWarningDataItem =
  DisksScopedListWarningDataItem' {_dslwdiValue = Nothing, _dslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
dslwdiValue :: Lens' DisksScopedListWarningDataItem (Maybe Text)
dslwdiValue
  = lens _dslwdiValue (\ s a -> s{_dslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
dslwdiKey :: Lens' DisksScopedListWarningDataItem (Maybe Text)
dslwdiKey
  = lens _dslwdiKey (\ s a -> s{_dslwdiKey = a})

instance FromJSON DisksScopedListWarningDataItem
         where
        parseJSON
          = withObject "DisksScopedListWarningDataItem"
              (\ o ->
                 DisksScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON DisksScopedListWarningDataItem where
        toJSON DisksScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _dslwdiValue,
                  ("key" .=) <$> _dslwdiKey])

-- | Represents a Persistent Disk resource. Google Compute Engine has two
-- Disk resources: *
-- [Zonal](\/compute\/docs\/reference\/rest\/{$api_version}\/disks) *
-- [Regional](\/compute\/docs\/reference\/rest\/{$api_version}\/regionDisks)
-- Persistent disks are required for running your VM instances. Create both
-- boot and non-boot (data) persistent disks. For more information, read
-- Persistent Disks. For more storage options, read Storage options. The
-- disks resource represents a zonal persistent disk. For more information,
-- read Zonal persistent disks. The regionDisks resource represents a
-- regional persistent disk. For more information, read Regional resources.
-- (== resource_for {$api_version}.disks ==) (== resource_for
-- {$api_version}.regionDisks ==)
--
-- /See:/ 'disk' smart constructor.
data Disk =
  Disk'
    { _dSatisfiesPzs :: !(Maybe Bool)
    , _dStatus :: !(Maybe DiskStatus)
    , _dSourceSnapshotId :: !(Maybe Text)
    , _dLastAttachTimestamp :: !(Maybe Text)
    , _dUsers :: !(Maybe [Text])
    , _dSourceImage :: !(Maybe Text)
    , _dProvisionedIops :: !(Maybe (Textual Int64))
    , _dReplicaZones :: !(Maybe [Text])
    , _dSourceDiskId :: !(Maybe Text)
    , _dDiskEncryptionKey :: !(Maybe CustomerEncryptionKey)
    , _dSizeGb :: !(Maybe (Textual Int64))
    , _dKind :: !Text
    , _dLastDetachTimestamp :: !(Maybe Text)
    , _dGuestOSFeatures :: !(Maybe [GuestOSFeature])
    , _dZone :: !(Maybe Text)
    , _dResourcePolicies :: !(Maybe [Text])
    , _dSelfLink :: !(Maybe Text)
    , _dName :: !(Maybe Text)
    , _dSourceImageId :: !(Maybe Text)
    , _dCreationTimestamp :: !(Maybe Text)
    , _dSourceImageEncryptionKey :: !(Maybe CustomerEncryptionKey)
    , _dLicenseCodes :: !(Maybe [Textual Int64])
    , _dId :: !(Maybe (Textual Word64))
    , _dLabels :: !(Maybe DiskLabels)
    , _dLicenses :: !(Maybe [Text])
    , _dRegion :: !(Maybe Text)
    , _dOptions :: !(Maybe Text)
    , _dSourceDisk :: !(Maybe Text)
    , _dPhysicalBlockSizeBytes :: !(Maybe (Textual Int64))
    , _dType :: !(Maybe Text)
    , _dLocationHint :: !(Maybe Text)
    , _dLabelFingerprint :: !(Maybe Bytes)
    , _dDescription :: !(Maybe Text)
    , _dSourceSnapshotEncryptionKey :: !(Maybe CustomerEncryptionKey)
    , _dSourceStorageObject :: !(Maybe Text)
    , _dSourceSnapshot :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Disk' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dSatisfiesPzs'
--
-- * 'dStatus'
--
-- * 'dSourceSnapshotId'
--
-- * 'dLastAttachTimestamp'
--
-- * 'dUsers'
--
-- * 'dSourceImage'
--
-- * 'dProvisionedIops'
--
-- * 'dReplicaZones'
--
-- * 'dSourceDiskId'
--
-- * 'dDiskEncryptionKey'
--
-- * 'dSizeGb'
--
-- * 'dKind'
--
-- * 'dLastDetachTimestamp'
--
-- * 'dGuestOSFeatures'
--
-- * 'dZone'
--
-- * 'dResourcePolicies'
--
-- * 'dSelfLink'
--
-- * 'dName'
--
-- * 'dSourceImageId'
--
-- * 'dCreationTimestamp'
--
-- * 'dSourceImageEncryptionKey'
--
-- * 'dLicenseCodes'
--
-- * 'dId'
--
-- * 'dLabels'
--
-- * 'dLicenses'
--
-- * 'dRegion'
--
-- * 'dOptions'
--
-- * 'dSourceDisk'
--
-- * 'dPhysicalBlockSizeBytes'
--
-- * 'dType'
--
-- * 'dLocationHint'
--
-- * 'dLabelFingerprint'
--
-- * 'dDescription'
--
-- * 'dSourceSnapshotEncryptionKey'
--
-- * 'dSourceStorageObject'
--
-- * 'dSourceSnapshot'
disk
    :: Disk
disk =
  Disk'
    { _dSatisfiesPzs = Nothing
    , _dStatus = Nothing
    , _dSourceSnapshotId = Nothing
    , _dLastAttachTimestamp = Nothing
    , _dUsers = Nothing
    , _dSourceImage = Nothing
    , _dProvisionedIops = Nothing
    , _dReplicaZones = Nothing
    , _dSourceDiskId = Nothing
    , _dDiskEncryptionKey = Nothing
    , _dSizeGb = Nothing
    , _dKind = "compute#disk"
    , _dLastDetachTimestamp = Nothing
    , _dGuestOSFeatures = Nothing
    , _dZone = Nothing
    , _dResourcePolicies = Nothing
    , _dSelfLink = Nothing
    , _dName = Nothing
    , _dSourceImageId = Nothing
    , _dCreationTimestamp = Nothing
    , _dSourceImageEncryptionKey = Nothing
    , _dLicenseCodes = Nothing
    , _dId = Nothing
    , _dLabels = Nothing
    , _dLicenses = Nothing
    , _dRegion = Nothing
    , _dOptions = Nothing
    , _dSourceDisk = Nothing
    , _dPhysicalBlockSizeBytes = Nothing
    , _dType = Nothing
    , _dLocationHint = Nothing
    , _dLabelFingerprint = Nothing
    , _dDescription = Nothing
    , _dSourceSnapshotEncryptionKey = Nothing
    , _dSourceStorageObject = Nothing
    , _dSourceSnapshot = Nothing
    }


-- | [Output Only] Reserved for future use.
dSatisfiesPzs :: Lens' Disk (Maybe Bool)
dSatisfiesPzs
  = lens _dSatisfiesPzs
      (\ s a -> s{_dSatisfiesPzs = a})

-- | [Output Only] The status of disk creation. - CREATING: Disk is
-- provisioning. - RESTORING: Source data is being copied into the disk. -
-- FAILED: Disk creation failed. - READY: Disk is ready for use. -
-- DELETING: Disk is deleting.
dStatus :: Lens' Disk (Maybe DiskStatus)
dStatus = lens _dStatus (\ s a -> s{_dStatus = a})

-- | [Output Only] The unique ID of the snapshot used to create this disk.
-- This value identifies the exact snapshot that was used to create this
-- persistent disk. For example, if you created the persistent disk from a
-- snapshot that was later deleted and recreated under the same name, the
-- source snapshot ID would identify the exact version of the snapshot that
-- was used.
dSourceSnapshotId :: Lens' Disk (Maybe Text)
dSourceSnapshotId
  = lens _dSourceSnapshotId
      (\ s a -> s{_dSourceSnapshotId = a})

-- | [Output Only] Last attach timestamp in RFC3339 text format.
dLastAttachTimestamp :: Lens' Disk (Maybe Text)
dLastAttachTimestamp
  = lens _dLastAttachTimestamp
      (\ s a -> s{_dLastAttachTimestamp = a})

-- | [Output Only] Links to the users of the disk (attached instances) in
-- form: projects\/project\/zones\/zone\/instances\/instance
dUsers :: Lens' Disk [Text]
dUsers
  = lens _dUsers (\ s a -> s{_dUsers = a}) . _Default .
      _Coerce

-- | The source image used to create this disk. If the source image is
-- deleted, this field will not be set. To create a disk with one of the
-- public operating system images, specify the image by its family name.
-- For example, specify family\/debian-9 to use the latest Debian 9 image:
-- projects\/debian-cloud\/global\/images\/family\/debian-9 Alternatively,
-- use a specific version of a public operating system image:
-- projects\/debian-cloud\/global\/images\/debian-9-stretch-vYYYYMMDD To
-- create a disk with a custom image that you created, specify the image
-- name in the following format: global\/images\/my-custom-image You can
-- also specify a custom image by its image family, which returns the
-- latest version of the image in that family. Replace the image name with
-- family\/family-name: global\/images\/family\/my-image-family
dSourceImage :: Lens' Disk (Maybe Text)
dSourceImage
  = lens _dSourceImage (\ s a -> s{_dSourceImage = a})

-- | Indicates how many IOPS must be provisioned for the disk.
dProvisionedIops :: Lens' Disk (Maybe Int64)
dProvisionedIops
  = lens _dProvisionedIops
      (\ s a -> s{_dProvisionedIops = a})
      . mapping _Coerce

-- | URLs of the zones where the disk should be replicated to. Only
-- applicable for regional resources.
dReplicaZones :: Lens' Disk [Text]
dReplicaZones
  = lens _dReplicaZones
      (\ s a -> s{_dReplicaZones = a})
      . _Default
      . _Coerce

-- | [Output Only] The unique ID of the disk used to create this disk. This
-- value identifies the exact disk that was used to create this persistent
-- disk. For example, if you created the persistent disk from a disk that
-- was later deleted and recreated under the same name, the source disk ID
-- would identify the exact version of the disk that was used.
dSourceDiskId :: Lens' Disk (Maybe Text)
dSourceDiskId
  = lens _dSourceDiskId
      (\ s a -> s{_dSourceDiskId = a})

-- | Encrypts the disk using a customer-supplied encryption key. After you
-- encrypt a disk with a customer-supplied key, you must provide the same
-- key if you use the disk later (e.g. to create a disk snapshot, to create
-- a disk image, to create a machine image, or to attach the disk to a
-- virtual machine). Customer-supplied encryption keys do not protect
-- access to metadata of the disk. If you do not provide an encryption key
-- when creating the disk, then the disk will be encrypted using an
-- automatically generated key and you do not need to provide a key to use
-- the disk later.
dDiskEncryptionKey :: Lens' Disk (Maybe CustomerEncryptionKey)
dDiskEncryptionKey
  = lens _dDiskEncryptionKey
      (\ s a -> s{_dDiskEncryptionKey = a})

-- | Size, in GB, of the persistent disk. You can specify this field when
-- creating a persistent disk using the sourceImage, sourceSnapshot, or
-- sourceDisk parameter, or specify it alone to create an empty persistent
-- disk. If you specify this field along with a source, the value of sizeGb
-- must not be less than the size of the source. Acceptable values are 1 to
-- 65536, inclusive.
dSizeGb :: Lens' Disk (Maybe Int64)
dSizeGb
  = lens _dSizeGb (\ s a -> s{_dSizeGb = a}) .
      mapping _Coerce

-- | [Output Only] Type of the resource. Always compute#disk for disks.
dKind :: Lens' Disk Text
dKind = lens _dKind (\ s a -> s{_dKind = a})

-- | [Output Only] Last detach timestamp in RFC3339 text format.
dLastDetachTimestamp :: Lens' Disk (Maybe Text)
dLastDetachTimestamp
  = lens _dLastDetachTimestamp
      (\ s a -> s{_dLastDetachTimestamp = a})

-- | A list of features to enable on the guest operating system. Applicable
-- only for bootable images. Read Enabling guest operating system features
-- to see a list of available options.
dGuestOSFeatures :: Lens' Disk [GuestOSFeature]
dGuestOSFeatures
  = lens _dGuestOSFeatures
      (\ s a -> s{_dGuestOSFeatures = a})
      . _Default
      . _Coerce

-- | [Output Only] URL of the zone where the disk resides. You must specify
-- this field as part of the HTTP request URL. It is not settable as a
-- field in the request body.
dZone :: Lens' Disk (Maybe Text)
dZone = lens _dZone (\ s a -> s{_dZone = a})

-- | Resource policies applied to this disk for automatic snapshot creations.
dResourcePolicies :: Lens' Disk [Text]
dResourcePolicies
  = lens _dResourcePolicies
      (\ s a -> s{_dResourcePolicies = a})
      . _Default
      . _Coerce

-- | [Output Only] Server-defined fully-qualified URL for this resource.
dSelfLink :: Lens' Disk (Maybe Text)
dSelfLink
  = lens _dSelfLink (\ s a -> s{_dSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
dName :: Lens' Disk (Maybe Text)
dName = lens _dName (\ s a -> s{_dName = a})

-- | [Output Only] The ID value of the image used to create this disk. This
-- value identifies the exact image that was used to create this persistent
-- disk. For example, if you created the persistent disk from an image that
-- was later deleted and recreated under the same name, the source image ID
-- would identify the exact version of the image that was used.
dSourceImageId :: Lens' Disk (Maybe Text)
dSourceImageId
  = lens _dSourceImageId
      (\ s a -> s{_dSourceImageId = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
dCreationTimestamp :: Lens' Disk (Maybe Text)
dCreationTimestamp
  = lens _dCreationTimestamp
      (\ s a -> s{_dCreationTimestamp = a})

-- | The customer-supplied encryption key of the source image. Required if
-- the source image is protected by a customer-supplied encryption key.
dSourceImageEncryptionKey :: Lens' Disk (Maybe CustomerEncryptionKey)
dSourceImageEncryptionKey
  = lens _dSourceImageEncryptionKey
      (\ s a -> s{_dSourceImageEncryptionKey = a})

-- | Integer license codes indicating which licenses are attached to this
-- disk.
dLicenseCodes :: Lens' Disk [Int64]
dLicenseCodes
  = lens _dLicenseCodes
      (\ s a -> s{_dLicenseCodes = a})
      . _Default
      . _Coerce

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
dId :: Lens' Disk (Maybe Word64)
dId
  = lens _dId (\ s a -> s{_dId = a}) . mapping _Coerce

-- | Labels to apply to this disk. These can be later modified by the
-- setLabels method.
dLabels :: Lens' Disk (Maybe DiskLabels)
dLabels = lens _dLabels (\ s a -> s{_dLabels = a})

-- | A list of publicly visible licenses. Reserved for Google\'s use.
dLicenses :: Lens' Disk [Text]
dLicenses
  = lens _dLicenses (\ s a -> s{_dLicenses = a}) .
      _Default
      . _Coerce

-- | [Output Only] URL of the region where the disk resides. Only applicable
-- for regional resources. You must specify this field as part of the HTTP
-- request URL. It is not settable as a field in the request body.
dRegion :: Lens' Disk (Maybe Text)
dRegion = lens _dRegion (\ s a -> s{_dRegion = a})

-- | Internal use only.
dOptions :: Lens' Disk (Maybe Text)
dOptions = lens _dOptions (\ s a -> s{_dOptions = a})

-- | The source disk used to create this disk. You can provide this as a
-- partial or full URL to the resource. For example, the following are
-- valid values: -
-- https:\/\/www.googleapis.com\/compute\/v1\/projects\/project\/zones\/zone\/disks\/disk
-- -
-- https:\/\/www.googleapis.com\/compute\/v1\/projects\/project\/regions\/region\/disks\/disk
-- - projects\/project\/zones\/zone\/disks\/disk -
-- projects\/project\/regions\/region\/disks\/disk -
-- zones\/zone\/disks\/disk - regions\/region\/disks\/disk
dSourceDisk :: Lens' Disk (Maybe Text)
dSourceDisk
  = lens _dSourceDisk (\ s a -> s{_dSourceDisk = a})

-- | Physical block size of the persistent disk, in bytes. If not present in
-- a request, a default value is used. The currently supported size is
-- 4096, other sizes may be added in the future. If an unsupported value is
-- requested, the error message will list the supported values for the
-- caller\'s project.
dPhysicalBlockSizeBytes :: Lens' Disk (Maybe Int64)
dPhysicalBlockSizeBytes
  = lens _dPhysicalBlockSizeBytes
      (\ s a -> s{_dPhysicalBlockSizeBytes = a})
      . mapping _Coerce

-- | URL of the disk type resource describing which disk type to use to
-- create the disk. Provide this when creating the disk. For example:
-- projects\/project\/zones\/zone\/diskTypes\/pd-standard or pd-ssd
dType :: Lens' Disk (Maybe Text)
dType = lens _dType (\ s a -> s{_dType = a})

-- | An opaque location hint used to place the disk close to other resources.
-- This field is for use by internal tools that use the public API.
dLocationHint :: Lens' Disk (Maybe Text)
dLocationHint
  = lens _dLocationHint
      (\ s a -> s{_dLocationHint = a})

-- | A fingerprint for the labels being applied to this disk, which is
-- essentially a hash of the labels set used for optimistic locking. The
-- fingerprint is initially generated by Compute Engine and changes after
-- every request to modify or update labels. You must always provide an
-- up-to-date fingerprint hash in order to update or change labels,
-- otherwise the request will fail with error 412 conditionNotMet. To see
-- the latest fingerprint, make a get() request to retrieve a disk.
dLabelFingerprint :: Lens' Disk (Maybe ByteString)
dLabelFingerprint
  = lens _dLabelFingerprint
      (\ s a -> s{_dLabelFingerprint = a})
      . mapping _Bytes

-- | An optional description of this resource. Provide this property when you
-- create the resource.
dDescription :: Lens' Disk (Maybe Text)
dDescription
  = lens _dDescription (\ s a -> s{_dDescription = a})

-- | The customer-supplied encryption key of the source snapshot. Required if
-- the source snapshot is protected by a customer-supplied encryption key.
dSourceSnapshotEncryptionKey :: Lens' Disk (Maybe CustomerEncryptionKey)
dSourceSnapshotEncryptionKey
  = lens _dSourceSnapshotEncryptionKey
      (\ s a -> s{_dSourceSnapshotEncryptionKey = a})

-- | The full Google Cloud Storage URI where the disk image is stored. This
-- file must be a gzip-compressed tarball whose name ends in .tar.gz or
-- virtual machine disk whose name ends in vmdk. Valid URIs may start with
-- gs:\/\/ or https:\/\/storage.googleapis.com\/. This flag is not
-- optimized for creating multiple disks from a source storage object. To
-- create many disks from a source storage object, use gcloud compute
-- images import instead.
dSourceStorageObject :: Lens' Disk (Maybe Text)
dSourceStorageObject
  = lens _dSourceStorageObject
      (\ s a -> s{_dSourceStorageObject = a})

-- | The source snapshot used to create this disk. You can provide this as a
-- partial or full URL to the resource. For example, the following are
-- valid values: -
-- https:\/\/www.googleapis.com\/compute\/v1\/projects\/project\/global\/snapshots\/snapshot
-- - projects\/project\/global\/snapshots\/snapshot -
-- global\/snapshots\/snapshot
dSourceSnapshot :: Lens' Disk (Maybe Text)
dSourceSnapshot
  = lens _dSourceSnapshot
      (\ s a -> s{_dSourceSnapshot = a})

instance FromJSON Disk where
        parseJSON
          = withObject "Disk"
              (\ o ->
                 Disk' <$>
                   (o .:? "satisfiesPzs") <*> (o .:? "status") <*>
                     (o .:? "sourceSnapshotId")
                     <*> (o .:? "lastAttachTimestamp")
                     <*> (o .:? "users" .!= mempty)
                     <*> (o .:? "sourceImage")
                     <*> (o .:? "provisionedIops")
                     <*> (o .:? "replicaZones" .!= mempty)
                     <*> (o .:? "sourceDiskId")
                     <*> (o .:? "diskEncryptionKey")
                     <*> (o .:? "sizeGb")
                     <*> (o .:? "kind" .!= "compute#disk")
                     <*> (o .:? "lastDetachTimestamp")
                     <*> (o .:? "guestOsFeatures" .!= mempty)
                     <*> (o .:? "zone")
                     <*> (o .:? "resourcePolicies" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "sourceImageId")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "sourceImageEncryptionKey")
                     <*> (o .:? "licenseCodes" .!= mempty)
                     <*> (o .:? "id")
                     <*> (o .:? "labels")
                     <*> (o .:? "licenses" .!= mempty)
                     <*> (o .:? "region")
                     <*> (o .:? "options")
                     <*> (o .:? "sourceDisk")
                     <*> (o .:? "physicalBlockSizeBytes")
                     <*> (o .:? "type")
                     <*> (o .:? "locationHint")
                     <*> (o .:? "labelFingerprint")
                     <*> (o .:? "description")
                     <*> (o .:? "sourceSnapshotEncryptionKey")
                     <*> (o .:? "sourceStorageObject")
                     <*> (o .:? "sourceSnapshot"))

instance ToJSON Disk where
        toJSON Disk'{..}
          = object
              (catMaybes
                 [("satisfiesPzs" .=) <$> _dSatisfiesPzs,
                  ("status" .=) <$> _dStatus,
                  ("sourceSnapshotId" .=) <$> _dSourceSnapshotId,
                  ("lastAttachTimestamp" .=) <$> _dLastAttachTimestamp,
                  ("users" .=) <$> _dUsers,
                  ("sourceImage" .=) <$> _dSourceImage,
                  ("provisionedIops" .=) <$> _dProvisionedIops,
                  ("replicaZones" .=) <$> _dReplicaZones,
                  ("sourceDiskId" .=) <$> _dSourceDiskId,
                  ("diskEncryptionKey" .=) <$> _dDiskEncryptionKey,
                  ("sizeGb" .=) <$> _dSizeGb, Just ("kind" .= _dKind),
                  ("lastDetachTimestamp" .=) <$> _dLastDetachTimestamp,
                  ("guestOsFeatures" .=) <$> _dGuestOSFeatures,
                  ("zone" .=) <$> _dZone,
                  ("resourcePolicies" .=) <$> _dResourcePolicies,
                  ("selfLink" .=) <$> _dSelfLink,
                  ("name" .=) <$> _dName,
                  ("sourceImageId" .=) <$> _dSourceImageId,
                  ("creationTimestamp" .=) <$> _dCreationTimestamp,
                  ("sourceImageEncryptionKey" .=) <$>
                    _dSourceImageEncryptionKey,
                  ("licenseCodes" .=) <$> _dLicenseCodes,
                  ("id" .=) <$> _dId, ("labels" .=) <$> _dLabels,
                  ("licenses" .=) <$> _dLicenses,
                  ("region" .=) <$> _dRegion,
                  ("options" .=) <$> _dOptions,
                  ("sourceDisk" .=) <$> _dSourceDisk,
                  ("physicalBlockSizeBytes" .=) <$>
                    _dPhysicalBlockSizeBytes,
                  ("type" .=) <$> _dType,
                  ("locationHint" .=) <$> _dLocationHint,
                  ("labelFingerprint" .=) <$> _dLabelFingerprint,
                  ("description" .=) <$> _dDescription,
                  ("sourceSnapshotEncryptionKey" .=) <$>
                    _dSourceSnapshotEncryptionKey,
                  ("sourceStorageObject" .=) <$> _dSourceStorageObject,
                  ("sourceSnapshot" .=) <$> _dSourceSnapshot])

--
-- /See:/ 'reservationListWarningDataItem' smart constructor.
data ReservationListWarningDataItem =
  ReservationListWarningDataItem'
    { _rlwdiValue :: !(Maybe Text)
    , _rlwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ReservationListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rlwdiValue'
--
-- * 'rlwdiKey'
reservationListWarningDataItem
    :: ReservationListWarningDataItem
reservationListWarningDataItem =
  ReservationListWarningDataItem' {_rlwdiValue = Nothing, _rlwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
rlwdiValue :: Lens' ReservationListWarningDataItem (Maybe Text)
rlwdiValue
  = lens _rlwdiValue (\ s a -> s{_rlwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
rlwdiKey :: Lens' ReservationListWarningDataItem (Maybe Text)
rlwdiKey = lens _rlwdiKey (\ s a -> s{_rlwdiKey = a})

instance FromJSON ReservationListWarningDataItem
         where
        parseJSON
          = withObject "ReservationListWarningDataItem"
              (\ o ->
                 ReservationListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON ReservationListWarningDataItem where
        toJSON ReservationListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _rlwdiValue,
                  ("key" .=) <$> _rlwdiKey])

--
-- /See:/ 'usableSubnetworksAggregatedListWarningDataItem' smart constructor.
data UsableSubnetworksAggregatedListWarningDataItem =
  UsableSubnetworksAggregatedListWarningDataItem'
    { _usalwdiValue :: !(Maybe Text)
    , _usalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'UsableSubnetworksAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'usalwdiValue'
--
-- * 'usalwdiKey'
usableSubnetworksAggregatedListWarningDataItem
    :: UsableSubnetworksAggregatedListWarningDataItem
usableSubnetworksAggregatedListWarningDataItem =
  UsableSubnetworksAggregatedListWarningDataItem'
    {_usalwdiValue = Nothing, _usalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
usalwdiValue :: Lens' UsableSubnetworksAggregatedListWarningDataItem (Maybe Text)
usalwdiValue
  = lens _usalwdiValue (\ s a -> s{_usalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
usalwdiKey :: Lens' UsableSubnetworksAggregatedListWarningDataItem (Maybe Text)
usalwdiKey
  = lens _usalwdiKey (\ s a -> s{_usalwdiKey = a})

instance FromJSON
           UsableSubnetworksAggregatedListWarningDataItem
         where
        parseJSON
          = withObject
              "UsableSubnetworksAggregatedListWarningDataItem"
              (\ o ->
                 UsableSubnetworksAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           UsableSubnetworksAggregatedListWarningDataItem
         where
        toJSON
          UsableSubnetworksAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _usalwdiValue,
                  ("key" .=) <$> _usalwdiKey])

-- | Contains a list of nodeGroups.
--
-- /See:/ 'nodeGroupList' smart constructor.
data NodeGroupList =
  NodeGroupList'
    { _nglNextPageToken :: !(Maybe Text)
    , _nglKind :: !Text
    , _nglItems :: !(Maybe [NodeGroup])
    , _nglSelfLink :: !(Maybe Text)
    , _nglWarning :: !(Maybe NodeGroupListWarning)
    , _nglId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeGroupList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nglNextPageToken'
--
-- * 'nglKind'
--
-- * 'nglItems'
--
-- * 'nglSelfLink'
--
-- * 'nglWarning'
--
-- * 'nglId'
nodeGroupList
    :: NodeGroupList
nodeGroupList =
  NodeGroupList'
    { _nglNextPageToken = Nothing
    , _nglKind = "compute#nodeGroupList"
    , _nglItems = Nothing
    , _nglSelfLink = Nothing
    , _nglWarning = Nothing
    , _nglId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
nglNextPageToken :: Lens' NodeGroupList (Maybe Text)
nglNextPageToken
  = lens _nglNextPageToken
      (\ s a -> s{_nglNextPageToken = a})

-- | [Output Only] Type of resource.Always compute#nodeGroupList for lists of
-- node groups.
nglKind :: Lens' NodeGroupList Text
nglKind = lens _nglKind (\ s a -> s{_nglKind = a})

-- | A list of NodeGroup resources.
nglItems :: Lens' NodeGroupList [NodeGroup]
nglItems
  = lens _nglItems (\ s a -> s{_nglItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
nglSelfLink :: Lens' NodeGroupList (Maybe Text)
nglSelfLink
  = lens _nglSelfLink (\ s a -> s{_nglSelfLink = a})

-- | [Output Only] Informational warning message.
nglWarning :: Lens' NodeGroupList (Maybe NodeGroupListWarning)
nglWarning
  = lens _nglWarning (\ s a -> s{_nglWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
nglId :: Lens' NodeGroupList (Maybe Text)
nglId = lens _nglId (\ s a -> s{_nglId = a})

instance FromJSON NodeGroupList where
        parseJSON
          = withObject "NodeGroupList"
              (\ o ->
                 NodeGroupList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#nodeGroupList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON NodeGroupList where
        toJSON NodeGroupList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _nglNextPageToken,
                  Just ("kind" .= _nglKind),
                  ("items" .=) <$> _nglItems,
                  ("selfLink" .=) <$> _nglSelfLink,
                  ("warning" .=) <$> _nglWarning,
                  ("id" .=) <$> _nglId])

--
-- /See:/ 'publicDelegatedPrefixAggregatedList' smart constructor.
data PublicDelegatedPrefixAggregatedList =
  PublicDelegatedPrefixAggregatedList'
    { _pdpalUnreachables :: !(Maybe [Text])
    , _pdpalNextPageToken :: !(Maybe Text)
    , _pdpalKind :: !Text
    , _pdpalItems :: !(Maybe PublicDelegatedPrefixAggregatedListItems)
    , _pdpalSelfLink :: !(Maybe Text)
    , _pdpalWarning :: !(Maybe PublicDelegatedPrefixAggregatedListWarning)
    , _pdpalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PublicDelegatedPrefixAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pdpalUnreachables'
--
-- * 'pdpalNextPageToken'
--
-- * 'pdpalKind'
--
-- * 'pdpalItems'
--
-- * 'pdpalSelfLink'
--
-- * 'pdpalWarning'
--
-- * 'pdpalId'
publicDelegatedPrefixAggregatedList
    :: PublicDelegatedPrefixAggregatedList
publicDelegatedPrefixAggregatedList =
  PublicDelegatedPrefixAggregatedList'
    { _pdpalUnreachables = Nothing
    , _pdpalNextPageToken = Nothing
    , _pdpalKind = "compute#publicDelegatedPrefixAggregatedList"
    , _pdpalItems = Nothing
    , _pdpalSelfLink = Nothing
    , _pdpalWarning = Nothing
    , _pdpalId = Nothing
    }


-- | [Output Only] Unreachable resources.
pdpalUnreachables :: Lens' PublicDelegatedPrefixAggregatedList [Text]
pdpalUnreachables
  = lens _pdpalUnreachables
      (\ s a -> s{_pdpalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
pdpalNextPageToken :: Lens' PublicDelegatedPrefixAggregatedList (Maybe Text)
pdpalNextPageToken
  = lens _pdpalNextPageToken
      (\ s a -> s{_pdpalNextPageToken = a})

-- | [Output Only] Type of the resource. Always
-- compute#publicDelegatedPrefixAggregatedList for aggregated lists of
-- public delegated prefixes.
pdpalKind :: Lens' PublicDelegatedPrefixAggregatedList Text
pdpalKind
  = lens _pdpalKind (\ s a -> s{_pdpalKind = a})

-- | A list of PublicDelegatedPrefixesScopedList resources.
pdpalItems :: Lens' PublicDelegatedPrefixAggregatedList (Maybe PublicDelegatedPrefixAggregatedListItems)
pdpalItems
  = lens _pdpalItems (\ s a -> s{_pdpalItems = a})

-- | [Output Only] Server-defined URL for this resource.
pdpalSelfLink :: Lens' PublicDelegatedPrefixAggregatedList (Maybe Text)
pdpalSelfLink
  = lens _pdpalSelfLink
      (\ s a -> s{_pdpalSelfLink = a})

-- | [Output Only] Informational warning message.
pdpalWarning :: Lens' PublicDelegatedPrefixAggregatedList (Maybe PublicDelegatedPrefixAggregatedListWarning)
pdpalWarning
  = lens _pdpalWarning (\ s a -> s{_pdpalWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
pdpalId :: Lens' PublicDelegatedPrefixAggregatedList (Maybe Text)
pdpalId = lens _pdpalId (\ s a -> s{_pdpalId = a})

instance FromJSON PublicDelegatedPrefixAggregatedList
         where
        parseJSON
          = withObject "PublicDelegatedPrefixAggregatedList"
              (\ o ->
                 PublicDelegatedPrefixAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!=
                        "compute#publicDelegatedPrefixAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON PublicDelegatedPrefixAggregatedList
         where
        toJSON PublicDelegatedPrefixAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _pdpalUnreachables,
                  ("nextPageToken" .=) <$> _pdpalNextPageToken,
                  Just ("kind" .= _pdpalKind),
                  ("items" .=) <$> _pdpalItems,
                  ("selfLink" .=) <$> _pdpalSelfLink,
                  ("warning" .=) <$> _pdpalWarning,
                  ("id" .=) <$> _pdpalId])

--
-- /See:/ 'diskMoveRequest' smart constructor.
data DiskMoveRequest =
  DiskMoveRequest'
    { _dmrTargetDisk :: !(Maybe Text)
    , _dmrDestinationZone :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DiskMoveRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dmrTargetDisk'
--
-- * 'dmrDestinationZone'
diskMoveRequest
    :: DiskMoveRequest
diskMoveRequest =
  DiskMoveRequest' {_dmrTargetDisk = Nothing, _dmrDestinationZone = Nothing}


-- | The URL of the target disk to move. This can be a full or partial URL.
-- For example, the following are all valid URLs to a disk: -
-- https:\/\/www.googleapis.com\/compute\/v1\/projects\/project\/zones\/zone\/disks\/disk
-- - projects\/project\/zones\/zone\/disks\/disk - zones\/zone\/disks\/disk
dmrTargetDisk :: Lens' DiskMoveRequest (Maybe Text)
dmrTargetDisk
  = lens _dmrTargetDisk
      (\ s a -> s{_dmrTargetDisk = a})

-- | The URL of the destination zone to move the disk. This can be a full or
-- partial URL. For example, the following are all valid URLs to a zone: -
-- https:\/\/www.googleapis.com\/compute\/v1\/projects\/project\/zones\/zone
-- - projects\/project\/zones\/zone - zones\/zone
dmrDestinationZone :: Lens' DiskMoveRequest (Maybe Text)
dmrDestinationZone
  = lens _dmrDestinationZone
      (\ s a -> s{_dmrDestinationZone = a})

instance FromJSON DiskMoveRequest where
        parseJSON
          = withObject "DiskMoveRequest"
              (\ o ->
                 DiskMoveRequest' <$>
                   (o .:? "targetDisk") <*> (o .:? "destinationZone"))

instance ToJSON DiskMoveRequest where
        toJSON DiskMoveRequest'{..}
          = object
              (catMaybes
                 [("targetDisk" .=) <$> _dmrTargetDisk,
                  ("destinationZone" .=) <$> _dmrDestinationZone])

--
-- /See:/ 'sslPolicyWarningsItemDataItem' smart constructor.
data SSLPolicyWarningsItemDataItem =
  SSLPolicyWarningsItemDataItem'
    { _spwidiValue :: !(Maybe Text)
    , _spwidiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SSLPolicyWarningsItemDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'spwidiValue'
--
-- * 'spwidiKey'
sslPolicyWarningsItemDataItem
    :: SSLPolicyWarningsItemDataItem
sslPolicyWarningsItemDataItem =
  SSLPolicyWarningsItemDataItem' {_spwidiValue = Nothing, _spwidiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
spwidiValue :: Lens' SSLPolicyWarningsItemDataItem (Maybe Text)
spwidiValue
  = lens _spwidiValue (\ s a -> s{_spwidiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
spwidiKey :: Lens' SSLPolicyWarningsItemDataItem (Maybe Text)
spwidiKey
  = lens _spwidiKey (\ s a -> s{_spwidiKey = a})

instance FromJSON SSLPolicyWarningsItemDataItem where
        parseJSON
          = withObject "SSLPolicyWarningsItemDataItem"
              (\ o ->
                 SSLPolicyWarningsItemDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON SSLPolicyWarningsItemDataItem where
        toJSON SSLPolicyWarningsItemDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _spwidiValue,
                  ("key" .=) <$> _spwidiKey])

-- | Configuration parameters of autoscaling based on load balancing.
--
-- /See:/ 'autoscalingPolicyLoadBalancingUtilization' smart constructor.
newtype AutoscalingPolicyLoadBalancingUtilization =
  AutoscalingPolicyLoadBalancingUtilization'
    { _aplbuUtilizationTarget :: Maybe (Textual Double)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AutoscalingPolicyLoadBalancingUtilization' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'aplbuUtilizationTarget'
autoscalingPolicyLoadBalancingUtilization
    :: AutoscalingPolicyLoadBalancingUtilization
autoscalingPolicyLoadBalancingUtilization =
  AutoscalingPolicyLoadBalancingUtilization' {_aplbuUtilizationTarget = Nothing}


-- | Fraction of backend capacity utilization (set in HTTP(S) load balancing
-- configuration) that the autoscaler maintains. Must be a positive float
-- value. If not defined, the default is 0.8.
aplbuUtilizationTarget :: Lens' AutoscalingPolicyLoadBalancingUtilization (Maybe Double)
aplbuUtilizationTarget
  = lens _aplbuUtilizationTarget
      (\ s a -> s{_aplbuUtilizationTarget = a})
      . mapping _Coerce

instance FromJSON
           AutoscalingPolicyLoadBalancingUtilization
         where
        parseJSON
          = withObject
              "AutoscalingPolicyLoadBalancingUtilization"
              (\ o ->
                 AutoscalingPolicyLoadBalancingUtilization' <$>
                   (o .:? "utilizationTarget"))

instance ToJSON
           AutoscalingPolicyLoadBalancingUtilization
         where
        toJSON AutoscalingPolicyLoadBalancingUtilization'{..}
          = object
              (catMaybes
                 [("utilizationTarget" .=) <$>
                    _aplbuUtilizationTarget])

--
-- /See:/ 'networkEndpointGroupsListNetworkEndpoints' smart constructor.
data NetworkEndpointGroupsListNetworkEndpoints =
  NetworkEndpointGroupsListNetworkEndpoints'
    { _neglneNextPageToken :: !(Maybe Text)
    , _neglneKind :: !Text
    , _neglneItems :: !(Maybe [NetworkEndpointWithHealthStatus])
    , _neglneWarning :: !(Maybe NetworkEndpointGroupsListNetworkEndpointsWarning)
    , _neglneId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkEndpointGroupsListNetworkEndpoints' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'neglneNextPageToken'
--
-- * 'neglneKind'
--
-- * 'neglneItems'
--
-- * 'neglneWarning'
--
-- * 'neglneId'
networkEndpointGroupsListNetworkEndpoints
    :: NetworkEndpointGroupsListNetworkEndpoints
networkEndpointGroupsListNetworkEndpoints =
  NetworkEndpointGroupsListNetworkEndpoints'
    { _neglneNextPageToken = Nothing
    , _neglneKind = "compute#networkEndpointGroupsListNetworkEndpoints"
    , _neglneItems = Nothing
    , _neglneWarning = Nothing
    , _neglneId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
neglneNextPageToken :: Lens' NetworkEndpointGroupsListNetworkEndpoints (Maybe Text)
neglneNextPageToken
  = lens _neglneNextPageToken
      (\ s a -> s{_neglneNextPageToken = a})

-- | [Output Only] The resource type, which is always
-- compute#networkEndpointGroupsListNetworkEndpoints for the list of
-- network endpoints in the specified network endpoint group.
neglneKind :: Lens' NetworkEndpointGroupsListNetworkEndpoints Text
neglneKind
  = lens _neglneKind (\ s a -> s{_neglneKind = a})

-- | A list of NetworkEndpointWithHealthStatus resources.
neglneItems :: Lens' NetworkEndpointGroupsListNetworkEndpoints [NetworkEndpointWithHealthStatus]
neglneItems
  = lens _neglneItems (\ s a -> s{_neglneItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Informational warning message.
neglneWarning :: Lens' NetworkEndpointGroupsListNetworkEndpoints (Maybe NetworkEndpointGroupsListNetworkEndpointsWarning)
neglneWarning
  = lens _neglneWarning
      (\ s a -> s{_neglneWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
neglneId :: Lens' NetworkEndpointGroupsListNetworkEndpoints (Maybe Text)
neglneId = lens _neglneId (\ s a -> s{_neglneId = a})

instance FromJSON
           NetworkEndpointGroupsListNetworkEndpoints
         where
        parseJSON
          = withObject
              "NetworkEndpointGroupsListNetworkEndpoints"
              (\ o ->
                 NetworkEndpointGroupsListNetworkEndpoints' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!=
                        "compute#networkEndpointGroupsListNetworkEndpoints")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON
           NetworkEndpointGroupsListNetworkEndpoints
         where
        toJSON NetworkEndpointGroupsListNetworkEndpoints'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _neglneNextPageToken,
                  Just ("kind" .= _neglneKind),
                  ("items" .=) <$> _neglneItems,
                  ("warning" .=) <$> _neglneWarning,
                  ("id" .=) <$> _neglneId])

--
-- /See:/ 'forwardingRuleAggregatedListWarningDataItem' smart constructor.
data ForwardingRuleAggregatedListWarningDataItem =
  ForwardingRuleAggregatedListWarningDataItem'
    { _fralwdiValue :: !(Maybe Text)
    , _fralwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ForwardingRuleAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'fralwdiValue'
--
-- * 'fralwdiKey'
forwardingRuleAggregatedListWarningDataItem
    :: ForwardingRuleAggregatedListWarningDataItem
forwardingRuleAggregatedListWarningDataItem =
  ForwardingRuleAggregatedListWarningDataItem'
    {_fralwdiValue = Nothing, _fralwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
fralwdiValue :: Lens' ForwardingRuleAggregatedListWarningDataItem (Maybe Text)
fralwdiValue
  = lens _fralwdiValue (\ s a -> s{_fralwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
fralwdiKey :: Lens' ForwardingRuleAggregatedListWarningDataItem (Maybe Text)
fralwdiKey
  = lens _fralwdiKey (\ s a -> s{_fralwdiKey = a})

instance FromJSON
           ForwardingRuleAggregatedListWarningDataItem
         where
        parseJSON
          = withObject
              "ForwardingRuleAggregatedListWarningDataItem"
              (\ o ->
                 ForwardingRuleAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           ForwardingRuleAggregatedListWarningDataItem
         where
        toJSON
          ForwardingRuleAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _fralwdiValue,
                  ("key" .=) <$> _fralwdiKey])

--
-- /See:/ 'targetPoolsScopedListWarningDataItem' smart constructor.
data TargetPoolsScopedListWarningDataItem =
  TargetPoolsScopedListWarningDataItem'
    { _tpslwdiValue :: !(Maybe Text)
    , _tpslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetPoolsScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tpslwdiValue'
--
-- * 'tpslwdiKey'
targetPoolsScopedListWarningDataItem
    :: TargetPoolsScopedListWarningDataItem
targetPoolsScopedListWarningDataItem =
  TargetPoolsScopedListWarningDataItem'
    {_tpslwdiValue = Nothing, _tpslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
tpslwdiValue :: Lens' TargetPoolsScopedListWarningDataItem (Maybe Text)
tpslwdiValue
  = lens _tpslwdiValue (\ s a -> s{_tpslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
tpslwdiKey :: Lens' TargetPoolsScopedListWarningDataItem (Maybe Text)
tpslwdiKey
  = lens _tpslwdiKey (\ s a -> s{_tpslwdiKey = a})

instance FromJSON
           TargetPoolsScopedListWarningDataItem
         where
        parseJSON
          = withObject "TargetPoolsScopedListWarningDataItem"
              (\ o ->
                 TargetPoolsScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON TargetPoolsScopedListWarningDataItem
         where
        toJSON TargetPoolsScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _tpslwdiValue,
                  ("key" .=) <$> _tpslwdiKey])

-- | Whether the instance is a standby. Properties of a standby instance
-- comparing to the regular instance:
-- =========================================================================
-- | regular | standby
-- =========================================================================
-- managed by IGM? | yes | yes added to the IG? | yes | yes counts towards
-- IGM\'s target size? | yes | no taken into account by Autoscaler? | yes |
-- no receives traffic from LB? | yes | no
-- =========================================================================
-- Represents a Managed Instance Group resource. An instance group is a
-- collection of VM instances that you can manage as a single entity. For
-- more information, read Instance groups. For zonal Managed Instance
-- Group, use the instanceGroupManagers resource. For regional Managed
-- Instance Group, use the regionInstanceGroupManagers resource. (==
-- resource_for {$api_version}.instanceGroupManagers ==) (== resource_for
-- {$api_version}.regionInstanceGroupManagers ==)
--
-- /See:/ 'instanceGroupManager' smart constructor.
data InstanceGroupManager =
  InstanceGroupManager'
    { _igmStatus :: !(Maybe InstanceGroupManagerStatus)
    , _igmKind :: !Text
    , _igmStatefulPolicy :: !(Maybe StatefulPolicy)
    , _igmFingerprint :: !(Maybe Bytes)
    , _igmBaseInstanceName :: !(Maybe Text)
    , _igmZone :: !(Maybe Text)
    , _igmAutoHealingPolicies :: !(Maybe [InstanceGroupManagerAutoHealingPolicy])
    , _igmVersions :: !(Maybe [InstanceGroupManagerVersion])
    , _igmInstanceTemplate :: !(Maybe Text)
    , _igmUpdatePolicy :: !(Maybe InstanceGroupManagerUpdatePolicy)
    , _igmTargetSize :: !(Maybe (Textual Int32))
    , _igmSelfLink :: !(Maybe Text)
    , _igmCurrentActions :: !(Maybe InstanceGroupManagerActionsSummary)
    , _igmName :: !(Maybe Text)
    , _igmCreationTimestamp :: !(Maybe Text)
    , _igmDistributionPolicy :: !(Maybe DistributionPolicy)
    , _igmId :: !(Maybe (Textual Word64))
    , _igmRegion :: !(Maybe Text)
    , _igmTargetPools :: !(Maybe [Text])
    , _igmDescription :: !(Maybe Text)
    , _igmInstanceGroup :: !(Maybe Text)
    , _igmNamedPorts :: !(Maybe [NamedPort])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManager' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmStatus'
--
-- * 'igmKind'
--
-- * 'igmStatefulPolicy'
--
-- * 'igmFingerprint'
--
-- * 'igmBaseInstanceName'
--
-- * 'igmZone'
--
-- * 'igmAutoHealingPolicies'
--
-- * 'igmVersions'
--
-- * 'igmInstanceTemplate'
--
-- * 'igmUpdatePolicy'
--
-- * 'igmTargetSize'
--
-- * 'igmSelfLink'
--
-- * 'igmCurrentActions'
--
-- * 'igmName'
--
-- * 'igmCreationTimestamp'
--
-- * 'igmDistributionPolicy'
--
-- * 'igmId'
--
-- * 'igmRegion'
--
-- * 'igmTargetPools'
--
-- * 'igmDescription'
--
-- * 'igmInstanceGroup'
--
-- * 'igmNamedPorts'
instanceGroupManager
    :: InstanceGroupManager
instanceGroupManager =
  InstanceGroupManager'
    { _igmStatus = Nothing
    , _igmKind = "compute#instanceGroupManager"
    , _igmStatefulPolicy = Nothing
    , _igmFingerprint = Nothing
    , _igmBaseInstanceName = Nothing
    , _igmZone = Nothing
    , _igmAutoHealingPolicies = Nothing
    , _igmVersions = Nothing
    , _igmInstanceTemplate = Nothing
    , _igmUpdatePolicy = Nothing
    , _igmTargetSize = Nothing
    , _igmSelfLink = Nothing
    , _igmCurrentActions = Nothing
    , _igmName = Nothing
    , _igmCreationTimestamp = Nothing
    , _igmDistributionPolicy = Nothing
    , _igmId = Nothing
    , _igmRegion = Nothing
    , _igmTargetPools = Nothing
    , _igmDescription = Nothing
    , _igmInstanceGroup = Nothing
    , _igmNamedPorts = Nothing
    }


-- | [Output Only] The status of this managed instance group.
igmStatus :: Lens' InstanceGroupManager (Maybe InstanceGroupManagerStatus)
igmStatus
  = lens _igmStatus (\ s a -> s{_igmStatus = a})

-- | [Output Only] The resource type, which is always
-- compute#instanceGroupManager for managed instance groups.
igmKind :: Lens' InstanceGroupManager Text
igmKind = lens _igmKind (\ s a -> s{_igmKind = a})

-- | Stateful configuration for this Instanced Group Manager
igmStatefulPolicy :: Lens' InstanceGroupManager (Maybe StatefulPolicy)
igmStatefulPolicy
  = lens _igmStatefulPolicy
      (\ s a -> s{_igmStatefulPolicy = a})

-- | Fingerprint of this resource. This field may be used in optimistic
-- locking. It will be ignored when inserting an InstanceGroupManager. An
-- up-to-date fingerprint must be provided in order to update the
-- InstanceGroupManager, otherwise the request will fail with error 412
-- conditionNotMet. To see the latest fingerprint, make a get() request to
-- retrieve an InstanceGroupManager.
igmFingerprint :: Lens' InstanceGroupManager (Maybe ByteString)
igmFingerprint
  = lens _igmFingerprint
      (\ s a -> s{_igmFingerprint = a})
      . mapping _Bytes

-- | The base instance name to use for instances in this group. The value
-- must be 1-58 characters long. Instances are named by appending a hyphen
-- and a random four-character string to the base instance name. The base
-- instance name must comply with RFC1035.
igmBaseInstanceName :: Lens' InstanceGroupManager (Maybe Text)
igmBaseInstanceName
  = lens _igmBaseInstanceName
      (\ s a -> s{_igmBaseInstanceName = a})

-- | [Output Only] The URL of a zone where the managed instance group is
-- located (for zonal resources).
igmZone :: Lens' InstanceGroupManager (Maybe Text)
igmZone = lens _igmZone (\ s a -> s{_igmZone = a})

-- | The autohealing policy for this managed instance group. You can specify
-- only one value.
igmAutoHealingPolicies :: Lens' InstanceGroupManager [InstanceGroupManagerAutoHealingPolicy]
igmAutoHealingPolicies
  = lens _igmAutoHealingPolicies
      (\ s a -> s{_igmAutoHealingPolicies = a})
      . _Default
      . _Coerce

-- | Specifies the instance templates used by this managed instance group to
-- create instances. Each version is defined by an instanceTemplate and a
-- name. Every version can appear at most once per instance group. This
-- field overrides the top-level instanceTemplate field. Read more about
-- the relationships between these fields. Exactly one version must leave
-- the targetSize field unset. That version will be applied to all
-- remaining instances. For more information, read about canary updates.
igmVersions :: Lens' InstanceGroupManager [InstanceGroupManagerVersion]
igmVersions
  = lens _igmVersions (\ s a -> s{_igmVersions = a}) .
      _Default
      . _Coerce

-- | The URL of the instance template that is specified for this managed
-- instance group. The group uses this template to create all new instances
-- in the managed instance group. The templates for existing instances in
-- the group do not change unless you run recreateInstances, run
-- applyUpdatesToInstances, or set the group\'s updatePolicy.type to
-- PROACTIVE.
igmInstanceTemplate :: Lens' InstanceGroupManager (Maybe Text)
igmInstanceTemplate
  = lens _igmInstanceTemplate
      (\ s a -> s{_igmInstanceTemplate = a})

-- | The update policy for this managed instance group.
igmUpdatePolicy :: Lens' InstanceGroupManager (Maybe InstanceGroupManagerUpdatePolicy)
igmUpdatePolicy
  = lens _igmUpdatePolicy
      (\ s a -> s{_igmUpdatePolicy = a})

-- | The target number of running instances for this managed instance group.
-- You can reduce this number by using the instanceGroupManager
-- deleteInstances or abandonInstances methods. Resizing the group also
-- changes this number.
igmTargetSize :: Lens' InstanceGroupManager (Maybe Int32)
igmTargetSize
  = lens _igmTargetSize
      (\ s a -> s{_igmTargetSize = a})
      . mapping _Coerce

-- | [Output Only] The URL for this managed instance group. The server
-- defines this URL.
igmSelfLink :: Lens' InstanceGroupManager (Maybe Text)
igmSelfLink
  = lens _igmSelfLink (\ s a -> s{_igmSelfLink = a})

-- | [Output Only] The list of instance actions and the number of instances
-- in this managed instance group that are scheduled for each of those
-- actions.
igmCurrentActions :: Lens' InstanceGroupManager (Maybe InstanceGroupManagerActionsSummary)
igmCurrentActions
  = lens _igmCurrentActions
      (\ s a -> s{_igmCurrentActions = a})

-- | The name of the managed instance group. The name must be 1-63 characters
-- long, and comply with RFC1035.
igmName :: Lens' InstanceGroupManager (Maybe Text)
igmName = lens _igmName (\ s a -> s{_igmName = a})

-- | [Output Only] The creation timestamp for this managed instance group in
-- RFC3339 text format.
igmCreationTimestamp :: Lens' InstanceGroupManager (Maybe Text)
igmCreationTimestamp
  = lens _igmCreationTimestamp
      (\ s a -> s{_igmCreationTimestamp = a})

-- | Policy specifying the intended distribution of managed instances across
-- zones in a regional managed instance group.
igmDistributionPolicy :: Lens' InstanceGroupManager (Maybe DistributionPolicy)
igmDistributionPolicy
  = lens _igmDistributionPolicy
      (\ s a -> s{_igmDistributionPolicy = a})

-- | [Output Only] A unique identifier for this resource type. The server
-- generates this identifier.
igmId :: Lens' InstanceGroupManager (Maybe Word64)
igmId
  = lens _igmId (\ s a -> s{_igmId = a}) .
      mapping _Coerce

-- | [Output Only] The URL of the region where the managed instance group
-- resides (for regional resources).
igmRegion :: Lens' InstanceGroupManager (Maybe Text)
igmRegion
  = lens _igmRegion (\ s a -> s{_igmRegion = a})

-- | The URLs for all TargetPool resources to which instances in the
-- instanceGroup field are added. The target pools automatically apply to
-- all of the instances in the managed instance group.
igmTargetPools :: Lens' InstanceGroupManager [Text]
igmTargetPools
  = lens _igmTargetPools
      (\ s a -> s{_igmTargetPools = a})
      . _Default
      . _Coerce

-- | An optional description of this resource. Provide this property when you
-- create the resource.
igmDescription :: Lens' InstanceGroupManager (Maybe Text)
igmDescription
  = lens _igmDescription
      (\ s a -> s{_igmDescription = a})

-- | [Output Only] The URL of the Instance Group resource.
igmInstanceGroup :: Lens' InstanceGroupManager (Maybe Text)
igmInstanceGroup
  = lens _igmInstanceGroup
      (\ s a -> s{_igmInstanceGroup = a})

-- | Named ports configured for the Instance Groups complementary to this
-- Instance Group Manager.
igmNamedPorts :: Lens' InstanceGroupManager [NamedPort]
igmNamedPorts
  = lens _igmNamedPorts
      (\ s a -> s{_igmNamedPorts = a})
      . _Default
      . _Coerce

instance FromJSON InstanceGroupManager where
        parseJSON
          = withObject "InstanceGroupManager"
              (\ o ->
                 InstanceGroupManager' <$>
                   (o .:? "status") <*>
                     (o .:? "kind" .!= "compute#instanceGroupManager")
                     <*> (o .:? "statefulPolicy")
                     <*> (o .:? "fingerprint")
                     <*> (o .:? "baseInstanceName")
                     <*> (o .:? "zone")
                     <*> (o .:? "autoHealingPolicies" .!= mempty)
                     <*> (o .:? "versions" .!= mempty)
                     <*> (o .:? "instanceTemplate")
                     <*> (o .:? "updatePolicy")
                     <*> (o .:? "targetSize")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "currentActions")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "distributionPolicy")
                     <*> (o .:? "id")
                     <*> (o .:? "region")
                     <*> (o .:? "targetPools" .!= mempty)
                     <*> (o .:? "description")
                     <*> (o .:? "instanceGroup")
                     <*> (o .:? "namedPorts" .!= mempty))

instance ToJSON InstanceGroupManager where
        toJSON InstanceGroupManager'{..}
          = object
              (catMaybes
                 [("status" .=) <$> _igmStatus,
                  Just ("kind" .= _igmKind),
                  ("statefulPolicy" .=) <$> _igmStatefulPolicy,
                  ("fingerprint" .=) <$> _igmFingerprint,
                  ("baseInstanceName" .=) <$> _igmBaseInstanceName,
                  ("zone" .=) <$> _igmZone,
                  ("autoHealingPolicies" .=) <$>
                    _igmAutoHealingPolicies,
                  ("versions" .=) <$> _igmVersions,
                  ("instanceTemplate" .=) <$> _igmInstanceTemplate,
                  ("updatePolicy" .=) <$> _igmUpdatePolicy,
                  ("targetSize" .=) <$> _igmTargetSize,
                  ("selfLink" .=) <$> _igmSelfLink,
                  ("currentActions" .=) <$> _igmCurrentActions,
                  ("name" .=) <$> _igmName,
                  ("creationTimestamp" .=) <$> _igmCreationTimestamp,
                  ("distributionPolicy" .=) <$> _igmDistributionPolicy,
                  ("id" .=) <$> _igmId, ("region" .=) <$> _igmRegion,
                  ("targetPools" .=) <$> _igmTargetPools,
                  ("description" .=) <$> _igmDescription,
                  ("instanceGroup" .=) <$> _igmInstanceGroup,
                  ("namedPorts" .=) <$> _igmNamedPorts])

--
-- /See:/ 'packetMirroringMirroredResourceInfo' smart constructor.
data PacketMirroringMirroredResourceInfo =
  PacketMirroringMirroredResourceInfo'
    { _pmmriSubnetworks :: !(Maybe [PacketMirroringMirroredResourceInfoSubnetInfo])
    , _pmmriInstances :: !(Maybe [PacketMirroringMirroredResourceInfoInstanceInfo])
    , _pmmriTags :: !(Maybe [Text])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PacketMirroringMirroredResourceInfo' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pmmriSubnetworks'
--
-- * 'pmmriInstances'
--
-- * 'pmmriTags'
packetMirroringMirroredResourceInfo
    :: PacketMirroringMirroredResourceInfo
packetMirroringMirroredResourceInfo =
  PacketMirroringMirroredResourceInfo'
    { _pmmriSubnetworks = Nothing
    , _pmmriInstances = Nothing
    , _pmmriTags = Nothing
    }


-- | A set of subnetworks for which traffic from\/to all VM instances will be
-- mirrored. They must live in the same region as this packetMirroring. You
-- may specify a maximum of 5 subnetworks.
pmmriSubnetworks :: Lens' PacketMirroringMirroredResourceInfo [PacketMirroringMirroredResourceInfoSubnetInfo]
pmmriSubnetworks
  = lens _pmmriSubnetworks
      (\ s a -> s{_pmmriSubnetworks = a})
      . _Default
      . _Coerce

-- | A set of virtual machine instances that are being mirrored. They must
-- live in zones contained in the same region as this packetMirroring. Note
-- that this config will apply only to those network interfaces of the
-- Instances that belong to the network specified in this packetMirroring.
-- You may specify a maximum of 50 Instances.
pmmriInstances :: Lens' PacketMirroringMirroredResourceInfo [PacketMirroringMirroredResourceInfoInstanceInfo]
pmmriInstances
  = lens _pmmriInstances
      (\ s a -> s{_pmmriInstances = a})
      . _Default
      . _Coerce

-- | A set of mirrored tags. Traffic from\/to all VM instances that have one
-- or more of these tags will be mirrored.
pmmriTags :: Lens' PacketMirroringMirroredResourceInfo [Text]
pmmriTags
  = lens _pmmriTags (\ s a -> s{_pmmriTags = a}) .
      _Default
      . _Coerce

instance FromJSON PacketMirroringMirroredResourceInfo
         where
        parseJSON
          = withObject "PacketMirroringMirroredResourceInfo"
              (\ o ->
                 PacketMirroringMirroredResourceInfo' <$>
                   (o .:? "subnetworks" .!= mempty) <*>
                     (o .:? "instances" .!= mempty)
                     <*> (o .:? "tags" .!= mempty))

instance ToJSON PacketMirroringMirroredResourceInfo
         where
        toJSON PacketMirroringMirroredResourceInfo'{..}
          = object
              (catMaybes
                 [("subnetworks" .=) <$> _pmmriSubnetworks,
                  ("instances" .=) <$> _pmmriInstances,
                  ("tags" .=) <$> _pmmriTags])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'instanceGroupManagerListWarning' smart constructor.
data InstanceGroupManagerListWarning =
  InstanceGroupManagerListWarning'
    { _igmlwData :: !(Maybe [InstanceGroupManagerListWarningDataItem])
    , _igmlwCode :: !(Maybe InstanceGroupManagerListWarningCode)
    , _igmlwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagerListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmlwData'
--
-- * 'igmlwCode'
--
-- * 'igmlwMessage'
instanceGroupManagerListWarning
    :: InstanceGroupManagerListWarning
instanceGroupManagerListWarning =
  InstanceGroupManagerListWarning'
    {_igmlwData = Nothing, _igmlwCode = Nothing, _igmlwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
igmlwData :: Lens' InstanceGroupManagerListWarning [InstanceGroupManagerListWarningDataItem]
igmlwData
  = lens _igmlwData (\ s a -> s{_igmlwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
igmlwCode :: Lens' InstanceGroupManagerListWarning (Maybe InstanceGroupManagerListWarningCode)
igmlwCode
  = lens _igmlwCode (\ s a -> s{_igmlwCode = a})

-- | [Output Only] A human-readable description of the warning code.
igmlwMessage :: Lens' InstanceGroupManagerListWarning (Maybe Text)
igmlwMessage
  = lens _igmlwMessage (\ s a -> s{_igmlwMessage = a})

instance FromJSON InstanceGroupManagerListWarning
         where
        parseJSON
          = withObject "InstanceGroupManagerListWarning"
              (\ o ->
                 InstanceGroupManagerListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON InstanceGroupManagerListWarning where
        toJSON InstanceGroupManagerListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _igmlwData,
                  ("code" .=) <$> _igmlwCode,
                  ("message" .=) <$> _igmlwMessage])

-- | Opaque filter criteria used by loadbalancers to restrict routing
-- configuration to a limited set of loadbalancing proxies. Proxies and
-- sidecars involved in loadbalancing would typically present metadata to
-- the loadbalancers which need to match criteria specified here. If a
-- match takes place, the relevant configuration is made available to those
-- proxies. For each metadataFilter in this list, if its
-- filterMatchCriteria is set to MATCH_ANY, at least one of the
-- filterLabels must match the corresponding label provided in the
-- metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of
-- its filterLabels must match with corresponding labels provided in the
-- metadata. An example for using metadataFilters would be: if
-- loadbalancing involves Envoys, they will only receive routing
-- configuration when values in metadataFilters match values supplied in
--
-- /See:/ 'metadataFilter' smart constructor.
data MetadataFilter =
  MetadataFilter'
    { _mfFilterLabels :: !(Maybe [MetadataFilterLabelMatch])
    , _mfFilterMatchCriteria :: !(Maybe MetadataFilterFilterMatchCriteria)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'MetadataFilter' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'mfFilterLabels'
--
-- * 'mfFilterMatchCriteria'
metadataFilter
    :: MetadataFilter
metadataFilter =
  MetadataFilter' {_mfFilterLabels = Nothing, _mfFilterMatchCriteria = Nothing}


-- | The list of label value pairs that must match labels in the provided
-- metadata based on filterMatchCriteria This list must not be empty and
-- can have at the most 64 entries.
mfFilterLabels :: Lens' MetadataFilter [MetadataFilterLabelMatch]
mfFilterLabels
  = lens _mfFilterLabels
      (\ s a -> s{_mfFilterLabels = a})
      . _Default
      . _Coerce

-- | Specifies how individual filterLabel matches within the list of
-- filterLabels contribute towards the overall metadataFilter match.
-- Supported values are: - MATCH_ANY: At least one of the filterLabels must
-- have a matching label in the provided metadata. - MATCH_ALL: All
-- filterLabels must have matching labels in the provided metadata.
mfFilterMatchCriteria :: Lens' MetadataFilter (Maybe MetadataFilterFilterMatchCriteria)
mfFilterMatchCriteria
  = lens _mfFilterMatchCriteria
      (\ s a -> s{_mfFilterMatchCriteria = a})

instance FromJSON MetadataFilter where
        parseJSON
          = withObject "MetadataFilter"
              (\ o ->
                 MetadataFilter' <$>
                   (o .:? "filterLabels" .!= mempty) <*>
                     (o .:? "filterMatchCriteria"))

instance ToJSON MetadataFilter where
        toJSON MetadataFilter'{..}
          = object
              (catMaybes
                 [("filterLabels" .=) <$> _mfFilterLabels,
                  ("filterMatchCriteria" .=) <$>
                    _mfFilterMatchCriteria])

--
-- /See:/ 'regionInstanceGroupsListInstances' smart constructor.
data RegionInstanceGroupsListInstances =
  RegionInstanceGroupsListInstances'
    { _rigliNextPageToken :: !(Maybe Text)
    , _rigliKind :: !Text
    , _rigliItems :: !(Maybe [InstanceWithNamedPorts])
    , _rigliSelfLink :: !(Maybe Text)
    , _rigliWarning :: !(Maybe RegionInstanceGroupsListInstancesWarning)
    , _rigliId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupsListInstances' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rigliNextPageToken'
--
-- * 'rigliKind'
--
-- * 'rigliItems'
--
-- * 'rigliSelfLink'
--
-- * 'rigliWarning'
--
-- * 'rigliId'
regionInstanceGroupsListInstances
    :: RegionInstanceGroupsListInstances
regionInstanceGroupsListInstances =
  RegionInstanceGroupsListInstances'
    { _rigliNextPageToken = Nothing
    , _rigliKind = "compute#regionInstanceGroupsListInstances"
    , _rigliItems = Nothing
    , _rigliSelfLink = Nothing
    , _rigliWarning = Nothing
    , _rigliId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
rigliNextPageToken :: Lens' RegionInstanceGroupsListInstances (Maybe Text)
rigliNextPageToken
  = lens _rigliNextPageToken
      (\ s a -> s{_rigliNextPageToken = a})

-- | The resource type.
rigliKind :: Lens' RegionInstanceGroupsListInstances Text
rigliKind
  = lens _rigliKind (\ s a -> s{_rigliKind = a})

-- | A list of InstanceWithNamedPorts resources.
rigliItems :: Lens' RegionInstanceGroupsListInstances [InstanceWithNamedPorts]
rigliItems
  = lens _rigliItems (\ s a -> s{_rigliItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
rigliSelfLink :: Lens' RegionInstanceGroupsListInstances (Maybe Text)
rigliSelfLink
  = lens _rigliSelfLink
      (\ s a -> s{_rigliSelfLink = a})

-- | [Output Only] Informational warning message.
rigliWarning :: Lens' RegionInstanceGroupsListInstances (Maybe RegionInstanceGroupsListInstancesWarning)
rigliWarning
  = lens _rigliWarning (\ s a -> s{_rigliWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
rigliId :: Lens' RegionInstanceGroupsListInstances (Maybe Text)
rigliId = lens _rigliId (\ s a -> s{_rigliId = a})

instance FromJSON RegionInstanceGroupsListInstances
         where
        parseJSON
          = withObject "RegionInstanceGroupsListInstances"
              (\ o ->
                 RegionInstanceGroupsListInstances' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!=
                        "compute#regionInstanceGroupsListInstances")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON RegionInstanceGroupsListInstances
         where
        toJSON RegionInstanceGroupsListInstances'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _rigliNextPageToken,
                  Just ("kind" .= _rigliKind),
                  ("items" .=) <$> _rigliItems,
                  ("selfLink" .=) <$> _rigliSelfLink,
                  ("warning" .=) <$> _rigliWarning,
                  ("id" .=) <$> _rigliId])

--
-- /See:/ 'regionDisksRemoveResourcePoliciesRequest' smart constructor.
newtype RegionDisksRemoveResourcePoliciesRequest =
  RegionDisksRemoveResourcePoliciesRequest'
    { _rdrrprResourcePolicies :: Maybe [Text]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionDisksRemoveResourcePoliciesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rdrrprResourcePolicies'
regionDisksRemoveResourcePoliciesRequest
    :: RegionDisksRemoveResourcePoliciesRequest
regionDisksRemoveResourcePoliciesRequest =
  RegionDisksRemoveResourcePoliciesRequest' {_rdrrprResourcePolicies = Nothing}


-- | Resource policies to be removed from this disk.
rdrrprResourcePolicies :: Lens' RegionDisksRemoveResourcePoliciesRequest [Text]
rdrrprResourcePolicies
  = lens _rdrrprResourcePolicies
      (\ s a -> s{_rdrrprResourcePolicies = a})
      . _Default
      . _Coerce

instance FromJSON
           RegionDisksRemoveResourcePoliciesRequest
         where
        parseJSON
          = withObject
              "RegionDisksRemoveResourcePoliciesRequest"
              (\ o ->
                 RegionDisksRemoveResourcePoliciesRequest' <$>
                   (o .:? "resourcePolicies" .!= mempty))

instance ToJSON
           RegionDisksRemoveResourcePoliciesRequest
         where
        toJSON RegionDisksRemoveResourcePoliciesRequest'{..}
          = object
              (catMaybes
                 [("resourcePolicies" .=) <$>
                    _rdrrprResourcePolicies])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'reservationAggregatedListWarning' smart constructor.
data ReservationAggregatedListWarning =
  ReservationAggregatedListWarning'
    { _ralwData :: !(Maybe [ReservationAggregatedListWarningDataItem])
    , _ralwCode :: !(Maybe ReservationAggregatedListWarningCode)
    , _ralwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ReservationAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ralwData'
--
-- * 'ralwCode'
--
-- * 'ralwMessage'
reservationAggregatedListWarning
    :: ReservationAggregatedListWarning
reservationAggregatedListWarning =
  ReservationAggregatedListWarning'
    {_ralwData = Nothing, _ralwCode = Nothing, _ralwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
ralwData :: Lens' ReservationAggregatedListWarning [ReservationAggregatedListWarningDataItem]
ralwData
  = lens _ralwData (\ s a -> s{_ralwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
ralwCode :: Lens' ReservationAggregatedListWarning (Maybe ReservationAggregatedListWarningCode)
ralwCode = lens _ralwCode (\ s a -> s{_ralwCode = a})

-- | [Output Only] A human-readable description of the warning code.
ralwMessage :: Lens' ReservationAggregatedListWarning (Maybe Text)
ralwMessage
  = lens _ralwMessage (\ s a -> s{_ralwMessage = a})

instance FromJSON ReservationAggregatedListWarning
         where
        parseJSON
          = withObject "ReservationAggregatedListWarning"
              (\ o ->
                 ReservationAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON ReservationAggregatedListWarning
         where
        toJSON ReservationAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _ralwData,
                  ("code" .=) <$> _ralwCode,
                  ("message" .=) <$> _ralwMessage])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'diskListWarning' smart constructor.
data DiskListWarning =
  DiskListWarning'
    { _dlwData :: !(Maybe [DiskListWarningDataItem])
    , _dlwCode :: !(Maybe DiskListWarningCode)
    , _dlwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DiskListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dlwData'
--
-- * 'dlwCode'
--
-- * 'dlwMessage'
diskListWarning
    :: DiskListWarning
diskListWarning =
  DiskListWarning'
    {_dlwData = Nothing, _dlwCode = Nothing, _dlwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
dlwData :: Lens' DiskListWarning [DiskListWarningDataItem]
dlwData
  = lens _dlwData (\ s a -> s{_dlwData = a}) . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
dlwCode :: Lens' DiskListWarning (Maybe DiskListWarningCode)
dlwCode = lens _dlwCode (\ s a -> s{_dlwCode = a})

-- | [Output Only] A human-readable description of the warning code.
dlwMessage :: Lens' DiskListWarning (Maybe Text)
dlwMessage
  = lens _dlwMessage (\ s a -> s{_dlwMessage = a})

instance FromJSON DiskListWarning where
        parseJSON
          = withObject "DiskListWarning"
              (\ o ->
                 DiskListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON DiskListWarning where
        toJSON DiskListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _dlwData, ("code" .=) <$> _dlwCode,
                  ("message" .=) <$> _dlwMessage])

--
-- /See:/ 'tcpHealthCheck' smart constructor.
data TCPHealthCheck =
  TCPHealthCheck'
    { _thcResponse :: !(Maybe Text)
    , _thcPortSpecification :: !(Maybe TCPHealthCheckPortSpecification)
    , _thcProxyHeader :: !(Maybe TCPHealthCheckProxyHeader)
    , _thcPortName :: !(Maybe Text)
    , _thcPort :: !(Maybe (Textual Int32))
    , _thcRequest :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TCPHealthCheck' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'thcResponse'
--
-- * 'thcPortSpecification'
--
-- * 'thcProxyHeader'
--
-- * 'thcPortName'
--
-- * 'thcPort'
--
-- * 'thcRequest'
tcpHealthCheck
    :: TCPHealthCheck
tcpHealthCheck =
  TCPHealthCheck'
    { _thcResponse = Nothing
    , _thcPortSpecification = Nothing
    , _thcProxyHeader = Nothing
    , _thcPortName = Nothing
    , _thcPort = Nothing
    , _thcRequest = Nothing
    }


-- | The bytes to match against the beginning of the response data. If left
-- empty (the default value), any response will indicate health. The
-- response data can only be ASCII.
thcResponse :: Lens' TCPHealthCheck (Maybe Text)
thcResponse
  = lens _thcResponse (\ s a -> s{_thcResponse = a})

-- | Specifies how port is selected for health checking, can be one of
-- following values: USE_FIXED_PORT: The port number in port is used for
-- health checking. USE_NAMED_PORT: The portName is used for health
-- checking. USE_SERVING_PORT: For NetworkEndpointGroup, the port specified
-- for each network endpoint is used for health checking. For other
-- backends, the port or named port specified in the Backend Service is
-- used for health checking. If not specified, TCP health check follows
-- behavior specified in port and portName fields.
thcPortSpecification :: Lens' TCPHealthCheck (Maybe TCPHealthCheckPortSpecification)
thcPortSpecification
  = lens _thcPortSpecification
      (\ s a -> s{_thcPortSpecification = a})

-- | Specifies the type of proxy header to append before sending data to the
-- backend, either NONE or PROXY_V1. The default is NONE.
thcProxyHeader :: Lens' TCPHealthCheck (Maybe TCPHealthCheckProxyHeader)
thcProxyHeader
  = lens _thcProxyHeader
      (\ s a -> s{_thcProxyHeader = a})

-- | Port name as defined in InstanceGroup#NamedPort#name. If both port and
-- port_name are defined, port takes precedence.
thcPortName :: Lens' TCPHealthCheck (Maybe Text)
thcPortName
  = lens _thcPortName (\ s a -> s{_thcPortName = a})

-- | The TCP port number for the health check request. The default value is
-- 80. Valid values are 1 through 65535.
thcPort :: Lens' TCPHealthCheck (Maybe Int32)
thcPort
  = lens _thcPort (\ s a -> s{_thcPort = a}) .
      mapping _Coerce

-- | The application data to send once the TCP connection has been
-- established (default value is empty). If both request and response are
-- empty, the connection establishment alone will indicate health. The
-- request data can only be ASCII.
thcRequest :: Lens' TCPHealthCheck (Maybe Text)
thcRequest
  = lens _thcRequest (\ s a -> s{_thcRequest = a})

instance FromJSON TCPHealthCheck where
        parseJSON
          = withObject "TCPHealthCheck"
              (\ o ->
                 TCPHealthCheck' <$>
                   (o .:? "response") <*> (o .:? "portSpecification")
                     <*> (o .:? "proxyHeader")
                     <*> (o .:? "portName")
                     <*> (o .:? "port")
                     <*> (o .:? "request"))

instance ToJSON TCPHealthCheck where
        toJSON TCPHealthCheck'{..}
          = object
              (catMaybes
                 [("response" .=) <$> _thcResponse,
                  ("portSpecification" .=) <$> _thcPortSpecification,
                  ("proxyHeader" .=) <$> _thcProxyHeader,
                  ("portName" .=) <$> _thcPortName,
                  ("port" .=) <$> _thcPort,
                  ("request" .=) <$> _thcRequest])

--
-- /See:/ 'instanceGroupManagerAggregatedListWarningDataItem' smart constructor.
data InstanceGroupManagerAggregatedListWarningDataItem =
  InstanceGroupManagerAggregatedListWarningDataItem'
    { _igmalwdiValue :: !(Maybe Text)
    , _igmalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagerAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmalwdiValue'
--
-- * 'igmalwdiKey'
instanceGroupManagerAggregatedListWarningDataItem
    :: InstanceGroupManagerAggregatedListWarningDataItem
instanceGroupManagerAggregatedListWarningDataItem =
  InstanceGroupManagerAggregatedListWarningDataItem'
    {_igmalwdiValue = Nothing, _igmalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
igmalwdiValue :: Lens' InstanceGroupManagerAggregatedListWarningDataItem (Maybe Text)
igmalwdiValue
  = lens _igmalwdiValue
      (\ s a -> s{_igmalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
igmalwdiKey :: Lens' InstanceGroupManagerAggregatedListWarningDataItem (Maybe Text)
igmalwdiKey
  = lens _igmalwdiKey (\ s a -> s{_igmalwdiKey = a})

instance FromJSON
           InstanceGroupManagerAggregatedListWarningDataItem
         where
        parseJSON
          = withObject
              "InstanceGroupManagerAggregatedListWarningDataItem"
              (\ o ->
                 InstanceGroupManagerAggregatedListWarningDataItem'
                   <$> (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           InstanceGroupManagerAggregatedListWarningDataItem
         where
        toJSON
          InstanceGroupManagerAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _igmalwdiValue,
                  ("key" .=) <$> _igmalwdiKey])

--
-- /See:/ 'testPermissionsResponse' smart constructor.
newtype TestPermissionsResponse =
  TestPermissionsResponse'
    { _tprPermissions :: Maybe [Text]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TestPermissionsResponse' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tprPermissions'
testPermissionsResponse
    :: TestPermissionsResponse
testPermissionsResponse = TestPermissionsResponse' {_tprPermissions = Nothing}


-- | A subset of \`TestPermissionsRequest.permissions\` that the caller is
-- allowed.
tprPermissions :: Lens' TestPermissionsResponse [Text]
tprPermissions
  = lens _tprPermissions
      (\ s a -> s{_tprPermissions = a})
      . _Default
      . _Coerce

instance FromJSON TestPermissionsResponse where
        parseJSON
          = withObject "TestPermissionsResponse"
              (\ o ->
                 TestPermissionsResponse' <$>
                   (o .:? "permissions" .!= mempty))

instance ToJSON TestPermissionsResponse where
        toJSON TestPermissionsResponse'{..}
          = object
              (catMaybes [("permissions" .=) <$> _tprPermissions])

-- | [Output Only] Informational warning which replaces the list of addresses
-- when the list is empty.
--
-- /See:/ 'vpnGatewaysScopedListWarning' smart constructor.
data VPNGatewaysScopedListWarning =
  VPNGatewaysScopedListWarning'
    { _vgslwData :: !(Maybe [VPNGatewaysScopedListWarningDataItem])
    , _vgslwCode :: !(Maybe VPNGatewaysScopedListWarningCode)
    , _vgslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNGatewaysScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vgslwData'
--
-- * 'vgslwCode'
--
-- * 'vgslwMessage'
vpnGatewaysScopedListWarning
    :: VPNGatewaysScopedListWarning
vpnGatewaysScopedListWarning =
  VPNGatewaysScopedListWarning'
    {_vgslwData = Nothing, _vgslwCode = Nothing, _vgslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
vgslwData :: Lens' VPNGatewaysScopedListWarning [VPNGatewaysScopedListWarningDataItem]
vgslwData
  = lens _vgslwData (\ s a -> s{_vgslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
vgslwCode :: Lens' VPNGatewaysScopedListWarning (Maybe VPNGatewaysScopedListWarningCode)
vgslwCode
  = lens _vgslwCode (\ s a -> s{_vgslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
vgslwMessage :: Lens' VPNGatewaysScopedListWarning (Maybe Text)
vgslwMessage
  = lens _vgslwMessage (\ s a -> s{_vgslwMessage = a})

instance FromJSON VPNGatewaysScopedListWarning where
        parseJSON
          = withObject "VPNGatewaysScopedListWarning"
              (\ o ->
                 VPNGatewaysScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON VPNGatewaysScopedListWarning where
        toJSON VPNGatewaysScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _vgslwData,
                  ("code" .=) <$> _vgslwCode,
                  ("message" .=) <$> _vgslwMessage])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'regionAutoscalerListWarning' smart constructor.
data RegionAutoscalerListWarning =
  RegionAutoscalerListWarning'
    { _rData :: !(Maybe [RegionAutoscalerListWarningDataItem])
    , _rCode :: !(Maybe RegionAutoscalerListWarningCode)
    , _rMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionAutoscalerListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rData'
--
-- * 'rCode'
--
-- * 'rMessage'
regionAutoscalerListWarning
    :: RegionAutoscalerListWarning
regionAutoscalerListWarning =
  RegionAutoscalerListWarning'
    {_rData = Nothing, _rCode = Nothing, _rMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
rData :: Lens' RegionAutoscalerListWarning [RegionAutoscalerListWarningDataItem]
rData
  = lens _rData (\ s a -> s{_rData = a}) . _Default .
      _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
rCode :: Lens' RegionAutoscalerListWarning (Maybe RegionAutoscalerListWarningCode)
rCode = lens _rCode (\ s a -> s{_rCode = a})

-- | [Output Only] A human-readable description of the warning code.
rMessage :: Lens' RegionAutoscalerListWarning (Maybe Text)
rMessage = lens _rMessage (\ s a -> s{_rMessage = a})

instance FromJSON RegionAutoscalerListWarning where
        parseJSON
          = withObject "RegionAutoscalerListWarning"
              (\ o ->
                 RegionAutoscalerListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON RegionAutoscalerListWarning where
        toJSON RegionAutoscalerListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _rData, ("code" .=) <$> _rCode,
                  ("message" .=) <$> _rMessage])

-- | Configuration for an App Engine network endpoint group (NEG). The
-- service is optional, may be provided explicitly or in the URL mask. The
-- version is optional and can only be provided explicitly or in the URL
-- mask when service is present. Note: App Engine service must be in the
-- same project and located in the same region as the Serverless NEG.
--
-- /See:/ 'networkEndpointGroupAppEngine' smart constructor.
data NetworkEndpointGroupAppEngine =
  NetworkEndpointGroupAppEngine'
    { _negaeService :: !(Maybe Text)
    , _negaeURLMask :: !(Maybe Text)
    , _negaeVersion :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkEndpointGroupAppEngine' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'negaeService'
--
-- * 'negaeURLMask'
--
-- * 'negaeVersion'
networkEndpointGroupAppEngine
    :: NetworkEndpointGroupAppEngine
networkEndpointGroupAppEngine =
  NetworkEndpointGroupAppEngine'
    {_negaeService = Nothing, _negaeURLMask = Nothing, _negaeVersion = Nothing}


-- | Optional serving service. The service name is case-sensitive and must be
-- 1-63 characters long. Example value: \"default\", \"my-service\".
negaeService :: Lens' NetworkEndpointGroupAppEngine (Maybe Text)
negaeService
  = lens _negaeService (\ s a -> s{_negaeService = a})

-- | A template to parse service and version fields from a request URL. URL
-- mask allows for routing to multiple App Engine services without having
-- to create multiple Network Endpoint Groups and backend services. For
-- example, the request URLs \"foo1-dot-appname.appspot.com\/v1\" and
-- \"foo1-dot-appname.appspot.com\/v2\" can be backed by the same
-- Serverless NEG with URL mask \"-dot-appname.appspot.com\/\". The URL
-- mask will parse them to { service = \"foo1\", version = \"v1\" } and {
-- service = \"foo1\", version = \"v2\" } respectively.
negaeURLMask :: Lens' NetworkEndpointGroupAppEngine (Maybe Text)
negaeURLMask
  = lens _negaeURLMask (\ s a -> s{_negaeURLMask = a})

-- | Optional serving version. The version name is case-sensitive and must be
-- 1-100 characters long. Example value: \"v1\", \"v2\".
negaeVersion :: Lens' NetworkEndpointGroupAppEngine (Maybe Text)
negaeVersion
  = lens _negaeVersion (\ s a -> s{_negaeVersion = a})

instance FromJSON NetworkEndpointGroupAppEngine where
        parseJSON
          = withObject "NetworkEndpointGroupAppEngine"
              (\ o ->
                 NetworkEndpointGroupAppEngine' <$>
                   (o .:? "service") <*> (o .:? "urlMask") <*>
                     (o .:? "version"))

instance ToJSON NetworkEndpointGroupAppEngine where
        toJSON NetworkEndpointGroupAppEngine'{..}
          = object
              (catMaybes
                 [("service" .=) <$> _negaeService,
                  ("urlMask" .=) <$> _negaeURLMask,
                  ("version" .=) <$> _negaeVersion])

-- | Preserved disks defined for this instance. This map is keyed with the
-- device names of the disks.
--
-- /See:/ 'preservedStateDisks' smart constructor.
newtype PreservedStateDisks =
  PreservedStateDisks'
    { _psdAddtional :: HashMap Text PreservedStatePreservedDisk
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PreservedStateDisks' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'psdAddtional'
preservedStateDisks
    :: HashMap Text PreservedStatePreservedDisk -- ^ 'psdAddtional'
    -> PreservedStateDisks
preservedStateDisks pPsdAddtional_ =
  PreservedStateDisks' {_psdAddtional = _Coerce # pPsdAddtional_}


psdAddtional :: Lens' PreservedStateDisks (HashMap Text PreservedStatePreservedDisk)
psdAddtional
  = lens _psdAddtional (\ s a -> s{_psdAddtional = a})
      . _Coerce

instance FromJSON PreservedStateDisks where
        parseJSON
          = withObject "PreservedStateDisks"
              (\ o -> PreservedStateDisks' <$> (parseJSONObject o))

instance ToJSON PreservedStateDisks where
        toJSON = toJSON . _psdAddtional

--
-- /See:/ 'targetInstanceListWarningDataItem' smart constructor.
data TargetInstanceListWarningDataItem =
  TargetInstanceListWarningDataItem'
    { _tilwdiValue :: !(Maybe Text)
    , _tilwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetInstanceListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tilwdiValue'
--
-- * 'tilwdiKey'
targetInstanceListWarningDataItem
    :: TargetInstanceListWarningDataItem
targetInstanceListWarningDataItem =
  TargetInstanceListWarningDataItem'
    {_tilwdiValue = Nothing, _tilwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
tilwdiValue :: Lens' TargetInstanceListWarningDataItem (Maybe Text)
tilwdiValue
  = lens _tilwdiValue (\ s a -> s{_tilwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
tilwdiKey :: Lens' TargetInstanceListWarningDataItem (Maybe Text)
tilwdiKey
  = lens _tilwdiKey (\ s a -> s{_tilwdiKey = a})

instance FromJSON TargetInstanceListWarningDataItem
         where
        parseJSON
          = withObject "TargetInstanceListWarningDataItem"
              (\ o ->
                 TargetInstanceListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON TargetInstanceListWarningDataItem
         where
        toJSON TargetInstanceListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _tilwdiValue,
                  ("key" .=) <$> _tilwdiKey])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'operationListWarning' smart constructor.
data OperationListWarning =
  OperationListWarning'
    { _olwData :: !(Maybe [OperationListWarningDataItem])
    , _olwCode :: !(Maybe OperationListWarningCode)
    , _olwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'OperationListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'olwData'
--
-- * 'olwCode'
--
-- * 'olwMessage'
operationListWarning
    :: OperationListWarning
operationListWarning =
  OperationListWarning'
    {_olwData = Nothing, _olwCode = Nothing, _olwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
olwData :: Lens' OperationListWarning [OperationListWarningDataItem]
olwData
  = lens _olwData (\ s a -> s{_olwData = a}) . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
olwCode :: Lens' OperationListWarning (Maybe OperationListWarningCode)
olwCode = lens _olwCode (\ s a -> s{_olwCode = a})

-- | [Output Only] A human-readable description of the warning code.
olwMessage :: Lens' OperationListWarning (Maybe Text)
olwMessage
  = lens _olwMessage (\ s a -> s{_olwMessage = a})

instance FromJSON OperationListWarning where
        parseJSON
          = withObject "OperationListWarning"
              (\ o ->
                 OperationListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON OperationListWarning where
        toJSON OperationListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _olwData, ("code" .=) <$> _olwCode,
                  ("message" .=) <$> _olwMessage])

--
-- /See:/ 'instanceGroupsRemoveInstancesRequest' smart constructor.
newtype InstanceGroupsRemoveInstancesRequest =
  InstanceGroupsRemoveInstancesRequest'
    { _igrirInstances :: Maybe [InstanceReference]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupsRemoveInstancesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igrirInstances'
instanceGroupsRemoveInstancesRequest
    :: InstanceGroupsRemoveInstancesRequest
instanceGroupsRemoveInstancesRequest =
  InstanceGroupsRemoveInstancesRequest' {_igrirInstances = Nothing}


-- | The list of instances to remove from the instance group.
igrirInstances :: Lens' InstanceGroupsRemoveInstancesRequest [InstanceReference]
igrirInstances
  = lens _igrirInstances
      (\ s a -> s{_igrirInstances = a})
      . _Default
      . _Coerce

instance FromJSON
           InstanceGroupsRemoveInstancesRequest
         where
        parseJSON
          = withObject "InstanceGroupsRemoveInstancesRequest"
              (\ o ->
                 InstanceGroupsRemoveInstancesRequest' <$>
                   (o .:? "instances" .!= mempty))

instance ToJSON InstanceGroupsRemoveInstancesRequest
         where
        toJSON InstanceGroupsRemoveInstancesRequest'{..}
          = object
              (catMaybes [("instances" .=) <$> _igrirInstances])

-- | Informational metadata about Partner attachments from Partners to
-- display to customers. These fields are propagated from PARTNER_PROVIDER
-- attachments to their corresponding PARTNER attachments.
--
-- /See:/ 'interconnectAttachmentPartnerMetadata' smart constructor.
data InterconnectAttachmentPartnerMetadata =
  InterconnectAttachmentPartnerMetadata'
    { _iapmPortalURL :: !(Maybe Text)
    , _iapmInterconnectName :: !(Maybe Text)
    , _iapmPartnerName :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectAttachmentPartnerMetadata' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iapmPortalURL'
--
-- * 'iapmInterconnectName'
--
-- * 'iapmPartnerName'
interconnectAttachmentPartnerMetadata
    :: InterconnectAttachmentPartnerMetadata
interconnectAttachmentPartnerMetadata =
  InterconnectAttachmentPartnerMetadata'
    { _iapmPortalURL = Nothing
    , _iapmInterconnectName = Nothing
    , _iapmPartnerName = Nothing
    }


-- | URL of the Partner\'s portal for this Attachment. Partners may customise
-- this to be a deep link to the specific resource on the Partner portal.
-- This value may be validated to match approved Partner values.
iapmPortalURL :: Lens' InterconnectAttachmentPartnerMetadata (Maybe Text)
iapmPortalURL
  = lens _iapmPortalURL
      (\ s a -> s{_iapmPortalURL = a})

-- | Plain text name of the Interconnect this attachment is connected to, as
-- displayed in the Partner\'s portal. For instance \"Chicago 1\". This
-- value may be validated to match approved Partner values.
iapmInterconnectName :: Lens' InterconnectAttachmentPartnerMetadata (Maybe Text)
iapmInterconnectName
  = lens _iapmInterconnectName
      (\ s a -> s{_iapmInterconnectName = a})

-- | Plain text name of the Partner providing this attachment. This value may
-- be validated to match approved Partner values.
iapmPartnerName :: Lens' InterconnectAttachmentPartnerMetadata (Maybe Text)
iapmPartnerName
  = lens _iapmPartnerName
      (\ s a -> s{_iapmPartnerName = a})

instance FromJSON
           InterconnectAttachmentPartnerMetadata
         where
        parseJSON
          = withObject "InterconnectAttachmentPartnerMetadata"
              (\ o ->
                 InterconnectAttachmentPartnerMetadata' <$>
                   (o .:? "portalUrl") <*> (o .:? "interconnectName")
                     <*> (o .:? "partnerName"))

instance ToJSON InterconnectAttachmentPartnerMetadata
         where
        toJSON InterconnectAttachmentPartnerMetadata'{..}
          = object
              (catMaybes
                 [("portalUrl" .=) <$> _iapmPortalURL,
                  ("interconnectName" .=) <$> _iapmInterconnectName,
                  ("partnerName" .=) <$> _iapmPartnerName])

--
-- /See:/ 'machineTypeListWarningDataItem' smart constructor.
data MachineTypeListWarningDataItem =
  MachineTypeListWarningDataItem'
    { _mtlwdiValue :: !(Maybe Text)
    , _mtlwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'MachineTypeListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'mtlwdiValue'
--
-- * 'mtlwdiKey'
machineTypeListWarningDataItem
    :: MachineTypeListWarningDataItem
machineTypeListWarningDataItem =
  MachineTypeListWarningDataItem' {_mtlwdiValue = Nothing, _mtlwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
mtlwdiValue :: Lens' MachineTypeListWarningDataItem (Maybe Text)
mtlwdiValue
  = lens _mtlwdiValue (\ s a -> s{_mtlwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
mtlwdiKey :: Lens' MachineTypeListWarningDataItem (Maybe Text)
mtlwdiKey
  = lens _mtlwdiKey (\ s a -> s{_mtlwdiKey = a})

instance FromJSON MachineTypeListWarningDataItem
         where
        parseJSON
          = withObject "MachineTypeListWarningDataItem"
              (\ o ->
                 MachineTypeListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON MachineTypeListWarningDataItem where
        toJSON MachineTypeListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _mtlwdiValue,
                  ("key" .=) <$> _mtlwdiKey])

--
-- /See:/ 'networksRemovePeeringRequest' smart constructor.
newtype NetworksRemovePeeringRequest =
  NetworksRemovePeeringRequest'
    { _nrprName :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworksRemovePeeringRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nrprName'
networksRemovePeeringRequest
    :: NetworksRemovePeeringRequest
networksRemovePeeringRequest =
  NetworksRemovePeeringRequest' {_nrprName = Nothing}


-- | Name of the peering, which should conform to RFC1035.
nrprName :: Lens' NetworksRemovePeeringRequest (Maybe Text)
nrprName = lens _nrprName (\ s a -> s{_nrprName = a})

instance FromJSON NetworksRemovePeeringRequest where
        parseJSON
          = withObject "NetworksRemovePeeringRequest"
              (\ o ->
                 NetworksRemovePeeringRequest' <$> (o .:? "name"))

instance ToJSON NetworksRemovePeeringRequest where
        toJSON NetworksRemovePeeringRequest'{..}
          = object (catMaybes [("name" .=) <$> _nrprName])

-- | Labels for this resource. These can only be added or modified by the
-- setLabels method. Each label key\/value pair must comply with RFC1035.
-- Label values may be empty.
--
-- /See:/ 'externalVPNGatewayLabels' smart constructor.
newtype ExternalVPNGatewayLabels =
  ExternalVPNGatewayLabels'
    { _evglAddtional :: HashMap Text Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ExternalVPNGatewayLabels' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'evglAddtional'
externalVPNGatewayLabels
    :: HashMap Text Text -- ^ 'evglAddtional'
    -> ExternalVPNGatewayLabels
externalVPNGatewayLabels pEvglAddtional_ =
  ExternalVPNGatewayLabels' {_evglAddtional = _Coerce # pEvglAddtional_}


evglAddtional :: Lens' ExternalVPNGatewayLabels (HashMap Text Text)
evglAddtional
  = lens _evglAddtional
      (\ s a -> s{_evglAddtional = a})
      . _Coerce

instance FromJSON ExternalVPNGatewayLabels where
        parseJSON
          = withObject "ExternalVPNGatewayLabels"
              (\ o ->
                 ExternalVPNGatewayLabels' <$> (parseJSONObject o))

instance ToJSON ExternalVPNGatewayLabels where
        toJSON = toJSON . _evglAddtional

--
-- /See:/ 'targetHTTPProxyListWarningDataItem' smart constructor.
data TargetHTTPProxyListWarningDataItem =
  TargetHTTPProxyListWarningDataItem'
    { _thttpplwdiValue :: !(Maybe Text)
    , _thttpplwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetHTTPProxyListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'thttpplwdiValue'
--
-- * 'thttpplwdiKey'
targetHTTPProxyListWarningDataItem
    :: TargetHTTPProxyListWarningDataItem
targetHTTPProxyListWarningDataItem =
  TargetHTTPProxyListWarningDataItem'
    {_thttpplwdiValue = Nothing, _thttpplwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
thttpplwdiValue :: Lens' TargetHTTPProxyListWarningDataItem (Maybe Text)
thttpplwdiValue
  = lens _thttpplwdiValue
      (\ s a -> s{_thttpplwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
thttpplwdiKey :: Lens' TargetHTTPProxyListWarningDataItem (Maybe Text)
thttpplwdiKey
  = lens _thttpplwdiKey
      (\ s a -> s{_thttpplwdiKey = a})

instance FromJSON TargetHTTPProxyListWarningDataItem
         where
        parseJSON
          = withObject "TargetHTTPProxyListWarningDataItem"
              (\ o ->
                 TargetHTTPProxyListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON TargetHTTPProxyListWarningDataItem
         where
        toJSON TargetHTTPProxyListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _thttpplwdiValue,
                  ("key" .=) <$> _thttpplwdiKey])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'machineTypeAggregatedListWarning' smart constructor.
data MachineTypeAggregatedListWarning =
  MachineTypeAggregatedListWarning'
    { _mtalwData :: !(Maybe [MachineTypeAggregatedListWarningDataItem])
    , _mtalwCode :: !(Maybe MachineTypeAggregatedListWarningCode)
    , _mtalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'MachineTypeAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'mtalwData'
--
-- * 'mtalwCode'
--
-- * 'mtalwMessage'
machineTypeAggregatedListWarning
    :: MachineTypeAggregatedListWarning
machineTypeAggregatedListWarning =
  MachineTypeAggregatedListWarning'
    {_mtalwData = Nothing, _mtalwCode = Nothing, _mtalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
mtalwData :: Lens' MachineTypeAggregatedListWarning [MachineTypeAggregatedListWarningDataItem]
mtalwData
  = lens _mtalwData (\ s a -> s{_mtalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
mtalwCode :: Lens' MachineTypeAggregatedListWarning (Maybe MachineTypeAggregatedListWarningCode)
mtalwCode
  = lens _mtalwCode (\ s a -> s{_mtalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
mtalwMessage :: Lens' MachineTypeAggregatedListWarning (Maybe Text)
mtalwMessage
  = lens _mtalwMessage (\ s a -> s{_mtalwMessage = a})

instance FromJSON MachineTypeAggregatedListWarning
         where
        parseJSON
          = withObject "MachineTypeAggregatedListWarning"
              (\ o ->
                 MachineTypeAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON MachineTypeAggregatedListWarning
         where
        toJSON MachineTypeAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _mtalwData,
                  ("code" .=) <$> _mtalwCode,
                  ("message" .=) <$> _mtalwMessage])

-- | Settings controlling the volume of connections to a backend service.
--
-- /See:/ 'circuitBreakers' smart constructor.
data CircuitBreakers =
  CircuitBreakers'
    { _cbMaxRequests :: !(Maybe (Textual Int32))
    , _cbMaxConnections :: !(Maybe (Textual Int32))
    , _cbMaxRequestsPerConnection :: !(Maybe (Textual Int32))
    , _cbMaxRetries :: !(Maybe (Textual Int32))
    , _cbMaxPendingRequests :: !(Maybe (Textual Int32))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'CircuitBreakers' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'cbMaxRequests'
--
-- * 'cbMaxConnections'
--
-- * 'cbMaxRequestsPerConnection'
--
-- * 'cbMaxRetries'
--
-- * 'cbMaxPendingRequests'
circuitBreakers
    :: CircuitBreakers
circuitBreakers =
  CircuitBreakers'
    { _cbMaxRequests = Nothing
    , _cbMaxConnections = Nothing
    , _cbMaxRequestsPerConnection = Nothing
    , _cbMaxRetries = Nothing
    , _cbMaxPendingRequests = Nothing
    }


-- | The maximum number of parallel requests that allowed to the backend
-- service. If not specified, there is no limit.
cbMaxRequests :: Lens' CircuitBreakers (Maybe Int32)
cbMaxRequests
  = lens _cbMaxRequests
      (\ s a -> s{_cbMaxRequests = a})
      . mapping _Coerce

-- | Not supported when the backend service is referenced by a URL map that
-- is bound to target gRPC proxy that has validateForProxyless field set to
-- true.
cbMaxConnections :: Lens' CircuitBreakers (Maybe Int32)
cbMaxConnections
  = lens _cbMaxConnections
      (\ s a -> s{_cbMaxConnections = a})
      . mapping _Coerce

-- | Not supported when the backend service is referenced by a URL map that
-- is bound to target gRPC proxy that has validateForProxyless field set to
-- true.
cbMaxRequestsPerConnection :: Lens' CircuitBreakers (Maybe Int32)
cbMaxRequestsPerConnection
  = lens _cbMaxRequestsPerConnection
      (\ s a -> s{_cbMaxRequestsPerConnection = a})
      . mapping _Coerce

-- | Not supported when the backend service is referenced by a URL map that
-- is bound to target gRPC proxy that has validateForProxyless field set to
-- true.
cbMaxRetries :: Lens' CircuitBreakers (Maybe Int32)
cbMaxRetries
  = lens _cbMaxRetries (\ s a -> s{_cbMaxRetries = a})
      . mapping _Coerce

-- | Not supported when the backend service is referenced by a URL map that
-- is bound to target gRPC proxy that has validateForProxyless field set to
-- true.
cbMaxPendingRequests :: Lens' CircuitBreakers (Maybe Int32)
cbMaxPendingRequests
  = lens _cbMaxPendingRequests
      (\ s a -> s{_cbMaxPendingRequests = a})
      . mapping _Coerce

instance FromJSON CircuitBreakers where
        parseJSON
          = withObject "CircuitBreakers"
              (\ o ->
                 CircuitBreakers' <$>
                   (o .:? "maxRequests") <*> (o .:? "maxConnections")
                     <*> (o .:? "maxRequestsPerConnection")
                     <*> (o .:? "maxRetries")
                     <*> (o .:? "maxPendingRequests"))

instance ToJSON CircuitBreakers where
        toJSON CircuitBreakers'{..}
          = object
              (catMaybes
                 [("maxRequests" .=) <$> _cbMaxRequests,
                  ("maxConnections" .=) <$> _cbMaxConnections,
                  ("maxRequestsPerConnection" .=) <$>
                    _cbMaxRequestsPerConnection,
                  ("maxRetries" .=) <$> _cbMaxRetries,
                  ("maxPendingRequests" .=) <$> _cbMaxPendingRequests])

-- | Represents a rule that describes one or more match conditions along with
-- the action to be taken when traffic matches this condition (allow or
-- deny).
--
-- /See:/ 'firewallPolicyRule' smart constructor.
data FirewallPolicyRule =
  FirewallPolicyRule'
    { _fprEnableLogging :: !(Maybe Bool)
    , _fprPriority :: !(Maybe (Textual Int32))
    , _fprDirection :: !(Maybe FirewallPolicyRuleDirection)
    , _fprTargetResources :: !(Maybe [Text])
    , _fprKind :: !Text
    , _fprDisabled :: !(Maybe Bool)
    , _fprAction :: !(Maybe Text)
    , _fprRuleTupleCount :: !(Maybe (Textual Int32))
    , _fprMatch :: !(Maybe FirewallPolicyRuleMatcher)
    , _fprTargetServiceAccounts :: !(Maybe [Text])
    , _fprDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'FirewallPolicyRule' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'fprEnableLogging'
--
-- * 'fprPriority'
--
-- * 'fprDirection'
--
-- * 'fprTargetResources'
--
-- * 'fprKind'
--
-- * 'fprDisabled'
--
-- * 'fprAction'
--
-- * 'fprRuleTupleCount'
--
-- * 'fprMatch'
--
-- * 'fprTargetServiceAccounts'
--
-- * 'fprDescription'
firewallPolicyRule
    :: FirewallPolicyRule
firewallPolicyRule =
  FirewallPolicyRule'
    { _fprEnableLogging = Nothing
    , _fprPriority = Nothing
    , _fprDirection = Nothing
    , _fprTargetResources = Nothing
    , _fprKind = "compute#firewallPolicyRule"
    , _fprDisabled = Nothing
    , _fprAction = Nothing
    , _fprRuleTupleCount = Nothing
    , _fprMatch = Nothing
    , _fprTargetServiceAccounts = Nothing
    , _fprDescription = Nothing
    }


-- | Denotes whether to enable logging for a particular rule. If logging is
-- enabled, logs will be exported to the configured export destination in
-- Stackdriver. Logs may be exported to BigQuery or Pub\/Sub. Note: you
-- cannot enable logging on \"goto_next\" rules.
fprEnableLogging :: Lens' FirewallPolicyRule (Maybe Bool)
fprEnableLogging
  = lens _fprEnableLogging
      (\ s a -> s{_fprEnableLogging = a})

-- | An integer indicating the priority of a rule in the list. The priority
-- must be a positive value between 0 and 2147483647. Rules are evaluated
-- from highest to lowest priority where 0 is the highest priority and
-- 2147483647 is the lowest prority.
fprPriority :: Lens' FirewallPolicyRule (Maybe Int32)
fprPriority
  = lens _fprPriority (\ s a -> s{_fprPriority = a}) .
      mapping _Coerce

-- | The direction in which this rule applies.
fprDirection :: Lens' FirewallPolicyRule (Maybe FirewallPolicyRuleDirection)
fprDirection
  = lens _fprDirection (\ s a -> s{_fprDirection = a})

-- | A list of network resource URLs to which this rule applies. This field
-- allows you to control which network\'s VMs get this rule. If this field
-- is left blank, all VMs within the organization will receive the rule.
fprTargetResources :: Lens' FirewallPolicyRule [Text]
fprTargetResources
  = lens _fprTargetResources
      (\ s a -> s{_fprTargetResources = a})
      . _Default
      . _Coerce

-- | [Output only] Type of the resource. Always compute#firewallPolicyRule
-- for firewall policy rules
fprKind :: Lens' FirewallPolicyRule Text
fprKind = lens _fprKind (\ s a -> s{_fprKind = a})

-- | Denotes whether the firewall policy rule is disabled. When set to true,
-- the firewall policy rule is not enforced and traffic behaves as if it
-- did not exist. If this is unspecified, the firewall policy rule will be
-- enabled.
fprDisabled :: Lens' FirewallPolicyRule (Maybe Bool)
fprDisabled
  = lens _fprDisabled (\ s a -> s{_fprDisabled = a})

-- | The Action to perform when the client connection triggers the rule. Can
-- currently be either \"allow\" or \"deny()\" where valid values for
-- status are 403, 404, and 502.
fprAction :: Lens' FirewallPolicyRule (Maybe Text)
fprAction
  = lens _fprAction (\ s a -> s{_fprAction = a})

-- | [Output Only] Calculation of the complexity of a single firewall policy
-- rule.
fprRuleTupleCount :: Lens' FirewallPolicyRule (Maybe Int32)
fprRuleTupleCount
  = lens _fprRuleTupleCount
      (\ s a -> s{_fprRuleTupleCount = a})
      . mapping _Coerce

-- | A match condition that incoming traffic is evaluated against. If it
-- evaluates to true, the corresponding \'action\' is enforced.
fprMatch :: Lens' FirewallPolicyRule (Maybe FirewallPolicyRuleMatcher)
fprMatch = lens _fprMatch (\ s a -> s{_fprMatch = a})

-- | A list of service accounts indicating the sets of instances that are
-- applied with this rule.
fprTargetServiceAccounts :: Lens' FirewallPolicyRule [Text]
fprTargetServiceAccounts
  = lens _fprTargetServiceAccounts
      (\ s a -> s{_fprTargetServiceAccounts = a})
      . _Default
      . _Coerce

-- | An optional description for this resource.
fprDescription :: Lens' FirewallPolicyRule (Maybe Text)
fprDescription
  = lens _fprDescription
      (\ s a -> s{_fprDescription = a})

instance FromJSON FirewallPolicyRule where
        parseJSON
          = withObject "FirewallPolicyRule"
              (\ o ->
                 FirewallPolicyRule' <$>
                   (o .:? "enableLogging") <*> (o .:? "priority") <*>
                     (o .:? "direction")
                     <*> (o .:? "targetResources" .!= mempty)
                     <*> (o .:? "kind" .!= "compute#firewallPolicyRule")
                     <*> (o .:? "disabled")
                     <*> (o .:? "action")
                     <*> (o .:? "ruleTupleCount")
                     <*> (o .:? "match")
                     <*> (o .:? "targetServiceAccounts" .!= mempty)
                     <*> (o .:? "description"))

instance ToJSON FirewallPolicyRule where
        toJSON FirewallPolicyRule'{..}
          = object
              (catMaybes
                 [("enableLogging" .=) <$> _fprEnableLogging,
                  ("priority" .=) <$> _fprPriority,
                  ("direction" .=) <$> _fprDirection,
                  ("targetResources" .=) <$> _fprTargetResources,
                  Just ("kind" .= _fprKind),
                  ("disabled" .=) <$> _fprDisabled,
                  ("action" .=) <$> _fprAction,
                  ("ruleTupleCount" .=) <$> _fprRuleTupleCount,
                  ("match" .=) <$> _fprMatch,
                  ("targetServiceAccounts" .=) <$>
                    _fprTargetServiceAccounts,
                  ("description" .=) <$> _fprDescription])

--
-- /See:/ 'nodeTemplateAggregatedListWarningDataItem' smart constructor.
data NodeTemplateAggregatedListWarningDataItem =
  NodeTemplateAggregatedListWarningDataItem'
    { _ntalwdiValue :: !(Maybe Text)
    , _ntalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeTemplateAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ntalwdiValue'
--
-- * 'ntalwdiKey'
nodeTemplateAggregatedListWarningDataItem
    :: NodeTemplateAggregatedListWarningDataItem
nodeTemplateAggregatedListWarningDataItem =
  NodeTemplateAggregatedListWarningDataItem'
    {_ntalwdiValue = Nothing, _ntalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
ntalwdiValue :: Lens' NodeTemplateAggregatedListWarningDataItem (Maybe Text)
ntalwdiValue
  = lens _ntalwdiValue (\ s a -> s{_ntalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
ntalwdiKey :: Lens' NodeTemplateAggregatedListWarningDataItem (Maybe Text)
ntalwdiKey
  = lens _ntalwdiKey (\ s a -> s{_ntalwdiKey = a})

instance FromJSON
           NodeTemplateAggregatedListWarningDataItem
         where
        parseJSON
          = withObject
              "NodeTemplateAggregatedListWarningDataItem"
              (\ o ->
                 NodeTemplateAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           NodeTemplateAggregatedListWarningDataItem
         where
        toJSON NodeTemplateAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _ntalwdiValue,
                  ("key" .=) <$> _ntalwdiKey])

-- | Contains a list of BackendBucket resources.
--
-- /See:/ 'backendBucketList' smart constructor.
data BackendBucketList =
  BackendBucketList'
    { _bblNextPageToken :: !(Maybe Text)
    , _bblKind :: !Text
    , _bblItems :: !(Maybe [BackendBucket])
    , _bblSelfLink :: !(Maybe Text)
    , _bblWarning :: !(Maybe BackendBucketListWarning)
    , _bblId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendBucketList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bblNextPageToken'
--
-- * 'bblKind'
--
-- * 'bblItems'
--
-- * 'bblSelfLink'
--
-- * 'bblWarning'
--
-- * 'bblId'
backendBucketList
    :: BackendBucketList
backendBucketList =
  BackendBucketList'
    { _bblNextPageToken = Nothing
    , _bblKind = "compute#backendBucketList"
    , _bblItems = Nothing
    , _bblSelfLink = Nothing
    , _bblWarning = Nothing
    , _bblId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
bblNextPageToken :: Lens' BackendBucketList (Maybe Text)
bblNextPageToken
  = lens _bblNextPageToken
      (\ s a -> s{_bblNextPageToken = a})

-- | Type of resource.
bblKind :: Lens' BackendBucketList Text
bblKind = lens _bblKind (\ s a -> s{_bblKind = a})

-- | A list of BackendBucket resources.
bblItems :: Lens' BackendBucketList [BackendBucket]
bblItems
  = lens _bblItems (\ s a -> s{_bblItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
bblSelfLink :: Lens' BackendBucketList (Maybe Text)
bblSelfLink
  = lens _bblSelfLink (\ s a -> s{_bblSelfLink = a})

-- | [Output Only] Informational warning message.
bblWarning :: Lens' BackendBucketList (Maybe BackendBucketListWarning)
bblWarning
  = lens _bblWarning (\ s a -> s{_bblWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
bblId :: Lens' BackendBucketList (Maybe Text)
bblId = lens _bblId (\ s a -> s{_bblId = a})

instance FromJSON BackendBucketList where
        parseJSON
          = withObject "BackendBucketList"
              (\ o ->
                 BackendBucketList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#backendBucketList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON BackendBucketList where
        toJSON BackendBucketList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _bblNextPageToken,
                  Just ("kind" .= _bblKind),
                  ("items" .=) <$> _bblItems,
                  ("selfLink" .=) <$> _bblSelfLink,
                  ("warning" .=) <$> _bblWarning,
                  ("id" .=) <$> _bblId])

-- | Information for an interconnect attachment when this belongs to an
-- interconnect of type DEDICATED.
--
-- /See:/ 'interconnectAttachmentPrivateInfo' smart constructor.
newtype InterconnectAttachmentPrivateInfo =
  InterconnectAttachmentPrivateInfo'
    { _iapiTag8021q :: Maybe (Textual Word32)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectAttachmentPrivateInfo' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iapiTag8021q'
interconnectAttachmentPrivateInfo
    :: InterconnectAttachmentPrivateInfo
interconnectAttachmentPrivateInfo =
  InterconnectAttachmentPrivateInfo' {_iapiTag8021q = Nothing}


-- | [Output Only] 802.1q encapsulation tag to be used for traffic between
-- Google and the customer, going to and from this network and region.
iapiTag8021q :: Lens' InterconnectAttachmentPrivateInfo (Maybe Word32)
iapiTag8021q
  = lens _iapiTag8021q (\ s a -> s{_iapiTag8021q = a})
      . mapping _Coerce

instance FromJSON InterconnectAttachmentPrivateInfo
         where
        parseJSON
          = withObject "InterconnectAttachmentPrivateInfo"
              (\ o ->
                 InterconnectAttachmentPrivateInfo' <$>
                   (o .:? "tag8021q"))

instance ToJSON InterconnectAttachmentPrivateInfo
         where
        toJSON InterconnectAttachmentPrivateInfo'{..}
          = object
              (catMaybes [("tag8021q" .=) <$> _iapiTag8021q])

--
-- /See:/ 'acceleratorTypesScopedList' smart constructor.
data AcceleratorTypesScopedList =
  AcceleratorTypesScopedList'
    { _atslAcceleratorTypes :: !(Maybe [AcceleratorType])
    , _atslWarning :: !(Maybe AcceleratorTypesScopedListWarning)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AcceleratorTypesScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'atslAcceleratorTypes'
--
-- * 'atslWarning'
acceleratorTypesScopedList
    :: AcceleratorTypesScopedList
acceleratorTypesScopedList =
  AcceleratorTypesScopedList'
    {_atslAcceleratorTypes = Nothing, _atslWarning = Nothing}


-- | [Output Only] A list of accelerator types contained in this scope.
atslAcceleratorTypes :: Lens' AcceleratorTypesScopedList [AcceleratorType]
atslAcceleratorTypes
  = lens _atslAcceleratorTypes
      (\ s a -> s{_atslAcceleratorTypes = a})
      . _Default
      . _Coerce

-- | [Output Only] An informational warning that appears when the accelerator
-- types list is empty.
atslWarning :: Lens' AcceleratorTypesScopedList (Maybe AcceleratorTypesScopedListWarning)
atslWarning
  = lens _atslWarning (\ s a -> s{_atslWarning = a})

instance FromJSON AcceleratorTypesScopedList where
        parseJSON
          = withObject "AcceleratorTypesScopedList"
              (\ o ->
                 AcceleratorTypesScopedList' <$>
                   (o .:? "acceleratorTypes" .!= mempty) <*>
                     (o .:? "warning"))

instance ToJSON AcceleratorTypesScopedList where
        toJSON AcceleratorTypesScopedList'{..}
          = object
              (catMaybes
                 [("acceleratorTypes" .=) <$> _atslAcceleratorTypes,
                  ("warning" .=) <$> _atslWarning])

--
-- /See:/ 'externalVPNGatewayListWarningDataItem' smart constructor.
data ExternalVPNGatewayListWarningDataItem =
  ExternalVPNGatewayListWarningDataItem'
    { _evglwdiValue :: !(Maybe Text)
    , _evglwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ExternalVPNGatewayListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'evglwdiValue'
--
-- * 'evglwdiKey'
externalVPNGatewayListWarningDataItem
    :: ExternalVPNGatewayListWarningDataItem
externalVPNGatewayListWarningDataItem =
  ExternalVPNGatewayListWarningDataItem'
    {_evglwdiValue = Nothing, _evglwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
evglwdiValue :: Lens' ExternalVPNGatewayListWarningDataItem (Maybe Text)
evglwdiValue
  = lens _evglwdiValue (\ s a -> s{_evglwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
evglwdiKey :: Lens' ExternalVPNGatewayListWarningDataItem (Maybe Text)
evglwdiKey
  = lens _evglwdiKey (\ s a -> s{_evglwdiKey = a})

instance FromJSON
           ExternalVPNGatewayListWarningDataItem
         where
        parseJSON
          = withObject "ExternalVPNGatewayListWarningDataItem"
              (\ o ->
                 ExternalVPNGatewayListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON ExternalVPNGatewayListWarningDataItem
         where
        toJSON ExternalVPNGatewayListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _evglwdiValue,
                  ("key" .=) <$> _evglwdiKey])

--
-- /See:/ 'publicDelegatedPrefixList' smart constructor.
data PublicDelegatedPrefixList =
  PublicDelegatedPrefixList'
    { _pdplNextPageToken :: !(Maybe Text)
    , _pdplKind :: !Text
    , _pdplItems :: !(Maybe [PublicDelegatedPrefix])
    , _pdplSelfLink :: !(Maybe Text)
    , _pdplWarning :: !(Maybe PublicDelegatedPrefixListWarning)
    , _pdplId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PublicDelegatedPrefixList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pdplNextPageToken'
--
-- * 'pdplKind'
--
-- * 'pdplItems'
--
-- * 'pdplSelfLink'
--
-- * 'pdplWarning'
--
-- * 'pdplId'
publicDelegatedPrefixList
    :: PublicDelegatedPrefixList
publicDelegatedPrefixList =
  PublicDelegatedPrefixList'
    { _pdplNextPageToken = Nothing
    , _pdplKind = "compute#publicDelegatedPrefixList"
    , _pdplItems = Nothing
    , _pdplSelfLink = Nothing
    , _pdplWarning = Nothing
    , _pdplId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
pdplNextPageToken :: Lens' PublicDelegatedPrefixList (Maybe Text)
pdplNextPageToken
  = lens _pdplNextPageToken
      (\ s a -> s{_pdplNextPageToken = a})

-- | [Output Only] Type of the resource. Always
-- compute#publicDelegatedPrefixList for public delegated prefixes.
pdplKind :: Lens' PublicDelegatedPrefixList Text
pdplKind = lens _pdplKind (\ s a -> s{_pdplKind = a})

-- | A list of PublicDelegatedPrefix resources.
pdplItems :: Lens' PublicDelegatedPrefixList [PublicDelegatedPrefix]
pdplItems
  = lens _pdplItems (\ s a -> s{_pdplItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
pdplSelfLink :: Lens' PublicDelegatedPrefixList (Maybe Text)
pdplSelfLink
  = lens _pdplSelfLink (\ s a -> s{_pdplSelfLink = a})

-- | [Output Only] Informational warning message.
pdplWarning :: Lens' PublicDelegatedPrefixList (Maybe PublicDelegatedPrefixListWarning)
pdplWarning
  = lens _pdplWarning (\ s a -> s{_pdplWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
pdplId :: Lens' PublicDelegatedPrefixList (Maybe Text)
pdplId = lens _pdplId (\ s a -> s{_pdplId = a})

instance FromJSON PublicDelegatedPrefixList where
        parseJSON
          = withObject "PublicDelegatedPrefixList"
              (\ o ->
                 PublicDelegatedPrefixList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!=
                        "compute#publicDelegatedPrefixList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON PublicDelegatedPrefixList where
        toJSON PublicDelegatedPrefixList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _pdplNextPageToken,
                  Just ("kind" .= _pdplKind),
                  ("items" .=) <$> _pdplItems,
                  ("selfLink" .=) <$> _pdplSelfLink,
                  ("warning" .=) <$> _pdplWarning,
                  ("id" .=) <$> _pdplId])

-- | Message containing Cloud CDN configuration for a backend service.
--
-- /See:/ 'backendServiceCdnPolicy' smart constructor.
data BackendServiceCdnPolicy =
  BackendServiceCdnPolicy'
    { _bscpServeWhileStale :: !(Maybe (Textual Int32))
    , _bscpSignedURLCacheMaxAgeSec :: !(Maybe (Textual Int64))
    , _bscpNegativeCachingPolicy :: !(Maybe [BackendServiceCdnPolicyNegativeCachingPolicy])
    , _bscpBypassCacheOnRequestHeaders :: !(Maybe [BackendServiceCdnPolicyBypassCacheOnRequestHeader])
    , _bscpRequestCoalescing :: !(Maybe Bool)
    , _bscpClientTtl :: !(Maybe (Textual Int32))
    , _bscpMaxTtl :: !(Maybe (Textual Int32))
    , _bscpCacheMode :: !(Maybe BackendServiceCdnPolicyCacheMode)
    , _bscpDefaultTtl :: !(Maybe (Textual Int32))
    , _bscpNegativeCaching :: !(Maybe Bool)
    , _bscpSignedURLKeyNames :: !(Maybe [Text])
    , _bscpCacheKeyPolicy :: !(Maybe CacheKeyPolicy)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendServiceCdnPolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bscpServeWhileStale'
--
-- * 'bscpSignedURLCacheMaxAgeSec'
--
-- * 'bscpNegativeCachingPolicy'
--
-- * 'bscpBypassCacheOnRequestHeaders'
--
-- * 'bscpRequestCoalescing'
--
-- * 'bscpClientTtl'
--
-- * 'bscpMaxTtl'
--
-- * 'bscpCacheMode'
--
-- * 'bscpDefaultTtl'
--
-- * 'bscpNegativeCaching'
--
-- * 'bscpSignedURLKeyNames'
--
-- * 'bscpCacheKeyPolicy'
backendServiceCdnPolicy
    :: BackendServiceCdnPolicy
backendServiceCdnPolicy =
  BackendServiceCdnPolicy'
    { _bscpServeWhileStale = Nothing
    , _bscpSignedURLCacheMaxAgeSec = Nothing
    , _bscpNegativeCachingPolicy = Nothing
    , _bscpBypassCacheOnRequestHeaders = Nothing
    , _bscpRequestCoalescing = Nothing
    , _bscpClientTtl = Nothing
    , _bscpMaxTtl = Nothing
    , _bscpCacheMode = Nothing
    , _bscpDefaultTtl = Nothing
    , _bscpNegativeCaching = Nothing
    , _bscpSignedURLKeyNames = Nothing
    , _bscpCacheKeyPolicy = Nothing
    }


-- | Serve existing content from the cache (if available) when revalidating
-- content with the origin, or when an error is encountered when refreshing
-- the cache. This setting defines the default \"max-stale\" duration for
-- any cached responses that do not specify a max-stale directive. Stale
-- responses that exceed the TTL configured here will not be served. The
-- default limit (max-stale) is 86400s (1 day), which will allow stale
-- content to be served up to this limit beyond the max-age (or s-max-age)
-- of a cached response. The maximum allowed value is 604800 (1 week). Set
-- this to zero (0) to disable serve-while-stale.
bscpServeWhileStale :: Lens' BackendServiceCdnPolicy (Maybe Int32)
bscpServeWhileStale
  = lens _bscpServeWhileStale
      (\ s a -> s{_bscpServeWhileStale = a})
      . mapping _Coerce

-- | Maximum number of seconds the response to a signed URL request will be
-- considered fresh. After this time period, the response will be
-- revalidated before being served. Defaults to 1hr (3600s). When serving
-- responses to signed URL requests, Cloud CDN will internally behave as
-- though all responses from this backend had a \"Cache-Control: public,
-- max-age=[TTL]\" header, regardless of any existing Cache-Control header.
-- The actual headers served in responses will not be altered.
bscpSignedURLCacheMaxAgeSec :: Lens' BackendServiceCdnPolicy (Maybe Int64)
bscpSignedURLCacheMaxAgeSec
  = lens _bscpSignedURLCacheMaxAgeSec
      (\ s a -> s{_bscpSignedURLCacheMaxAgeSec = a})
      . mapping _Coerce

-- | Sets a cache TTL for the specified HTTP status code. negative_caching
-- must be enabled to configure negative_caching_policy. Omitting the
-- policy and leaving negative_caching enabled will use Cloud CDN\'s
-- default cache TTLs. Note that when specifying an explicit
-- negative_caching_policy, you should take care to specify a cache TTL for
-- all response codes that you wish to cache. Cloud CDN will not apply any
-- default negative caching when a policy exists.
bscpNegativeCachingPolicy :: Lens' BackendServiceCdnPolicy [BackendServiceCdnPolicyNegativeCachingPolicy]
bscpNegativeCachingPolicy
  = lens _bscpNegativeCachingPolicy
      (\ s a -> s{_bscpNegativeCachingPolicy = a})
      . _Default
      . _Coerce

-- | Bypass the cache when the specified request headers are matched - e.g.
-- Pragma or Authorization headers. Up to 5 headers can be specified. The
-- cache is bypassed for all cdnPolicy.cacheMode settings.
bscpBypassCacheOnRequestHeaders :: Lens' BackendServiceCdnPolicy [BackendServiceCdnPolicyBypassCacheOnRequestHeader]
bscpBypassCacheOnRequestHeaders
  = lens _bscpBypassCacheOnRequestHeaders
      (\ s a -> s{_bscpBypassCacheOnRequestHeaders = a})
      . _Default
      . _Coerce

-- | If true then Cloud CDN will combine multiple concurrent cache fill
-- requests into a small number of requests to the origin.
bscpRequestCoalescing :: Lens' BackendServiceCdnPolicy (Maybe Bool)
bscpRequestCoalescing
  = lens _bscpRequestCoalescing
      (\ s a -> s{_bscpRequestCoalescing = a})

-- | Specifies a separate client (e.g. browser client) maximum TTL. This is
-- used to clamp the max-age (or Expires) value sent to the client. With
-- FORCE_CACHE_ALL, the lesser of client_ttl and default_ttl is used for
-- the response max-age directive, along with a \"public\" directive. For
-- cacheable content in CACHE_ALL_STATIC mode, client_ttl clamps the
-- max-age from the origin (if specified), or else sets the response
-- max-age directive to the lesser of the client_ttl and default_ttl, and
-- also ensures a \"public\" cache-control directive is present. If a
-- client TTL is not specified, a default value (1 hour) will be used. The
-- maximum allowed value is 86400s (1 day).
bscpClientTtl :: Lens' BackendServiceCdnPolicy (Maybe Int32)
bscpClientTtl
  = lens _bscpClientTtl
      (\ s a -> s{_bscpClientTtl = a})
      . mapping _Coerce

-- | Specifies the maximum allowed TTL for cached content served by this
-- origin. Cache directives that attempt to set a max-age or s-maxage
-- higher than this, or an Expires header more than maxTTL seconds in the
-- future will be capped at the value of maxTTL, as if it were the value of
-- an s-maxage Cache-Control directive. Headers sent to the client will not
-- be modified. Setting a TTL of \"0\" means \"always revalidate\". The
-- maximum allowed value is 31,622,400s (1 year), noting that infrequently
-- accessed objects may be evicted from the cache before the defined TTL.
bscpMaxTtl :: Lens' BackendServiceCdnPolicy (Maybe Int32)
bscpMaxTtl
  = lens _bscpMaxTtl (\ s a -> s{_bscpMaxTtl = a}) .
      mapping _Coerce

-- | Specifies the cache setting for all responses from this backend. The
-- possible values are: USE_ORIGIN_HEADERS Requires the origin to set valid
-- caching headers to cache content. Responses without these headers will
-- not be cached at Google\'s edge, and will require a full trip to the
-- origin on every request, potentially impacting performance and
-- increasing load on the origin server. FORCE_CACHE_ALL Cache all content,
-- ignoring any \"private\", \"no-store\" or \"no-cache\" directives in
-- Cache-Control response headers. Warning: this may result in Cloud CDN
-- caching private, per-user (user identifiable) content. CACHE_ALL_STATIC
-- Automatically cache static content, including common image formats,
-- media (video and audio), and web assets (JavaScript and CSS). Requests
-- and responses that are marked as uncacheable, as well as dynamic content
-- (including HTML), will not be cached.
bscpCacheMode :: Lens' BackendServiceCdnPolicy (Maybe BackendServiceCdnPolicyCacheMode)
bscpCacheMode
  = lens _bscpCacheMode
      (\ s a -> s{_bscpCacheMode = a})

-- | Specifies the default TTL for cached content served by this origin for
-- responses that do not have an existing valid TTL (max-age or s-max-age).
-- Setting a TTL of \"0\" means \"always revalidate\". The value of
-- defaultTTL cannot be set to a value greater than that of maxTTL, but can
-- be equal. When the cacheMode is set to FORCE_CACHE_ALL, the defaultTTL
-- will overwrite the TTL set in all responses. The maximum allowed value
-- is 31,622,400s (1 year), noting that infrequently accessed objects may
-- be evicted from the cache before the defined TTL.
bscpDefaultTtl :: Lens' BackendServiceCdnPolicy (Maybe Int32)
bscpDefaultTtl
  = lens _bscpDefaultTtl
      (\ s a -> s{_bscpDefaultTtl = a})
      . mapping _Coerce

-- | Negative caching allows per-status code TTLs to be set, in order to
-- apply fine-grained caching for common errors or redirects. This can
-- reduce the load on your origin and improve end-user experience by
-- reducing response latency. When the cache mode is set to
-- CACHE_ALL_STATIC or USE_ORIGIN_HEADERS, negative caching applies to
-- responses with the specified response code that lack any Cache-Control,
-- Expires, or Pragma: no-cache directives. When the cache mode is set to
-- FORCE_CACHE_ALL, negative caching applies to all responses with the
-- specified response code, and override any caching headers. By default,
-- Cloud CDN will apply the following default TTLs to these status codes:
-- HTTP 300 (Multiple Choice), 301, 308 (Permanent Redirects): 10m HTTP 404
-- (Not Found), 410 (Gone), 451 (Unavailable For Legal Reasons): 120s HTTP
-- 405 (Method Not Found), 421 (Misdirected Request), 501 (Not
-- Implemented): 60s. These defaults can be overridden in
-- negative_caching_policy.
bscpNegativeCaching :: Lens' BackendServiceCdnPolicy (Maybe Bool)
bscpNegativeCaching
  = lens _bscpNegativeCaching
      (\ s a -> s{_bscpNegativeCaching = a})

-- | [Output Only] Names of the keys for signing request URLs.
bscpSignedURLKeyNames :: Lens' BackendServiceCdnPolicy [Text]
bscpSignedURLKeyNames
  = lens _bscpSignedURLKeyNames
      (\ s a -> s{_bscpSignedURLKeyNames = a})
      . _Default
      . _Coerce

-- | The CacheKeyPolicy for this CdnPolicy.
bscpCacheKeyPolicy :: Lens' BackendServiceCdnPolicy (Maybe CacheKeyPolicy)
bscpCacheKeyPolicy
  = lens _bscpCacheKeyPolicy
      (\ s a -> s{_bscpCacheKeyPolicy = a})

instance FromJSON BackendServiceCdnPolicy where
        parseJSON
          = withObject "BackendServiceCdnPolicy"
              (\ o ->
                 BackendServiceCdnPolicy' <$>
                   (o .:? "serveWhileStale") <*>
                     (o .:? "signedUrlCacheMaxAgeSec")
                     <*> (o .:? "negativeCachingPolicy" .!= mempty)
                     <*> (o .:? "bypassCacheOnRequestHeaders" .!= mempty)
                     <*> (o .:? "requestCoalescing")
                     <*> (o .:? "clientTtl")
                     <*> (o .:? "maxTtl")
                     <*> (o .:? "cacheMode")
                     <*> (o .:? "defaultTtl")
                     <*> (o .:? "negativeCaching")
                     <*> (o .:? "signedUrlKeyNames" .!= mempty)
                     <*> (o .:? "cacheKeyPolicy"))

instance ToJSON BackendServiceCdnPolicy where
        toJSON BackendServiceCdnPolicy'{..}
          = object
              (catMaybes
                 [("serveWhileStale" .=) <$> _bscpServeWhileStale,
                  ("signedUrlCacheMaxAgeSec" .=) <$>
                    _bscpSignedURLCacheMaxAgeSec,
                  ("negativeCachingPolicy" .=) <$>
                    _bscpNegativeCachingPolicy,
                  ("bypassCacheOnRequestHeaders" .=) <$>
                    _bscpBypassCacheOnRequestHeaders,
                  ("requestCoalescing" .=) <$> _bscpRequestCoalescing,
                  ("clientTtl" .=) <$> _bscpClientTtl,
                  ("maxTtl" .=) <$> _bscpMaxTtl,
                  ("cacheMode" .=) <$> _bscpCacheMode,
                  ("defaultTtl" .=) <$> _bscpDefaultTtl,
                  ("negativeCaching" .=) <$> _bscpNegativeCaching,
                  ("signedUrlKeyNames" .=) <$> _bscpSignedURLKeyNames,
                  ("cacheKeyPolicy" .=) <$> _bscpCacheKeyPolicy])

--
-- /See:/ 'routeWarningsItemDataItem' smart constructor.
data RouteWarningsItemDataItem =
  RouteWarningsItemDataItem'
    { _rwidiValue :: !(Maybe Text)
    , _rwidiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RouteWarningsItemDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rwidiValue'
--
-- * 'rwidiKey'
routeWarningsItemDataItem
    :: RouteWarningsItemDataItem
routeWarningsItemDataItem =
  RouteWarningsItemDataItem' {_rwidiValue = Nothing, _rwidiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
rwidiValue :: Lens' RouteWarningsItemDataItem (Maybe Text)
rwidiValue
  = lens _rwidiValue (\ s a -> s{_rwidiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
rwidiKey :: Lens' RouteWarningsItemDataItem (Maybe Text)
rwidiKey = lens _rwidiKey (\ s a -> s{_rwidiKey = a})

instance FromJSON RouteWarningsItemDataItem where
        parseJSON
          = withObject "RouteWarningsItemDataItem"
              (\ o ->
                 RouteWarningsItemDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON RouteWarningsItemDataItem where
        toJSON RouteWarningsItemDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _rwidiValue,
                  ("key" .=) <$> _rwidiKey])

--
-- /See:/ 'nodeGroupAggregatedList' smart constructor.
data NodeGroupAggregatedList =
  NodeGroupAggregatedList'
    { _ngalUnreachables :: !(Maybe [Text])
    , _ngalNextPageToken :: !(Maybe Text)
    , _ngalKind :: !Text
    , _ngalItems :: !(Maybe NodeGroupAggregatedListItems)
    , _ngalSelfLink :: !(Maybe Text)
    , _ngalWarning :: !(Maybe NodeGroupAggregatedListWarning)
    , _ngalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeGroupAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ngalUnreachables'
--
-- * 'ngalNextPageToken'
--
-- * 'ngalKind'
--
-- * 'ngalItems'
--
-- * 'ngalSelfLink'
--
-- * 'ngalWarning'
--
-- * 'ngalId'
nodeGroupAggregatedList
    :: NodeGroupAggregatedList
nodeGroupAggregatedList =
  NodeGroupAggregatedList'
    { _ngalUnreachables = Nothing
    , _ngalNextPageToken = Nothing
    , _ngalKind = "compute#nodeGroupAggregatedList"
    , _ngalItems = Nothing
    , _ngalSelfLink = Nothing
    , _ngalWarning = Nothing
    , _ngalId = Nothing
    }


-- | [Output Only] Unreachable resources.
ngalUnreachables :: Lens' NodeGroupAggregatedList [Text]
ngalUnreachables
  = lens _ngalUnreachables
      (\ s a -> s{_ngalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
ngalNextPageToken :: Lens' NodeGroupAggregatedList (Maybe Text)
ngalNextPageToken
  = lens _ngalNextPageToken
      (\ s a -> s{_ngalNextPageToken = a})

-- | [Output Only] Type of resource.Always compute#nodeGroupAggregatedList
-- for aggregated lists of node groups.
ngalKind :: Lens' NodeGroupAggregatedList Text
ngalKind = lens _ngalKind (\ s a -> s{_ngalKind = a})

-- | A list of NodeGroupsScopedList resources.
ngalItems :: Lens' NodeGroupAggregatedList (Maybe NodeGroupAggregatedListItems)
ngalItems
  = lens _ngalItems (\ s a -> s{_ngalItems = a})

-- | [Output Only] Server-defined URL for this resource.
ngalSelfLink :: Lens' NodeGroupAggregatedList (Maybe Text)
ngalSelfLink
  = lens _ngalSelfLink (\ s a -> s{_ngalSelfLink = a})

-- | [Output Only] Informational warning message.
ngalWarning :: Lens' NodeGroupAggregatedList (Maybe NodeGroupAggregatedListWarning)
ngalWarning
  = lens _ngalWarning (\ s a -> s{_ngalWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
ngalId :: Lens' NodeGroupAggregatedList (Maybe Text)
ngalId = lens _ngalId (\ s a -> s{_ngalId = a})

instance FromJSON NodeGroupAggregatedList where
        parseJSON
          = withObject "NodeGroupAggregatedList"
              (\ o ->
                 NodeGroupAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!= "compute#nodeGroupAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON NodeGroupAggregatedList where
        toJSON NodeGroupAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _ngalUnreachables,
                  ("nextPageToken" .=) <$> _ngalNextPageToken,
                  Just ("kind" .= _ngalKind),
                  ("items" .=) <$> _ngalItems,
                  ("selfLink" .=) <$> _ngalSelfLink,
                  ("warning" .=) <$> _ngalWarning,
                  ("id" .=) <$> _ngalId])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'vpnTunnelListWarning' smart constructor.
data VPNTunnelListWarning =
  VPNTunnelListWarning'
    { _vtlwData :: !(Maybe [VPNTunnelListWarningDataItem])
    , _vtlwCode :: !(Maybe VPNTunnelListWarningCode)
    , _vtlwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNTunnelListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vtlwData'
--
-- * 'vtlwCode'
--
-- * 'vtlwMessage'
vpnTunnelListWarning
    :: VPNTunnelListWarning
vpnTunnelListWarning =
  VPNTunnelListWarning'
    {_vtlwData = Nothing, _vtlwCode = Nothing, _vtlwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
vtlwData :: Lens' VPNTunnelListWarning [VPNTunnelListWarningDataItem]
vtlwData
  = lens _vtlwData (\ s a -> s{_vtlwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
vtlwCode :: Lens' VPNTunnelListWarning (Maybe VPNTunnelListWarningCode)
vtlwCode = lens _vtlwCode (\ s a -> s{_vtlwCode = a})

-- | [Output Only] A human-readable description of the warning code.
vtlwMessage :: Lens' VPNTunnelListWarning (Maybe Text)
vtlwMessage
  = lens _vtlwMessage (\ s a -> s{_vtlwMessage = a})

instance FromJSON VPNTunnelListWarning where
        parseJSON
          = withObject "VPNTunnelListWarning"
              (\ o ->
                 VPNTunnelListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON VPNTunnelListWarning where
        toJSON VPNTunnelListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _vtlwData,
                  ("code" .=) <$> _vtlwCode,
                  ("message" .=) <$> _vtlwMessage])

-- | A list of BackendServicesScopedList resources.
--
-- /See:/ 'backendServiceAggregatedListItems' smart constructor.
newtype BackendServiceAggregatedListItems =
  BackendServiceAggregatedListItems'
    { _bsaliAddtional :: HashMap Text BackendServicesScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendServiceAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bsaliAddtional'
backendServiceAggregatedListItems
    :: HashMap Text BackendServicesScopedList -- ^ 'bsaliAddtional'
    -> BackendServiceAggregatedListItems
backendServiceAggregatedListItems pBsaliAddtional_ =
  BackendServiceAggregatedListItems'
    {_bsaliAddtional = _Coerce # pBsaliAddtional_}


-- | Name of the scope containing this set of BackendServices.
bsaliAddtional :: Lens' BackendServiceAggregatedListItems (HashMap Text BackendServicesScopedList)
bsaliAddtional
  = lens _bsaliAddtional
      (\ s a -> s{_bsaliAddtional = a})
      . _Coerce

instance FromJSON BackendServiceAggregatedListItems
         where
        parseJSON
          = withObject "BackendServiceAggregatedListItems"
              (\ o ->
                 BackendServiceAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON BackendServiceAggregatedListItems
         where
        toJSON = toJSON . _bsaliAddtional

--
-- /See:/ 'reservationsScopedListWarningDataItem' smart constructor.
data ReservationsScopedListWarningDataItem =
  ReservationsScopedListWarningDataItem'
    { _rslwdiValue :: !(Maybe Text)
    , _rslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ReservationsScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rslwdiValue'
--
-- * 'rslwdiKey'
reservationsScopedListWarningDataItem
    :: ReservationsScopedListWarningDataItem
reservationsScopedListWarningDataItem =
  ReservationsScopedListWarningDataItem'
    {_rslwdiValue = Nothing, _rslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
rslwdiValue :: Lens' ReservationsScopedListWarningDataItem (Maybe Text)
rslwdiValue
  = lens _rslwdiValue (\ s a -> s{_rslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
rslwdiKey :: Lens' ReservationsScopedListWarningDataItem (Maybe Text)
rslwdiKey
  = lens _rslwdiKey (\ s a -> s{_rslwdiKey = a})

instance FromJSON
           ReservationsScopedListWarningDataItem
         where
        parseJSON
          = withObject "ReservationsScopedListWarningDataItem"
              (\ o ->
                 ReservationsScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON ReservationsScopedListWarningDataItem
         where
        toJSON ReservationsScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _rslwdiValue,
                  ("key" .=) <$> _rslwdiKey])

-- | Represents a reservation resource. A reservation ensures that capacity
-- is held in a specific zone even if the reserved VMs are not running. For
-- more information, read Reserving zonal resources. (== resource_for
-- {$api_version}.reservations ==)
--
-- /See:/ 'reservation' smart constructor.
data Reservation =
  Reservation'
    { _rrSatisfiesPzs :: !(Maybe Bool)
    , _rrStatus :: !(Maybe ReservationStatus)
    , _rrKind :: !Text
    , _rrSpecificReservation :: !(Maybe AllocationSpecificSKUReservation)
    , _rrZone :: !(Maybe Text)
    , _rrSpecificReservationRequired :: !(Maybe Bool)
    , _rrSelfLink :: !(Maybe Text)
    , _rrName :: !(Maybe Text)
    , _rrCreationTimestamp :: !(Maybe Text)
    , _rrId :: !(Maybe (Textual Word64))
    , _rrCommitment :: !(Maybe Text)
    , _rrDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Reservation' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rrSatisfiesPzs'
--
-- * 'rrStatus'
--
-- * 'rrKind'
--
-- * 'rrSpecificReservation'
--
-- * 'rrZone'
--
-- * 'rrSpecificReservationRequired'
--
-- * 'rrSelfLink'
--
-- * 'rrName'
--
-- * 'rrCreationTimestamp'
--
-- * 'rrId'
--
-- * 'rrCommitment'
--
-- * 'rrDescription'
reservation
    :: Reservation
reservation =
  Reservation'
    { _rrSatisfiesPzs = Nothing
    , _rrStatus = Nothing
    , _rrKind = "compute#reservation"
    , _rrSpecificReservation = Nothing
    , _rrZone = Nothing
    , _rrSpecificReservationRequired = Nothing
    , _rrSelfLink = Nothing
    , _rrName = Nothing
    , _rrCreationTimestamp = Nothing
    , _rrId = Nothing
    , _rrCommitment = Nothing
    , _rrDescription = Nothing
    }


-- | [Output Only] Reserved for future use.
rrSatisfiesPzs :: Lens' Reservation (Maybe Bool)
rrSatisfiesPzs
  = lens _rrSatisfiesPzs
      (\ s a -> s{_rrSatisfiesPzs = a})

-- | [Output Only] The status of the reservation.
rrStatus :: Lens' Reservation (Maybe ReservationStatus)
rrStatus = lens _rrStatus (\ s a -> s{_rrStatus = a})

-- | [Output Only] Type of the resource. Always compute#reservations for
-- reservations.
rrKind :: Lens' Reservation Text
rrKind = lens _rrKind (\ s a -> s{_rrKind = a})

-- | Reservation for instances with specific machine shapes.
rrSpecificReservation :: Lens' Reservation (Maybe AllocationSpecificSKUReservation)
rrSpecificReservation
  = lens _rrSpecificReservation
      (\ s a -> s{_rrSpecificReservation = a})

-- | Zone in which the reservation resides. A zone must be provided if the
-- reservation is created within a commitment.
rrZone :: Lens' Reservation (Maybe Text)
rrZone = lens _rrZone (\ s a -> s{_rrZone = a})

-- | Indicates whether the reservation can be consumed by VMs with affinity
-- for \"any\" reservation. If the field is set, then only VMs that target
-- the reservation by name can consume from this reservation.
rrSpecificReservationRequired :: Lens' Reservation (Maybe Bool)
rrSpecificReservationRequired
  = lens _rrSpecificReservationRequired
      (\ s a -> s{_rrSpecificReservationRequired = a})

-- | [Output Only] Server-defined fully-qualified URL for this resource.
rrSelfLink :: Lens' Reservation (Maybe Text)
rrSelfLink
  = lens _rrSelfLink (\ s a -> s{_rrSelfLink = a})

-- | The name of the resource, provided by the client when initially creating
-- the resource. The resource name must be 1-63 characters long, and comply
-- with RFC1035. Specifically, the name must be 1-63 characters long and
-- match the regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means
-- the first character must be a lowercase letter, and all following
-- characters must be a dash, lowercase letter, or digit, except the last
-- character, which cannot be a dash.
rrName :: Lens' Reservation (Maybe Text)
rrName = lens _rrName (\ s a -> s{_rrName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
rrCreationTimestamp :: Lens' Reservation (Maybe Text)
rrCreationTimestamp
  = lens _rrCreationTimestamp
      (\ s a -> s{_rrCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
rrId :: Lens' Reservation (Maybe Word64)
rrId
  = lens _rrId (\ s a -> s{_rrId = a}) .
      mapping _Coerce

-- | [Output Only] Full or partial URL to a parent commitment. This field
-- displays for reservations that are tied to a commitment.
rrCommitment :: Lens' Reservation (Maybe Text)
rrCommitment
  = lens _rrCommitment (\ s a -> s{_rrCommitment = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource.
rrDescription :: Lens' Reservation (Maybe Text)
rrDescription
  = lens _rrDescription
      (\ s a -> s{_rrDescription = a})

instance FromJSON Reservation where
        parseJSON
          = withObject "Reservation"
              (\ o ->
                 Reservation' <$>
                   (o .:? "satisfiesPzs") <*> (o .:? "status") <*>
                     (o .:? "kind" .!= "compute#reservation")
                     <*> (o .:? "specificReservation")
                     <*> (o .:? "zone")
                     <*> (o .:? "specificReservationRequired")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "commitment")
                     <*> (o .:? "description"))

instance ToJSON Reservation where
        toJSON Reservation'{..}
          = object
              (catMaybes
                 [("satisfiesPzs" .=) <$> _rrSatisfiesPzs,
                  ("status" .=) <$> _rrStatus,
                  Just ("kind" .= _rrKind),
                  ("specificReservation" .=) <$>
                    _rrSpecificReservation,
                  ("zone" .=) <$> _rrZone,
                  ("specificReservationRequired" .=) <$>
                    _rrSpecificReservationRequired,
                  ("selfLink" .=) <$> _rrSelfLink,
                  ("name" .=) <$> _rrName,
                  ("creationTimestamp" .=) <$> _rrCreationTimestamp,
                  ("id" .=) <$> _rrId,
                  ("commitment" .=) <$> _rrCommitment,
                  ("description" .=) <$> _rrDescription])

--
-- /See:/ 'instanceManagedByIgmErrorManagedInstanceError' smart constructor.
data InstanceManagedByIgmErrorManagedInstanceError =
  InstanceManagedByIgmErrorManagedInstanceError'
    { _imbiemieCode :: !(Maybe Text)
    , _imbiemieMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceManagedByIgmErrorManagedInstanceError' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'imbiemieCode'
--
-- * 'imbiemieMessage'
instanceManagedByIgmErrorManagedInstanceError
    :: InstanceManagedByIgmErrorManagedInstanceError
instanceManagedByIgmErrorManagedInstanceError =
  InstanceManagedByIgmErrorManagedInstanceError'
    {_imbiemieCode = Nothing, _imbiemieMessage = Nothing}


-- | [Output Only] Error code.
imbiemieCode :: Lens' InstanceManagedByIgmErrorManagedInstanceError (Maybe Text)
imbiemieCode
  = lens _imbiemieCode (\ s a -> s{_imbiemieCode = a})

-- | [Output Only] Error message.
imbiemieMessage :: Lens' InstanceManagedByIgmErrorManagedInstanceError (Maybe Text)
imbiemieMessage
  = lens _imbiemieMessage
      (\ s a -> s{_imbiemieMessage = a})

instance FromJSON
           InstanceManagedByIgmErrorManagedInstanceError
         where
        parseJSON
          = withObject
              "InstanceManagedByIgmErrorManagedInstanceError"
              (\ o ->
                 InstanceManagedByIgmErrorManagedInstanceError' <$>
                   (o .:? "code") <*> (o .:? "message"))

instance ToJSON
           InstanceManagedByIgmErrorManagedInstanceError
         where
        toJSON
          InstanceManagedByIgmErrorManagedInstanceError'{..}
          = object
              (catMaybes
                 [("code" .=) <$> _imbiemieCode,
                  ("message" .=) <$> _imbiemieMessage])

-- | An object that contains a list of instances scoped by zone.
--
-- /See:/ 'instanceAggregatedListItems' smart constructor.
newtype InstanceAggregatedListItems =
  InstanceAggregatedListItems'
    { _ialiAddtional :: HashMap Text InstancesScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ialiAddtional'
instanceAggregatedListItems
    :: HashMap Text InstancesScopedList -- ^ 'ialiAddtional'
    -> InstanceAggregatedListItems
instanceAggregatedListItems pIaliAddtional_ =
  InstanceAggregatedListItems' {_ialiAddtional = _Coerce # pIaliAddtional_}


-- | [Output Only] Name of the scope containing this set of instances.
ialiAddtional :: Lens' InstanceAggregatedListItems (HashMap Text InstancesScopedList)
ialiAddtional
  = lens _ialiAddtional
      (\ s a -> s{_ialiAddtional = a})
      . _Coerce

instance FromJSON InstanceAggregatedListItems where
        parseJSON
          = withObject "InstanceAggregatedListItems"
              (\ o ->
                 InstanceAggregatedListItems' <$> (parseJSONObject o))

instance ToJSON InstanceAggregatedListItems where
        toJSON = toJSON . _ialiAddtional

-- | [Output Only] Informational warning which replaces the list of
-- autoscalers when the list is empty.
--
-- /See:/ 'autoscalersScopedListWarning' smart constructor.
data AutoscalersScopedListWarning =
  AutoscalersScopedListWarning'
    { _aslwData :: !(Maybe [AutoscalersScopedListWarningDataItem])
    , _aslwCode :: !(Maybe AutoscalersScopedListWarningCode)
    , _aslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AutoscalersScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'aslwData'
--
-- * 'aslwCode'
--
-- * 'aslwMessage'
autoscalersScopedListWarning
    :: AutoscalersScopedListWarning
autoscalersScopedListWarning =
  AutoscalersScopedListWarning'
    {_aslwData = Nothing, _aslwCode = Nothing, _aslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
aslwData :: Lens' AutoscalersScopedListWarning [AutoscalersScopedListWarningDataItem]
aslwData
  = lens _aslwData (\ s a -> s{_aslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
aslwCode :: Lens' AutoscalersScopedListWarning (Maybe AutoscalersScopedListWarningCode)
aslwCode = lens _aslwCode (\ s a -> s{_aslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
aslwMessage :: Lens' AutoscalersScopedListWarning (Maybe Text)
aslwMessage
  = lens _aslwMessage (\ s a -> s{_aslwMessage = a})

instance FromJSON AutoscalersScopedListWarning where
        parseJSON
          = withObject "AutoscalersScopedListWarning"
              (\ o ->
                 AutoscalersScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON AutoscalersScopedListWarning where
        toJSON AutoscalersScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _aslwData,
                  ("code" .=) <$> _aslwCode,
                  ("message" .=) <$> _aslwMessage])

--
-- /See:/ 'urlMapsScopedList' smart constructor.
data URLMapsScopedList =
  URLMapsScopedList'
    { _umslURLMaps :: !(Maybe [URLMap])
    , _umslWarning :: !(Maybe URLMapsScopedListWarning)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'URLMapsScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'umslURLMaps'
--
-- * 'umslWarning'
urlMapsScopedList
    :: URLMapsScopedList
urlMapsScopedList =
  URLMapsScopedList' {_umslURLMaps = Nothing, _umslWarning = Nothing}


-- | A list of UrlMaps contained in this scope.
umslURLMaps :: Lens' URLMapsScopedList [URLMap]
umslURLMaps
  = lens _umslURLMaps (\ s a -> s{_umslURLMaps = a}) .
      _Default
      . _Coerce

-- | Informational warning which replaces the list of backend services when
-- the list is empty.
umslWarning :: Lens' URLMapsScopedList (Maybe URLMapsScopedListWarning)
umslWarning
  = lens _umslWarning (\ s a -> s{_umslWarning = a})

instance FromJSON URLMapsScopedList where
        parseJSON
          = withObject "URLMapsScopedList"
              (\ o ->
                 URLMapsScopedList' <$>
                   (o .:? "urlMaps" .!= mempty) <*> (o .:? "warning"))

instance ToJSON URLMapsScopedList where
        toJSON URLMapsScopedList'{..}
          = object
              (catMaybes
                 [("urlMaps" .=) <$> _umslURLMaps,
                  ("warning" .=) <$> _umslWarning])

-- | A specification of the desired way to instantiate a disk in the instance
-- template when its created from a source instance.
--
-- /See:/ 'diskInstantiationConfig' smart constructor.
data DiskInstantiationConfig =
  DiskInstantiationConfig'
    { _dicAutoDelete :: !(Maybe Bool)
    , _dicInstantiateFrom :: !(Maybe DiskInstantiationConfigInstantiateFrom)
    , _dicCustomImage :: !(Maybe Text)
    , _dicDeviceName :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DiskInstantiationConfig' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dicAutoDelete'
--
-- * 'dicInstantiateFrom'
--
-- * 'dicCustomImage'
--
-- * 'dicDeviceName'
diskInstantiationConfig
    :: DiskInstantiationConfig
diskInstantiationConfig =
  DiskInstantiationConfig'
    { _dicAutoDelete = Nothing
    , _dicInstantiateFrom = Nothing
    , _dicCustomImage = Nothing
    , _dicDeviceName = Nothing
    }


-- | Specifies whether the disk will be auto-deleted when the instance is
-- deleted (but not when the disk is detached from the instance).
dicAutoDelete :: Lens' DiskInstantiationConfig (Maybe Bool)
dicAutoDelete
  = lens _dicAutoDelete
      (\ s a -> s{_dicAutoDelete = a})

-- | Specifies whether to include the disk and what image to use. Possible
-- values are: - source-image: to use the same image that was used to
-- create the source instance\'s corresponding disk. Applicable to the boot
-- disk and additional read-write disks. - source-image-family: to use the
-- same image family that was used to create the source instance\'s
-- corresponding disk. Applicable to the boot disk and additional
-- read-write disks. - custom-image: to use a user-provided image url for
-- disk creation. Applicable to the boot disk and additional read-write
-- disks. - attach-read-only: to attach a read-only disk. Applicable to
-- read-only disks. - do-not-include: to exclude a disk from the template.
-- Applicable to additional read-write disks, local SSDs, and read-only
-- disks.
dicInstantiateFrom :: Lens' DiskInstantiationConfig (Maybe DiskInstantiationConfigInstantiateFrom)
dicInstantiateFrom
  = lens _dicInstantiateFrom
      (\ s a -> s{_dicInstantiateFrom = a})

-- | The custom source image to be used to restore this disk when
-- instantiating this instance template.
dicCustomImage :: Lens' DiskInstantiationConfig (Maybe Text)
dicCustomImage
  = lens _dicCustomImage
      (\ s a -> s{_dicCustomImage = a})

-- | Specifies the device name of the disk to which the configurations apply
-- to.
dicDeviceName :: Lens' DiskInstantiationConfig (Maybe Text)
dicDeviceName
  = lens _dicDeviceName
      (\ s a -> s{_dicDeviceName = a})

instance FromJSON DiskInstantiationConfig where
        parseJSON
          = withObject "DiskInstantiationConfig"
              (\ o ->
                 DiskInstantiationConfig' <$>
                   (o .:? "autoDelete") <*> (o .:? "instantiateFrom")
                     <*> (o .:? "customImage")
                     <*> (o .:? "deviceName"))

instance ToJSON DiskInstantiationConfig where
        toJSON DiskInstantiationConfig'{..}
          = object
              (catMaybes
                 [("autoDelete" .=) <$> _dicAutoDelete,
                  ("instantiateFrom" .=) <$> _dicInstantiateFrom,
                  ("customImage" .=) <$> _dicCustomImage,
                  ("deviceName" .=) <$> _dicDeviceName])

--
-- /See:/ 'regionInstanceGroupManagersListInstanceConfigsResp' smart constructor.
data RegionInstanceGroupManagersListInstanceConfigsResp =
  RegionInstanceGroupManagersListInstanceConfigsResp'
    { _rigmlicrNextPageToken :: !(Maybe Text)
    , _rigmlicrItems :: !(Maybe [PerInstanceConfig])
    , _rigmlicrWarning :: !(Maybe RegionInstanceGroupManagersListInstanceConfigsRespWarning)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupManagersListInstanceConfigsResp' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rigmlicrNextPageToken'
--
-- * 'rigmlicrItems'
--
-- * 'rigmlicrWarning'
regionInstanceGroupManagersListInstanceConfigsResp
    :: RegionInstanceGroupManagersListInstanceConfigsResp
regionInstanceGroupManagersListInstanceConfigsResp =
  RegionInstanceGroupManagersListInstanceConfigsResp'
    { _rigmlicrNextPageToken = Nothing
    , _rigmlicrItems = Nothing
    , _rigmlicrWarning = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
rigmlicrNextPageToken :: Lens' RegionInstanceGroupManagersListInstanceConfigsResp (Maybe Text)
rigmlicrNextPageToken
  = lens _rigmlicrNextPageToken
      (\ s a -> s{_rigmlicrNextPageToken = a})

-- | [Output Only] The list of PerInstanceConfig.
rigmlicrItems :: Lens' RegionInstanceGroupManagersListInstanceConfigsResp [PerInstanceConfig]
rigmlicrItems
  = lens _rigmlicrItems
      (\ s a -> s{_rigmlicrItems = a})
      . _Default
      . _Coerce

-- | [Output Only] Informational warning message.
rigmlicrWarning :: Lens' RegionInstanceGroupManagersListInstanceConfigsResp (Maybe RegionInstanceGroupManagersListInstanceConfigsRespWarning)
rigmlicrWarning
  = lens _rigmlicrWarning
      (\ s a -> s{_rigmlicrWarning = a})

instance FromJSON
           RegionInstanceGroupManagersListInstanceConfigsResp
         where
        parseJSON
          = withObject
              "RegionInstanceGroupManagersListInstanceConfigsResp"
              (\ o ->
                 RegionInstanceGroupManagersListInstanceConfigsResp'
                   <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "items" .!= mempty)
                     <*> (o .:? "warning"))

instance ToJSON
           RegionInstanceGroupManagersListInstanceConfigsResp
         where
        toJSON
          RegionInstanceGroupManagersListInstanceConfigsResp'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _rigmlicrNextPageToken,
                  ("items" .=) <$> _rigmlicrItems,
                  ("warning" .=) <$> _rigmlicrWarning])

--
-- /See:/ 'localDisk' smart constructor.
data LocalDisk =
  LocalDisk'
    { _ldDiskSizeGb :: !(Maybe (Textual Int32))
    , _ldDiskCount :: !(Maybe (Textual Int32))
    , _ldDiskType :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'LocalDisk' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ldDiskSizeGb'
--
-- * 'ldDiskCount'
--
-- * 'ldDiskType'
localDisk
    :: LocalDisk
localDisk =
  LocalDisk'
    {_ldDiskSizeGb = Nothing, _ldDiskCount = Nothing, _ldDiskType = Nothing}


-- | Specifies the size of the disk in base-2 GB.
ldDiskSizeGb :: Lens' LocalDisk (Maybe Int32)
ldDiskSizeGb
  = lens _ldDiskSizeGb (\ s a -> s{_ldDiskSizeGb = a})
      . mapping _Coerce

-- | Specifies the number of such disks.
ldDiskCount :: Lens' LocalDisk (Maybe Int32)
ldDiskCount
  = lens _ldDiskCount (\ s a -> s{_ldDiskCount = a}) .
      mapping _Coerce

-- | Specifies the desired disk type on the node. This disk type must be a
-- local storage type (e.g.: local-ssd). Note that for nodeTemplates, this
-- should be the name of the disk type and not its URL.
ldDiskType :: Lens' LocalDisk (Maybe Text)
ldDiskType
  = lens _ldDiskType (\ s a -> s{_ldDiskType = a})

instance FromJSON LocalDisk where
        parseJSON
          = withObject "LocalDisk"
              (\ o ->
                 LocalDisk' <$>
                   (o .:? "diskSizeGb") <*> (o .:? "diskCount") <*>
                     (o .:? "diskType"))

instance ToJSON LocalDisk where
        toJSON LocalDisk'{..}
          = object
              (catMaybes
                 [("diskSizeGb" .=) <$> _ldDiskSizeGb,
                  ("diskCount" .=) <$> _ldDiskCount,
                  ("diskType" .=) <$> _ldDiskType])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'diskTypeAggregatedListWarning' smart constructor.
data DiskTypeAggregatedListWarning =
  DiskTypeAggregatedListWarning'
    { _dtalwData :: !(Maybe [DiskTypeAggregatedListWarningDataItem])
    , _dtalwCode :: !(Maybe DiskTypeAggregatedListWarningCode)
    , _dtalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DiskTypeAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dtalwData'
--
-- * 'dtalwCode'
--
-- * 'dtalwMessage'
diskTypeAggregatedListWarning
    :: DiskTypeAggregatedListWarning
diskTypeAggregatedListWarning =
  DiskTypeAggregatedListWarning'
    {_dtalwData = Nothing, _dtalwCode = Nothing, _dtalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
dtalwData :: Lens' DiskTypeAggregatedListWarning [DiskTypeAggregatedListWarningDataItem]
dtalwData
  = lens _dtalwData (\ s a -> s{_dtalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
dtalwCode :: Lens' DiskTypeAggregatedListWarning (Maybe DiskTypeAggregatedListWarningCode)
dtalwCode
  = lens _dtalwCode (\ s a -> s{_dtalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
dtalwMessage :: Lens' DiskTypeAggregatedListWarning (Maybe Text)
dtalwMessage
  = lens _dtalwMessage (\ s a -> s{_dtalwMessage = a})

instance FromJSON DiskTypeAggregatedListWarning where
        parseJSON
          = withObject "DiskTypeAggregatedListWarning"
              (\ o ->
                 DiskTypeAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON DiskTypeAggregatedListWarning where
        toJSON DiskTypeAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _dtalwData,
                  ("code" .=) <$> _dtalwCode,
                  ("message" .=) <$> _dtalwMessage])

--
-- /See:/ 'diskTypeListWarningDataItem' smart constructor.
data DiskTypeListWarningDataItem =
  DiskTypeListWarningDataItem'
    { _dtlwdiValue :: !(Maybe Text)
    , _dtlwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DiskTypeListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dtlwdiValue'
--
-- * 'dtlwdiKey'
diskTypeListWarningDataItem
    :: DiskTypeListWarningDataItem
diskTypeListWarningDataItem =
  DiskTypeListWarningDataItem' {_dtlwdiValue = Nothing, _dtlwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
dtlwdiValue :: Lens' DiskTypeListWarningDataItem (Maybe Text)
dtlwdiValue
  = lens _dtlwdiValue (\ s a -> s{_dtlwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
dtlwdiKey :: Lens' DiskTypeListWarningDataItem (Maybe Text)
dtlwdiKey
  = lens _dtlwdiKey (\ s a -> s{_dtlwdiKey = a})

instance FromJSON DiskTypeListWarningDataItem where
        parseJSON
          = withObject "DiskTypeListWarningDataItem"
              (\ o ->
                 DiskTypeListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON DiskTypeListWarningDataItem where
        toJSON DiskTypeListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _dtlwdiValue,
                  ("key" .=) <$> _dtlwdiKey])

-- | The retry policy associates with HttpRouteRule
--
-- /See:/ 'hTTPRetryPolicy' smart constructor.
data HTTPRetryPolicy =
  HTTPRetryPolicy'
    { _httprpNumRetries :: !(Maybe (Textual Word32))
    , _httprpPerTryTimeout :: !(Maybe Duration)
    , _httprpRetryConditions :: !(Maybe [Text])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HTTPRetryPolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'httprpNumRetries'
--
-- * 'httprpPerTryTimeout'
--
-- * 'httprpRetryConditions'
hTTPRetryPolicy
    :: HTTPRetryPolicy
hTTPRetryPolicy =
  HTTPRetryPolicy'
    { _httprpNumRetries = Nothing
    , _httprpPerTryTimeout = Nothing
    , _httprpRetryConditions = Nothing
    }


-- | Specifies the allowed number retries. This number must be > 0. If not
-- specified, defaults to 1.
httprpNumRetries :: Lens' HTTPRetryPolicy (Maybe Word32)
httprpNumRetries
  = lens _httprpNumRetries
      (\ s a -> s{_httprpNumRetries = a})
      . mapping _Coerce

-- | Specifies a non-zero timeout per retry attempt. If not specified, will
-- use the timeout set in HttpRouteAction. If timeout in HttpRouteAction is
-- not set, will use the largest timeout among all backend services
-- associated with the route.
httprpPerTryTimeout :: Lens' HTTPRetryPolicy (Maybe Duration)
httprpPerTryTimeout
  = lens _httprpPerTryTimeout
      (\ s a -> s{_httprpPerTryTimeout = a})

-- | Specifies one or more conditions when this retry rule applies. Valid
-- values are: - 5xx: Loadbalancer will attempt a retry if the backend
-- service responds with any 5xx response code, or if the backend service
-- does not respond at all, example: disconnects, reset, read timeout,
-- connection failure, and refused streams. - gateway-error: Similar to
-- 5xx, but only applies to response codes 502, 503 or 504. - -
-- connect-failure: Loadbalancer will retry on failures connecting to
-- backend services, for example due to connection timeouts. -
-- retriable-4xx: Loadbalancer will retry for retriable 4xx response codes.
-- Currently the only retriable error supported is 409. -
-- refused-stream:Loadbalancer will retry if the backend service resets the
-- stream with a REFUSED_STREAM error code. This reset type indicates that
-- it is safe to retry. - cancelledLoadbalancer will retry if the gRPC
-- status code in the response header is set to cancelled -
-- deadline-exceeded: Loadbalancer will retry if the gRPC status code in
-- the response header is set to deadline-exceeded - resource-exhausted:
-- Loadbalancer will retry if the gRPC status code in the response header
-- is set to resource-exhausted - unavailable: Loadbalancer will retry if
-- the gRPC status code in the response header is set to unavailable
httprpRetryConditions :: Lens' HTTPRetryPolicy [Text]
httprpRetryConditions
  = lens _httprpRetryConditions
      (\ s a -> s{_httprpRetryConditions = a})
      . _Default
      . _Coerce

instance FromJSON HTTPRetryPolicy where
        parseJSON
          = withObject "HTTPRetryPolicy"
              (\ o ->
                 HTTPRetryPolicy' <$>
                   (o .:? "numRetries") <*> (o .:? "perTryTimeout") <*>
                     (o .:? "retryConditions" .!= mempty))

instance ToJSON HTTPRetryPolicy where
        toJSON HTTPRetryPolicy'{..}
          = object
              (catMaybes
                 [("numRetries" .=) <$> _httprpNumRetries,
                  ("perTryTimeout" .=) <$> _httprpPerTryTimeout,
                  ("retryConditions" .=) <$> _httprpRetryConditions])

--
-- /See:/ 'wafExpressionSet' smart constructor.
data WafExpressionSet =
  WafExpressionSet'
    { _wesAliases :: !(Maybe [Text])
    , _wesExpressions :: !(Maybe [WafExpressionSetExpression])
    , _wesId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'WafExpressionSet' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'wesAliases'
--
-- * 'wesExpressions'
--
-- * 'wesId'
wafExpressionSet
    :: WafExpressionSet
wafExpressionSet =
  WafExpressionSet'
    {_wesAliases = Nothing, _wesExpressions = Nothing, _wesId = Nothing}


-- | A list of alternate IDs. The format should be: - E.g. XSS-stable Generic
-- suffix like \"stable\" is particularly useful if a policy likes to avail
-- newer set of expressions without having to change the policy. A given
-- alias name can\'t be used for more than one entity set.
wesAliases :: Lens' WafExpressionSet [Text]
wesAliases
  = lens _wesAliases (\ s a -> s{_wesAliases = a}) .
      _Default
      . _Coerce

-- | List of available expressions.
wesExpressions :: Lens' WafExpressionSet [WafExpressionSetExpression]
wesExpressions
  = lens _wesExpressions
      (\ s a -> s{_wesExpressions = a})
      . _Default
      . _Coerce

-- | Google specified expression set ID. The format should be: - E.g.
-- XSS-20170329
wesId :: Lens' WafExpressionSet (Maybe Text)
wesId = lens _wesId (\ s a -> s{_wesId = a})

instance FromJSON WafExpressionSet where
        parseJSON
          = withObject "WafExpressionSet"
              (\ o ->
                 WafExpressionSet' <$>
                   (o .:? "aliases" .!= mempty) <*>
                     (o .:? "expressions" .!= mempty)
                     <*> (o .:? "id"))

instance ToJSON WafExpressionSet where
        toJSON WafExpressionSet'{..}
          = object
              (catMaybes
                 [("aliases" .=) <$> _wesAliases,
                  ("expressions" .=) <$> _wesExpressions,
                  ("id" .=) <$> _wesId])

-- | Represents a rule that describes one or more match conditions along with
-- the action to be taken when traffic matches this condition (allow or
-- deny).
--
-- /See:/ 'securityPolicyRule' smart constructor.
data SecurityPolicyRule =
  SecurityPolicyRule'
    { _sprPriority :: !(Maybe (Textual Int32))
    , _sprKind :: !Text
    , _sprAction :: !(Maybe Text)
    , _sprPreview :: !(Maybe Bool)
    , _sprMatch :: !(Maybe SecurityPolicyRuleMatcher)
    , _sprDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SecurityPolicyRule' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sprPriority'
--
-- * 'sprKind'
--
-- * 'sprAction'
--
-- * 'sprPreview'
--
-- * 'sprMatch'
--
-- * 'sprDescription'
securityPolicyRule
    :: SecurityPolicyRule
securityPolicyRule =
  SecurityPolicyRule'
    { _sprPriority = Nothing
    , _sprKind = "compute#securityPolicyRule"
    , _sprAction = Nothing
    , _sprPreview = Nothing
    , _sprMatch = Nothing
    , _sprDescription = Nothing
    }


-- | An integer indicating the priority of a rule in the list. The priority
-- must be a positive value between 0 and 2147483647. Rules are evaluated
-- from highest to lowest priority where 0 is the highest priority and
-- 2147483647 is the lowest priority.
sprPriority :: Lens' SecurityPolicyRule (Maybe Int32)
sprPriority
  = lens _sprPriority (\ s a -> s{_sprPriority = a}) .
      mapping _Coerce

-- | [Output only] Type of the resource. Always compute#securityPolicyRule
-- for security policy rules
sprKind :: Lens' SecurityPolicyRule Text
sprKind = lens _sprKind (\ s a -> s{_sprKind = a})

-- | The Action to perform when the client connection triggers the rule. Can
-- currently be either \"allow\" or \"deny()\" where valid values for
-- status are 403, 404, and 502.
sprAction :: Lens' SecurityPolicyRule (Maybe Text)
sprAction
  = lens _sprAction (\ s a -> s{_sprAction = a})

-- | If set to true, the specified action is not enforced.
sprPreview :: Lens' SecurityPolicyRule (Maybe Bool)
sprPreview
  = lens _sprPreview (\ s a -> s{_sprPreview = a})

-- | A match condition that incoming traffic is evaluated against. If it
-- evaluates to true, the corresponding \'action\' is enforced.
sprMatch :: Lens' SecurityPolicyRule (Maybe SecurityPolicyRuleMatcher)
sprMatch = lens _sprMatch (\ s a -> s{_sprMatch = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource.
sprDescription :: Lens' SecurityPolicyRule (Maybe Text)
sprDescription
  = lens _sprDescription
      (\ s a -> s{_sprDescription = a})

instance FromJSON SecurityPolicyRule where
        parseJSON
          = withObject "SecurityPolicyRule"
              (\ o ->
                 SecurityPolicyRule' <$>
                   (o .:? "priority") <*>
                     (o .:? "kind" .!= "compute#securityPolicyRule")
                     <*> (o .:? "action")
                     <*> (o .:? "preview")
                     <*> (o .:? "match")
                     <*> (o .:? "description"))

instance ToJSON SecurityPolicyRule where
        toJSON SecurityPolicyRule'{..}
          = object
              (catMaybes
                 [("priority" .=) <$> _sprPriority,
                  Just ("kind" .= _sprKind),
                  ("action" .=) <$> _sprAction,
                  ("preview" .=) <$> _sprPreview,
                  ("match" .=) <$> _sprMatch,
                  ("description" .=) <$> _sprDescription])

-- | Response for the InterconnectsGetDiagnosticsRequest.
--
-- /See:/ 'interconnectsGetDiagnosticsResponse' smart constructor.
newtype InterconnectsGetDiagnosticsResponse =
  InterconnectsGetDiagnosticsResponse'
    { _igdrResult :: Maybe InterconnectDiagnostics
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectsGetDiagnosticsResponse' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igdrResult'
interconnectsGetDiagnosticsResponse
    :: InterconnectsGetDiagnosticsResponse
interconnectsGetDiagnosticsResponse =
  InterconnectsGetDiagnosticsResponse' {_igdrResult = Nothing}


igdrResult :: Lens' InterconnectsGetDiagnosticsResponse (Maybe InterconnectDiagnostics)
igdrResult
  = lens _igdrResult (\ s a -> s{_igdrResult = a})

instance FromJSON InterconnectsGetDiagnosticsResponse
         where
        parseJSON
          = withObject "InterconnectsGetDiagnosticsResponse"
              (\ o ->
                 InterconnectsGetDiagnosticsResponse' <$>
                   (o .:? "result"))

instance ToJSON InterconnectsGetDiagnosticsResponse
         where
        toJSON InterconnectsGetDiagnosticsResponse'{..}
          = object (catMaybes [("result" .=) <$> _igdrResult])

-- | In contrast to a single BackendService in HttpRouteAction to which all
-- matching traffic is directed to, WeightedBackendService allows traffic
-- to be split across multiple BackendServices. The volume of traffic for
-- each BackendService is proportional to the weight specified in each
-- WeightedBackendService
--
-- /See:/ 'weightedBackendService' smart constructor.
data WeightedBackendService =
  WeightedBackendService'
    { _wbsWeight :: !(Maybe (Textual Word32))
    , _wbsHeaderAction :: !(Maybe HTTPHeaderAction)
    , _wbsBackendService :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'WeightedBackendService' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'wbsWeight'
--
-- * 'wbsHeaderAction'
--
-- * 'wbsBackendService'
weightedBackendService
    :: WeightedBackendService
weightedBackendService =
  WeightedBackendService'
    { _wbsWeight = Nothing
    , _wbsHeaderAction = Nothing
    , _wbsBackendService = Nothing
    }


-- | Specifies the fraction of traffic sent to backendService, computed as
-- weight \/ (sum of all weightedBackendService weights in routeAction) .
-- The selection of a backend service is determined only for new traffic.
-- Once a user\'s request has been directed to a backendService, subsequent
-- requests will be sent to the same backendService as determined by the
-- BackendService\'s session affinity policy. The value must be between 0
-- and 1000
wbsWeight :: Lens' WeightedBackendService (Maybe Word32)
wbsWeight
  = lens _wbsWeight (\ s a -> s{_wbsWeight = a}) .
      mapping _Coerce

-- | Specifies changes to request and response headers that need to take
-- effect for the selected backendService. headerAction specified here take
-- effect before headerAction in the enclosing HttpRouteRule, PathMatcher
-- and UrlMap. Note that headerAction is not supported for Loadbalancers
-- that have their loadBalancingScheme set to EXTERNAL. Not supported when
-- the URL map is bound to target gRPC proxy that has validateForProxyless
-- field set to true.
wbsHeaderAction :: Lens' WeightedBackendService (Maybe HTTPHeaderAction)
wbsHeaderAction
  = lens _wbsHeaderAction
      (\ s a -> s{_wbsHeaderAction = a})

-- | The full or partial URL to the default BackendService resource. Before
-- forwarding the request to backendService, the loadbalancer applies any
-- relevant headerActions specified as part of this backendServiceWeight.
wbsBackendService :: Lens' WeightedBackendService (Maybe Text)
wbsBackendService
  = lens _wbsBackendService
      (\ s a -> s{_wbsBackendService = a})

instance FromJSON WeightedBackendService where
        parseJSON
          = withObject "WeightedBackendService"
              (\ o ->
                 WeightedBackendService' <$>
                   (o .:? "weight") <*> (o .:? "headerAction") <*>
                     (o .:? "backendService"))

instance ToJSON WeightedBackendService where
        toJSON WeightedBackendService'{..}
          = object
              (catMaybes
                 [("weight" .=) <$> _wbsWeight,
                  ("headerAction" .=) <$> _wbsHeaderAction,
                  ("backendService" .=) <$> _wbsBackendService])

--
-- /See:/ 'vpnTunnelAggregatedListWarningDataItem' smart constructor.
data VPNTunnelAggregatedListWarningDataItem =
  VPNTunnelAggregatedListWarningDataItem'
    { _vtalwdiValue :: !(Maybe Text)
    , _vtalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNTunnelAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vtalwdiValue'
--
-- * 'vtalwdiKey'
vpnTunnelAggregatedListWarningDataItem
    :: VPNTunnelAggregatedListWarningDataItem
vpnTunnelAggregatedListWarningDataItem =
  VPNTunnelAggregatedListWarningDataItem'
    {_vtalwdiValue = Nothing, _vtalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
vtalwdiValue :: Lens' VPNTunnelAggregatedListWarningDataItem (Maybe Text)
vtalwdiValue
  = lens _vtalwdiValue (\ s a -> s{_vtalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
vtalwdiKey :: Lens' VPNTunnelAggregatedListWarningDataItem (Maybe Text)
vtalwdiKey
  = lens _vtalwdiKey (\ s a -> s{_vtalwdiKey = a})

instance FromJSON
           VPNTunnelAggregatedListWarningDataItem
         where
        parseJSON
          = withObject "VPNTunnelAggregatedListWarningDataItem"
              (\ o ->
                 VPNTunnelAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           VPNTunnelAggregatedListWarningDataItem
         where
        toJSON VPNTunnelAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _vtalwdiValue,
                  ("key" .=) <$> _vtalwdiKey])

-- | Encapsulates numeric value that can be either absolute or relative.
--
-- /See:/ 'fixedOrPercent' smart constructor.
data FixedOrPercent =
  FixedOrPercent'
    { _fopCalculated :: !(Maybe (Textual Int32))
    , _fopPercent :: !(Maybe (Textual Int32))
    , _fopFixed :: !(Maybe (Textual Int32))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'FixedOrPercent' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'fopCalculated'
--
-- * 'fopPercent'
--
-- * 'fopFixed'
fixedOrPercent
    :: FixedOrPercent
fixedOrPercent =
  FixedOrPercent'
    {_fopCalculated = Nothing, _fopPercent = Nothing, _fopFixed = Nothing}


-- | [Output Only] Absolute value of VM instances calculated based on the
-- specific mode. - If the value is fixed, then the calculated value is
-- equal to the fixed value. - If the value is a percent, then the
-- calculated value is percent\/100 * targetSize. For example, the
-- calculated value of a 80% of a managed instance group with 150 instances
-- would be (80\/100 * 150) = 120 VM instances. If there is a remainder,
-- the number is rounded.
fopCalculated :: Lens' FixedOrPercent (Maybe Int32)
fopCalculated
  = lens _fopCalculated
      (\ s a -> s{_fopCalculated = a})
      . mapping _Coerce

-- | Specifies a percentage of instances between 0 to 100%, inclusive. For
-- example, specify 80 for 80%.
fopPercent :: Lens' FixedOrPercent (Maybe Int32)
fopPercent
  = lens _fopPercent (\ s a -> s{_fopPercent = a}) .
      mapping _Coerce

-- | Specifies a fixed number of VM instances. This must be a positive
-- integer.
fopFixed :: Lens' FixedOrPercent (Maybe Int32)
fopFixed
  = lens _fopFixed (\ s a -> s{_fopFixed = a}) .
      mapping _Coerce

instance FromJSON FixedOrPercent where
        parseJSON
          = withObject "FixedOrPercent"
              (\ o ->
                 FixedOrPercent' <$>
                   (o .:? "calculated") <*> (o .:? "percent") <*>
                     (o .:? "fixed"))

instance ToJSON FixedOrPercent where
        toJSON FixedOrPercent'{..}
          = object
              (catMaybes
                 [("calculated" .=) <$> _fopCalculated,
                  ("percent" .=) <$> _fopPercent,
                  ("fixed" .=) <$> _fopFixed])

-- | The available logging options for a firewall rule.
--
-- /See:/ 'firewallLogConfig' smart constructor.
data FirewallLogConfig =
  FirewallLogConfig'
    { _flcEnable :: !(Maybe Bool)
    , _flcMetadata :: !(Maybe FirewallLogConfigMetadata)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'FirewallLogConfig' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'flcEnable'
--
-- * 'flcMetadata'
firewallLogConfig
    :: FirewallLogConfig
firewallLogConfig =
  FirewallLogConfig' {_flcEnable = Nothing, _flcMetadata = Nothing}


-- | This field denotes whether to enable logging for a particular firewall
-- rule.
flcEnable :: Lens' FirewallLogConfig (Maybe Bool)
flcEnable
  = lens _flcEnable (\ s a -> s{_flcEnable = a})

-- | This field can only be specified for a particular firewall rule if
-- logging is enabled for that rule. This field denotes whether to include
-- or exclude metadata for firewall logs.
flcMetadata :: Lens' FirewallLogConfig (Maybe FirewallLogConfigMetadata)
flcMetadata
  = lens _flcMetadata (\ s a -> s{_flcMetadata = a})

instance FromJSON FirewallLogConfig where
        parseJSON
          = withObject "FirewallLogConfig"
              (\ o ->
                 FirewallLogConfig' <$>
                   (o .:? "enable") <*> (o .:? "metadata"))

instance ToJSON FirewallLogConfig where
        toJSON FirewallLogConfig'{..}
          = object
              (catMaybes
                 [("enable" .=) <$> _flcEnable,
                  ("metadata" .=) <$> _flcMetadata])

-- | The policy describes the baseline against which Instance boot integrity
-- is measured.
--
-- /See:/ 'shieldedInstanceIntegrityPolicy' smart constructor.
newtype ShieldedInstanceIntegrityPolicy =
  ShieldedInstanceIntegrityPolicy'
    { _siipUpdateAutoLearnPolicy :: Maybe Bool
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ShieldedInstanceIntegrityPolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'siipUpdateAutoLearnPolicy'
shieldedInstanceIntegrityPolicy
    :: ShieldedInstanceIntegrityPolicy
shieldedInstanceIntegrityPolicy =
  ShieldedInstanceIntegrityPolicy' {_siipUpdateAutoLearnPolicy = Nothing}


-- | Updates the integrity policy baseline using the measurements from the VM
-- instance\'s most recent boot.
siipUpdateAutoLearnPolicy :: Lens' ShieldedInstanceIntegrityPolicy (Maybe Bool)
siipUpdateAutoLearnPolicy
  = lens _siipUpdateAutoLearnPolicy
      (\ s a -> s{_siipUpdateAutoLearnPolicy = a})

instance FromJSON ShieldedInstanceIntegrityPolicy
         where
        parseJSON
          = withObject "ShieldedInstanceIntegrityPolicy"
              (\ o ->
                 ShieldedInstanceIntegrityPolicy' <$>
                   (o .:? "updateAutoLearnPolicy"))

instance ToJSON ShieldedInstanceIntegrityPolicy where
        toJSON ShieldedInstanceIntegrityPolicy'{..}
          = object
              (catMaybes
                 [("updateAutoLearnPolicy" .=) <$>
                    _siipUpdateAutoLearnPolicy])

-- | Represents a Nat resource. It enables the VMs within the specified
-- subnetworks to access Internet without external IP addresses. It
-- specifies a list of subnetworks (and the ranges within) that want to use
-- NAT. Customers can also provide the external IPs that would be used for
-- NAT. GCP would auto-allocate ephemeral IPs if no external IPs are
-- provided.
--
-- /See:/ 'routerNAT' smart constructor.
data RouterNAT =
  RouterNAT'
    { _rnatNATIPAllocateOption :: !(Maybe RouterNATNATIPAllocateOption)
    , _rnatICMPIdleTimeoutSec :: !(Maybe (Textual Int32))
    , _rnatEnableEndpointIndependentMApping :: !(Maybe Bool)
    , _rnatUdpIdleTimeoutSec :: !(Maybe (Textual Int32))
    , _rnatNATIPs :: !(Maybe [Text])
    , _rnatSubnetworks :: !(Maybe [RouterNATSubnetworkToNAT])
    , _rnatMinPortsPerVM :: !(Maybe (Textual Int32))
    , _rnatName :: !(Maybe Text)
    , _rnatSourceSubnetworkIPRangesToNAT :: !(Maybe RouterNATSourceSubnetworkIPRangesToNAT)
    , _rnatTCPEstablishedIdleTimeoutSec :: !(Maybe (Textual Int32))
    , _rnatLogConfig :: !(Maybe RouterNATLogConfig)
    , _rnatTCPTransitoryIdleTimeoutSec :: !(Maybe (Textual Int32))
    , _rnatDrainNATIPs :: !(Maybe [Text])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RouterNAT' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rnatNATIPAllocateOption'
--
-- * 'rnatICMPIdleTimeoutSec'
--
-- * 'rnatEnableEndpointIndependentMApping'
--
-- * 'rnatUdpIdleTimeoutSec'
--
-- * 'rnatNATIPs'
--
-- * 'rnatSubnetworks'
--
-- * 'rnatMinPortsPerVM'
--
-- * 'rnatName'
--
-- * 'rnatSourceSubnetworkIPRangesToNAT'
--
-- * 'rnatTCPEstablishedIdleTimeoutSec'
--
-- * 'rnatLogConfig'
--
-- * 'rnatTCPTransitoryIdleTimeoutSec'
--
-- * 'rnatDrainNATIPs'
routerNAT
    :: RouterNAT
routerNAT =
  RouterNAT'
    { _rnatNATIPAllocateOption = Nothing
    , _rnatICMPIdleTimeoutSec = Nothing
    , _rnatEnableEndpointIndependentMApping = Nothing
    , _rnatUdpIdleTimeoutSec = Nothing
    , _rnatNATIPs = Nothing
    , _rnatSubnetworks = Nothing
    , _rnatMinPortsPerVM = Nothing
    , _rnatName = Nothing
    , _rnatSourceSubnetworkIPRangesToNAT = Nothing
    , _rnatTCPEstablishedIdleTimeoutSec = Nothing
    , _rnatLogConfig = Nothing
    , _rnatTCPTransitoryIdleTimeoutSec = Nothing
    , _rnatDrainNATIPs = Nothing
    }


-- | Specify the NatIpAllocateOption, which can take one of the following
-- values: - MANUAL_ONLY: Uses only Nat IP addresses provided by customers.
-- When there are not enough specified Nat IPs, the Nat service fails for
-- new VMs. - AUTO_ONLY: Nat IPs are allocated by Google Cloud Platform;
-- customers can\'t specify any Nat IPs. When choosing AUTO_ONLY, then
-- nat_ip should be empty.
rnatNATIPAllocateOption :: Lens' RouterNAT (Maybe RouterNATNATIPAllocateOption)
rnatNATIPAllocateOption
  = lens _rnatNATIPAllocateOption
      (\ s a -> s{_rnatNATIPAllocateOption = a})

-- | Timeout (in seconds) for ICMP connections. Defaults to 30s if not set.
rnatICMPIdleTimeoutSec :: Lens' RouterNAT (Maybe Int32)
rnatICMPIdleTimeoutSec
  = lens _rnatICMPIdleTimeoutSec
      (\ s a -> s{_rnatICMPIdleTimeoutSec = a})
      . mapping _Coerce

rnatEnableEndpointIndependentMApping :: Lens' RouterNAT (Maybe Bool)
rnatEnableEndpointIndependentMApping
  = lens _rnatEnableEndpointIndependentMApping
      (\ s a ->
         s{_rnatEnableEndpointIndependentMApping = a})

-- | Timeout (in seconds) for UDP connections. Defaults to 30s if not set.
rnatUdpIdleTimeoutSec :: Lens' RouterNAT (Maybe Int32)
rnatUdpIdleTimeoutSec
  = lens _rnatUdpIdleTimeoutSec
      (\ s a -> s{_rnatUdpIdleTimeoutSec = a})
      . mapping _Coerce

-- | A list of URLs of the IP resources used for this Nat service. These IP
-- addresses must be valid static external IP addresses assigned to the
-- project.
rnatNATIPs :: Lens' RouterNAT [Text]
rnatNATIPs
  = lens _rnatNATIPs (\ s a -> s{_rnatNATIPs = a}) .
      _Default
      . _Coerce

-- | A list of Subnetwork resources whose traffic should be translated by NAT
-- Gateway. It is used only when LIST_OF_SUBNETWORKS is selected for the
-- SubnetworkIpRangeToNatOption above.
rnatSubnetworks :: Lens' RouterNAT [RouterNATSubnetworkToNAT]
rnatSubnetworks
  = lens _rnatSubnetworks
      (\ s a -> s{_rnatSubnetworks = a})
      . _Default
      . _Coerce

-- | Minimum number of ports allocated to a VM from this NAT config. If not
-- set, a default number of ports is allocated to a VM. This is rounded up
-- to the nearest power of 2. For example, if the value of this field is
-- 50, at least 64 ports are allocated to a VM.
rnatMinPortsPerVM :: Lens' RouterNAT (Maybe Int32)
rnatMinPortsPerVM
  = lens _rnatMinPortsPerVM
      (\ s a -> s{_rnatMinPortsPerVM = a})
      . mapping _Coerce

-- | Unique name of this Nat service. The name must be 1-63 characters long
-- and comply with RFC1035.
rnatName :: Lens' RouterNAT (Maybe Text)
rnatName = lens _rnatName (\ s a -> s{_rnatName = a})

-- | Specify the Nat option, which can take one of the following values: -
-- ALL_SUBNETWORKS_ALL_IP_RANGES: All of the IP ranges in every Subnetwork
-- are allowed to Nat. - ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES: All of the
-- primary IP ranges in every Subnetwork are allowed to Nat. -
-- LIST_OF_SUBNETWORKS: A list of Subnetworks are allowed to Nat (specified
-- in the field subnetwork below) The default is
-- SUBNETWORK_IP_RANGE_TO_NAT_OPTION_UNSPECIFIED. Note that if this field
-- contains ALL_SUBNETWORKS_ALL_IP_RANGES or
-- ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES, then there should not be any
-- other Router.Nat section in any Router for this network in this region.
rnatSourceSubnetworkIPRangesToNAT :: Lens' RouterNAT (Maybe RouterNATSourceSubnetworkIPRangesToNAT)
rnatSourceSubnetworkIPRangesToNAT
  = lens _rnatSourceSubnetworkIPRangesToNAT
      (\ s a -> s{_rnatSourceSubnetworkIPRangesToNAT = a})

-- | Timeout (in seconds) for TCP established connections. Defaults to 1200s
-- if not set.
rnatTCPEstablishedIdleTimeoutSec :: Lens' RouterNAT (Maybe Int32)
rnatTCPEstablishedIdleTimeoutSec
  = lens _rnatTCPEstablishedIdleTimeoutSec
      (\ s a -> s{_rnatTCPEstablishedIdleTimeoutSec = a})
      . mapping _Coerce

-- | Configure logging on this NAT.
rnatLogConfig :: Lens' RouterNAT (Maybe RouterNATLogConfig)
rnatLogConfig
  = lens _rnatLogConfig
      (\ s a -> s{_rnatLogConfig = a})

-- | Timeout (in seconds) for TCP transitory connections. Defaults to 30s if
-- not set.
rnatTCPTransitoryIdleTimeoutSec :: Lens' RouterNAT (Maybe Int32)
rnatTCPTransitoryIdleTimeoutSec
  = lens _rnatTCPTransitoryIdleTimeoutSec
      (\ s a -> s{_rnatTCPTransitoryIdleTimeoutSec = a})
      . mapping _Coerce

-- | A list of URLs of the IP resources to be drained. These IPs must be
-- valid static external IPs that have been assigned to the NAT. These IPs
-- should be used for updating\/patching a NAT only.
rnatDrainNATIPs :: Lens' RouterNAT [Text]
rnatDrainNATIPs
  = lens _rnatDrainNATIPs
      (\ s a -> s{_rnatDrainNATIPs = a})
      . _Default
      . _Coerce

instance FromJSON RouterNAT where
        parseJSON
          = withObject "RouterNAT"
              (\ o ->
                 RouterNAT' <$>
                   (o .:? "natIpAllocateOption") <*>
                     (o .:? "icmpIdleTimeoutSec")
                     <*> (o .:? "enableEndpointIndependentMapping")
                     <*> (o .:? "udpIdleTimeoutSec")
                     <*> (o .:? "natIps" .!= mempty)
                     <*> (o .:? "subnetworks" .!= mempty)
                     <*> (o .:? "minPortsPerVm")
                     <*> (o .:? "name")
                     <*> (o .:? "sourceSubnetworkIpRangesToNat")
                     <*> (o .:? "tcpEstablishedIdleTimeoutSec")
                     <*> (o .:? "logConfig")
                     <*> (o .:? "tcpTransitoryIdleTimeoutSec")
                     <*> (o .:? "drainNatIps" .!= mempty))

instance ToJSON RouterNAT where
        toJSON RouterNAT'{..}
          = object
              (catMaybes
                 [("natIpAllocateOption" .=) <$>
                    _rnatNATIPAllocateOption,
                  ("icmpIdleTimeoutSec" .=) <$>
                    _rnatICMPIdleTimeoutSec,
                  ("enableEndpointIndependentMapping" .=) <$>
                    _rnatEnableEndpointIndependentMApping,
                  ("udpIdleTimeoutSec" .=) <$> _rnatUdpIdleTimeoutSec,
                  ("natIps" .=) <$> _rnatNATIPs,
                  ("subnetworks" .=) <$> _rnatSubnetworks,
                  ("minPortsPerVm" .=) <$> _rnatMinPortsPerVM,
                  ("name" .=) <$> _rnatName,
                  ("sourceSubnetworkIpRangesToNat" .=) <$>
                    _rnatSourceSubnetworkIPRangesToNAT,
                  ("tcpEstablishedIdleTimeoutSec" .=) <$>
                    _rnatTCPEstablishedIdleTimeoutSec,
                  ("logConfig" .=) <$> _rnatLogConfig,
                  ("tcpTransitoryIdleTimeoutSec" .=) <$>
                    _rnatTCPTransitoryIdleTimeoutSec,
                  ("drainNatIps" .=) <$> _rnatDrainNATIPs])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'autoscalerAggregatedListWarning' smart constructor.
data AutoscalerAggregatedListWarning =
  AutoscalerAggregatedListWarning'
    { _aalwData :: !(Maybe [AutoscalerAggregatedListWarningDataItem])
    , _aalwCode :: !(Maybe AutoscalerAggregatedListWarningCode)
    , _aalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AutoscalerAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'aalwData'
--
-- * 'aalwCode'
--
-- * 'aalwMessage'
autoscalerAggregatedListWarning
    :: AutoscalerAggregatedListWarning
autoscalerAggregatedListWarning =
  AutoscalerAggregatedListWarning'
    {_aalwData = Nothing, _aalwCode = Nothing, _aalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
aalwData :: Lens' AutoscalerAggregatedListWarning [AutoscalerAggregatedListWarningDataItem]
aalwData
  = lens _aalwData (\ s a -> s{_aalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
aalwCode :: Lens' AutoscalerAggregatedListWarning (Maybe AutoscalerAggregatedListWarningCode)
aalwCode = lens _aalwCode (\ s a -> s{_aalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
aalwMessage :: Lens' AutoscalerAggregatedListWarning (Maybe Text)
aalwMessage
  = lens _aalwMessage (\ s a -> s{_aalwMessage = a})

instance FromJSON AutoscalerAggregatedListWarning
         where
        parseJSON
          = withObject "AutoscalerAggregatedListWarning"
              (\ o ->
                 AutoscalerAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON AutoscalerAggregatedListWarning where
        toJSON AutoscalerAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _aalwData,
                  ("code" .=) <$> _aalwCode,
                  ("message" .=) <$> _aalwMessage])

--
-- /See:/ 'autoscalerListWarningDataItem' smart constructor.
data AutoscalerListWarningDataItem =
  AutoscalerListWarningDataItem'
    { _alwdiValue :: !(Maybe Text)
    , _alwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AutoscalerListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'alwdiValue'
--
-- * 'alwdiKey'
autoscalerListWarningDataItem
    :: AutoscalerListWarningDataItem
autoscalerListWarningDataItem =
  AutoscalerListWarningDataItem' {_alwdiValue = Nothing, _alwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
alwdiValue :: Lens' AutoscalerListWarningDataItem (Maybe Text)
alwdiValue
  = lens _alwdiValue (\ s a -> s{_alwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
alwdiKey :: Lens' AutoscalerListWarningDataItem (Maybe Text)
alwdiKey = lens _alwdiKey (\ s a -> s{_alwdiKey = a})

instance FromJSON AutoscalerListWarningDataItem where
        parseJSON
          = withObject "AutoscalerListWarningDataItem"
              (\ o ->
                 AutoscalerListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON AutoscalerListWarningDataItem where
        toJSON AutoscalerListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _alwdiValue,
                  ("key" .=) <$> _alwdiKey])

-- | A list of PacketMirroring resources.
--
-- /See:/ 'packetMirroringAggregatedListItems' smart constructor.
newtype PacketMirroringAggregatedListItems =
  PacketMirroringAggregatedListItems'
    { _pmaliAddtional :: HashMap Text PacketMirroringsScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PacketMirroringAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pmaliAddtional'
packetMirroringAggregatedListItems
    :: HashMap Text PacketMirroringsScopedList -- ^ 'pmaliAddtional'
    -> PacketMirroringAggregatedListItems
packetMirroringAggregatedListItems pPmaliAddtional_ =
  PacketMirroringAggregatedListItems'
    {_pmaliAddtional = _Coerce # pPmaliAddtional_}


-- | Name of the scope containing this set of packetMirrorings.
pmaliAddtional :: Lens' PacketMirroringAggregatedListItems (HashMap Text PacketMirroringsScopedList)
pmaliAddtional
  = lens _pmaliAddtional
      (\ s a -> s{_pmaliAddtional = a})
      . _Coerce

instance FromJSON PacketMirroringAggregatedListItems
         where
        parseJSON
          = withObject "PacketMirroringAggregatedListItems"
              (\ o ->
                 PacketMirroringAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON PacketMirroringAggregatedListItems
         where
        toJSON = toJSON . _pmaliAddtional

--
-- /See:/ 'instanceGroupManagersListPerInstanceConfigsRespWarningDataItem' smart constructor.
data InstanceGroupManagersListPerInstanceConfigsRespWarningDataItem =
  InstanceGroupManagersListPerInstanceConfigsRespWarningDataItem'
    { _igmlpicrwdiValue :: !(Maybe Text)
    , _igmlpicrwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagersListPerInstanceConfigsRespWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmlpicrwdiValue'
--
-- * 'igmlpicrwdiKey'
instanceGroupManagersListPerInstanceConfigsRespWarningDataItem
    :: InstanceGroupManagersListPerInstanceConfigsRespWarningDataItem
instanceGroupManagersListPerInstanceConfigsRespWarningDataItem =
  InstanceGroupManagersListPerInstanceConfigsRespWarningDataItem'
    {_igmlpicrwdiValue = Nothing, _igmlpicrwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
igmlpicrwdiValue :: Lens' InstanceGroupManagersListPerInstanceConfigsRespWarningDataItem (Maybe Text)
igmlpicrwdiValue
  = lens _igmlpicrwdiValue
      (\ s a -> s{_igmlpicrwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
igmlpicrwdiKey :: Lens' InstanceGroupManagersListPerInstanceConfigsRespWarningDataItem (Maybe Text)
igmlpicrwdiKey
  = lens _igmlpicrwdiKey
      (\ s a -> s{_igmlpicrwdiKey = a})

instance FromJSON
           InstanceGroupManagersListPerInstanceConfigsRespWarningDataItem
         where
        parseJSON
          = withObject
              "InstanceGroupManagersListPerInstanceConfigsRespWarningDataItem"
              (\ o ->
                 InstanceGroupManagersListPerInstanceConfigsRespWarningDataItem'
                   <$> (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           InstanceGroupManagersListPerInstanceConfigsRespWarningDataItem
         where
        toJSON
          InstanceGroupManagersListPerInstanceConfigsRespWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _igmlpicrwdiValue,
                  ("key" .=) <$> _igmlpicrwdiKey])

--
-- /See:/ 'resourcePolicyList' smart constructor.
data ResourcePolicyList =
  ResourcePolicyList'
    { _rplEtag :: !(Maybe Text)
    , _rplNextPageToken :: !(Maybe Text)
    , _rplKind :: !Text
    , _rplItems :: !(Maybe [ResourcePolicy])
    , _rplSelfLink :: !(Maybe Text)
    , _rplWarning :: !(Maybe ResourcePolicyListWarning)
    , _rplId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePolicyList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rplEtag'
--
-- * 'rplNextPageToken'
--
-- * 'rplKind'
--
-- * 'rplItems'
--
-- * 'rplSelfLink'
--
-- * 'rplWarning'
--
-- * 'rplId'
resourcePolicyList
    :: ResourcePolicyList
resourcePolicyList =
  ResourcePolicyList'
    { _rplEtag = Nothing
    , _rplNextPageToken = Nothing
    , _rplKind = "compute#resourcePolicyList"
    , _rplItems = Nothing
    , _rplSelfLink = Nothing
    , _rplWarning = Nothing
    , _rplId = Nothing
    }


rplEtag :: Lens' ResourcePolicyList (Maybe Text)
rplEtag = lens _rplEtag (\ s a -> s{_rplEtag = a})

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
rplNextPageToken :: Lens' ResourcePolicyList (Maybe Text)
rplNextPageToken
  = lens _rplNextPageToken
      (\ s a -> s{_rplNextPageToken = a})

-- | [Output Only] Type of resource.Always compute#resourcePoliciesList for
-- listsof resourcePolicies
rplKind :: Lens' ResourcePolicyList Text
rplKind = lens _rplKind (\ s a -> s{_rplKind = a})

-- | [Output Only] A list of ResourcePolicy resources.
rplItems :: Lens' ResourcePolicyList [ResourcePolicy]
rplItems
  = lens _rplItems (\ s a -> s{_rplItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
rplSelfLink :: Lens' ResourcePolicyList (Maybe Text)
rplSelfLink
  = lens _rplSelfLink (\ s a -> s{_rplSelfLink = a})

-- | [Output Only] Informational warning message.
rplWarning :: Lens' ResourcePolicyList (Maybe ResourcePolicyListWarning)
rplWarning
  = lens _rplWarning (\ s a -> s{_rplWarning = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
rplId :: Lens' ResourcePolicyList (Maybe Text)
rplId = lens _rplId (\ s a -> s{_rplId = a})

instance FromJSON ResourcePolicyList where
        parseJSON
          = withObject "ResourcePolicyList"
              (\ o ->
                 ResourcePolicyList' <$>
                   (o .:? "etag") <*> (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#resourcePolicyList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON ResourcePolicyList where
        toJSON ResourcePolicyList'{..}
          = object
              (catMaybes
                 [("etag" .=) <$> _rplEtag,
                  ("nextPageToken" .=) <$> _rplNextPageToken,
                  Just ("kind" .= _rplKind),
                  ("items" .=) <$> _rplItems,
                  ("selfLink" .=) <$> _rplSelfLink,
                  ("warning" .=) <$> _rplWarning,
                  ("id" .=) <$> _rplId])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'nodeTypeListWarning' smart constructor.
data NodeTypeListWarning =
  NodeTypeListWarning'
    { _ntlwData :: !(Maybe [NodeTypeListWarningDataItem])
    , _ntlwCode :: !(Maybe NodeTypeListWarningCode)
    , _ntlwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeTypeListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ntlwData'
--
-- * 'ntlwCode'
--
-- * 'ntlwMessage'
nodeTypeListWarning
    :: NodeTypeListWarning
nodeTypeListWarning =
  NodeTypeListWarning'
    {_ntlwData = Nothing, _ntlwCode = Nothing, _ntlwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
ntlwData :: Lens' NodeTypeListWarning [NodeTypeListWarningDataItem]
ntlwData
  = lens _ntlwData (\ s a -> s{_ntlwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
ntlwCode :: Lens' NodeTypeListWarning (Maybe NodeTypeListWarningCode)
ntlwCode = lens _ntlwCode (\ s a -> s{_ntlwCode = a})

-- | [Output Only] A human-readable description of the warning code.
ntlwMessage :: Lens' NodeTypeListWarning (Maybe Text)
ntlwMessage
  = lens _ntlwMessage (\ s a -> s{_ntlwMessage = a})

instance FromJSON NodeTypeListWarning where
        parseJSON
          = withObject "NodeTypeListWarning"
              (\ o ->
                 NodeTypeListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON NodeTypeListWarning where
        toJSON NodeTypeListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _ntlwData,
                  ("code" .=) <$> _ntlwCode,
                  ("message" .=) <$> _ntlwMessage])

--
-- /See:/ 'packetMirroringMirroredResourceInfoSubnetInfo' smart constructor.
data PacketMirroringMirroredResourceInfoSubnetInfo =
  PacketMirroringMirroredResourceInfoSubnetInfo'
    { _pmmrisiURL :: !(Maybe Text)
    , _pmmrisiCanonicalURL :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PacketMirroringMirroredResourceInfoSubnetInfo' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pmmrisiURL'
--
-- * 'pmmrisiCanonicalURL'
packetMirroringMirroredResourceInfoSubnetInfo
    :: PacketMirroringMirroredResourceInfoSubnetInfo
packetMirroringMirroredResourceInfoSubnetInfo =
  PacketMirroringMirroredResourceInfoSubnetInfo'
    {_pmmrisiURL = Nothing, _pmmrisiCanonicalURL = Nothing}


-- | Resource URL to the subnetwork for which traffic from\/to all VM
-- instances will be mirrored.
pmmrisiURL :: Lens' PacketMirroringMirroredResourceInfoSubnetInfo (Maybe Text)
pmmrisiURL
  = lens _pmmrisiURL (\ s a -> s{_pmmrisiURL = a})

-- | [Output Only] Unique identifier for the subnetwork; defined by the
-- server.
pmmrisiCanonicalURL :: Lens' PacketMirroringMirroredResourceInfoSubnetInfo (Maybe Text)
pmmrisiCanonicalURL
  = lens _pmmrisiCanonicalURL
      (\ s a -> s{_pmmrisiCanonicalURL = a})

instance FromJSON
           PacketMirroringMirroredResourceInfoSubnetInfo
         where
        parseJSON
          = withObject
              "PacketMirroringMirroredResourceInfoSubnetInfo"
              (\ o ->
                 PacketMirroringMirroredResourceInfoSubnetInfo' <$>
                   (o .:? "url") <*> (o .:? "canonicalUrl"))

instance ToJSON
           PacketMirroringMirroredResourceInfoSubnetInfo
         where
        toJSON
          PacketMirroringMirroredResourceInfoSubnetInfo'{..}
          = object
              (catMaybes
                 [("url" .=) <$> _pmmrisiURL,
                  ("canonicalUrl" .=) <$> _pmmrisiCanonicalURL])

-- | Contains a list of HealthCheck resources.
--
-- /See:/ 'healthCheckList' smart constructor.
data HealthCheckList =
  HealthCheckList'
    { _hclNextPageToken :: !(Maybe Text)
    , _hclKind :: !Text
    , _hclItems :: !(Maybe [HealthCheck])
    , _hclSelfLink :: !(Maybe Text)
    , _hclWarning :: !(Maybe HealthCheckListWarning)
    , _hclId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HealthCheckList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hclNextPageToken'
--
-- * 'hclKind'
--
-- * 'hclItems'
--
-- * 'hclSelfLink'
--
-- * 'hclWarning'
--
-- * 'hclId'
healthCheckList
    :: HealthCheckList
healthCheckList =
  HealthCheckList'
    { _hclNextPageToken = Nothing
    , _hclKind = "compute#healthCheckList"
    , _hclItems = Nothing
    , _hclSelfLink = Nothing
    , _hclWarning = Nothing
    , _hclId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
hclNextPageToken :: Lens' HealthCheckList (Maybe Text)
hclNextPageToken
  = lens _hclNextPageToken
      (\ s a -> s{_hclNextPageToken = a})

-- | Type of resource.
hclKind :: Lens' HealthCheckList Text
hclKind = lens _hclKind (\ s a -> s{_hclKind = a})

-- | A list of HealthCheck resources.
hclItems :: Lens' HealthCheckList [HealthCheck]
hclItems
  = lens _hclItems (\ s a -> s{_hclItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
hclSelfLink :: Lens' HealthCheckList (Maybe Text)
hclSelfLink
  = lens _hclSelfLink (\ s a -> s{_hclSelfLink = a})

-- | [Output Only] Informational warning message.
hclWarning :: Lens' HealthCheckList (Maybe HealthCheckListWarning)
hclWarning
  = lens _hclWarning (\ s a -> s{_hclWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
hclId :: Lens' HealthCheckList (Maybe Text)
hclId = lens _hclId (\ s a -> s{_hclId = a})

instance FromJSON HealthCheckList where
        parseJSON
          = withObject "HealthCheckList"
              (\ o ->
                 HealthCheckList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#healthCheckList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON HealthCheckList where
        toJSON HealthCheckList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _hclNextPageToken,
                  Just ("kind" .= _hclKind),
                  ("items" .=) <$> _hclItems,
                  ("selfLink" .=) <$> _hclSelfLink,
                  ("warning" .=) <$> _hclWarning,
                  ("id" .=) <$> _hclId])

-- | [Output Only] Encountered errors during the last attempt to create or
-- delete the instance.
--
-- /See:/ 'managedInstanceLastAttemptErrors' smart constructor.
newtype ManagedInstanceLastAttemptErrors =
  ManagedInstanceLastAttemptErrors'
    { _milaeErrors :: Maybe [ManagedInstanceLastAttemptErrorsErrorsItem]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ManagedInstanceLastAttemptErrors' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'milaeErrors'
managedInstanceLastAttemptErrors
    :: ManagedInstanceLastAttemptErrors
managedInstanceLastAttemptErrors =
  ManagedInstanceLastAttemptErrors' {_milaeErrors = Nothing}


-- | [Output Only] The array of errors encountered while processing this
-- operation.
milaeErrors :: Lens' ManagedInstanceLastAttemptErrors [ManagedInstanceLastAttemptErrorsErrorsItem]
milaeErrors
  = lens _milaeErrors (\ s a -> s{_milaeErrors = a}) .
      _Default
      . _Coerce

instance FromJSON ManagedInstanceLastAttemptErrors
         where
        parseJSON
          = withObject "ManagedInstanceLastAttemptErrors"
              (\ o ->
                 ManagedInstanceLastAttemptErrors' <$>
                   (o .:? "errors" .!= mempty))

instance ToJSON ManagedInstanceLastAttemptErrors
         where
        toJSON ManagedInstanceLastAttemptErrors'{..}
          = object (catMaybes [("errors" .=) <$> _milaeErrors])

-- | Status of a NAT contained in this router.
--
-- /See:/ 'routerStatusNATStatus' smart constructor.
data RouterStatusNATStatus =
  RouterStatusNATStatus'
    { _rsnatsDrainAutoAllocatedNATIPs :: !(Maybe [Text])
    , _rsnatsUserAllocatedNATIPResources :: !(Maybe [Text])
    , _rsnatsDrainUserAllocatedNATIPs :: !(Maybe [Text])
    , _rsnatsName :: !(Maybe Text)
    , _rsnatsAutoAllocatedNATIPs :: !(Maybe [Text])
    , _rsnatsMinExtraNATIPsNeeded :: !(Maybe (Textual Int32))
    , _rsnatsNumVMEndpointsWithNATMAppings :: !(Maybe (Textual Int32))
    , _rsnatsUserAllocatedNATIPs :: !(Maybe [Text])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RouterStatusNATStatus' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rsnatsDrainAutoAllocatedNATIPs'
--
-- * 'rsnatsUserAllocatedNATIPResources'
--
-- * 'rsnatsDrainUserAllocatedNATIPs'
--
-- * 'rsnatsName'
--
-- * 'rsnatsAutoAllocatedNATIPs'
--
-- * 'rsnatsMinExtraNATIPsNeeded'
--
-- * 'rsnatsNumVMEndpointsWithNATMAppings'
--
-- * 'rsnatsUserAllocatedNATIPs'
routerStatusNATStatus
    :: RouterStatusNATStatus
routerStatusNATStatus =
  RouterStatusNATStatus'
    { _rsnatsDrainAutoAllocatedNATIPs = Nothing
    , _rsnatsUserAllocatedNATIPResources = Nothing
    , _rsnatsDrainUserAllocatedNATIPs = Nothing
    , _rsnatsName = Nothing
    , _rsnatsAutoAllocatedNATIPs = Nothing
    , _rsnatsMinExtraNATIPsNeeded = Nothing
    , _rsnatsNumVMEndpointsWithNATMAppings = Nothing
    , _rsnatsUserAllocatedNATIPs = Nothing
    }


-- | A list of IPs auto-allocated for NAT that are in drain mode. Example:
-- [\"1.1.1.1\", \"179.12.26.133\"].
rsnatsDrainAutoAllocatedNATIPs :: Lens' RouterStatusNATStatus [Text]
rsnatsDrainAutoAllocatedNATIPs
  = lens _rsnatsDrainAutoAllocatedNATIPs
      (\ s a -> s{_rsnatsDrainAutoAllocatedNATIPs = a})
      . _Default
      . _Coerce

-- | A list of fully qualified URLs of reserved IP address resources.
rsnatsUserAllocatedNATIPResources :: Lens' RouterStatusNATStatus [Text]
rsnatsUserAllocatedNATIPResources
  = lens _rsnatsUserAllocatedNATIPResources
      (\ s a -> s{_rsnatsUserAllocatedNATIPResources = a})
      . _Default
      . _Coerce

-- | A list of IPs user-allocated for NAT that are in drain mode. Example:
-- [\"1.1.1.1\", \"179.12.26.133\"].
rsnatsDrainUserAllocatedNATIPs :: Lens' RouterStatusNATStatus [Text]
rsnatsDrainUserAllocatedNATIPs
  = lens _rsnatsDrainUserAllocatedNATIPs
      (\ s a -> s{_rsnatsDrainUserAllocatedNATIPs = a})
      . _Default
      . _Coerce

-- | Unique name of this NAT.
rsnatsName :: Lens' RouterStatusNATStatus (Maybe Text)
rsnatsName
  = lens _rsnatsName (\ s a -> s{_rsnatsName = a})

-- | A list of IPs auto-allocated for NAT. Example: [\"1.1.1.1\",
-- \"129.2.16.89\"]
rsnatsAutoAllocatedNATIPs :: Lens' RouterStatusNATStatus [Text]
rsnatsAutoAllocatedNATIPs
  = lens _rsnatsAutoAllocatedNATIPs
      (\ s a -> s{_rsnatsAutoAllocatedNATIPs = a})
      . _Default
      . _Coerce

-- | The number of extra IPs to allocate. This will be greater than 0 only if
-- user-specified IPs are NOT enough to allow all configured VMs to use
-- NAT. This value is meaningful only when auto-allocation of NAT IPs is
-- *not* used.
rsnatsMinExtraNATIPsNeeded :: Lens' RouterStatusNATStatus (Maybe Int32)
rsnatsMinExtraNATIPsNeeded
  = lens _rsnatsMinExtraNATIPsNeeded
      (\ s a -> s{_rsnatsMinExtraNATIPsNeeded = a})
      . mapping _Coerce

-- | Number of VM endpoints (i.e., Nics) that can use NAT.
rsnatsNumVMEndpointsWithNATMAppings :: Lens' RouterStatusNATStatus (Maybe Int32)
rsnatsNumVMEndpointsWithNATMAppings
  = lens _rsnatsNumVMEndpointsWithNATMAppings
      (\ s a ->
         s{_rsnatsNumVMEndpointsWithNATMAppings = a})
      . mapping _Coerce

-- | A list of IPs user-allocated for NAT. They will be raw IP strings like
-- \"179.12.26.133\".
rsnatsUserAllocatedNATIPs :: Lens' RouterStatusNATStatus [Text]
rsnatsUserAllocatedNATIPs
  = lens _rsnatsUserAllocatedNATIPs
      (\ s a -> s{_rsnatsUserAllocatedNATIPs = a})
      . _Default
      . _Coerce

instance FromJSON RouterStatusNATStatus where
        parseJSON
          = withObject "RouterStatusNATStatus"
              (\ o ->
                 RouterStatusNATStatus' <$>
                   (o .:? "drainAutoAllocatedNatIps" .!= mempty) <*>
                     (o .:? "userAllocatedNatIpResources" .!= mempty)
                     <*> (o .:? "drainUserAllocatedNatIps" .!= mempty)
                     <*> (o .:? "name")
                     <*> (o .:? "autoAllocatedNatIps" .!= mempty)
                     <*> (o .:? "minExtraNatIpsNeeded")
                     <*> (o .:? "numVmEndpointsWithNatMappings")
                     <*> (o .:? "userAllocatedNatIps" .!= mempty))

instance ToJSON RouterStatusNATStatus where
        toJSON RouterStatusNATStatus'{..}
          = object
              (catMaybes
                 [("drainAutoAllocatedNatIps" .=) <$>
                    _rsnatsDrainAutoAllocatedNATIPs,
                  ("userAllocatedNatIpResources" .=) <$>
                    _rsnatsUserAllocatedNATIPResources,
                  ("drainUserAllocatedNatIps" .=) <$>
                    _rsnatsDrainUserAllocatedNATIPs,
                  ("name" .=) <$> _rsnatsName,
                  ("autoAllocatedNatIps" .=) <$>
                    _rsnatsAutoAllocatedNATIPs,
                  ("minExtraNatIpsNeeded" .=) <$>
                    _rsnatsMinExtraNATIPsNeeded,
                  ("numVmEndpointsWithNatMappings" .=) <$>
                    _rsnatsNumVMEndpointsWithNATMAppings,
                  ("userAllocatedNatIps" .=) <$>
                    _rsnatsUserAllocatedNATIPs])

-- | Represents a CIDR range which can be used to assign addresses.
--
-- /See:/ 'publicAdvertisedPrefixPublicDelegatedPrefix' smart constructor.
data PublicAdvertisedPrefixPublicDelegatedPrefix =
  PublicAdvertisedPrefixPublicDelegatedPrefix'
    { _pAppdpStatus :: !(Maybe Text)
    , _pAppdpProject :: !(Maybe Text)
    , _pAppdpName :: !(Maybe Text)
    , _pAppdpRegion :: !(Maybe Text)
    , _pAppdpIPRange :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PublicAdvertisedPrefixPublicDelegatedPrefix' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pAppdpStatus'
--
-- * 'pAppdpProject'
--
-- * 'pAppdpName'
--
-- * 'pAppdpRegion'
--
-- * 'pAppdpIPRange'
publicAdvertisedPrefixPublicDelegatedPrefix
    :: PublicAdvertisedPrefixPublicDelegatedPrefix
publicAdvertisedPrefixPublicDelegatedPrefix =
  PublicAdvertisedPrefixPublicDelegatedPrefix'
    { _pAppdpStatus = Nothing
    , _pAppdpProject = Nothing
    , _pAppdpName = Nothing
    , _pAppdpRegion = Nothing
    , _pAppdpIPRange = Nothing
    }


-- | The status of the public delegated prefix. Possible values are:
-- INITIALIZING: The public delegated prefix is being initialized and
-- addresses cannot be created yet. ANNOUNCED: The public delegated prefix
-- is active.
pAppdpStatus :: Lens' PublicAdvertisedPrefixPublicDelegatedPrefix (Maybe Text)
pAppdpStatus
  = lens _pAppdpStatus (\ s a -> s{_pAppdpStatus = a})

-- | The project number of the public delegated prefix
pAppdpProject :: Lens' PublicAdvertisedPrefixPublicDelegatedPrefix (Maybe Text)
pAppdpProject
  = lens _pAppdpProject
      (\ s a -> s{_pAppdpProject = a})

-- | The name of the public delegated prefix
pAppdpName :: Lens' PublicAdvertisedPrefixPublicDelegatedPrefix (Maybe Text)
pAppdpName
  = lens _pAppdpName (\ s a -> s{_pAppdpName = a})

-- | The region of the public delegated prefix if it is regional. If absent,
-- the prefix is global.
pAppdpRegion :: Lens' PublicAdvertisedPrefixPublicDelegatedPrefix (Maybe Text)
pAppdpRegion
  = lens _pAppdpRegion (\ s a -> s{_pAppdpRegion = a})

-- | The IP address range of the public delegated prefix
pAppdpIPRange :: Lens' PublicAdvertisedPrefixPublicDelegatedPrefix (Maybe Text)
pAppdpIPRange
  = lens _pAppdpIPRange
      (\ s a -> s{_pAppdpIPRange = a})

instance FromJSON
           PublicAdvertisedPrefixPublicDelegatedPrefix
         where
        parseJSON
          = withObject
              "PublicAdvertisedPrefixPublicDelegatedPrefix"
              (\ o ->
                 PublicAdvertisedPrefixPublicDelegatedPrefix' <$>
                   (o .:? "status") <*> (o .:? "project") <*>
                     (o .:? "name")
                     <*> (o .:? "region")
                     <*> (o .:? "ipRange"))

instance ToJSON
           PublicAdvertisedPrefixPublicDelegatedPrefix
         where
        toJSON
          PublicAdvertisedPrefixPublicDelegatedPrefix'{..}
          = object
              (catMaybes
                 [("status" .=) <$> _pAppdpStatus,
                  ("project" .=) <$> _pAppdpProject,
                  ("name" .=) <$> _pAppdpName,
                  ("region" .=) <$> _pAppdpRegion,
                  ("ipRange" .=) <$> _pAppdpIPRange])

--
-- /See:/ 'targetPoolsRemoveInstanceRequest' smart constructor.
newtype TargetPoolsRemoveInstanceRequest =
  TargetPoolsRemoveInstanceRequest'
    { _tprirInstances :: Maybe [InstanceReference]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetPoolsRemoveInstanceRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tprirInstances'
targetPoolsRemoveInstanceRequest
    :: TargetPoolsRemoveInstanceRequest
targetPoolsRemoveInstanceRequest =
  TargetPoolsRemoveInstanceRequest' {_tprirInstances = Nothing}


-- | URLs of the instances to be removed from target pool.
tprirInstances :: Lens' TargetPoolsRemoveInstanceRequest [InstanceReference]
tprirInstances
  = lens _tprirInstances
      (\ s a -> s{_tprirInstances = a})
      . _Default
      . _Coerce

instance FromJSON TargetPoolsRemoveInstanceRequest
         where
        parseJSON
          = withObject "TargetPoolsRemoveInstanceRequest"
              (\ o ->
                 TargetPoolsRemoveInstanceRequest' <$>
                   (o .:? "instances" .!= mempty))

instance ToJSON TargetPoolsRemoveInstanceRequest
         where
        toJSON TargetPoolsRemoveInstanceRequest'{..}
          = object
              (catMaybes [("instances" .=) <$> _tprirInstances])

--
-- /See:/ 'nodeTypeAggregatedListWarningDataItem' smart constructor.
data NodeTypeAggregatedListWarningDataItem =
  NodeTypeAggregatedListWarningDataItem'
    { _nValue :: !(Maybe Text)
    , _nKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeTypeAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nValue'
--
-- * 'nKey'
nodeTypeAggregatedListWarningDataItem
    :: NodeTypeAggregatedListWarningDataItem
nodeTypeAggregatedListWarningDataItem =
  NodeTypeAggregatedListWarningDataItem' {_nValue = Nothing, _nKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
nValue :: Lens' NodeTypeAggregatedListWarningDataItem (Maybe Text)
nValue = lens _nValue (\ s a -> s{_nValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
nKey :: Lens' NodeTypeAggregatedListWarningDataItem (Maybe Text)
nKey = lens _nKey (\ s a -> s{_nKey = a})

instance FromJSON
           NodeTypeAggregatedListWarningDataItem
         where
        parseJSON
          = withObject "NodeTypeAggregatedListWarningDataItem"
              (\ o ->
                 NodeTypeAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON NodeTypeAggregatedListWarningDataItem
         where
        toJSON NodeTypeAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _nValue, ("key" .=) <$> _nKey])

--
-- /See:/ 'globalNetworkEndpointGroupsAttachEndpointsRequest' smart constructor.
newtype GlobalNetworkEndpointGroupsAttachEndpointsRequest =
  GlobalNetworkEndpointGroupsAttachEndpointsRequest'
    { _gnegaerNetworkEndpoints :: Maybe [NetworkEndpoint]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'GlobalNetworkEndpointGroupsAttachEndpointsRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'gnegaerNetworkEndpoints'
globalNetworkEndpointGroupsAttachEndpointsRequest
    :: GlobalNetworkEndpointGroupsAttachEndpointsRequest
globalNetworkEndpointGroupsAttachEndpointsRequest =
  GlobalNetworkEndpointGroupsAttachEndpointsRequest'
    {_gnegaerNetworkEndpoints = Nothing}


-- | The list of network endpoints to be attached.
gnegaerNetworkEndpoints :: Lens' GlobalNetworkEndpointGroupsAttachEndpointsRequest [NetworkEndpoint]
gnegaerNetworkEndpoints
  = lens _gnegaerNetworkEndpoints
      (\ s a -> s{_gnegaerNetworkEndpoints = a})
      . _Default
      . _Coerce

instance FromJSON
           GlobalNetworkEndpointGroupsAttachEndpointsRequest
         where
        parseJSON
          = withObject
              "GlobalNetworkEndpointGroupsAttachEndpointsRequest"
              (\ o ->
                 GlobalNetworkEndpointGroupsAttachEndpointsRequest'
                   <$> (o .:? "networkEndpoints" .!= mempty))

instance ToJSON
           GlobalNetworkEndpointGroupsAttachEndpointsRequest
         where
        toJSON
          GlobalNetworkEndpointGroupsAttachEndpointsRequest'{..}
          = object
              (catMaybes
                 [("networkEndpoints" .=) <$>
                    _gnegaerNetworkEndpoints])

--
-- /See:/ 'targetInstancesScopedListWarningDataItem' smart constructor.
data TargetInstancesScopedListWarningDataItem =
  TargetInstancesScopedListWarningDataItem'
    { _tislwdiValue :: !(Maybe Text)
    , _tislwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetInstancesScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tislwdiValue'
--
-- * 'tislwdiKey'
targetInstancesScopedListWarningDataItem
    :: TargetInstancesScopedListWarningDataItem
targetInstancesScopedListWarningDataItem =
  TargetInstancesScopedListWarningDataItem'
    {_tislwdiValue = Nothing, _tislwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
tislwdiValue :: Lens' TargetInstancesScopedListWarningDataItem (Maybe Text)
tislwdiValue
  = lens _tislwdiValue (\ s a -> s{_tislwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
tislwdiKey :: Lens' TargetInstancesScopedListWarningDataItem (Maybe Text)
tislwdiKey
  = lens _tislwdiKey (\ s a -> s{_tislwdiKey = a})

instance FromJSON
           TargetInstancesScopedListWarningDataItem
         where
        parseJSON
          = withObject
              "TargetInstancesScopedListWarningDataItem"
              (\ o ->
                 TargetInstancesScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           TargetInstancesScopedListWarningDataItem
         where
        toJSON TargetInstancesScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _tislwdiValue,
                  ("key" .=) <$> _tislwdiKey])

-- | [Output Only] An informational warning that appears when the machine
-- types list is empty.
--
-- /See:/ 'machineTypesScopedListWarning' smart constructor.
data MachineTypesScopedListWarning =
  MachineTypesScopedListWarning'
    { _mtslwData :: !(Maybe [MachineTypesScopedListWarningDataItem])
    , _mtslwCode :: !(Maybe MachineTypesScopedListWarningCode)
    , _mtslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'MachineTypesScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'mtslwData'
--
-- * 'mtslwCode'
--
-- * 'mtslwMessage'
machineTypesScopedListWarning
    :: MachineTypesScopedListWarning
machineTypesScopedListWarning =
  MachineTypesScopedListWarning'
    {_mtslwData = Nothing, _mtslwCode = Nothing, _mtslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
mtslwData :: Lens' MachineTypesScopedListWarning [MachineTypesScopedListWarningDataItem]
mtslwData
  = lens _mtslwData (\ s a -> s{_mtslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
mtslwCode :: Lens' MachineTypesScopedListWarning (Maybe MachineTypesScopedListWarningCode)
mtslwCode
  = lens _mtslwCode (\ s a -> s{_mtslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
mtslwMessage :: Lens' MachineTypesScopedListWarning (Maybe Text)
mtslwMessage
  = lens _mtslwMessage (\ s a -> s{_mtslwMessage = a})

instance FromJSON MachineTypesScopedListWarning where
        parseJSON
          = withObject "MachineTypesScopedListWarning"
              (\ o ->
                 MachineTypesScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON MachineTypesScopedListWarning where
        toJSON MachineTypesScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _mtslwData,
                  ("code" .=) <$> _mtslwCode,
                  ("message" .=) <$> _mtslwMessage])

--
-- /See:/ 'zoneSetLabelsRequest' smart constructor.
data ZoneSetLabelsRequest =
  ZoneSetLabelsRequest'
    { _zslrLabels :: !(Maybe ZoneSetLabelsRequestLabels)
    , _zslrLabelFingerprint :: !(Maybe Bytes)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ZoneSetLabelsRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'zslrLabels'
--
-- * 'zslrLabelFingerprint'
zoneSetLabelsRequest
    :: ZoneSetLabelsRequest
zoneSetLabelsRequest =
  ZoneSetLabelsRequest' {_zslrLabels = Nothing, _zslrLabelFingerprint = Nothing}


-- | The labels to set for this resource.
zslrLabels :: Lens' ZoneSetLabelsRequest (Maybe ZoneSetLabelsRequestLabels)
zslrLabels
  = lens _zslrLabels (\ s a -> s{_zslrLabels = a})

-- | The fingerprint of the previous set of labels for this resource, used to
-- detect conflicts. The fingerprint is initially generated by Compute
-- Engine and changes after every request to modify or update labels. You
-- must always provide an up-to-date fingerprint hash in order to update or
-- change labels. Make a get() request to the resource to get the latest
-- fingerprint.
zslrLabelFingerprint :: Lens' ZoneSetLabelsRequest (Maybe ByteString)
zslrLabelFingerprint
  = lens _zslrLabelFingerprint
      (\ s a -> s{_zslrLabelFingerprint = a})
      . mapping _Bytes

instance FromJSON ZoneSetLabelsRequest where
        parseJSON
          = withObject "ZoneSetLabelsRequest"
              (\ o ->
                 ZoneSetLabelsRequest' <$>
                   (o .:? "labels") <*> (o .:? "labelFingerprint"))

instance ToJSON ZoneSetLabelsRequest where
        toJSON ZoneSetLabelsRequest'{..}
          = object
              (catMaybes
                 [("labels" .=) <$> _zslrLabels,
                  ("labelFingerprint" .=) <$> _zslrLabelFingerprint])

-- | Represents a Target Instance resource. You can use a target instance to
-- handle traffic for one or more forwarding rules, which is ideal for
-- forwarding protocol traffic that is managed by a single source. For
-- example, ESP, AH, TCP, or UDP. For more information, read Target
-- instances. (== resource_for {$api_version}.targetInstances ==)
--
-- /See:/ 'targetInstance' smart constructor.
data TargetInstance =
  TargetInstance'
    { _tiKind :: !Text
    , _tiNATPolicy :: !(Maybe TargetInstanceNATPolicy)
    , _tiZone :: !(Maybe Text)
    , _tiSelfLink :: !(Maybe Text)
    , _tiName :: !(Maybe Text)
    , _tiCreationTimestamp :: !(Maybe Text)
    , _tiId :: !(Maybe (Textual Word64))
    , _tiDescription :: !(Maybe Text)
    , _tiInstance :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetInstance' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tiKind'
--
-- * 'tiNATPolicy'
--
-- * 'tiZone'
--
-- * 'tiSelfLink'
--
-- * 'tiName'
--
-- * 'tiCreationTimestamp'
--
-- * 'tiId'
--
-- * 'tiDescription'
--
-- * 'tiInstance'
targetInstance
    :: TargetInstance
targetInstance =
  TargetInstance'
    { _tiKind = "compute#targetInstance"
    , _tiNATPolicy = Nothing
    , _tiZone = Nothing
    , _tiSelfLink = Nothing
    , _tiName = Nothing
    , _tiCreationTimestamp = Nothing
    , _tiId = Nothing
    , _tiDescription = Nothing
    , _tiInstance = Nothing
    }


-- | [Output Only] The type of the resource. Always compute#targetInstance
-- for target instances.
tiKind :: Lens' TargetInstance Text
tiKind = lens _tiKind (\ s a -> s{_tiKind = a})

-- | NAT option controlling how IPs are NAT\'ed to the instance. Currently
-- only NO_NAT (default value) is supported.
tiNATPolicy :: Lens' TargetInstance (Maybe TargetInstanceNATPolicy)
tiNATPolicy
  = lens _tiNATPolicy (\ s a -> s{_tiNATPolicy = a})

-- | [Output Only] URL of the zone where the target instance resides. You
-- must specify this field as part of the HTTP request URL. It is not
-- settable as a field in the request body.
tiZone :: Lens' TargetInstance (Maybe Text)
tiZone = lens _tiZone (\ s a -> s{_tiZone = a})

-- | [Output Only] Server-defined URL for the resource.
tiSelfLink :: Lens' TargetInstance (Maybe Text)
tiSelfLink
  = lens _tiSelfLink (\ s a -> s{_tiSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
tiName :: Lens' TargetInstance (Maybe Text)
tiName = lens _tiName (\ s a -> s{_tiName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
tiCreationTimestamp :: Lens' TargetInstance (Maybe Text)
tiCreationTimestamp
  = lens _tiCreationTimestamp
      (\ s a -> s{_tiCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
tiId :: Lens' TargetInstance (Maybe Word64)
tiId
  = lens _tiId (\ s a -> s{_tiId = a}) .
      mapping _Coerce

-- | An optional description of this resource. Provide this property when you
-- create the resource.
tiDescription :: Lens' TargetInstance (Maybe Text)
tiDescription
  = lens _tiDescription
      (\ s a -> s{_tiDescription = a})

-- | A URL to the virtual machine instance that handles traffic for this
-- target instance. When creating a target instance, you can provide the
-- fully-qualified URL or a valid partial URL to the desired virtual
-- machine. For example, the following are all valid URLs: -
-- https:\/\/www.googleapis.com\/compute\/v1\/projects\/project\/zones\/zone\/instances\/instance
-- - projects\/project\/zones\/zone\/instances\/instance -
-- zones\/zone\/instances\/instance
tiInstance :: Lens' TargetInstance (Maybe Text)
tiInstance
  = lens _tiInstance (\ s a -> s{_tiInstance = a})

instance FromJSON TargetInstance where
        parseJSON
          = withObject "TargetInstance"
              (\ o ->
                 TargetInstance' <$>
                   (o .:? "kind" .!= "compute#targetInstance") <*>
                     (o .:? "natPolicy")
                     <*> (o .:? "zone")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "description")
                     <*> (o .:? "instance"))

instance ToJSON TargetInstance where
        toJSON TargetInstance'{..}
          = object
              (catMaybes
                 [Just ("kind" .= _tiKind),
                  ("natPolicy" .=) <$> _tiNATPolicy,
                  ("zone" .=) <$> _tiZone,
                  ("selfLink" .=) <$> _tiSelfLink,
                  ("name" .=) <$> _tiName,
                  ("creationTimestamp" .=) <$> _tiCreationTimestamp,
                  ("id" .=) <$> _tiId,
                  ("description" .=) <$> _tiDescription,
                  ("instance" .=) <$> _tiInstance])

--
-- /See:/ 'targetPoolInstanceHealth' smart constructor.
data TargetPoolInstanceHealth =
  TargetPoolInstanceHealth'
    { _tpihKind :: !Text
    , _tpihHealthStatus :: !(Maybe [HealthStatus])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetPoolInstanceHealth' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tpihKind'
--
-- * 'tpihHealthStatus'
targetPoolInstanceHealth
    :: TargetPoolInstanceHealth
targetPoolInstanceHealth =
  TargetPoolInstanceHealth'
    { _tpihKind = "compute#targetPoolInstanceHealth"
    , _tpihHealthStatus = Nothing
    }


-- | [Output Only] Type of resource. Always compute#targetPoolInstanceHealth
-- when checking the health of an instance.
tpihKind :: Lens' TargetPoolInstanceHealth Text
tpihKind = lens _tpihKind (\ s a -> s{_tpihKind = a})

tpihHealthStatus :: Lens' TargetPoolInstanceHealth [HealthStatus]
tpihHealthStatus
  = lens _tpihHealthStatus
      (\ s a -> s{_tpihHealthStatus = a})
      . _Default
      . _Coerce

instance FromJSON TargetPoolInstanceHealth where
        parseJSON
          = withObject "TargetPoolInstanceHealth"
              (\ o ->
                 TargetPoolInstanceHealth' <$>
                   (o .:? "kind" .!= "compute#targetPoolInstanceHealth")
                     <*> (o .:? "healthStatus" .!= mempty))

instance ToJSON TargetPoolInstanceHealth where
        toJSON TargetPoolInstanceHealth'{..}
          = object
              (catMaybes
                 [Just ("kind" .= _tpihKind),
                  ("healthStatus" .=) <$> _tpihHealthStatus])

--
-- /See:/ 'acceleratorTypeAggregatedList' smart constructor.
data AcceleratorTypeAggregatedList =
  AcceleratorTypeAggregatedList'
    { _atalUnreachables :: !(Maybe [Text])
    , _atalNextPageToken :: !(Maybe Text)
    , _atalKind :: !Text
    , _atalItems :: !(Maybe AcceleratorTypeAggregatedListItems)
    , _atalSelfLink :: !(Maybe Text)
    , _atalWarning :: !(Maybe AcceleratorTypeAggregatedListWarning)
    , _atalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AcceleratorTypeAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'atalUnreachables'
--
-- * 'atalNextPageToken'
--
-- * 'atalKind'
--
-- * 'atalItems'
--
-- * 'atalSelfLink'
--
-- * 'atalWarning'
--
-- * 'atalId'
acceleratorTypeAggregatedList
    :: AcceleratorTypeAggregatedList
acceleratorTypeAggregatedList =
  AcceleratorTypeAggregatedList'
    { _atalUnreachables = Nothing
    , _atalNextPageToken = Nothing
    , _atalKind = "compute#acceleratorTypeAggregatedList"
    , _atalItems = Nothing
    , _atalSelfLink = Nothing
    , _atalWarning = Nothing
    , _atalId = Nothing
    }


-- | [Output Only] Unreachable resources.
atalUnreachables :: Lens' AcceleratorTypeAggregatedList [Text]
atalUnreachables
  = lens _atalUnreachables
      (\ s a -> s{_atalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
atalNextPageToken :: Lens' AcceleratorTypeAggregatedList (Maybe Text)
atalNextPageToken
  = lens _atalNextPageToken
      (\ s a -> s{_atalNextPageToken = a})

-- | [Output Only] Type of resource. Always
-- compute#acceleratorTypeAggregatedList for aggregated lists of
-- accelerator types.
atalKind :: Lens' AcceleratorTypeAggregatedList Text
atalKind = lens _atalKind (\ s a -> s{_atalKind = a})

-- | A list of AcceleratorTypesScopedList resources.
atalItems :: Lens' AcceleratorTypeAggregatedList (Maybe AcceleratorTypeAggregatedListItems)
atalItems
  = lens _atalItems (\ s a -> s{_atalItems = a})

-- | [Output Only] Server-defined URL for this resource.
atalSelfLink :: Lens' AcceleratorTypeAggregatedList (Maybe Text)
atalSelfLink
  = lens _atalSelfLink (\ s a -> s{_atalSelfLink = a})

-- | [Output Only] Informational warning message.
atalWarning :: Lens' AcceleratorTypeAggregatedList (Maybe AcceleratorTypeAggregatedListWarning)
atalWarning
  = lens _atalWarning (\ s a -> s{_atalWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
atalId :: Lens' AcceleratorTypeAggregatedList (Maybe Text)
atalId = lens _atalId (\ s a -> s{_atalId = a})

instance FromJSON AcceleratorTypeAggregatedList where
        parseJSON
          = withObject "AcceleratorTypeAggregatedList"
              (\ o ->
                 AcceleratorTypeAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!=
                        "compute#acceleratorTypeAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON AcceleratorTypeAggregatedList where
        toJSON AcceleratorTypeAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _atalUnreachables,
                  ("nextPageToken" .=) <$> _atalNextPageToken,
                  Just ("kind" .= _atalKind),
                  ("items" .=) <$> _atalItems,
                  ("selfLink" .=) <$> _atalSelfLink,
                  ("warning" .=) <$> _atalWarning,
                  ("id" .=) <$> _atalId])

-- | A routing configuration attached to a network resource. The message
-- includes the list of routers associated with the network, and a flag
-- indicating the type of routing behavior to enforce network-wide.
--
-- /See:/ 'networkRoutingConfig' smart constructor.
newtype NetworkRoutingConfig =
  NetworkRoutingConfig'
    { _nrcRoutingMode :: Maybe NetworkRoutingConfigRoutingMode
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkRoutingConfig' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nrcRoutingMode'
networkRoutingConfig
    :: NetworkRoutingConfig
networkRoutingConfig = NetworkRoutingConfig' {_nrcRoutingMode = Nothing}


-- | The network-wide routing mode to use. If set to REGIONAL, this
-- network\'s Cloud Routers will only advertise routes with subnets of this
-- network in the same region as the router. If set to GLOBAL, this
-- network\'s Cloud Routers will advertise routes with all subnets of this
-- network, across regions.
nrcRoutingMode :: Lens' NetworkRoutingConfig (Maybe NetworkRoutingConfigRoutingMode)
nrcRoutingMode
  = lens _nrcRoutingMode
      (\ s a -> s{_nrcRoutingMode = a})

instance FromJSON NetworkRoutingConfig where
        parseJSON
          = withObject "NetworkRoutingConfig"
              (\ o ->
                 NetworkRoutingConfig' <$> (o .:? "routingMode"))

instance ToJSON NetworkRoutingConfig where
        toJSON NetworkRoutingConfig'{..}
          = object
              (catMaybes [("routingMode" .=) <$> _nrcRoutingMode])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'nodeTemplateListWarning' smart constructor.
data NodeTemplateListWarning =
  NodeTemplateListWarning'
    { _nodData :: !(Maybe [NodeTemplateListWarningDataItem])
    , _nodCode :: !(Maybe NodeTemplateListWarningCode)
    , _nodMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeTemplateListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nodData'
--
-- * 'nodCode'
--
-- * 'nodMessage'
nodeTemplateListWarning
    :: NodeTemplateListWarning
nodeTemplateListWarning =
  NodeTemplateListWarning'
    {_nodData = Nothing, _nodCode = Nothing, _nodMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
nodData :: Lens' NodeTemplateListWarning [NodeTemplateListWarningDataItem]
nodData
  = lens _nodData (\ s a -> s{_nodData = a}) . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
nodCode :: Lens' NodeTemplateListWarning (Maybe NodeTemplateListWarningCode)
nodCode = lens _nodCode (\ s a -> s{_nodCode = a})

-- | [Output Only] A human-readable description of the warning code.
nodMessage :: Lens' NodeTemplateListWarning (Maybe Text)
nodMessage
  = lens _nodMessage (\ s a -> s{_nodMessage = a})

instance FromJSON NodeTemplateListWarning where
        parseJSON
          = withObject "NodeTemplateListWarning"
              (\ o ->
                 NodeTemplateListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON NodeTemplateListWarning where
        toJSON NodeTemplateListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _nodData, ("code" .=) <$> _nodCode,
                  ("message" .=) <$> _nodMessage])

--
-- /See:/ 'instanceGroupManagersListManagedInstancesResponse' smart constructor.
data InstanceGroupManagersListManagedInstancesResponse =
  InstanceGroupManagersListManagedInstancesResponse'
    { _igmlmirNextPageToken :: !(Maybe Text)
    , _igmlmirManagedInstances :: !(Maybe [ManagedInstance])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagersListManagedInstancesResponse' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmlmirNextPageToken'
--
-- * 'igmlmirManagedInstances'
instanceGroupManagersListManagedInstancesResponse
    :: InstanceGroupManagersListManagedInstancesResponse
instanceGroupManagersListManagedInstancesResponse =
  InstanceGroupManagersListManagedInstancesResponse'
    {_igmlmirNextPageToken = Nothing, _igmlmirManagedInstances = Nothing}


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
igmlmirNextPageToken :: Lens' InstanceGroupManagersListManagedInstancesResponse (Maybe Text)
igmlmirNextPageToken
  = lens _igmlmirNextPageToken
      (\ s a -> s{_igmlmirNextPageToken = a})

-- | [Output Only] The list of instances in the managed instance group.
igmlmirManagedInstances :: Lens' InstanceGroupManagersListManagedInstancesResponse [ManagedInstance]
igmlmirManagedInstances
  = lens _igmlmirManagedInstances
      (\ s a -> s{_igmlmirManagedInstances = a})
      . _Default
      . _Coerce

instance FromJSON
           InstanceGroupManagersListManagedInstancesResponse
         where
        parseJSON
          = withObject
              "InstanceGroupManagersListManagedInstancesResponse"
              (\ o ->
                 InstanceGroupManagersListManagedInstancesResponse'
                   <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "managedInstances" .!= mempty))

instance ToJSON
           InstanceGroupManagersListManagedInstancesResponse
         where
        toJSON
          InstanceGroupManagersListManagedInstancesResponse'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _igmlmirNextPageToken,
                  ("managedInstances" .=) <$>
                    _igmlmirManagedInstances])

-- |
--
-- /See:/ 'instanceProperties' smart constructor.
data InstanceProperties =
  InstanceProperties'
    { _ipAdvancedMachineFeatures :: !(Maybe AdvancedMachineFeatures)
    , _ipServiceAccounts :: !(Maybe [ServiceAccount])
    , _ipReservationAffinity :: !(Maybe ReservationAffinity)
    , _ipNetworkInterfaces :: !(Maybe [NetworkInterface])
    , _ipConfidentialInstanceConfig :: !(Maybe ConfidentialInstanceConfig)
    , _ipResourcePolicies :: !(Maybe [Text])
    , _ipGuestAccelerators :: !(Maybe [AcceleratorConfig])
    , _ipMachineType :: !(Maybe Text)
    , _ipMetadata :: !(Maybe Metadata)
    , _ipShieldedInstanceConfig :: !(Maybe ShieldedInstanceConfig)
    , _ipLabels :: !(Maybe InstancePropertiesLabels)
    , _ipScheduling :: !(Maybe Scheduling)
    , _ipMinCPUPlatform :: !(Maybe Text)
    , _ipDisks :: !(Maybe [AttachedDisk])
    , _ipCanIPForward :: !(Maybe Bool)
    , _ipDescription :: !(Maybe Text)
    , _ipTags :: !(Maybe Tags)
    , _ipPrivateIPv6GoogleAccess :: !(Maybe InstancePropertiesPrivateIPv6GoogleAccess)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceProperties' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ipAdvancedMachineFeatures'
--
-- * 'ipServiceAccounts'
--
-- * 'ipReservationAffinity'
--
-- * 'ipNetworkInterfaces'
--
-- * 'ipConfidentialInstanceConfig'
--
-- * 'ipResourcePolicies'
--
-- * 'ipGuestAccelerators'
--
-- * 'ipMachineType'
--
-- * 'ipMetadata'
--
-- * 'ipShieldedInstanceConfig'
--
-- * 'ipLabels'
--
-- * 'ipScheduling'
--
-- * 'ipMinCPUPlatform'
--
-- * 'ipDisks'
--
-- * 'ipCanIPForward'
--
-- * 'ipDescription'
--
-- * 'ipTags'
--
-- * 'ipPrivateIPv6GoogleAccess'
instanceProperties
    :: InstanceProperties
instanceProperties =
  InstanceProperties'
    { _ipAdvancedMachineFeatures = Nothing
    , _ipServiceAccounts = Nothing
    , _ipReservationAffinity = Nothing
    , _ipNetworkInterfaces = Nothing
    , _ipConfidentialInstanceConfig = Nothing
    , _ipResourcePolicies = Nothing
    , _ipGuestAccelerators = Nothing
    , _ipMachineType = Nothing
    , _ipMetadata = Nothing
    , _ipShieldedInstanceConfig = Nothing
    , _ipLabels = Nothing
    , _ipScheduling = Nothing
    , _ipMinCPUPlatform = Nothing
    , _ipDisks = Nothing
    , _ipCanIPForward = Nothing
    , _ipDescription = Nothing
    , _ipTags = Nothing
    , _ipPrivateIPv6GoogleAccess = Nothing
    }


-- | Controls for advanced machine-related behavior features.
ipAdvancedMachineFeatures :: Lens' InstanceProperties (Maybe AdvancedMachineFeatures)
ipAdvancedMachineFeatures
  = lens _ipAdvancedMachineFeatures
      (\ s a -> s{_ipAdvancedMachineFeatures = a})

-- | A list of service accounts with specified scopes. Access tokens for
-- these service accounts are available to the instances that are created
-- from these properties. Use metadata queries to obtain the access tokens
-- for these instances.
ipServiceAccounts :: Lens' InstanceProperties [ServiceAccount]
ipServiceAccounts
  = lens _ipServiceAccounts
      (\ s a -> s{_ipServiceAccounts = a})
      . _Default
      . _Coerce

-- | Specifies the reservations that instances can consume from.
ipReservationAffinity :: Lens' InstanceProperties (Maybe ReservationAffinity)
ipReservationAffinity
  = lens _ipReservationAffinity
      (\ s a -> s{_ipReservationAffinity = a})

-- | An array of network access configurations for this interface.
ipNetworkInterfaces :: Lens' InstanceProperties [NetworkInterface]
ipNetworkInterfaces
  = lens _ipNetworkInterfaces
      (\ s a -> s{_ipNetworkInterfaces = a})
      . _Default
      . _Coerce

-- | Specifies the Confidential Instance options.
ipConfidentialInstanceConfig :: Lens' InstanceProperties (Maybe ConfidentialInstanceConfig)
ipConfidentialInstanceConfig
  = lens _ipConfidentialInstanceConfig
      (\ s a -> s{_ipConfidentialInstanceConfig = a})

-- | Resource policies (names, not ULRs) applied to instances created from
-- these properties.
ipResourcePolicies :: Lens' InstanceProperties [Text]
ipResourcePolicies
  = lens _ipResourcePolicies
      (\ s a -> s{_ipResourcePolicies = a})
      . _Default
      . _Coerce

-- | A list of guest accelerator cards\' type and count to use for instances
-- created from these properties.
ipGuestAccelerators :: Lens' InstanceProperties [AcceleratorConfig]
ipGuestAccelerators
  = lens _ipGuestAccelerators
      (\ s a -> s{_ipGuestAccelerators = a})
      . _Default
      . _Coerce

-- | The machine type to use for instances that are created from these
-- properties.
ipMachineType :: Lens' InstanceProperties (Maybe Text)
ipMachineType
  = lens _ipMachineType
      (\ s a -> s{_ipMachineType = a})

-- | The metadata key\/value pairs to assign to instances that are created
-- from these properties. These pairs can consist of custom metadata or
-- predefined keys. See Project and instance metadata for more information.
ipMetadata :: Lens' InstanceProperties (Maybe Metadata)
ipMetadata
  = lens _ipMetadata (\ s a -> s{_ipMetadata = a})

ipShieldedInstanceConfig :: Lens' InstanceProperties (Maybe ShieldedInstanceConfig)
ipShieldedInstanceConfig
  = lens _ipShieldedInstanceConfig
      (\ s a -> s{_ipShieldedInstanceConfig = a})

-- | Labels to apply to instances that are created from these properties.
ipLabels :: Lens' InstanceProperties (Maybe InstancePropertiesLabels)
ipLabels = lens _ipLabels (\ s a -> s{_ipLabels = a})

-- | Specifies the scheduling options for the instances that are created from
-- these properties.
ipScheduling :: Lens' InstanceProperties (Maybe Scheduling)
ipScheduling
  = lens _ipScheduling (\ s a -> s{_ipScheduling = a})

-- | Minimum cpu\/platform to be used by instances. The instance may be
-- scheduled on the specified or newer cpu\/platform. Applicable values are
-- the friendly names of CPU platforms, such as minCpuPlatform: \"Intel
-- Haswell\" or minCpuPlatform: \"Intel Sandy Bridge\". For more
-- information, read Specifying a Minimum CPU Platform.
ipMinCPUPlatform :: Lens' InstanceProperties (Maybe Text)
ipMinCPUPlatform
  = lens _ipMinCPUPlatform
      (\ s a -> s{_ipMinCPUPlatform = a})

-- | An array of disks that are associated with the instances that are
-- created from these properties.
ipDisks :: Lens' InstanceProperties [AttachedDisk]
ipDisks
  = lens _ipDisks (\ s a -> s{_ipDisks = a}) . _Default
      . _Coerce

-- | Enables instances created based on these properties to send packets with
-- source IP addresses other than their own and receive packets with
-- destination IP addresses other than their own. If these instances will
-- be used as an IP gateway or it will be set as the next-hop in a Route
-- resource, specify true. If unsure, leave this set to false. See the
-- Enable IP forwarding documentation for more information.
ipCanIPForward :: Lens' InstanceProperties (Maybe Bool)
ipCanIPForward
  = lens _ipCanIPForward
      (\ s a -> s{_ipCanIPForward = a})

-- | An optional text description for the instances that are created from
-- these properties.
ipDescription :: Lens' InstanceProperties (Maybe Text)
ipDescription
  = lens _ipDescription
      (\ s a -> s{_ipDescription = a})

-- | A list of tags to apply to the instances that are created from these
-- properties. The tags identify valid sources or targets for network
-- firewalls. The setTags method can modify this list of tags. Each tag
-- within the list must comply with RFC1035.
ipTags :: Lens' InstanceProperties (Maybe Tags)
ipTags = lens _ipTags (\ s a -> s{_ipTags = a})

-- | The private IPv6 google access type for VMs. If not specified, use
-- INHERIT_FROM_SUBNETWORK as default.
ipPrivateIPv6GoogleAccess :: Lens' InstanceProperties (Maybe InstancePropertiesPrivateIPv6GoogleAccess)
ipPrivateIPv6GoogleAccess
  = lens _ipPrivateIPv6GoogleAccess
      (\ s a -> s{_ipPrivateIPv6GoogleAccess = a})

instance FromJSON InstanceProperties where
        parseJSON
          = withObject "InstanceProperties"
              (\ o ->
                 InstanceProperties' <$>
                   (o .:? "advancedMachineFeatures") <*>
                     (o .:? "serviceAccounts" .!= mempty)
                     <*> (o .:? "reservationAffinity")
                     <*> (o .:? "networkInterfaces" .!= mempty)
                     <*> (o .:? "confidentialInstanceConfig")
                     <*> (o .:? "resourcePolicies" .!= mempty)
                     <*> (o .:? "guestAccelerators" .!= mempty)
                     <*> (o .:? "machineType")
                     <*> (o .:? "metadata")
                     <*> (o .:? "shieldedInstanceConfig")
                     <*> (o .:? "labels")
                     <*> (o .:? "scheduling")
                     <*> (o .:? "minCpuPlatform")
                     <*> (o .:? "disks" .!= mempty)
                     <*> (o .:? "canIpForward")
                     <*> (o .:? "description")
                     <*> (o .:? "tags")
                     <*> (o .:? "privateIpv6GoogleAccess"))

instance ToJSON InstanceProperties where
        toJSON InstanceProperties'{..}
          = object
              (catMaybes
                 [("advancedMachineFeatures" .=) <$>
                    _ipAdvancedMachineFeatures,
                  ("serviceAccounts" .=) <$> _ipServiceAccounts,
                  ("reservationAffinity" .=) <$>
                    _ipReservationAffinity,
                  ("networkInterfaces" .=) <$> _ipNetworkInterfaces,
                  ("confidentialInstanceConfig" .=) <$>
                    _ipConfidentialInstanceConfig,
                  ("resourcePolicies" .=) <$> _ipResourcePolicies,
                  ("guestAccelerators" .=) <$> _ipGuestAccelerators,
                  ("machineType" .=) <$> _ipMachineType,
                  ("metadata" .=) <$> _ipMetadata,
                  ("shieldedInstanceConfig" .=) <$>
                    _ipShieldedInstanceConfig,
                  ("labels" .=) <$> _ipLabels,
                  ("scheduling" .=) <$> _ipScheduling,
                  ("minCpuPlatform" .=) <$> _ipMinCPUPlatform,
                  ("disks" .=) <$> _ipDisks,
                  ("canIpForward" .=) <$> _ipCanIPForward,
                  ("description" .=) <$> _ipDescription,
                  ("tags" .=) <$> _ipTags,
                  ("privateIpv6GoogleAccess" .=) <$>
                    _ipPrivateIPv6GoogleAccess])

--
-- /See:/ 'projectsListXpnHostsRequest' smart constructor.
newtype ProjectsListXpnHostsRequest =
  ProjectsListXpnHostsRequest'
    { _plxhrOrganization :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ProjectsListXpnHostsRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'plxhrOrganization'
projectsListXpnHostsRequest
    :: ProjectsListXpnHostsRequest
projectsListXpnHostsRequest =
  ProjectsListXpnHostsRequest' {_plxhrOrganization = Nothing}


-- | Optional organization ID managed by Cloud Resource Manager, for which to
-- list shared VPC host projects. If not specified, the organization will
-- be inferred from the project.
plxhrOrganization :: Lens' ProjectsListXpnHostsRequest (Maybe Text)
plxhrOrganization
  = lens _plxhrOrganization
      (\ s a -> s{_plxhrOrganization = a})

instance FromJSON ProjectsListXpnHostsRequest where
        parseJSON
          = withObject "ProjectsListXpnHostsRequest"
              (\ o ->
                 ProjectsListXpnHostsRequest' <$>
                   (o .:? "organization"))

instance ToJSON ProjectsListXpnHostsRequest where
        toJSON ProjectsListXpnHostsRequest'{..}
          = object
              (catMaybes
                 [("organization" .=) <$> _plxhrOrganization])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'vpnGatewayListWarning' smart constructor.
data VPNGatewayListWarning =
  VPNGatewayListWarning'
    { _vglwData :: !(Maybe [VPNGatewayListWarningDataItem])
    , _vglwCode :: !(Maybe VPNGatewayListWarningCode)
    , _vglwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNGatewayListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vglwData'
--
-- * 'vglwCode'
--
-- * 'vglwMessage'
vpnGatewayListWarning
    :: VPNGatewayListWarning
vpnGatewayListWarning =
  VPNGatewayListWarning'
    {_vglwData = Nothing, _vglwCode = Nothing, _vglwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
vglwData :: Lens' VPNGatewayListWarning [VPNGatewayListWarningDataItem]
vglwData
  = lens _vglwData (\ s a -> s{_vglwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
vglwCode :: Lens' VPNGatewayListWarning (Maybe VPNGatewayListWarningCode)
vglwCode = lens _vglwCode (\ s a -> s{_vglwCode = a})

-- | [Output Only] A human-readable description of the warning code.
vglwMessage :: Lens' VPNGatewayListWarning (Maybe Text)
vglwMessage
  = lens _vglwMessage (\ s a -> s{_vglwMessage = a})

instance FromJSON VPNGatewayListWarning where
        parseJSON
          = withObject "VPNGatewayListWarning"
              (\ o ->
                 VPNGatewayListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON VPNGatewayListWarning where
        toJSON VPNGatewayListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _vglwData,
                  ("code" .=) <$> _vglwCode,
                  ("message" .=) <$> _vglwMessage])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'regionListWarning' smart constructor.
data RegionListWarning =
  RegionListWarning'
    { _rlwData :: !(Maybe [RegionListWarningDataItem])
    , _rlwCode :: !(Maybe RegionListWarningCode)
    , _rlwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rlwData'
--
-- * 'rlwCode'
--
-- * 'rlwMessage'
regionListWarning
    :: RegionListWarning
regionListWarning =
  RegionListWarning'
    {_rlwData = Nothing, _rlwCode = Nothing, _rlwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
rlwData :: Lens' RegionListWarning [RegionListWarningDataItem]
rlwData
  = lens _rlwData (\ s a -> s{_rlwData = a}) . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
rlwCode :: Lens' RegionListWarning (Maybe RegionListWarningCode)
rlwCode = lens _rlwCode (\ s a -> s{_rlwCode = a})

-- | [Output Only] A human-readable description of the warning code.
rlwMessage :: Lens' RegionListWarning (Maybe Text)
rlwMessage
  = lens _rlwMessage (\ s a -> s{_rlwMessage = a})

instance FromJSON RegionListWarning where
        parseJSON
          = withObject "RegionListWarning"
              (\ o ->
                 RegionListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON RegionListWarning where
        toJSON RegionListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _rlwData, ("code" .=) <$> _rlwCode,
                  ("message" .=) <$> _rlwMessage])

-- | A list of HealthChecksScopedList resources.
--
-- /See:/ 'healthChecksAggregatedListItems' smart constructor.
newtype HealthChecksAggregatedListItems =
  HealthChecksAggregatedListItems'
    { _hcaliAddtional :: HashMap Text HealthChecksScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HealthChecksAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hcaliAddtional'
healthChecksAggregatedListItems
    :: HashMap Text HealthChecksScopedList -- ^ 'hcaliAddtional'
    -> HealthChecksAggregatedListItems
healthChecksAggregatedListItems pHcaliAddtional_ =
  HealthChecksAggregatedListItems'
    {_hcaliAddtional = _Coerce # pHcaliAddtional_}


-- | Name of the scope containing this set of HealthChecks.
hcaliAddtional :: Lens' HealthChecksAggregatedListItems (HashMap Text HealthChecksScopedList)
hcaliAddtional
  = lens _hcaliAddtional
      (\ s a -> s{_hcaliAddtional = a})
      . _Coerce

instance FromJSON HealthChecksAggregatedListItems
         where
        parseJSON
          = withObject "HealthChecksAggregatedListItems"
              (\ o ->
                 HealthChecksAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON HealthChecksAggregatedListItems where
        toJSON = toJSON . _hcaliAddtional

--
-- /See:/ 'hTTP2HealthCheck' smart constructor.
data HTTP2HealthCheck =
  HTTP2HealthCheck'
    { _httphcResponse :: !(Maybe Text)
    , _httphcPortSpecification :: !(Maybe HTTP2HealthCheckPortSpecification)
    , _httphcRequestPath :: !(Maybe Text)
    , _httphcHost :: !(Maybe Text)
    , _httphcProxyHeader :: !(Maybe HTTP2HealthCheckProxyHeader)
    , _httphcPortName :: !(Maybe Text)
    , _httphcPort :: !(Maybe (Textual Int32))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HTTP2HealthCheck' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'httphcResponse'
--
-- * 'httphcPortSpecification'
--
-- * 'httphcRequestPath'
--
-- * 'httphcHost'
--
-- * 'httphcProxyHeader'
--
-- * 'httphcPortName'
--
-- * 'httphcPort'
hTTP2HealthCheck
    :: HTTP2HealthCheck
hTTP2HealthCheck =
  HTTP2HealthCheck'
    { _httphcResponse = Nothing
    , _httphcPortSpecification = Nothing
    , _httphcRequestPath = Nothing
    , _httphcHost = Nothing
    , _httphcProxyHeader = Nothing
    , _httphcPortName = Nothing
    , _httphcPort = Nothing
    }


-- | The string to match anywhere in the first 1024 bytes of the response
-- body. If left empty (the default value), the status code determines
-- health. The response data can only be ASCII.
httphcResponse :: Lens' HTTP2HealthCheck (Maybe Text)
httphcResponse
  = lens _httphcResponse
      (\ s a -> s{_httphcResponse = a})

-- | Specifies how port is selected for health checking, can be one of
-- following values: USE_FIXED_PORT: The port number in port is used for
-- health checking. USE_NAMED_PORT: The portName is used for health
-- checking. USE_SERVING_PORT: For NetworkEndpointGroup, the port specified
-- for each network endpoint is used for health checking. For other
-- backends, the port or named port specified in the Backend Service is
-- used for health checking. If not specified, HTTP2 health check follows
-- behavior specified in port and portName fields.
httphcPortSpecification :: Lens' HTTP2HealthCheck (Maybe HTTP2HealthCheckPortSpecification)
httphcPortSpecification
  = lens _httphcPortSpecification
      (\ s a -> s{_httphcPortSpecification = a})

-- | The request path of the HTTP\/2 health check request. The default value
-- is \/.
httphcRequestPath :: Lens' HTTP2HealthCheck (Maybe Text)
httphcRequestPath
  = lens _httphcRequestPath
      (\ s a -> s{_httphcRequestPath = a})

-- | The value of the host header in the HTTP\/2 health check request. If
-- left empty (default value), the IP on behalf of which this health check
-- is performed will be used.
httphcHost :: Lens' HTTP2HealthCheck (Maybe Text)
httphcHost
  = lens _httphcHost (\ s a -> s{_httphcHost = a})

-- | Specifies the type of proxy header to append before sending data to the
-- backend, either NONE or PROXY_V1. The default is NONE.
httphcProxyHeader :: Lens' HTTP2HealthCheck (Maybe HTTP2HealthCheckProxyHeader)
httphcProxyHeader
  = lens _httphcProxyHeader
      (\ s a -> s{_httphcProxyHeader = a})

-- | Port name as defined in InstanceGroup#NamedPort#name. If both port and
-- port_name are defined, port takes precedence.
httphcPortName :: Lens' HTTP2HealthCheck (Maybe Text)
httphcPortName
  = lens _httphcPortName
      (\ s a -> s{_httphcPortName = a})

-- | The TCP port number for the health check request. The default value is
-- 443. Valid values are 1 through 65535.
httphcPort :: Lens' HTTP2HealthCheck (Maybe Int32)
httphcPort
  = lens _httphcPort (\ s a -> s{_httphcPort = a}) .
      mapping _Coerce

instance FromJSON HTTP2HealthCheck where
        parseJSON
          = withObject "HTTP2HealthCheck"
              (\ o ->
                 HTTP2HealthCheck' <$>
                   (o .:? "response") <*> (o .:? "portSpecification")
                     <*> (o .:? "requestPath")
                     <*> (o .:? "host")
                     <*> (o .:? "proxyHeader")
                     <*> (o .:? "portName")
                     <*> (o .:? "port"))

instance ToJSON HTTP2HealthCheck where
        toJSON HTTP2HealthCheck'{..}
          = object
              (catMaybes
                 [("response" .=) <$> _httphcResponse,
                  ("portSpecification" .=) <$>
                    _httphcPortSpecification,
                  ("requestPath" .=) <$> _httphcRequestPath,
                  ("host" .=) <$> _httphcHost,
                  ("proxyHeader" .=) <$> _httphcProxyHeader,
                  ("portName" .=) <$> _httphcPortName,
                  ("port" .=) <$> _httphcPort])

--
-- /See:/ 'vpnGatewayAggregatedListWarningDataItem' smart constructor.
data VPNGatewayAggregatedListWarningDataItem =
  VPNGatewayAggregatedListWarningDataItem'
    { _vgalwdiValue :: !(Maybe Text)
    , _vgalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNGatewayAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vgalwdiValue'
--
-- * 'vgalwdiKey'
vpnGatewayAggregatedListWarningDataItem
    :: VPNGatewayAggregatedListWarningDataItem
vpnGatewayAggregatedListWarningDataItem =
  VPNGatewayAggregatedListWarningDataItem'
    {_vgalwdiValue = Nothing, _vgalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
vgalwdiValue :: Lens' VPNGatewayAggregatedListWarningDataItem (Maybe Text)
vgalwdiValue
  = lens _vgalwdiValue (\ s a -> s{_vgalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
vgalwdiKey :: Lens' VPNGatewayAggregatedListWarningDataItem (Maybe Text)
vgalwdiKey
  = lens _vgalwdiKey (\ s a -> s{_vgalwdiKey = a})

instance FromJSON
           VPNGatewayAggregatedListWarningDataItem
         where
        parseJSON
          = withObject
              "VPNGatewayAggregatedListWarningDataItem"
              (\ o ->
                 VPNGatewayAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           VPNGatewayAggregatedListWarningDataItem
         where
        toJSON VPNGatewayAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _vgalwdiValue,
                  ("key" .=) <$> _vgalwdiKey])

--
-- /See:/ 'nodeGroupsScopedList' smart constructor.
data NodeGroupsScopedList =
  NodeGroupsScopedList'
    { _ngslNodeGroups :: !(Maybe [NodeGroup])
    , _ngslWarning :: !(Maybe NodeGroupsScopedListWarning)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeGroupsScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ngslNodeGroups'
--
-- * 'ngslWarning'
nodeGroupsScopedList
    :: NodeGroupsScopedList
nodeGroupsScopedList =
  NodeGroupsScopedList' {_ngslNodeGroups = Nothing, _ngslWarning = Nothing}


-- | [Output Only] A list of node groups contained in this scope.
ngslNodeGroups :: Lens' NodeGroupsScopedList [NodeGroup]
ngslNodeGroups
  = lens _ngslNodeGroups
      (\ s a -> s{_ngslNodeGroups = a})
      . _Default
      . _Coerce

-- | [Output Only] An informational warning that appears when the nodeGroup
-- list is empty.
ngslWarning :: Lens' NodeGroupsScopedList (Maybe NodeGroupsScopedListWarning)
ngslWarning
  = lens _ngslWarning (\ s a -> s{_ngslWarning = a})

instance FromJSON NodeGroupsScopedList where
        parseJSON
          = withObject "NodeGroupsScopedList"
              (\ o ->
                 NodeGroupsScopedList' <$>
                   (o .:? "nodeGroups" .!= mempty) <*>
                     (o .:? "warning"))

instance ToJSON NodeGroupsScopedList where
        toJSON NodeGroupsScopedList'{..}
          = object
              (catMaybes
                 [("nodeGroups" .=) <$> _ngslNodeGroups,
                  ("warning" .=) <$> _ngslWarning])

--
-- /See:/ 'publicAdvertisedPrefixList' smart constructor.
data PublicAdvertisedPrefixList =
  PublicAdvertisedPrefixList'
    { _paplNextPageToken :: !(Maybe Text)
    , _paplKind :: !Text
    , _paplItems :: !(Maybe [PublicAdvertisedPrefix])
    , _paplSelfLink :: !(Maybe Text)
    , _paplWarning :: !(Maybe PublicAdvertisedPrefixListWarning)
    , _paplId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PublicAdvertisedPrefixList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'paplNextPageToken'
--
-- * 'paplKind'
--
-- * 'paplItems'
--
-- * 'paplSelfLink'
--
-- * 'paplWarning'
--
-- * 'paplId'
publicAdvertisedPrefixList
    :: PublicAdvertisedPrefixList
publicAdvertisedPrefixList =
  PublicAdvertisedPrefixList'
    { _paplNextPageToken = Nothing
    , _paplKind = "compute#publicAdvertisedPrefixList"
    , _paplItems = Nothing
    , _paplSelfLink = Nothing
    , _paplWarning = Nothing
    , _paplId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
paplNextPageToken :: Lens' PublicAdvertisedPrefixList (Maybe Text)
paplNextPageToken
  = lens _paplNextPageToken
      (\ s a -> s{_paplNextPageToken = a})

-- | [Output Only] Type of the resource. Always
-- compute#publicAdvertisedPrefix for public advertised prefixes.
paplKind :: Lens' PublicAdvertisedPrefixList Text
paplKind = lens _paplKind (\ s a -> s{_paplKind = a})

-- | A list of PublicAdvertisedPrefix resources.
paplItems :: Lens' PublicAdvertisedPrefixList [PublicAdvertisedPrefix]
paplItems
  = lens _paplItems (\ s a -> s{_paplItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
paplSelfLink :: Lens' PublicAdvertisedPrefixList (Maybe Text)
paplSelfLink
  = lens _paplSelfLink (\ s a -> s{_paplSelfLink = a})

-- | [Output Only] Informational warning message.
paplWarning :: Lens' PublicAdvertisedPrefixList (Maybe PublicAdvertisedPrefixListWarning)
paplWarning
  = lens _paplWarning (\ s a -> s{_paplWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
paplId :: Lens' PublicAdvertisedPrefixList (Maybe Text)
paplId = lens _paplId (\ s a -> s{_paplId = a})

instance FromJSON PublicAdvertisedPrefixList where
        parseJSON
          = withObject "PublicAdvertisedPrefixList"
              (\ o ->
                 PublicAdvertisedPrefixList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!=
                        "compute#publicAdvertisedPrefixList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON PublicAdvertisedPrefixList where
        toJSON PublicAdvertisedPrefixList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _paplNextPageToken,
                  Just ("kind" .= _paplKind),
                  ("items" .=) <$> _paplItems,
                  ("selfLink" .=) <$> _paplSelfLink,
                  ("warning" .=) <$> _paplWarning,
                  ("id" .=) <$> _paplId])

-- | [Output Only] Informational warning which replaces the list of disk
-- types when the list is empty.
--
-- /See:/ 'diskTypesScopedListWarning' smart constructor.
data DiskTypesScopedListWarning =
  DiskTypesScopedListWarning'
    { _dtslwData :: !(Maybe [DiskTypesScopedListWarningDataItem])
    , _dtslwCode :: !(Maybe DiskTypesScopedListWarningCode)
    , _dtslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DiskTypesScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dtslwData'
--
-- * 'dtslwCode'
--
-- * 'dtslwMessage'
diskTypesScopedListWarning
    :: DiskTypesScopedListWarning
diskTypesScopedListWarning =
  DiskTypesScopedListWarning'
    {_dtslwData = Nothing, _dtslwCode = Nothing, _dtslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
dtslwData :: Lens' DiskTypesScopedListWarning [DiskTypesScopedListWarningDataItem]
dtslwData
  = lens _dtslwData (\ s a -> s{_dtslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
dtslwCode :: Lens' DiskTypesScopedListWarning (Maybe DiskTypesScopedListWarningCode)
dtslwCode
  = lens _dtslwCode (\ s a -> s{_dtslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
dtslwMessage :: Lens' DiskTypesScopedListWarning (Maybe Text)
dtslwMessage
  = lens _dtslwMessage (\ s a -> s{_dtslwMessage = a})

instance FromJSON DiskTypesScopedListWarning where
        parseJSON
          = withObject "DiskTypesScopedListWarning"
              (\ o ->
                 DiskTypesScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON DiskTypesScopedListWarning where
        toJSON DiskTypesScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _dtslwData,
                  ("code" .=) <$> _dtslwCode,
                  ("message" .=) <$> _dtslwMessage])

-- | Specification for how requests are aborted as part of fault injection.
--
-- /See:/ 'hTTPFaultAbort' smart constructor.
data HTTPFaultAbort =
  HTTPFaultAbort'
    { _httpfaHTTPStatus :: !(Maybe (Textual Word32))
    , _httpfaPercentage :: !(Maybe (Textual Double))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HTTPFaultAbort' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'httpfaHTTPStatus'
--
-- * 'httpfaPercentage'
hTTPFaultAbort
    :: HTTPFaultAbort
hTTPFaultAbort =
  HTTPFaultAbort' {_httpfaHTTPStatus = Nothing, _httpfaPercentage = Nothing}


-- | The HTTP status code used to abort the request. The value must be
-- between 200 and 599 inclusive. For gRPC protocol, the gRPC status code
-- is mapped to HTTP status code according to this mapping table. HTTP
-- status 200 is mapped to gRPC status UNKNOWN. Injecting an OK status is
-- currently not supported by Traffic Director.
httpfaHTTPStatus :: Lens' HTTPFaultAbort (Maybe Word32)
httpfaHTTPStatus
  = lens _httpfaHTTPStatus
      (\ s a -> s{_httpfaHTTPStatus = a})
      . mapping _Coerce

-- | The percentage of traffic (connections\/operations\/requests) which will
-- be aborted as part of fault injection. The value must be between 0.0 and
-- 100.0 inclusive.
httpfaPercentage :: Lens' HTTPFaultAbort (Maybe Double)
httpfaPercentage
  = lens _httpfaPercentage
      (\ s a -> s{_httpfaPercentage = a})
      . mapping _Coerce

instance FromJSON HTTPFaultAbort where
        parseJSON
          = withObject "HTTPFaultAbort"
              (\ o ->
                 HTTPFaultAbort' <$>
                   (o .:? "httpStatus") <*> (o .:? "percentage"))

instance ToJSON HTTPFaultAbort where
        toJSON HTTPFaultAbort'{..}
          = object
              (catMaybes
                 [("httpStatus" .=) <$> _httpfaHTTPStatus,
                  ("percentage" .=) <$> _httpfaPercentage])

--
-- /See:/ 'regionInstanceGroupManagerListWarningDataItem' smart constructor.
data RegionInstanceGroupManagerListWarningDataItem =
  RegionInstanceGroupManagerListWarningDataItem'
    { _rigmlwdiValue :: !(Maybe Text)
    , _rigmlwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupManagerListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rigmlwdiValue'
--
-- * 'rigmlwdiKey'
regionInstanceGroupManagerListWarningDataItem
    :: RegionInstanceGroupManagerListWarningDataItem
regionInstanceGroupManagerListWarningDataItem =
  RegionInstanceGroupManagerListWarningDataItem'
    {_rigmlwdiValue = Nothing, _rigmlwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
rigmlwdiValue :: Lens' RegionInstanceGroupManagerListWarningDataItem (Maybe Text)
rigmlwdiValue
  = lens _rigmlwdiValue
      (\ s a -> s{_rigmlwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
rigmlwdiKey :: Lens' RegionInstanceGroupManagerListWarningDataItem (Maybe Text)
rigmlwdiKey
  = lens _rigmlwdiKey (\ s a -> s{_rigmlwdiKey = a})

instance FromJSON
           RegionInstanceGroupManagerListWarningDataItem
         where
        parseJSON
          = withObject
              "RegionInstanceGroupManagerListWarningDataItem"
              (\ o ->
                 RegionInstanceGroupManagerListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           RegionInstanceGroupManagerListWarningDataItem
         where
        toJSON
          RegionInstanceGroupManagerListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _rigmlwdiValue,
                  ("key" .=) <$> _rigmlwdiKey])

--
-- /See:/ 'statefulPolicy' smart constructor.
newtype StatefulPolicy =
  StatefulPolicy'
    { _spPreservedState :: Maybe StatefulPolicyPreservedState
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'StatefulPolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'spPreservedState'
statefulPolicy
    :: StatefulPolicy
statefulPolicy = StatefulPolicy' {_spPreservedState = Nothing}


spPreservedState :: Lens' StatefulPolicy (Maybe StatefulPolicyPreservedState)
spPreservedState
  = lens _spPreservedState
      (\ s a -> s{_spPreservedState = a})

instance FromJSON StatefulPolicy where
        parseJSON
          = withObject "StatefulPolicy"
              (\ o -> StatefulPolicy' <$> (o .:? "preservedState"))

instance ToJSON StatefulPolicy where
        toJSON StatefulPolicy'{..}
          = object
              (catMaybes
                 [("preservedState" .=) <$> _spPreservedState])

-- | [Input Only] Specifies the parameters for a new disk that will be
-- created alongside the new instance. Use initialization parameters to
-- create boot disks or local SSDs attached to the new instance. This
-- property is mutually exclusive with the source property; you can only
-- define one or the other, but not both.
--
-- /See:/ 'attachedDiskInitializeParams' smart constructor.
data AttachedDiskInitializeParams =
  AttachedDiskInitializeParams'
    { _adipSourceImage :: !(Maybe Text)
    , _adipDiskSizeGb :: !(Maybe (Textual Int64))
    , _adipProvisionedIops :: !(Maybe (Textual Int64))
    , _adipOnUpdateAction :: !(Maybe AttachedDiskInitializeParamsOnUpdateAction)
    , _adipResourcePolicies :: !(Maybe [Text])
    , _adipDiskName :: !(Maybe Text)
    , _adipSourceImageEncryptionKey :: !(Maybe CustomerEncryptionKey)
    , _adipDiskType :: !(Maybe Text)
    , _adipLabels :: !(Maybe AttachedDiskInitializeParamsLabels)
    , _adipDescription :: !(Maybe Text)
    , _adipSourceSnapshotEncryptionKey :: !(Maybe CustomerEncryptionKey)
    , _adipSourceSnapshot :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AttachedDiskInitializeParams' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'adipSourceImage'
--
-- * 'adipDiskSizeGb'
--
-- * 'adipProvisionedIops'
--
-- * 'adipOnUpdateAction'
--
-- * 'adipResourcePolicies'
--
-- * 'adipDiskName'
--
-- * 'adipSourceImageEncryptionKey'
--
-- * 'adipDiskType'
--
-- * 'adipLabels'
--
-- * 'adipDescription'
--
-- * 'adipSourceSnapshotEncryptionKey'
--
-- * 'adipSourceSnapshot'
attachedDiskInitializeParams
    :: AttachedDiskInitializeParams
attachedDiskInitializeParams =
  AttachedDiskInitializeParams'
    { _adipSourceImage = Nothing
    , _adipDiskSizeGb = Nothing
    , _adipProvisionedIops = Nothing
    , _adipOnUpdateAction = Nothing
    , _adipResourcePolicies = Nothing
    , _adipDiskName = Nothing
    , _adipSourceImageEncryptionKey = Nothing
    , _adipDiskType = Nothing
    , _adipLabels = Nothing
    , _adipDescription = Nothing
    , _adipSourceSnapshotEncryptionKey = Nothing
    , _adipSourceSnapshot = Nothing
    }


-- | The source image to create this disk. When creating a new instance, one
-- of initializeParams.sourceImage or initializeParams.sourceSnapshot or
-- disks.source is required except for local SSD. To create a disk with one
-- of the public operating system images, specify the image by its family
-- name. For example, specify family\/debian-9 to use the latest Debian 9
-- image: projects\/debian-cloud\/global\/images\/family\/debian-9
-- Alternatively, use a specific version of a public operating system
-- image:
-- projects\/debian-cloud\/global\/images\/debian-9-stretch-vYYYYMMDD To
-- create a disk with a custom image that you created, specify the image
-- name in the following format: global\/images\/my-custom-image You can
-- also specify a custom image by its image family, which returns the
-- latest version of the image in that family. Replace the image name with
-- family\/family-name: global\/images\/family\/my-image-family If the
-- source image is deleted later, this field will not be set.
adipSourceImage :: Lens' AttachedDiskInitializeParams (Maybe Text)
adipSourceImage
  = lens _adipSourceImage
      (\ s a -> s{_adipSourceImage = a})

-- | Specifies the size of the disk in base-2 GB. The size must be at least
-- 10 GB. If you specify a sourceImage, which is required for boot disks,
-- the default size is the size of the sourceImage. If you do not specify a
-- sourceImage, the default disk size is 500 GB.
adipDiskSizeGb :: Lens' AttachedDiskInitializeParams (Maybe Int64)
adipDiskSizeGb
  = lens _adipDiskSizeGb
      (\ s a -> s{_adipDiskSizeGb = a})
      . mapping _Coerce

-- | Indicates how many IOPS must be provisioned for the disk.
adipProvisionedIops :: Lens' AttachedDiskInitializeParams (Maybe Int64)
adipProvisionedIops
  = lens _adipProvisionedIops
      (\ s a -> s{_adipProvisionedIops = a})
      . mapping _Coerce

-- | Specifies which action to take on instance update with this disk.
-- Default is to use the existing disk.
adipOnUpdateAction :: Lens' AttachedDiskInitializeParams (Maybe AttachedDiskInitializeParamsOnUpdateAction)
adipOnUpdateAction
  = lens _adipOnUpdateAction
      (\ s a -> s{_adipOnUpdateAction = a})

-- | Resource policies applied to this disk for automatic snapshot creations.
-- Specified using the full or partial URL. For instance template, specify
-- only the resource policy name.
adipResourcePolicies :: Lens' AttachedDiskInitializeParams [Text]
adipResourcePolicies
  = lens _adipResourcePolicies
      (\ s a -> s{_adipResourcePolicies = a})
      . _Default
      . _Coerce

-- | Specifies the disk name. If not specified, the default is to use the
-- name of the instance. If a disk with the same name already exists in the
-- given region, the existing disk is attached to the new instance and the
-- new disk is not created.
adipDiskName :: Lens' AttachedDiskInitializeParams (Maybe Text)
adipDiskName
  = lens _adipDiskName (\ s a -> s{_adipDiskName = a})

-- | The customer-supplied encryption key of the source image. Required if
-- the source image is protected by a customer-supplied encryption key.
-- Instance templates do not store customer-supplied encryption keys, so
-- you cannot create disks for instances in a managed instance group if the
-- source images are encrypted with your own keys.
adipSourceImageEncryptionKey :: Lens' AttachedDiskInitializeParams (Maybe CustomerEncryptionKey)
adipSourceImageEncryptionKey
  = lens _adipSourceImageEncryptionKey
      (\ s a -> s{_adipSourceImageEncryptionKey = a})

-- | Specifies the disk type to use to create the instance. If not specified,
-- the default is pd-standard, specified using the full URL. For example:
-- https:\/\/www.googleapis.com\/compute\/v1\/projects\/project\/zones\/zone\/diskTypes\/pd-standard
-- Other values include pd-ssd and local-ssd. If you define this field, you
-- can provide either the full or partial URL. For example, the following
-- are valid values: -
-- https:\/\/www.googleapis.com\/compute\/v1\/projects\/project\/zones\/zone\/diskTypes\/diskType
-- - projects\/project\/zones\/zone\/diskTypes\/diskType -
-- zones\/zone\/diskTypes\/diskType Note that for InstanceTemplate, this is
-- the name of the disk type, not URL.
adipDiskType :: Lens' AttachedDiskInitializeParams (Maybe Text)
adipDiskType
  = lens _adipDiskType (\ s a -> s{_adipDiskType = a})

-- | Labels to apply to this disk. These can be later modified by the
-- disks.setLabels method. This field is only applicable for persistent
-- disks.
adipLabels :: Lens' AttachedDiskInitializeParams (Maybe AttachedDiskInitializeParamsLabels)
adipLabels
  = lens _adipLabels (\ s a -> s{_adipLabels = a})

-- | An optional description. Provide this property when creating the disk.
adipDescription :: Lens' AttachedDiskInitializeParams (Maybe Text)
adipDescription
  = lens _adipDescription
      (\ s a -> s{_adipDescription = a})

-- | The customer-supplied encryption key of the source snapshot.
adipSourceSnapshotEncryptionKey :: Lens' AttachedDiskInitializeParams (Maybe CustomerEncryptionKey)
adipSourceSnapshotEncryptionKey
  = lens _adipSourceSnapshotEncryptionKey
      (\ s a -> s{_adipSourceSnapshotEncryptionKey = a})

-- | The source snapshot to create this disk. When creating a new instance,
-- one of initializeParams.sourceSnapshot or initializeParams.sourceImage
-- or disks.source is required except for local SSD. To create a disk with
-- a snapshot that you created, specify the snapshot name in the following
-- format: global\/snapshots\/my-backup If the source snapshot is deleted
-- later, this field will not be set.
adipSourceSnapshot :: Lens' AttachedDiskInitializeParams (Maybe Text)
adipSourceSnapshot
  = lens _adipSourceSnapshot
      (\ s a -> s{_adipSourceSnapshot = a})

instance FromJSON AttachedDiskInitializeParams where
        parseJSON
          = withObject "AttachedDiskInitializeParams"
              (\ o ->
                 AttachedDiskInitializeParams' <$>
                   (o .:? "sourceImage") <*> (o .:? "diskSizeGb") <*>
                     (o .:? "provisionedIops")
                     <*> (o .:? "onUpdateAction")
                     <*> (o .:? "resourcePolicies" .!= mempty)
                     <*> (o .:? "diskName")
                     <*> (o .:? "sourceImageEncryptionKey")
                     <*> (o .:? "diskType")
                     <*> (o .:? "labels")
                     <*> (o .:? "description")
                     <*> (o .:? "sourceSnapshotEncryptionKey")
                     <*> (o .:? "sourceSnapshot"))

instance ToJSON AttachedDiskInitializeParams where
        toJSON AttachedDiskInitializeParams'{..}
          = object
              (catMaybes
                 [("sourceImage" .=) <$> _adipSourceImage,
                  ("diskSizeGb" .=) <$> _adipDiskSizeGb,
                  ("provisionedIops" .=) <$> _adipProvisionedIops,
                  ("onUpdateAction" .=) <$> _adipOnUpdateAction,
                  ("resourcePolicies" .=) <$> _adipResourcePolicies,
                  ("diskName" .=) <$> _adipDiskName,
                  ("sourceImageEncryptionKey" .=) <$>
                    _adipSourceImageEncryptionKey,
                  ("diskType" .=) <$> _adipDiskType,
                  ("labels" .=) <$> _adipLabels,
                  ("description" .=) <$> _adipDescription,
                  ("sourceSnapshotEncryptionKey" .=) <$>
                    _adipSourceSnapshotEncryptionKey,
                  ("sourceSnapshot" .=) <$> _adipSourceSnapshot])

-- | Secondary IP range of a usable subnetwork.
--
-- /See:/ 'usableSubnetworkSecondaryRange' smart constructor.
data UsableSubnetworkSecondaryRange =
  UsableSubnetworkSecondaryRange'
    { _ussrRangeName :: !(Maybe Text)
    , _ussrIPCIdRRange :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'UsableSubnetworkSecondaryRange' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ussrRangeName'
--
-- * 'ussrIPCIdRRange'
usableSubnetworkSecondaryRange
    :: UsableSubnetworkSecondaryRange
usableSubnetworkSecondaryRange =
  UsableSubnetworkSecondaryRange'
    {_ussrRangeName = Nothing, _ussrIPCIdRRange = Nothing}


-- | The name associated with this subnetwork secondary range, used when
-- adding an alias IP range to a VM instance. The name must be 1-63
-- characters long, and comply with RFC1035. The name must be unique within
-- the subnetwork.
ussrRangeName :: Lens' UsableSubnetworkSecondaryRange (Maybe Text)
ussrRangeName
  = lens _ussrRangeName
      (\ s a -> s{_ussrRangeName = a})

-- | The range of IP addresses belonging to this subnetwork secondary range.
ussrIPCIdRRange :: Lens' UsableSubnetworkSecondaryRange (Maybe Text)
ussrIPCIdRRange
  = lens _ussrIPCIdRRange
      (\ s a -> s{_ussrIPCIdRRange = a})

instance FromJSON UsableSubnetworkSecondaryRange
         where
        parseJSON
          = withObject "UsableSubnetworkSecondaryRange"
              (\ o ->
                 UsableSubnetworkSecondaryRange' <$>
                   (o .:? "rangeName") <*> (o .:? "ipCidrRange"))

instance ToJSON UsableSubnetworkSecondaryRange where
        toJSON UsableSubnetworkSecondaryRange'{..}
          = object
              (catMaybes
                 [("rangeName" .=) <$> _ussrRangeName,
                  ("ipCidrRange" .=) <$> _ussrIPCIdRRange])

--
-- /See:/ 'networkEndpointGroupsAttachEndpointsRequest' smart constructor.
newtype NetworkEndpointGroupsAttachEndpointsRequest =
  NetworkEndpointGroupsAttachEndpointsRequest'
    { _negaerNetworkEndpoints :: Maybe [NetworkEndpoint]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkEndpointGroupsAttachEndpointsRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'negaerNetworkEndpoints'
networkEndpointGroupsAttachEndpointsRequest
    :: NetworkEndpointGroupsAttachEndpointsRequest
networkEndpointGroupsAttachEndpointsRequest =
  NetworkEndpointGroupsAttachEndpointsRequest'
    {_negaerNetworkEndpoints = Nothing}


-- | The list of network endpoints to be attached.
negaerNetworkEndpoints :: Lens' NetworkEndpointGroupsAttachEndpointsRequest [NetworkEndpoint]
negaerNetworkEndpoints
  = lens _negaerNetworkEndpoints
      (\ s a -> s{_negaerNetworkEndpoints = a})
      . _Default
      . _Coerce

instance FromJSON
           NetworkEndpointGroupsAttachEndpointsRequest
         where
        parseJSON
          = withObject
              "NetworkEndpointGroupsAttachEndpointsRequest"
              (\ o ->
                 NetworkEndpointGroupsAttachEndpointsRequest' <$>
                   (o .:? "networkEndpoints" .!= mempty))

instance ToJSON
           NetworkEndpointGroupsAttachEndpointsRequest
         where
        toJSON
          NetworkEndpointGroupsAttachEndpointsRequest'{..}
          = object
              (catMaybes
                 [("networkEndpoints" .=) <$>
                    _negaerNetworkEndpoints])

--
-- /See:/ 'addressesScopedListWarningDataItem' smart constructor.
data AddressesScopedListWarningDataItem =
  AddressesScopedListWarningDataItem'
    { _aslwdiValue :: !(Maybe Text)
    , _aslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AddressesScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'aslwdiValue'
--
-- * 'aslwdiKey'
addressesScopedListWarningDataItem
    :: AddressesScopedListWarningDataItem
addressesScopedListWarningDataItem =
  AddressesScopedListWarningDataItem'
    {_aslwdiValue = Nothing, _aslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
aslwdiValue :: Lens' AddressesScopedListWarningDataItem (Maybe Text)
aslwdiValue
  = lens _aslwdiValue (\ s a -> s{_aslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
aslwdiKey :: Lens' AddressesScopedListWarningDataItem (Maybe Text)
aslwdiKey
  = lens _aslwdiKey (\ s a -> s{_aslwdiKey = a})

instance FromJSON AddressesScopedListWarningDataItem
         where
        parseJSON
          = withObject "AddressesScopedListWarningDataItem"
              (\ o ->
                 AddressesScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON AddressesScopedListWarningDataItem
         where
        toJSON AddressesScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _aslwdiValue,
                  ("key" .=) <$> _aslwdiKey])

--
-- /See:/ 'instanceGroupListWarningDataItem' smart constructor.
data InstanceGroupListWarningDataItem =
  InstanceGroupListWarningDataItem'
    { _iglwdiValue :: !(Maybe Text)
    , _iglwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iglwdiValue'
--
-- * 'iglwdiKey'
instanceGroupListWarningDataItem
    :: InstanceGroupListWarningDataItem
instanceGroupListWarningDataItem =
  InstanceGroupListWarningDataItem'
    {_iglwdiValue = Nothing, _iglwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
iglwdiValue :: Lens' InstanceGroupListWarningDataItem (Maybe Text)
iglwdiValue
  = lens _iglwdiValue (\ s a -> s{_iglwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
iglwdiKey :: Lens' InstanceGroupListWarningDataItem (Maybe Text)
iglwdiKey
  = lens _iglwdiKey (\ s a -> s{_iglwdiKey = a})

instance FromJSON InstanceGroupListWarningDataItem
         where
        parseJSON
          = withObject "InstanceGroupListWarningDataItem"
              (\ o ->
                 InstanceGroupListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON InstanceGroupListWarningDataItem
         where
        toJSON InstanceGroupListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _iglwdiValue,
                  ("key" .=) <$> _iglwdiKey])

-- | A network interface resource attached to an instance.
--
-- /See:/ 'networkInterface' smart constructor.
data NetworkInterface =
  NetworkInterface'
    { _niIPv6AccessConfigs :: !(Maybe [AccessConfig])
    , _niIPv6Address :: !(Maybe Text)
    , _niKind :: !Text
    , _niFingerprint :: !(Maybe Bytes)
    , _niAliasIPRanges :: !(Maybe [AliasIPRange])
    , _niNetwork :: !(Maybe Text)
    , _niStackType :: !(Maybe NetworkInterfaceStackType)
    , _niNicType :: !(Maybe NetworkInterfaceNicType)
    , _niName :: !(Maybe Text)
    , _niNetworkIP :: !(Maybe Text)
    , _niSubnetwork :: !(Maybe Text)
    , _niIPv6AccessType :: !(Maybe NetworkInterfaceIPv6AccessType)
    , _niAccessConfigs :: !(Maybe [AccessConfig])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkInterface' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'niIPv6AccessConfigs'
--
-- * 'niIPv6Address'
--
-- * 'niKind'
--
-- * 'niFingerprint'
--
-- * 'niAliasIPRanges'
--
-- * 'niNetwork'
--
-- * 'niStackType'
--
-- * 'niNicType'
--
-- * 'niName'
--
-- * 'niNetworkIP'
--
-- * 'niSubnetwork'
--
-- * 'niIPv6AccessType'
--
-- * 'niAccessConfigs'
networkInterface
    :: NetworkInterface
networkInterface =
  NetworkInterface'
    { _niIPv6AccessConfigs = Nothing
    , _niIPv6Address = Nothing
    , _niKind = "compute#networkInterface"
    , _niFingerprint = Nothing
    , _niAliasIPRanges = Nothing
    , _niNetwork = Nothing
    , _niStackType = Nothing
    , _niNicType = Nothing
    , _niName = Nothing
    , _niNetworkIP = Nothing
    , _niSubnetwork = Nothing
    , _niIPv6AccessType = Nothing
    , _niAccessConfigs = Nothing
    }


-- | An array of IPv6 access configurations for this interface. Currently,
-- only one IPv6 access config, DIRECT_IPV6, is supported. If there is no
-- ipv6AccessConfig specified, then this instance will have no external
-- IPv6 Internet access.
niIPv6AccessConfigs :: Lens' NetworkInterface [AccessConfig]
niIPv6AccessConfigs
  = lens _niIPv6AccessConfigs
      (\ s a -> s{_niIPv6AccessConfigs = a})
      . _Default
      . _Coerce

-- | [Output Only] An IPv6 internal network address for this network
-- interface.
niIPv6Address :: Lens' NetworkInterface (Maybe Text)
niIPv6Address
  = lens _niIPv6Address
      (\ s a -> s{_niIPv6Address = a})

-- | [Output Only] Type of the resource. Always compute#networkInterface for
-- network interfaces.
niKind :: Lens' NetworkInterface Text
niKind = lens _niKind (\ s a -> s{_niKind = a})

-- | Fingerprint hash of contents stored in this network interface. This
-- field will be ignored when inserting an Instance or adding a
-- NetworkInterface. An up-to-date fingerprint must be provided in order to
-- update the NetworkInterface. The request will fail with error 400 Bad
-- Request if the fingerprint is not provided, or 412 Precondition Failed
-- if the fingerprint is out of date.
niFingerprint :: Lens' NetworkInterface (Maybe ByteString)
niFingerprint
  = lens _niFingerprint
      (\ s a -> s{_niFingerprint = a})
      . mapping _Bytes

-- | An array of alias IP ranges for this network interface. You can only
-- specify this field for network interfaces in VPC networks.
niAliasIPRanges :: Lens' NetworkInterface [AliasIPRange]
niAliasIPRanges
  = lens _niAliasIPRanges
      (\ s a -> s{_niAliasIPRanges = a})
      . _Default
      . _Coerce

-- | URL of the network resource for this instance. When creating an
-- instance, if neither the network nor the subnetwork is specified, the
-- default network global\/networks\/default is used; if the network is not
-- specified but the subnetwork is specified, the network is inferred. If
-- you specify this property, you can specify the network as a full or
-- partial URL. For example, the following are all valid URLs: -
-- https:\/\/www.googleapis.com\/compute\/v1\/projects\/project\/global\/networks\/network
-- - projects\/project\/global\/networks\/network -
-- global\/networks\/default
niNetwork :: Lens' NetworkInterface (Maybe Text)
niNetwork
  = lens _niNetwork (\ s a -> s{_niNetwork = a})

-- | The stack type for this network interface to identify whether the IPv6
-- feature is enabled or not. If not specified, IPV4_ONLY will be used.
-- This field can be both set at instance creation and update network
-- interface operations.
niStackType :: Lens' NetworkInterface (Maybe NetworkInterfaceStackType)
niStackType
  = lens _niStackType (\ s a -> s{_niStackType = a})

-- | The type of vNIC to be used on this interface. This may be gVNIC or
-- VirtioNet.
niNicType :: Lens' NetworkInterface (Maybe NetworkInterfaceNicType)
niNicType
  = lens _niNicType (\ s a -> s{_niNicType = a})

-- | [Output Only] The name of the network interface, which is generated by
-- the server. For network devices, these are eth0, eth1, etc.
niName :: Lens' NetworkInterface (Maybe Text)
niName = lens _niName (\ s a -> s{_niName = a})

-- | An IPv4 internal IP address to assign to the instance for this network
-- interface. If not specified by the user, an unused internal IP is
-- assigned by the system.
niNetworkIP :: Lens' NetworkInterface (Maybe Text)
niNetworkIP
  = lens _niNetworkIP (\ s a -> s{_niNetworkIP = a})

-- | The URL of the Subnetwork resource for this instance. If the network
-- resource is in legacy mode, do not specify this field. If the network is
-- in auto subnet mode, specifying the subnetwork is optional. If the
-- network is in custom subnet mode, specifying the subnetwork is required.
-- If you specify this field, you can specify the subnetwork as a full or
-- partial URL. For example, the following are all valid URLs: -
-- https:\/\/www.googleapis.com\/compute\/v1\/projects\/project\/regions\/region\/subnetworks\/subnetwork
-- - regions\/region\/subnetworks\/subnetwork
niSubnetwork :: Lens' NetworkInterface (Maybe Text)
niSubnetwork
  = lens _niSubnetwork (\ s a -> s{_niSubnetwork = a})

-- | [Output Only] One of EXTERNAL, INTERNAL to indicate whether the IP can
-- be accessed from the Internet. This field is always inherited from its
-- subnetwork. Valid only if stackType is IPV4_IPV6.
niIPv6AccessType :: Lens' NetworkInterface (Maybe NetworkInterfaceIPv6AccessType)
niIPv6AccessType
  = lens _niIPv6AccessType
      (\ s a -> s{_niIPv6AccessType = a})

-- | An array of configurations for this interface. Currently, only one
-- access config, ONE_TO_ONE_NAT, is supported. If there are no
-- accessConfigs specified, then this instance will have no external
-- internet access.
niAccessConfigs :: Lens' NetworkInterface [AccessConfig]
niAccessConfigs
  = lens _niAccessConfigs
      (\ s a -> s{_niAccessConfigs = a})
      . _Default
      . _Coerce

instance FromJSON NetworkInterface where
        parseJSON
          = withObject "NetworkInterface"
              (\ o ->
                 NetworkInterface' <$>
                   (o .:? "ipv6AccessConfigs" .!= mempty) <*>
                     (o .:? "ipv6Address")
                     <*> (o .:? "kind" .!= "compute#networkInterface")
                     <*> (o .:? "fingerprint")
                     <*> (o .:? "aliasIpRanges" .!= mempty)
                     <*> (o .:? "network")
                     <*> (o .:? "stackType")
                     <*> (o .:? "nicType")
                     <*> (o .:? "name")
                     <*> (o .:? "networkIP")
                     <*> (o .:? "subnetwork")
                     <*> (o .:? "ipv6AccessType")
                     <*> (o .:? "accessConfigs" .!= mempty))

instance ToJSON NetworkInterface where
        toJSON NetworkInterface'{..}
          = object
              (catMaybes
                 [("ipv6AccessConfigs" .=) <$> _niIPv6AccessConfigs,
                  ("ipv6Address" .=) <$> _niIPv6Address,
                  Just ("kind" .= _niKind),
                  ("fingerprint" .=) <$> _niFingerprint,
                  ("aliasIpRanges" .=) <$> _niAliasIPRanges,
                  ("network" .=) <$> _niNetwork,
                  ("stackType" .=) <$> _niStackType,
                  ("nicType" .=) <$> _niNicType,
                  ("name" .=) <$> _niName,
                  ("networkIP" .=) <$> _niNetworkIP,
                  ("subnetwork" .=) <$> _niSubnetwork,
                  ("ipv6AccessType" .=) <$> _niIPv6AccessType,
                  ("accessConfigs" .=) <$> _niAccessConfigs])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'targetHTTPSProxyAggregatedListWarning' smart constructor.
data TargetHTTPSProxyAggregatedListWarning =
  TargetHTTPSProxyAggregatedListWarning'
    { _thpalwData :: !(Maybe [TargetHTTPSProxyAggregatedListWarningDataItem])
    , _thpalwCode :: !(Maybe TargetHTTPSProxyAggregatedListWarningCode)
    , _thpalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetHTTPSProxyAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'thpalwData'
--
-- * 'thpalwCode'
--
-- * 'thpalwMessage'
targetHTTPSProxyAggregatedListWarning
    :: TargetHTTPSProxyAggregatedListWarning
targetHTTPSProxyAggregatedListWarning =
  TargetHTTPSProxyAggregatedListWarning'
    {_thpalwData = Nothing, _thpalwCode = Nothing, _thpalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
thpalwData :: Lens' TargetHTTPSProxyAggregatedListWarning [TargetHTTPSProxyAggregatedListWarningDataItem]
thpalwData
  = lens _thpalwData (\ s a -> s{_thpalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
thpalwCode :: Lens' TargetHTTPSProxyAggregatedListWarning (Maybe TargetHTTPSProxyAggregatedListWarningCode)
thpalwCode
  = lens _thpalwCode (\ s a -> s{_thpalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
thpalwMessage :: Lens' TargetHTTPSProxyAggregatedListWarning (Maybe Text)
thpalwMessage
  = lens _thpalwMessage
      (\ s a -> s{_thpalwMessage = a})

instance FromJSON
           TargetHTTPSProxyAggregatedListWarning
         where
        parseJSON
          = withObject "TargetHTTPSProxyAggregatedListWarning"
              (\ o ->
                 TargetHTTPSProxyAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON TargetHTTPSProxyAggregatedListWarning
         where
        toJSON TargetHTTPSProxyAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _thpalwData,
                  ("code" .=) <$> _thpalwCode,
                  ("message" .=) <$> _thpalwMessage])

-- | Initial State for shielded instance, these are public keys which are
-- safe to store in public
--
-- /See:/ 'initialStateConfig' smart constructor.
data InitialStateConfig =
  InitialStateConfig'
    { _iscDBxs :: !(Maybe [FileContentBuffer])
    , _iscPk :: !(Maybe FileContentBuffer)
    , _iscDBs :: !(Maybe [FileContentBuffer])
    , _iscKeks :: !(Maybe [FileContentBuffer])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InitialStateConfig' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iscDBxs'
--
-- * 'iscPk'
--
-- * 'iscDBs'
--
-- * 'iscKeks'
initialStateConfig
    :: InitialStateConfig
initialStateConfig =
  InitialStateConfig'
    { _iscDBxs = Nothing
    , _iscPk = Nothing
    , _iscDBs = Nothing
    , _iscKeks = Nothing
    }


-- | The forbidden key database (dbx).
iscDBxs :: Lens' InitialStateConfig [FileContentBuffer]
iscDBxs
  = lens _iscDBxs (\ s a -> s{_iscDBxs = a}) . _Default
      . _Coerce

-- | The Platform Key (PK).
iscPk :: Lens' InitialStateConfig (Maybe FileContentBuffer)
iscPk = lens _iscPk (\ s a -> s{_iscPk = a})

-- | The Key Database (db).
iscDBs :: Lens' InitialStateConfig [FileContentBuffer]
iscDBs
  = lens _iscDBs (\ s a -> s{_iscDBs = a}) . _Default .
      _Coerce

-- | The Key Exchange Key (KEK).
iscKeks :: Lens' InitialStateConfig [FileContentBuffer]
iscKeks
  = lens _iscKeks (\ s a -> s{_iscKeks = a}) . _Default
      . _Coerce

instance FromJSON InitialStateConfig where
        parseJSON
          = withObject "InitialStateConfig"
              (\ o ->
                 InitialStateConfig' <$>
                   (o .:? "dbxs" .!= mempty) <*> (o .:? "pk") <*>
                     (o .:? "dbs" .!= mempty)
                     <*> (o .:? "keks" .!= mempty))

instance ToJSON InitialStateConfig where
        toJSON InitialStateConfig'{..}
          = object
              (catMaybes
                 [("dbxs" .=) <$> _iscDBxs, ("pk" .=) <$> _iscPk,
                  ("dbs" .=) <$> _iscDBs, ("keks" .=) <$> _iscKeks])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'routerListWarning' smart constructor.
data RouterListWarning =
  RouterListWarning'
    { _rouData :: !(Maybe [RouterListWarningDataItem])
    , _rouCode :: !(Maybe RouterListWarningCode)
    , _rouMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RouterListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rouData'
--
-- * 'rouCode'
--
-- * 'rouMessage'
routerListWarning
    :: RouterListWarning
routerListWarning =
  RouterListWarning'
    {_rouData = Nothing, _rouCode = Nothing, _rouMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
rouData :: Lens' RouterListWarning [RouterListWarningDataItem]
rouData
  = lens _rouData (\ s a -> s{_rouData = a}) . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
rouCode :: Lens' RouterListWarning (Maybe RouterListWarningCode)
rouCode = lens _rouCode (\ s a -> s{_rouCode = a})

-- | [Output Only] A human-readable description of the warning code.
rouMessage :: Lens' RouterListWarning (Maybe Text)
rouMessage
  = lens _rouMessage (\ s a -> s{_rouMessage = a})

instance FromJSON RouterListWarning where
        parseJSON
          = withObject "RouterListWarning"
              (\ o ->
                 RouterListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON RouterListWarning where
        toJSON RouterListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _rouData, ("code" .=) <$> _rouCode,
                  ("message" .=) <$> _rouMessage])

--
-- /See:/ 'firewallListWarningDataItem' smart constructor.
data FirewallListWarningDataItem =
  FirewallListWarningDataItem'
    { _flwdiValue :: !(Maybe Text)
    , _flwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'FirewallListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'flwdiValue'
--
-- * 'flwdiKey'
firewallListWarningDataItem
    :: FirewallListWarningDataItem
firewallListWarningDataItem =
  FirewallListWarningDataItem' {_flwdiValue = Nothing, _flwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
flwdiValue :: Lens' FirewallListWarningDataItem (Maybe Text)
flwdiValue
  = lens _flwdiValue (\ s a -> s{_flwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
flwdiKey :: Lens' FirewallListWarningDataItem (Maybe Text)
flwdiKey = lens _flwdiKey (\ s a -> s{_flwdiKey = a})

instance FromJSON FirewallListWarningDataItem where
        parseJSON
          = withObject "FirewallListWarningDataItem"
              (\ o ->
                 FirewallListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON FirewallListWarningDataItem where
        toJSON FirewallListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _flwdiValue,
                  ("key" .=) <$> _flwdiKey])

-- | A list of ResourcePolicy resources.
--
-- /See:/ 'resourcePolicyAggregatedListItems' smart constructor.
newtype ResourcePolicyAggregatedListItems =
  ResourcePolicyAggregatedListItems'
    { _rpaliAddtional :: HashMap Text ResourcePoliciesScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePolicyAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rpaliAddtional'
resourcePolicyAggregatedListItems
    :: HashMap Text ResourcePoliciesScopedList -- ^ 'rpaliAddtional'
    -> ResourcePolicyAggregatedListItems
resourcePolicyAggregatedListItems pRpaliAddtional_ =
  ResourcePolicyAggregatedListItems'
    {_rpaliAddtional = _Coerce # pRpaliAddtional_}


-- | Name of the scope containing this set of resourcePolicies.
rpaliAddtional :: Lens' ResourcePolicyAggregatedListItems (HashMap Text ResourcePoliciesScopedList)
rpaliAddtional
  = lens _rpaliAddtional
      (\ s a -> s{_rpaliAddtional = a})
      . _Coerce

instance FromJSON ResourcePolicyAggregatedListItems
         where
        parseJSON
          = withObject "ResourcePolicyAggregatedListItems"
              (\ o ->
                 ResourcePolicyAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON ResourcePolicyAggregatedListItems
         where
        toJSON = toJSON . _rpaliAddtional

--
-- /See:/ 'targetPoolsRemoveHealthCheckRequest' smart constructor.
newtype TargetPoolsRemoveHealthCheckRequest =
  TargetPoolsRemoveHealthCheckRequest'
    { _tprhcrHealthChecks :: Maybe [HealthCheckReference]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetPoolsRemoveHealthCheckRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tprhcrHealthChecks'
targetPoolsRemoveHealthCheckRequest
    :: TargetPoolsRemoveHealthCheckRequest
targetPoolsRemoveHealthCheckRequest =
  TargetPoolsRemoveHealthCheckRequest' {_tprhcrHealthChecks = Nothing}


-- | Health check URL to be removed. This can be a full or valid partial URL.
-- For example, the following are valid URLs: -
-- https:\/\/www.googleapis.com\/compute\/beta\/projects\/project\/global\/httpHealthChecks\/health-check
-- - projects\/project\/global\/httpHealthChecks\/health-check -
-- global\/httpHealthChecks\/health-check
tprhcrHealthChecks :: Lens' TargetPoolsRemoveHealthCheckRequest [HealthCheckReference]
tprhcrHealthChecks
  = lens _tprhcrHealthChecks
      (\ s a -> s{_tprhcrHealthChecks = a})
      . _Default
      . _Coerce

instance FromJSON TargetPoolsRemoveHealthCheckRequest
         where
        parseJSON
          = withObject "TargetPoolsRemoveHealthCheckRequest"
              (\ o ->
                 TargetPoolsRemoveHealthCheckRequest' <$>
                   (o .:? "healthChecks" .!= mempty))

instance ToJSON TargetPoolsRemoveHealthCheckRequest
         where
        toJSON TargetPoolsRemoveHealthCheckRequest'{..}
          = object
              (catMaybes
                 [("healthChecks" .=) <$> _tprhcrHealthChecks])

--
-- /See:/ 'regionInstanceGroupManagersSetTargetPoolsRequest' smart constructor.
data RegionInstanceGroupManagersSetTargetPoolsRequest =
  RegionInstanceGroupManagersSetTargetPoolsRequest'
    { _rigmstprFingerprint :: !(Maybe Bytes)
    , _rigmstprTargetPools :: !(Maybe [Text])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupManagersSetTargetPoolsRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rigmstprFingerprint'
--
-- * 'rigmstprTargetPools'
regionInstanceGroupManagersSetTargetPoolsRequest
    :: RegionInstanceGroupManagersSetTargetPoolsRequest
regionInstanceGroupManagersSetTargetPoolsRequest =
  RegionInstanceGroupManagersSetTargetPoolsRequest'
    {_rigmstprFingerprint = Nothing, _rigmstprTargetPools = Nothing}


-- | Fingerprint of the target pools information, which is a hash of the
-- contents. This field is used for optimistic locking when you update the
-- target pool entries. This field is optional.
rigmstprFingerprint :: Lens' RegionInstanceGroupManagersSetTargetPoolsRequest (Maybe ByteString)
rigmstprFingerprint
  = lens _rigmstprFingerprint
      (\ s a -> s{_rigmstprFingerprint = a})
      . mapping _Bytes

-- | The URL of all TargetPool resources to which instances in the
-- instanceGroup field are added. The target pools automatically apply to
-- all of the instances in the managed instance group.
rigmstprTargetPools :: Lens' RegionInstanceGroupManagersSetTargetPoolsRequest [Text]
rigmstprTargetPools
  = lens _rigmstprTargetPools
      (\ s a -> s{_rigmstprTargetPools = a})
      . _Default
      . _Coerce

instance FromJSON
           RegionInstanceGroupManagersSetTargetPoolsRequest
         where
        parseJSON
          = withObject
              "RegionInstanceGroupManagersSetTargetPoolsRequest"
              (\ o ->
                 RegionInstanceGroupManagersSetTargetPoolsRequest' <$>
                   (o .:? "fingerprint") <*>
                     (o .:? "targetPools" .!= mempty))

instance ToJSON
           RegionInstanceGroupManagersSetTargetPoolsRequest
         where
        toJSON
          RegionInstanceGroupManagersSetTargetPoolsRequest'{..}
          = object
              (catMaybes
                 [("fingerprint" .=) <$> _rigmstprFingerprint,
                  ("targetPools" .=) <$> _rigmstprTargetPools])

-- | Message containing Cloud CDN configuration for a backend bucket.
--
-- /See:/ 'backendBucketCdnPolicy' smart constructor.
data BackendBucketCdnPolicy =
  BackendBucketCdnPolicy'
    { _bbcpServeWhileStale :: !(Maybe (Textual Int32))
    , _bbcpSignedURLCacheMaxAgeSec :: !(Maybe (Textual Int64))
    , _bbcpNegativeCachingPolicy :: !(Maybe [BackendBucketCdnPolicyNegativeCachingPolicy])
    , _bbcpBypassCacheOnRequestHeaders :: !(Maybe [BackendBucketCdnPolicyBypassCacheOnRequestHeader])
    , _bbcpRequestCoalescing :: !(Maybe Bool)
    , _bbcpClientTtl :: !(Maybe (Textual Int32))
    , _bbcpMaxTtl :: !(Maybe (Textual Int32))
    , _bbcpCacheMode :: !(Maybe BackendBucketCdnPolicyCacheMode)
    , _bbcpDefaultTtl :: !(Maybe (Textual Int32))
    , _bbcpNegativeCaching :: !(Maybe Bool)
    , _bbcpSignedURLKeyNames :: !(Maybe [Text])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendBucketCdnPolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bbcpServeWhileStale'
--
-- * 'bbcpSignedURLCacheMaxAgeSec'
--
-- * 'bbcpNegativeCachingPolicy'
--
-- * 'bbcpBypassCacheOnRequestHeaders'
--
-- * 'bbcpRequestCoalescing'
--
-- * 'bbcpClientTtl'
--
-- * 'bbcpMaxTtl'
--
-- * 'bbcpCacheMode'
--
-- * 'bbcpDefaultTtl'
--
-- * 'bbcpNegativeCaching'
--
-- * 'bbcpSignedURLKeyNames'
backendBucketCdnPolicy
    :: BackendBucketCdnPolicy
backendBucketCdnPolicy =
  BackendBucketCdnPolicy'
    { _bbcpServeWhileStale = Nothing
    , _bbcpSignedURLCacheMaxAgeSec = Nothing
    , _bbcpNegativeCachingPolicy = Nothing
    , _bbcpBypassCacheOnRequestHeaders = Nothing
    , _bbcpRequestCoalescing = Nothing
    , _bbcpClientTtl = Nothing
    , _bbcpMaxTtl = Nothing
    , _bbcpCacheMode = Nothing
    , _bbcpDefaultTtl = Nothing
    , _bbcpNegativeCaching = Nothing
    , _bbcpSignedURLKeyNames = Nothing
    }


-- | Serve existing content from the cache (if available) when revalidating
-- content with the origin, or when an error is encountered when refreshing
-- the cache. This setting defines the default \"max-stale\" duration for
-- any cached responses that do not specify a max-stale directive. Stale
-- responses that exceed the TTL configured here will not be served. The
-- default limit (max-stale) is 86400s (1 day), which will allow stale
-- content to be served up to this limit beyond the max-age (or s-max-age)
-- of a cached response. The maximum allowed value is 604800 (1 week). Set
-- this to zero (0) to disable serve-while-stale.
bbcpServeWhileStale :: Lens' BackendBucketCdnPolicy (Maybe Int32)
bbcpServeWhileStale
  = lens _bbcpServeWhileStale
      (\ s a -> s{_bbcpServeWhileStale = a})
      . mapping _Coerce

-- | Maximum number of seconds the response to a signed URL request will be
-- considered fresh. After this time period, the response will be
-- revalidated before being served. Defaults to 1hr (3600s). When serving
-- responses to signed URL requests, Cloud CDN will internally behave as
-- though all responses from this backend had a \"Cache-Control: public,
-- max-age=[TTL]\" header, regardless of any existing Cache-Control header.
-- The actual headers served in responses will not be altered.
bbcpSignedURLCacheMaxAgeSec :: Lens' BackendBucketCdnPolicy (Maybe Int64)
bbcpSignedURLCacheMaxAgeSec
  = lens _bbcpSignedURLCacheMaxAgeSec
      (\ s a -> s{_bbcpSignedURLCacheMaxAgeSec = a})
      . mapping _Coerce

-- | Sets a cache TTL for the specified HTTP status code. negative_caching
-- must be enabled to configure negative_caching_policy. Omitting the
-- policy and leaving negative_caching enabled will use Cloud CDN\'s
-- default cache TTLs. Note that when specifying an explicit
-- negative_caching_policy, you should take care to specify a cache TTL for
-- all response codes that you wish to cache. Cloud CDN will not apply any
-- default negative caching when a policy exists.
bbcpNegativeCachingPolicy :: Lens' BackendBucketCdnPolicy [BackendBucketCdnPolicyNegativeCachingPolicy]
bbcpNegativeCachingPolicy
  = lens _bbcpNegativeCachingPolicy
      (\ s a -> s{_bbcpNegativeCachingPolicy = a})
      . _Default
      . _Coerce

-- | Bypass the cache when the specified request headers are matched - e.g.
-- Pragma or Authorization headers. Up to 5 headers can be specified. The
-- cache is bypassed for all cdnPolicy.cacheMode settings.
bbcpBypassCacheOnRequestHeaders :: Lens' BackendBucketCdnPolicy [BackendBucketCdnPolicyBypassCacheOnRequestHeader]
bbcpBypassCacheOnRequestHeaders
  = lens _bbcpBypassCacheOnRequestHeaders
      (\ s a -> s{_bbcpBypassCacheOnRequestHeaders = a})
      . _Default
      . _Coerce

-- | If true then Cloud CDN will combine multiple concurrent cache fill
-- requests into a small number of requests to the origin.
bbcpRequestCoalescing :: Lens' BackendBucketCdnPolicy (Maybe Bool)
bbcpRequestCoalescing
  = lens _bbcpRequestCoalescing
      (\ s a -> s{_bbcpRequestCoalescing = a})

-- | Specifies a separate client (e.g. browser client) maximum TTL. This is
-- used to clamp the max-age (or Expires) value sent to the client. With
-- FORCE_CACHE_ALL, the lesser of client_ttl and default_ttl is used for
-- the response max-age directive, along with a \"public\" directive. For
-- cacheable content in CACHE_ALL_STATIC mode, client_ttl clamps the
-- max-age from the origin (if specified), or else sets the response
-- max-age directive to the lesser of the client_ttl and default_ttl, and
-- also ensures a \"public\" cache-control directive is present. If a
-- client TTL is not specified, a default value (1 hour) will be used. The
-- maximum allowed value is 86400s (1 day).
bbcpClientTtl :: Lens' BackendBucketCdnPolicy (Maybe Int32)
bbcpClientTtl
  = lens _bbcpClientTtl
      (\ s a -> s{_bbcpClientTtl = a})
      . mapping _Coerce

-- | Specifies the maximum allowed TTL for cached content served by this
-- origin. Cache directives that attempt to set a max-age or s-maxage
-- higher than this, or an Expires header more than maxTTL seconds in the
-- future will be capped at the value of maxTTL, as if it were the value of
-- an s-maxage Cache-Control directive. Headers sent to the client will not
-- be modified. Setting a TTL of \"0\" means \"always revalidate\". The
-- maximum allowed value is 31,622,400s (1 year), noting that infrequently
-- accessed objects may be evicted from the cache before the defined TTL.
bbcpMaxTtl :: Lens' BackendBucketCdnPolicy (Maybe Int32)
bbcpMaxTtl
  = lens _bbcpMaxTtl (\ s a -> s{_bbcpMaxTtl = a}) .
      mapping _Coerce

-- | Specifies the cache setting for all responses from this backend. The
-- possible values are: USE_ORIGIN_HEADERS Requires the origin to set valid
-- caching headers to cache content. Responses without these headers will
-- not be cached at Google\'s edge, and will require a full trip to the
-- origin on every request, potentially impacting performance and
-- increasing load on the origin server. FORCE_CACHE_ALL Cache all content,
-- ignoring any \"private\", \"no-store\" or \"no-cache\" directives in
-- Cache-Control response headers. Warning: this may result in Cloud CDN
-- caching private, per-user (user identifiable) content. CACHE_ALL_STATIC
-- Automatically cache static content, including common image formats,
-- media (video and audio), and web assets (JavaScript and CSS). Requests
-- and responses that are marked as uncacheable, as well as dynamic content
-- (including HTML), will not be cached.
bbcpCacheMode :: Lens' BackendBucketCdnPolicy (Maybe BackendBucketCdnPolicyCacheMode)
bbcpCacheMode
  = lens _bbcpCacheMode
      (\ s a -> s{_bbcpCacheMode = a})

-- | Specifies the default TTL for cached content served by this origin for
-- responses that do not have an existing valid TTL (max-age or s-max-age).
-- Setting a TTL of \"0\" means \"always revalidate\". The value of
-- defaultTTL cannot be set to a value greater than that of maxTTL, but can
-- be equal. When the cacheMode is set to FORCE_CACHE_ALL, the defaultTTL
-- will overwrite the TTL set in all responses. The maximum allowed value
-- is 31,622,400s (1 year), noting that infrequently accessed objects may
-- be evicted from the cache before the defined TTL.
bbcpDefaultTtl :: Lens' BackendBucketCdnPolicy (Maybe Int32)
bbcpDefaultTtl
  = lens _bbcpDefaultTtl
      (\ s a -> s{_bbcpDefaultTtl = a})
      . mapping _Coerce

-- | Negative caching allows per-status code TTLs to be set, in order to
-- apply fine-grained caching for common errors or redirects. This can
-- reduce the load on your origin and improve end-user experience by
-- reducing response latency. When the cache mode is set to
-- CACHE_ALL_STATIC or USE_ORIGIN_HEADERS, negative caching applies to
-- responses with the specified response code that lack any Cache-Control,
-- Expires, or Pragma: no-cache directives. When the cache mode is set to
-- FORCE_CACHE_ALL, negative caching applies to all responses with the
-- specified response code, and override any caching headers. By default,
-- Cloud CDN will apply the following default TTLs to these status codes:
-- HTTP 300 (Multiple Choice), 301, 308 (Permanent Redirects): 10m HTTP 404
-- (Not Found), 410 (Gone), 451 (Unavailable For Legal Reasons): 120s HTTP
-- 405 (Method Not Found), 421 (Misdirected Request), 501 (Not
-- Implemented): 60s. These defaults can be overridden in
-- negative_caching_policy.
bbcpNegativeCaching :: Lens' BackendBucketCdnPolicy (Maybe Bool)
bbcpNegativeCaching
  = lens _bbcpNegativeCaching
      (\ s a -> s{_bbcpNegativeCaching = a})

-- | [Output Only] Names of the keys for signing request URLs.
bbcpSignedURLKeyNames :: Lens' BackendBucketCdnPolicy [Text]
bbcpSignedURLKeyNames
  = lens _bbcpSignedURLKeyNames
      (\ s a -> s{_bbcpSignedURLKeyNames = a})
      . _Default
      . _Coerce

instance FromJSON BackendBucketCdnPolicy where
        parseJSON
          = withObject "BackendBucketCdnPolicy"
              (\ o ->
                 BackendBucketCdnPolicy' <$>
                   (o .:? "serveWhileStale") <*>
                     (o .:? "signedUrlCacheMaxAgeSec")
                     <*> (o .:? "negativeCachingPolicy" .!= mempty)
                     <*> (o .:? "bypassCacheOnRequestHeaders" .!= mempty)
                     <*> (o .:? "requestCoalescing")
                     <*> (o .:? "clientTtl")
                     <*> (o .:? "maxTtl")
                     <*> (o .:? "cacheMode")
                     <*> (o .:? "defaultTtl")
                     <*> (o .:? "negativeCaching")
                     <*> (o .:? "signedUrlKeyNames" .!= mempty))

instance ToJSON BackendBucketCdnPolicy where
        toJSON BackendBucketCdnPolicy'{..}
          = object
              (catMaybes
                 [("serveWhileStale" .=) <$> _bbcpServeWhileStale,
                  ("signedUrlCacheMaxAgeSec" .=) <$>
                    _bbcpSignedURLCacheMaxAgeSec,
                  ("negativeCachingPolicy" .=) <$>
                    _bbcpNegativeCachingPolicy,
                  ("bypassCacheOnRequestHeaders" .=) <$>
                    _bbcpBypassCacheOnRequestHeaders,
                  ("requestCoalescing" .=) <$> _bbcpRequestCoalescing,
                  ("clientTtl" .=) <$> _bbcpClientTtl,
                  ("maxTtl" .=) <$> _bbcpMaxTtl,
                  ("cacheMode" .=) <$> _bbcpCacheMode,
                  ("defaultTtl" .=) <$> _bbcpDefaultTtl,
                  ("negativeCaching" .=) <$> _bbcpNegativeCaching,
                  ("signedUrlKeyNames" .=) <$> _bbcpSignedURLKeyNames])

-- | Time window specified for daily operations.
--
-- /See:/ 'resourcePolicyDailyCycle' smart constructor.
data ResourcePolicyDailyCycle =
  ResourcePolicyDailyCycle'
    { _rpdcStartTime :: !(Maybe Text)
    , _rpdcDaysInCycle :: !(Maybe (Textual Int32))
    , _rpdcDuration :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePolicyDailyCycle' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rpdcStartTime'
--
-- * 'rpdcDaysInCycle'
--
-- * 'rpdcDuration'
resourcePolicyDailyCycle
    :: ResourcePolicyDailyCycle
resourcePolicyDailyCycle =
  ResourcePolicyDailyCycle'
    { _rpdcStartTime = Nothing
    , _rpdcDaysInCycle = Nothing
    , _rpdcDuration = Nothing
    }


-- | Start time of the window. This must be in UTC format that resolves to
-- one of 00:00, 04:00, 08:00, 12:00, 16:00, or 20:00. For example, both
-- 13:00-5 and 08:00 are valid.
rpdcStartTime :: Lens' ResourcePolicyDailyCycle (Maybe Text)
rpdcStartTime
  = lens _rpdcStartTime
      (\ s a -> s{_rpdcStartTime = a})

-- | Defines a schedule with units measured in months. The value determines
-- how many months pass between the start of each cycle.
rpdcDaysInCycle :: Lens' ResourcePolicyDailyCycle (Maybe Int32)
rpdcDaysInCycle
  = lens _rpdcDaysInCycle
      (\ s a -> s{_rpdcDaysInCycle = a})
      . mapping _Coerce

-- | [Output only] A predetermined duration for the window, automatically
-- chosen to be the smallest possible in the given scenario.
rpdcDuration :: Lens' ResourcePolicyDailyCycle (Maybe Text)
rpdcDuration
  = lens _rpdcDuration (\ s a -> s{_rpdcDuration = a})

instance FromJSON ResourcePolicyDailyCycle where
        parseJSON
          = withObject "ResourcePolicyDailyCycle"
              (\ o ->
                 ResourcePolicyDailyCycle' <$>
                   (o .:? "startTime") <*> (o .:? "daysInCycle") <*>
                     (o .:? "duration"))

instance ToJSON ResourcePolicyDailyCycle where
        toJSON ResourcePolicyDailyCycle'{..}
          = object
              (catMaybes
                 [("startTime" .=) <$> _rpdcStartTime,
                  ("daysInCycle" .=) <$> _rpdcDaysInCycle,
                  ("duration" .=) <$> _rpdcDuration])

-- | Contains a list of TargetSslProxy resources.
--
-- /See:/ 'targetSSLProxyList' smart constructor.
data TargetSSLProxyList =
  TargetSSLProxyList'
    { _tsplNextPageToken :: !(Maybe Text)
    , _tsplKind :: !Text
    , _tsplItems :: !(Maybe [TargetSSLProxy])
    , _tsplSelfLink :: !(Maybe Text)
    , _tsplWarning :: !(Maybe TargetSSLProxyListWarning)
    , _tsplId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetSSLProxyList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tsplNextPageToken'
--
-- * 'tsplKind'
--
-- * 'tsplItems'
--
-- * 'tsplSelfLink'
--
-- * 'tsplWarning'
--
-- * 'tsplId'
targetSSLProxyList
    :: TargetSSLProxyList
targetSSLProxyList =
  TargetSSLProxyList'
    { _tsplNextPageToken = Nothing
    , _tsplKind = "compute#targetSslProxyList"
    , _tsplItems = Nothing
    , _tsplSelfLink = Nothing
    , _tsplWarning = Nothing
    , _tsplId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
tsplNextPageToken :: Lens' TargetSSLProxyList (Maybe Text)
tsplNextPageToken
  = lens _tsplNextPageToken
      (\ s a -> s{_tsplNextPageToken = a})

-- | Type of resource.
tsplKind :: Lens' TargetSSLProxyList Text
tsplKind = lens _tsplKind (\ s a -> s{_tsplKind = a})

-- | A list of TargetSslProxy resources.
tsplItems :: Lens' TargetSSLProxyList [TargetSSLProxy]
tsplItems
  = lens _tsplItems (\ s a -> s{_tsplItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
tsplSelfLink :: Lens' TargetSSLProxyList (Maybe Text)
tsplSelfLink
  = lens _tsplSelfLink (\ s a -> s{_tsplSelfLink = a})

-- | [Output Only] Informational warning message.
tsplWarning :: Lens' TargetSSLProxyList (Maybe TargetSSLProxyListWarning)
tsplWarning
  = lens _tsplWarning (\ s a -> s{_tsplWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
tsplId :: Lens' TargetSSLProxyList (Maybe Text)
tsplId = lens _tsplId (\ s a -> s{_tsplId = a})

instance FromJSON TargetSSLProxyList where
        parseJSON
          = withObject "TargetSSLProxyList"
              (\ o ->
                 TargetSSLProxyList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#targetSslProxyList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON TargetSSLProxyList where
        toJSON TargetSSLProxyList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _tsplNextPageToken,
                  Just ("kind" .= _tsplKind),
                  ("items" .=) <$> _tsplItems,
                  ("selfLink" .=) <$> _tsplSelfLink,
                  ("warning" .=) <$> _tsplWarning,
                  ("id" .=) <$> _tsplId])

--
-- /See:/ 'customerEncryptionKeyProtectedDisk' smart constructor.
data CustomerEncryptionKeyProtectedDisk =
  CustomerEncryptionKeyProtectedDisk'
    { _cekpdDiskEncryptionKey :: !(Maybe CustomerEncryptionKey)
    , _cekpdSource :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'CustomerEncryptionKeyProtectedDisk' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'cekpdDiskEncryptionKey'
--
-- * 'cekpdSource'
customerEncryptionKeyProtectedDisk
    :: CustomerEncryptionKeyProtectedDisk
customerEncryptionKeyProtectedDisk =
  CustomerEncryptionKeyProtectedDisk'
    {_cekpdDiskEncryptionKey = Nothing, _cekpdSource = Nothing}


-- | Decrypts data associated with the disk with a customer-supplied
-- encryption key.
cekpdDiskEncryptionKey :: Lens' CustomerEncryptionKeyProtectedDisk (Maybe CustomerEncryptionKey)
cekpdDiskEncryptionKey
  = lens _cekpdDiskEncryptionKey
      (\ s a -> s{_cekpdDiskEncryptionKey = a})

-- | Specifies a valid partial or full URL to an existing Persistent Disk
-- resource. This field is only applicable for persistent disks.
cekpdSource :: Lens' CustomerEncryptionKeyProtectedDisk (Maybe Text)
cekpdSource
  = lens _cekpdSource (\ s a -> s{_cekpdSource = a})

instance FromJSON CustomerEncryptionKeyProtectedDisk
         where
        parseJSON
          = withObject "CustomerEncryptionKeyProtectedDisk"
              (\ o ->
                 CustomerEncryptionKeyProtectedDisk' <$>
                   (o .:? "diskEncryptionKey") <*> (o .:? "source"))

instance ToJSON CustomerEncryptionKeyProtectedDisk
         where
        toJSON CustomerEncryptionKeyProtectedDisk'{..}
          = object
              (catMaybes
                 [("diskEncryptionKey" .=) <$>
                    _cekpdDiskEncryptionKey,
                  ("source" .=) <$> _cekpdSource])

--
-- /See:/ 'globalOrganizationSetPolicyRequest' smart constructor.
data GlobalOrganizationSetPolicyRequest =
  GlobalOrganizationSetPolicyRequest'
    { _gosprEtag :: !(Maybe Bytes)
    , _gosprBindings :: !(Maybe [Binding])
    , _gosprPolicy :: !(Maybe Policy)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'GlobalOrganizationSetPolicyRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'gosprEtag'
--
-- * 'gosprBindings'
--
-- * 'gosprPolicy'
globalOrganizationSetPolicyRequest
    :: GlobalOrganizationSetPolicyRequest
globalOrganizationSetPolicyRequest =
  GlobalOrganizationSetPolicyRequest'
    {_gosprEtag = Nothing, _gosprBindings = Nothing, _gosprPolicy = Nothing}


-- | Flatten Policy to create a backward compatible wire-format. Deprecated.
-- Use \'policy\' to specify the etag.
gosprEtag :: Lens' GlobalOrganizationSetPolicyRequest (Maybe ByteString)
gosprEtag
  = lens _gosprEtag (\ s a -> s{_gosprEtag = a}) .
      mapping _Bytes

-- | Flatten Policy to create a backward compatible wire-format. Deprecated.
-- Use \'policy\' to specify bindings.
gosprBindings :: Lens' GlobalOrganizationSetPolicyRequest [Binding]
gosprBindings
  = lens _gosprBindings
      (\ s a -> s{_gosprBindings = a})
      . _Default
      . _Coerce

-- | REQUIRED: The complete policy to be applied to the \'resource\'. The
-- size of the policy is limited to a few 10s of KB. An empty policy is in
-- general a valid policy but certain services (like Projects) might reject
-- them.
gosprPolicy :: Lens' GlobalOrganizationSetPolicyRequest (Maybe Policy)
gosprPolicy
  = lens _gosprPolicy (\ s a -> s{_gosprPolicy = a})

instance FromJSON GlobalOrganizationSetPolicyRequest
         where
        parseJSON
          = withObject "GlobalOrganizationSetPolicyRequest"
              (\ o ->
                 GlobalOrganizationSetPolicyRequest' <$>
                   (o .:? "etag") <*> (o .:? "bindings" .!= mempty) <*>
                     (o .:? "policy"))

instance ToJSON GlobalOrganizationSetPolicyRequest
         where
        toJSON GlobalOrganizationSetPolicyRequest'{..}
          = object
              (catMaybes
                 [("etag" .=) <$> _gosprEtag,
                  ("bindings" .=) <$> _gosprBindings,
                  ("policy" .=) <$> _gosprPolicy])

-- | A list of instance templates.
--
-- /See:/ 'instanceTemplateList' smart constructor.
data InstanceTemplateList =
  InstanceTemplateList'
    { _itlNextPageToken :: !(Maybe Text)
    , _itlKind :: !Text
    , _itlItems :: !(Maybe [InstanceTemplate])
    , _itlSelfLink :: !(Maybe Text)
    , _itlWarning :: !(Maybe InstanceTemplateListWarning)
    , _itlId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceTemplateList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'itlNextPageToken'
--
-- * 'itlKind'
--
-- * 'itlItems'
--
-- * 'itlSelfLink'
--
-- * 'itlWarning'
--
-- * 'itlId'
instanceTemplateList
    :: InstanceTemplateList
instanceTemplateList =
  InstanceTemplateList'
    { _itlNextPageToken = Nothing
    , _itlKind = "compute#instanceTemplateList"
    , _itlItems = Nothing
    , _itlSelfLink = Nothing
    , _itlWarning = Nothing
    , _itlId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
itlNextPageToken :: Lens' InstanceTemplateList (Maybe Text)
itlNextPageToken
  = lens _itlNextPageToken
      (\ s a -> s{_itlNextPageToken = a})

-- | [Output Only] The resource type, which is always
-- compute#instanceTemplatesListResponse for instance template lists.
itlKind :: Lens' InstanceTemplateList Text
itlKind = lens _itlKind (\ s a -> s{_itlKind = a})

-- | A list of InstanceTemplate resources.
itlItems :: Lens' InstanceTemplateList [InstanceTemplate]
itlItems
  = lens _itlItems (\ s a -> s{_itlItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
itlSelfLink :: Lens' InstanceTemplateList (Maybe Text)
itlSelfLink
  = lens _itlSelfLink (\ s a -> s{_itlSelfLink = a})

-- | [Output Only] Informational warning message.
itlWarning :: Lens' InstanceTemplateList (Maybe InstanceTemplateListWarning)
itlWarning
  = lens _itlWarning (\ s a -> s{_itlWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
itlId :: Lens' InstanceTemplateList (Maybe Text)
itlId = lens _itlId (\ s a -> s{_itlId = a})

instance FromJSON InstanceTemplateList where
        parseJSON
          = withObject "InstanceTemplateList"
              (\ o ->
                 InstanceTemplateList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#instanceTemplateList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON InstanceTemplateList where
        toJSON InstanceTemplateList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _itlNextPageToken,
                  Just ("kind" .= _itlKind),
                  ("items" .=) <$> _itlItems,
                  ("selfLink" .=) <$> _itlSelfLink,
                  ("warning" .=) <$> _itlWarning,
                  ("id" .=) <$> _itlId])

-- | Represents a reference to a resource.
--
-- /See:/ 'reference' smart constructor.
data Reference =
  Reference'
    { _refKind :: !Text
    , _refReferrer :: !(Maybe Text)
    , _refReferenceType :: !(Maybe Text)
    , _refTarget :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Reference' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'refKind'
--
-- * 'refReferrer'
--
-- * 'refReferenceType'
--
-- * 'refTarget'
reference
    :: Reference
reference =
  Reference'
    { _refKind = "compute#reference"
    , _refReferrer = Nothing
    , _refReferenceType = Nothing
    , _refTarget = Nothing
    }


-- | [Output Only] Type of the resource. Always compute#reference for
-- references.
refKind :: Lens' Reference Text
refKind = lens _refKind (\ s a -> s{_refKind = a})

-- | URL of the resource which refers to the target.
refReferrer :: Lens' Reference (Maybe Text)
refReferrer
  = lens _refReferrer (\ s a -> s{_refReferrer = a})

-- | A description of the reference type with no implied semantics. Possible
-- values include: - MEMBER_OF
refReferenceType :: Lens' Reference (Maybe Text)
refReferenceType
  = lens _refReferenceType
      (\ s a -> s{_refReferenceType = a})

-- | URL of the resource to which this reference points.
refTarget :: Lens' Reference (Maybe Text)
refTarget
  = lens _refTarget (\ s a -> s{_refTarget = a})

instance FromJSON Reference where
        parseJSON
          = withObject "Reference"
              (\ o ->
                 Reference' <$>
                   (o .:? "kind" .!= "compute#reference") <*>
                     (o .:? "referrer")
                     <*> (o .:? "referenceType")
                     <*> (o .:? "target"))

instance ToJSON Reference where
        toJSON Reference'{..}
          = object
              (catMaybes
                 [Just ("kind" .= _refKind),
                  ("referrer" .=) <$> _refReferrer,
                  ("referenceType" .=) <$> _refReferenceType,
                  ("target" .=) <$> _refTarget])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'instanceGroupAggregatedListWarning' smart constructor.
data InstanceGroupAggregatedListWarning =
  InstanceGroupAggregatedListWarning'
    { _igalwData :: !(Maybe [InstanceGroupAggregatedListWarningDataItem])
    , _igalwCode :: !(Maybe InstanceGroupAggregatedListWarningCode)
    , _igalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igalwData'
--
-- * 'igalwCode'
--
-- * 'igalwMessage'
instanceGroupAggregatedListWarning
    :: InstanceGroupAggregatedListWarning
instanceGroupAggregatedListWarning =
  InstanceGroupAggregatedListWarning'
    {_igalwData = Nothing, _igalwCode = Nothing, _igalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
igalwData :: Lens' InstanceGroupAggregatedListWarning [InstanceGroupAggregatedListWarningDataItem]
igalwData
  = lens _igalwData (\ s a -> s{_igalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
igalwCode :: Lens' InstanceGroupAggregatedListWarning (Maybe InstanceGroupAggregatedListWarningCode)
igalwCode
  = lens _igalwCode (\ s a -> s{_igalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
igalwMessage :: Lens' InstanceGroupAggregatedListWarning (Maybe Text)
igalwMessage
  = lens _igalwMessage (\ s a -> s{_igalwMessage = a})

instance FromJSON InstanceGroupAggregatedListWarning
         where
        parseJSON
          = withObject "InstanceGroupAggregatedListWarning"
              (\ o ->
                 InstanceGroupAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON InstanceGroupAggregatedListWarning
         where
        toJSON InstanceGroupAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _igalwData,
                  ("code" .=) <$> _igalwCode,
                  ("message" .=) <$> _igalwMessage])

-- | Contains a list of Route resources.
--
-- /See:/ 'routeList' smart constructor.
data RouteList =
  RouteList'
    { _rouNextPageToken :: !(Maybe Text)
    , _rouKind :: !Text
    , _rouItems :: !(Maybe [Route])
    , _rouSelfLink :: !(Maybe Text)
    , _rouWarning :: !(Maybe RouteListWarning)
    , _rouId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RouteList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rouNextPageToken'
--
-- * 'rouKind'
--
-- * 'rouItems'
--
-- * 'rouSelfLink'
--
-- * 'rouWarning'
--
-- * 'rouId'
routeList
    :: RouteList
routeList =
  RouteList'
    { _rouNextPageToken = Nothing
    , _rouKind = "compute#routeList"
    , _rouItems = Nothing
    , _rouSelfLink = Nothing
    , _rouWarning = Nothing
    , _rouId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
rouNextPageToken :: Lens' RouteList (Maybe Text)
rouNextPageToken
  = lens _rouNextPageToken
      (\ s a -> s{_rouNextPageToken = a})

-- | Type of resource.
rouKind :: Lens' RouteList Text
rouKind = lens _rouKind (\ s a -> s{_rouKind = a})

-- | A list of Route resources.
rouItems :: Lens' RouteList [Route]
rouItems
  = lens _rouItems (\ s a -> s{_rouItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
rouSelfLink :: Lens' RouteList (Maybe Text)
rouSelfLink
  = lens _rouSelfLink (\ s a -> s{_rouSelfLink = a})

-- | [Output Only] Informational warning message.
rouWarning :: Lens' RouteList (Maybe RouteListWarning)
rouWarning
  = lens _rouWarning (\ s a -> s{_rouWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
rouId :: Lens' RouteList (Maybe Text)
rouId = lens _rouId (\ s a -> s{_rouId = a})

instance FromJSON RouteList where
        parseJSON
          = withObject "RouteList"
              (\ o ->
                 RouteList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#routeList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON RouteList where
        toJSON RouteList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _rouNextPageToken,
                  Just ("kind" .= _rouKind),
                  ("items" .=) <$> _rouItems,
                  ("selfLink" .=) <$> _rouSelfLink,
                  ("warning" .=) <$> _rouWarning,
                  ("id" .=) <$> _rouId])

--
-- /See:/ 'urlMapsAggregatedList' smart constructor.
data URLMapsAggregatedList =
  URLMapsAggregatedList'
    { _umalUnreachables :: !(Maybe [Text])
    , _umalNextPageToken :: !(Maybe Text)
    , _umalKind :: !Text
    , _umalItems :: !(Maybe URLMapsAggregatedListItems)
    , _umalSelfLink :: !(Maybe Text)
    , _umalWarning :: !(Maybe URLMapsAggregatedListWarning)
    , _umalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'URLMapsAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'umalUnreachables'
--
-- * 'umalNextPageToken'
--
-- * 'umalKind'
--
-- * 'umalItems'
--
-- * 'umalSelfLink'
--
-- * 'umalWarning'
--
-- * 'umalId'
urlMapsAggregatedList
    :: URLMapsAggregatedList
urlMapsAggregatedList =
  URLMapsAggregatedList'
    { _umalUnreachables = Nothing
    , _umalNextPageToken = Nothing
    , _umalKind = "compute#urlMapsAggregatedList"
    , _umalItems = Nothing
    , _umalSelfLink = Nothing
    , _umalWarning = Nothing
    , _umalId = Nothing
    }


-- | [Output Only] Unreachable resources.
umalUnreachables :: Lens' URLMapsAggregatedList [Text]
umalUnreachables
  = lens _umalUnreachables
      (\ s a -> s{_umalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
umalNextPageToken :: Lens' URLMapsAggregatedList (Maybe Text)
umalNextPageToken
  = lens _umalNextPageToken
      (\ s a -> s{_umalNextPageToken = a})

-- | Type of resource.
umalKind :: Lens' URLMapsAggregatedList Text
umalKind = lens _umalKind (\ s a -> s{_umalKind = a})

-- | A list of UrlMapsScopedList resources.
umalItems :: Lens' URLMapsAggregatedList (Maybe URLMapsAggregatedListItems)
umalItems
  = lens _umalItems (\ s a -> s{_umalItems = a})

-- | [Output Only] Server-defined URL for this resource.
umalSelfLink :: Lens' URLMapsAggregatedList (Maybe Text)
umalSelfLink
  = lens _umalSelfLink (\ s a -> s{_umalSelfLink = a})

-- | [Output Only] Informational warning message.
umalWarning :: Lens' URLMapsAggregatedList (Maybe URLMapsAggregatedListWarning)
umalWarning
  = lens _umalWarning (\ s a -> s{_umalWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
umalId :: Lens' URLMapsAggregatedList (Maybe Text)
umalId = lens _umalId (\ s a -> s{_umalId = a})

instance FromJSON URLMapsAggregatedList where
        parseJSON
          = withObject "URLMapsAggregatedList"
              (\ o ->
                 URLMapsAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!= "compute#urlMapsAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON URLMapsAggregatedList where
        toJSON URLMapsAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _umalUnreachables,
                  ("nextPageToken" .=) <$> _umalNextPageToken,
                  Just ("kind" .= _umalKind),
                  ("items" .=) <$> _umalItems,
                  ("selfLink" .=) <$> _umalSelfLink,
                  ("warning" .=) <$> _umalWarning,
                  ("id" .=) <$> _umalId])

-- | Contains a list of instance referrers.
--
-- /See:/ 'instanceListReferrers' smart constructor.
data InstanceListReferrers =
  InstanceListReferrers'
    { _ilrNextPageToken :: !(Maybe Text)
    , _ilrKind :: !Text
    , _ilrItems :: !(Maybe [Reference])
    , _ilrSelfLink :: !(Maybe Text)
    , _ilrWarning :: !(Maybe InstanceListReferrersWarning)
    , _ilrId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceListReferrers' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ilrNextPageToken'
--
-- * 'ilrKind'
--
-- * 'ilrItems'
--
-- * 'ilrSelfLink'
--
-- * 'ilrWarning'
--
-- * 'ilrId'
instanceListReferrers
    :: InstanceListReferrers
instanceListReferrers =
  InstanceListReferrers'
    { _ilrNextPageToken = Nothing
    , _ilrKind = "compute#instanceListReferrers"
    , _ilrItems = Nothing
    , _ilrSelfLink = Nothing
    , _ilrWarning = Nothing
    , _ilrId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
ilrNextPageToken :: Lens' InstanceListReferrers (Maybe Text)
ilrNextPageToken
  = lens _ilrNextPageToken
      (\ s a -> s{_ilrNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#instanceListReferrers for
-- lists of Instance referrers.
ilrKind :: Lens' InstanceListReferrers Text
ilrKind = lens _ilrKind (\ s a -> s{_ilrKind = a})

-- | A list of Reference resources.
ilrItems :: Lens' InstanceListReferrers [Reference]
ilrItems
  = lens _ilrItems (\ s a -> s{_ilrItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
ilrSelfLink :: Lens' InstanceListReferrers (Maybe Text)
ilrSelfLink
  = lens _ilrSelfLink (\ s a -> s{_ilrSelfLink = a})

-- | [Output Only] Informational warning message.
ilrWarning :: Lens' InstanceListReferrers (Maybe InstanceListReferrersWarning)
ilrWarning
  = lens _ilrWarning (\ s a -> s{_ilrWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
ilrId :: Lens' InstanceListReferrers (Maybe Text)
ilrId = lens _ilrId (\ s a -> s{_ilrId = a})

instance FromJSON InstanceListReferrers where
        parseJSON
          = withObject "InstanceListReferrers"
              (\ o ->
                 InstanceListReferrers' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#instanceListReferrers")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON InstanceListReferrers where
        toJSON InstanceListReferrers'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _ilrNextPageToken,
                  Just ("kind" .= _ilrKind),
                  ("items" .=) <$> _ilrItems,
                  ("selfLink" .=) <$> _ilrSelfLink,
                  ("warning" .=) <$> _ilrWarning,
                  ("id" .=) <$> _ilrId])

-- | Settings controlling the eviction of unhealthy hosts from the load
-- balancing pool for the backend service.
--
-- /See:/ 'outlierDetection' smart constructor.
data OutlierDetection =
  OutlierDetection'
    { _odEnforcingConsecutiveErrors :: !(Maybe (Textual Int32))
    , _odSuccessRateMinimumHosts :: !(Maybe (Textual Int32))
    , _odConsecutiveGatewayFailure :: !(Maybe (Textual Int32))
    , _odConsecutiveErrors :: !(Maybe (Textual Int32))
    , _odEnforcingConsecutiveGatewayFailure :: !(Maybe (Textual Int32))
    , _odBaseEjectionTime :: !(Maybe Duration)
    , _odSuccessRateStdevFactor :: !(Maybe (Textual Int32))
    , _odInterval :: !(Maybe Duration)
    , _odEnforcingSuccessRate :: !(Maybe (Textual Int32))
    , _odMaxEjectionPercent :: !(Maybe (Textual Int32))
    , _odSuccessRateRequestVolume :: !(Maybe (Textual Int32))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'OutlierDetection' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'odEnforcingConsecutiveErrors'
--
-- * 'odSuccessRateMinimumHosts'
--
-- * 'odConsecutiveGatewayFailure'
--
-- * 'odConsecutiveErrors'
--
-- * 'odEnforcingConsecutiveGatewayFailure'
--
-- * 'odBaseEjectionTime'
--
-- * 'odSuccessRateStdevFactor'
--
-- * 'odInterval'
--
-- * 'odEnforcingSuccessRate'
--
-- * 'odMaxEjectionPercent'
--
-- * 'odSuccessRateRequestVolume'
outlierDetection
    :: OutlierDetection
outlierDetection =
  OutlierDetection'
    { _odEnforcingConsecutiveErrors = Nothing
    , _odSuccessRateMinimumHosts = Nothing
    , _odConsecutiveGatewayFailure = Nothing
    , _odConsecutiveErrors = Nothing
    , _odEnforcingConsecutiveGatewayFailure = Nothing
    , _odBaseEjectionTime = Nothing
    , _odSuccessRateStdevFactor = Nothing
    , _odInterval = Nothing
    , _odEnforcingSuccessRate = Nothing
    , _odMaxEjectionPercent = Nothing
    , _odSuccessRateRequestVolume = Nothing
    }


-- | The percentage chance that a host will be actually ejected when an
-- outlier status is detected through consecutive 5xx. This setting can be
-- used to disable ejection or to ramp it up slowly. Defaults to 0.
odEnforcingConsecutiveErrors :: Lens' OutlierDetection (Maybe Int32)
odEnforcingConsecutiveErrors
  = lens _odEnforcingConsecutiveErrors
      (\ s a -> s{_odEnforcingConsecutiveErrors = a})
      . mapping _Coerce

-- | The number of hosts in a cluster that must have enough request volume to
-- detect success rate outliers. If the number of hosts is less than this
-- setting, outlier detection via success rate statistics is not performed
-- for any host in the cluster. Defaults to 5.
odSuccessRateMinimumHosts :: Lens' OutlierDetection (Maybe Int32)
odSuccessRateMinimumHosts
  = lens _odSuccessRateMinimumHosts
      (\ s a -> s{_odSuccessRateMinimumHosts = a})
      . mapping _Coerce

-- | The number of consecutive gateway failures (502, 503, 504 status or
-- connection errors that are mapped to one of those status codes) before a
-- consecutive gateway failure ejection occurs. Defaults to 3.
odConsecutiveGatewayFailure :: Lens' OutlierDetection (Maybe Int32)
odConsecutiveGatewayFailure
  = lens _odConsecutiveGatewayFailure
      (\ s a -> s{_odConsecutiveGatewayFailure = a})
      . mapping _Coerce

-- | Number of errors before a host is ejected from the connection pool. When
-- the backend host is accessed over HTTP, a 5xx return code qualifies as
-- an error. Defaults to 5.
odConsecutiveErrors :: Lens' OutlierDetection (Maybe Int32)
odConsecutiveErrors
  = lens _odConsecutiveErrors
      (\ s a -> s{_odConsecutiveErrors = a})
      . mapping _Coerce

-- | The percentage chance that a host will be actually ejected when an
-- outlier status is detected through consecutive gateway failures. This
-- setting can be used to disable ejection or to ramp it up slowly.
-- Defaults to 100.
odEnforcingConsecutiveGatewayFailure :: Lens' OutlierDetection (Maybe Int32)
odEnforcingConsecutiveGatewayFailure
  = lens _odEnforcingConsecutiveGatewayFailure
      (\ s a ->
         s{_odEnforcingConsecutiveGatewayFailure = a})
      . mapping _Coerce

-- | The base time that a host is ejected for. The real ejection time is
-- equal to the base ejection time multiplied by the number of times the
-- host has been ejected. Defaults to 30000ms or 30s.
odBaseEjectionTime :: Lens' OutlierDetection (Maybe Duration)
odBaseEjectionTime
  = lens _odBaseEjectionTime
      (\ s a -> s{_odBaseEjectionTime = a})

-- | This factor is used to determine the ejection threshold for success rate
-- outlier ejection. The ejection threshold is the difference between the
-- mean success rate, and the product of this factor and the standard
-- deviation of the mean success rate: mean - (stdev *
-- success_rate_stdev_factor). This factor is divided by a thousand to get
-- a double. That is, if the desired factor is 1.9, the runtime value
-- should be 1900. Defaults to 1900.
odSuccessRateStdevFactor :: Lens' OutlierDetection (Maybe Int32)
odSuccessRateStdevFactor
  = lens _odSuccessRateStdevFactor
      (\ s a -> s{_odSuccessRateStdevFactor = a})
      . mapping _Coerce

-- | Time interval between ejection analysis sweeps. This can result in both
-- new ejections as well as hosts being returned to service. Defaults to 1
-- second.
odInterval :: Lens' OutlierDetection (Maybe Duration)
odInterval
  = lens _odInterval (\ s a -> s{_odInterval = a})

-- | The percentage chance that a host will be actually ejected when an
-- outlier status is detected through success rate statistics. This setting
-- can be used to disable ejection or to ramp it up slowly. Defaults to
-- 100.
odEnforcingSuccessRate :: Lens' OutlierDetection (Maybe Int32)
odEnforcingSuccessRate
  = lens _odEnforcingSuccessRate
      (\ s a -> s{_odEnforcingSuccessRate = a})
      . mapping _Coerce

-- | Maximum percentage of hosts in the load balancing pool for the backend
-- service that can be ejected. Defaults to 50%.
odMaxEjectionPercent :: Lens' OutlierDetection (Maybe Int32)
odMaxEjectionPercent
  = lens _odMaxEjectionPercent
      (\ s a -> s{_odMaxEjectionPercent = a})
      . mapping _Coerce

-- | The minimum number of total requests that must be collected in one
-- interval (as defined by the interval duration above) to include this
-- host in success rate based outlier detection. If the volume is lower
-- than this setting, outlier detection via success rate statistics is not
-- performed for that host. Defaults to 100.
odSuccessRateRequestVolume :: Lens' OutlierDetection (Maybe Int32)
odSuccessRateRequestVolume
  = lens _odSuccessRateRequestVolume
      (\ s a -> s{_odSuccessRateRequestVolume = a})
      . mapping _Coerce

instance FromJSON OutlierDetection where
        parseJSON
          = withObject "OutlierDetection"
              (\ o ->
                 OutlierDetection' <$>
                   (o .:? "enforcingConsecutiveErrors") <*>
                     (o .:? "successRateMinimumHosts")
                     <*> (o .:? "consecutiveGatewayFailure")
                     <*> (o .:? "consecutiveErrors")
                     <*> (o .:? "enforcingConsecutiveGatewayFailure")
                     <*> (o .:? "baseEjectionTime")
                     <*> (o .:? "successRateStdevFactor")
                     <*> (o .:? "interval")
                     <*> (o .:? "enforcingSuccessRate")
                     <*> (o .:? "maxEjectionPercent")
                     <*> (o .:? "successRateRequestVolume"))

instance ToJSON OutlierDetection where
        toJSON OutlierDetection'{..}
          = object
              (catMaybes
                 [("enforcingConsecutiveErrors" .=) <$>
                    _odEnforcingConsecutiveErrors,
                  ("successRateMinimumHosts" .=) <$>
                    _odSuccessRateMinimumHosts,
                  ("consecutiveGatewayFailure" .=) <$>
                    _odConsecutiveGatewayFailure,
                  ("consecutiveErrors" .=) <$> _odConsecutiveErrors,
                  ("enforcingConsecutiveGatewayFailure" .=) <$>
                    _odEnforcingConsecutiveGatewayFailure,
                  ("baseEjectionTime" .=) <$> _odBaseEjectionTime,
                  ("successRateStdevFactor" .=) <$>
                    _odSuccessRateStdevFactor,
                  ("interval" .=) <$> _odInterval,
                  ("enforcingSuccessRate" .=) <$>
                    _odEnforcingSuccessRate,
                  ("maxEjectionPercent" .=) <$> _odMaxEjectionPercent,
                  ("successRateRequestVolume" .=) <$>
                    _odSuccessRateRequestVolume])

-- | Schedule for an instance operation.
--
-- /See:/ 'resourcePolicyInstanceSchedulePolicySchedule' smart constructor.
newtype ResourcePolicyInstanceSchedulePolicySchedule =
  ResourcePolicyInstanceSchedulePolicySchedule'
    { _rpispsSchedule :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePolicyInstanceSchedulePolicySchedule' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rpispsSchedule'
resourcePolicyInstanceSchedulePolicySchedule
    :: ResourcePolicyInstanceSchedulePolicySchedule
resourcePolicyInstanceSchedulePolicySchedule =
  ResourcePolicyInstanceSchedulePolicySchedule' {_rpispsSchedule = Nothing}


-- | Specifies the frequency for the operation, using the unix-cron format.
rpispsSchedule :: Lens' ResourcePolicyInstanceSchedulePolicySchedule (Maybe Text)
rpispsSchedule
  = lens _rpispsSchedule
      (\ s a -> s{_rpispsSchedule = a})

instance FromJSON
           ResourcePolicyInstanceSchedulePolicySchedule
         where
        parseJSON
          = withObject
              "ResourcePolicyInstanceSchedulePolicySchedule"
              (\ o ->
                 ResourcePolicyInstanceSchedulePolicySchedule' <$>
                   (o .:? "schedule"))

instance ToJSON
           ResourcePolicyInstanceSchedulePolicySchedule
         where
        toJSON
          ResourcePolicyInstanceSchedulePolicySchedule'{..}
          = object
              (catMaybes [("schedule" .=) <$> _rpispsSchedule])

-- | Represents a Cloud Router resource. For more information about Cloud
-- Router, read the Cloud Router overview.
--
-- /See:/ 'router' smart constructor.
data Router =
  Router'
    { _rouoBGPPeers :: !(Maybe [RouterBGPPeer])
    , _rouoEncryptedInterconnectRouter :: !(Maybe Bool)
    , _rouoBGP :: !(Maybe RouterBGP)
    , _rouoKind :: !Text
    , _rouoNetwork :: !(Maybe Text)
    , _rouoInterfaces :: !(Maybe [RouterInterface])
    , _rouoSelfLink :: !(Maybe Text)
    , _rouoName :: !(Maybe Text)
    , _rouoCreationTimestamp :: !(Maybe Text)
    , _rouoId :: !(Maybe (Textual Word64))
    , _rouoRegion :: !(Maybe Text)
    , _rouoNATs :: !(Maybe [RouterNAT])
    , _rouoDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Router' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rouoBGPPeers'
--
-- * 'rouoEncryptedInterconnectRouter'
--
-- * 'rouoBGP'
--
-- * 'rouoKind'
--
-- * 'rouoNetwork'
--
-- * 'rouoInterfaces'
--
-- * 'rouoSelfLink'
--
-- * 'rouoName'
--
-- * 'rouoCreationTimestamp'
--
-- * 'rouoId'
--
-- * 'rouoRegion'
--
-- * 'rouoNATs'
--
-- * 'rouoDescription'
router
    :: Router
router =
  Router'
    { _rouoBGPPeers = Nothing
    , _rouoEncryptedInterconnectRouter = Nothing
    , _rouoBGP = Nothing
    , _rouoKind = "compute#router"
    , _rouoNetwork = Nothing
    , _rouoInterfaces = Nothing
    , _rouoSelfLink = Nothing
    , _rouoName = Nothing
    , _rouoCreationTimestamp = Nothing
    , _rouoId = Nothing
    , _rouoRegion = Nothing
    , _rouoNATs = Nothing
    , _rouoDescription = Nothing
    }


-- | BGP information that must be configured into the routing stack to
-- establish BGP peering. This information must specify the peer ASN and
-- either the interface name, IP address, or peer IP address. Please refer
-- to RFC4273.
rouoBGPPeers :: Lens' Router [RouterBGPPeer]
rouoBGPPeers
  = lens _rouoBGPPeers (\ s a -> s{_rouoBGPPeers = a})
      . _Default
      . _Coerce

-- | Indicates if a router is dedicated for use with encrypted VLAN
-- attachments (interconnectAttachments). Not currently available publicly.
rouoEncryptedInterconnectRouter :: Lens' Router (Maybe Bool)
rouoEncryptedInterconnectRouter
  = lens _rouoEncryptedInterconnectRouter
      (\ s a -> s{_rouoEncryptedInterconnectRouter = a})

-- | BGP information specific to this router.
rouoBGP :: Lens' Router (Maybe RouterBGP)
rouoBGP = lens _rouoBGP (\ s a -> s{_rouoBGP = a})

-- | [Output Only] Type of resource. Always compute#router for routers.
rouoKind :: Lens' Router Text
rouoKind = lens _rouoKind (\ s a -> s{_rouoKind = a})

-- | URI of the network to which this router belongs.
rouoNetwork :: Lens' Router (Maybe Text)
rouoNetwork
  = lens _rouoNetwork (\ s a -> s{_rouoNetwork = a})

-- | Router interfaces. Each interface requires either one linked resource,
-- (for example, linkedVpnTunnel), or IP address and IP address range (for
-- example, ipRange), or both.
rouoInterfaces :: Lens' Router [RouterInterface]
rouoInterfaces
  = lens _rouoInterfaces
      (\ s a -> s{_rouoInterfaces = a})
      . _Default
      . _Coerce

-- | [Output Only] Server-defined URL for the resource.
rouoSelfLink :: Lens' Router (Maybe Text)
rouoSelfLink
  = lens _rouoSelfLink (\ s a -> s{_rouoSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
rouoName :: Lens' Router (Maybe Text)
rouoName = lens _rouoName (\ s a -> s{_rouoName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
rouoCreationTimestamp :: Lens' Router (Maybe Text)
rouoCreationTimestamp
  = lens _rouoCreationTimestamp
      (\ s a -> s{_rouoCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
rouoId :: Lens' Router (Maybe Word64)
rouoId
  = lens _rouoId (\ s a -> s{_rouoId = a}) .
      mapping _Coerce

-- | [Output Only] URI of the region where the router resides. You must
-- specify this field as part of the HTTP request URL. It is not settable
-- as a field in the request body.
rouoRegion :: Lens' Router (Maybe Text)
rouoRegion
  = lens _rouoRegion (\ s a -> s{_rouoRegion = a})

-- | A list of NAT services created in this router.
rouoNATs :: Lens' Router [RouterNAT]
rouoNATs
  = lens _rouoNATs (\ s a -> s{_rouoNATs = a}) .
      _Default
      . _Coerce

-- | An optional description of this resource. Provide this property when you
-- create the resource.
rouoDescription :: Lens' Router (Maybe Text)
rouoDescription
  = lens _rouoDescription
      (\ s a -> s{_rouoDescription = a})

instance FromJSON Router where
        parseJSON
          = withObject "Router"
              (\ o ->
                 Router' <$>
                   (o .:? "bgpPeers" .!= mempty) <*>
                     (o .:? "encryptedInterconnectRouter")
                     <*> (o .:? "bgp")
                     <*> (o .:? "kind" .!= "compute#router")
                     <*> (o .:? "network")
                     <*> (o .:? "interfaces" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "region")
                     <*> (o .:? "nats" .!= mempty)
                     <*> (o .:? "description"))

instance ToJSON Router where
        toJSON Router'{..}
          = object
              (catMaybes
                 [("bgpPeers" .=) <$> _rouoBGPPeers,
                  ("encryptedInterconnectRouter" .=) <$>
                    _rouoEncryptedInterconnectRouter,
                  ("bgp" .=) <$> _rouoBGP, Just ("kind" .= _rouoKind),
                  ("network" .=) <$> _rouoNetwork,
                  ("interfaces" .=) <$> _rouoInterfaces,
                  ("selfLink" .=) <$> _rouoSelfLink,
                  ("name" .=) <$> _rouoName,
                  ("creationTimestamp" .=) <$> _rouoCreationTimestamp,
                  ("id" .=) <$> _rouoId, ("region" .=) <$> _rouoRegion,
                  ("nats" .=) <$> _rouoNATs,
                  ("description" .=) <$> _rouoDescription])

-- | Location configurations mapped by location name. Currently only zone
-- names are supported and must be represented as valid internal URLs, such
-- as zones\/us-central1-a.
--
-- /See:/ 'locationPolicyLocations' smart constructor.
newtype LocationPolicyLocations =
  LocationPolicyLocations'
    { _lplAddtional :: HashMap Text LocationPolicyLocation
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'LocationPolicyLocations' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'lplAddtional'
locationPolicyLocations
    :: HashMap Text LocationPolicyLocation -- ^ 'lplAddtional'
    -> LocationPolicyLocations
locationPolicyLocations pLplAddtional_ =
  LocationPolicyLocations' {_lplAddtional = _Coerce # pLplAddtional_}


lplAddtional :: Lens' LocationPolicyLocations (HashMap Text LocationPolicyLocation)
lplAddtional
  = lens _lplAddtional (\ s a -> s{_lplAddtional = a})
      . _Coerce

instance FromJSON LocationPolicyLocations where
        parseJSON
          = withObject "LocationPolicyLocations"
              (\ o ->
                 LocationPolicyLocations' <$> (parseJSONObject o))

instance ToJSON LocationPolicyLocations where
        toJSON = toJSON . _lplAddtional

--
-- /See:/ 'routerAggregatedListWarningDataItem' smart constructor.
data RouterAggregatedListWarningDataItem =
  RouterAggregatedListWarningDataItem'
    { _ralwdiValue :: !(Maybe Text)
    , _ralwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RouterAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ralwdiValue'
--
-- * 'ralwdiKey'
routerAggregatedListWarningDataItem
    :: RouterAggregatedListWarningDataItem
routerAggregatedListWarningDataItem =
  RouterAggregatedListWarningDataItem'
    {_ralwdiValue = Nothing, _ralwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
ralwdiValue :: Lens' RouterAggregatedListWarningDataItem (Maybe Text)
ralwdiValue
  = lens _ralwdiValue (\ s a -> s{_ralwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
ralwdiKey :: Lens' RouterAggregatedListWarningDataItem (Maybe Text)
ralwdiKey
  = lens _ralwdiKey (\ s a -> s{_ralwdiKey = a})

instance FromJSON RouterAggregatedListWarningDataItem
         where
        parseJSON
          = withObject "RouterAggregatedListWarningDataItem"
              (\ o ->
                 RouterAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON RouterAggregatedListWarningDataItem
         where
        toJSON RouterAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _ralwdiValue,
                  ("key" .=) <$> _ralwdiKey])

--
-- /See:/ 'routersScopedListWarningDataItem' smart constructor.
data RoutersScopedListWarningDataItem =
  RoutersScopedListWarningDataItem'
    { _rValue :: !(Maybe Text)
    , _rKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RoutersScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rValue'
--
-- * 'rKey'
routersScopedListWarningDataItem
    :: RoutersScopedListWarningDataItem
routersScopedListWarningDataItem =
  RoutersScopedListWarningDataItem' {_rValue = Nothing, _rKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
rValue :: Lens' RoutersScopedListWarningDataItem (Maybe Text)
rValue = lens _rValue (\ s a -> s{_rValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
rKey :: Lens' RoutersScopedListWarningDataItem (Maybe Text)
rKey = lens _rKey (\ s a -> s{_rKey = a})

instance FromJSON RoutersScopedListWarningDataItem
         where
        parseJSON
          = withObject "RoutersScopedListWarningDataItem"
              (\ o ->
                 RoutersScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON RoutersScopedListWarningDataItem
         where
        toJSON RoutersScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _rValue, ("key" .=) <$> _rKey])

--
-- /See:/ 'subnetworksSetPrivateIPGoogleAccessRequest' smart constructor.
newtype SubnetworksSetPrivateIPGoogleAccessRequest =
  SubnetworksSetPrivateIPGoogleAccessRequest'
    { _sspigarPrivateIPGoogleAccess :: Maybe Bool
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SubnetworksSetPrivateIPGoogleAccessRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sspigarPrivateIPGoogleAccess'
subnetworksSetPrivateIPGoogleAccessRequest
    :: SubnetworksSetPrivateIPGoogleAccessRequest
subnetworksSetPrivateIPGoogleAccessRequest =
  SubnetworksSetPrivateIPGoogleAccessRequest'
    {_sspigarPrivateIPGoogleAccess = Nothing}


sspigarPrivateIPGoogleAccess :: Lens' SubnetworksSetPrivateIPGoogleAccessRequest (Maybe Bool)
sspigarPrivateIPGoogleAccess
  = lens _sspigarPrivateIPGoogleAccess
      (\ s a -> s{_sspigarPrivateIPGoogleAccess = a})

instance FromJSON
           SubnetworksSetPrivateIPGoogleAccessRequest
         where
        parseJSON
          = withObject
              "SubnetworksSetPrivateIPGoogleAccessRequest"
              (\ o ->
                 SubnetworksSetPrivateIPGoogleAccessRequest' <$>
                   (o .:? "privateIpGoogleAccess"))

instance ToJSON
           SubnetworksSetPrivateIPGoogleAccessRequest
         where
        toJSON
          SubnetworksSetPrivateIPGoogleAccessRequest'{..}
          = object
              (catMaybes
                 [("privateIpGoogleAccess" .=) <$>
                    _sspigarPrivateIPGoogleAccess])

--
-- /See:/ 'targetHTTPSProxyListWarningDataItem' smart constructor.
data TargetHTTPSProxyListWarningDataItem =
  TargetHTTPSProxyListWarningDataItem'
    { _thplwdiValue :: !(Maybe Text)
    , _thplwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetHTTPSProxyListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'thplwdiValue'
--
-- * 'thplwdiKey'
targetHTTPSProxyListWarningDataItem
    :: TargetHTTPSProxyListWarningDataItem
targetHTTPSProxyListWarningDataItem =
  TargetHTTPSProxyListWarningDataItem'
    {_thplwdiValue = Nothing, _thplwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
thplwdiValue :: Lens' TargetHTTPSProxyListWarningDataItem (Maybe Text)
thplwdiValue
  = lens _thplwdiValue (\ s a -> s{_thplwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
thplwdiKey :: Lens' TargetHTTPSProxyListWarningDataItem (Maybe Text)
thplwdiKey
  = lens _thplwdiKey (\ s a -> s{_thplwdiKey = a})

instance FromJSON TargetHTTPSProxyListWarningDataItem
         where
        parseJSON
          = withObject "TargetHTTPSProxyListWarningDataItem"
              (\ o ->
                 TargetHTTPSProxyListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON TargetHTTPSProxyListWarningDataItem
         where
        toJSON TargetHTTPSProxyListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _thplwdiValue,
                  ("key" .=) <$> _thplwdiKey])

-- | Describes the high availability requirement state for the VPN connection
-- between this Cloud VPN gateway and a peer gateway.
--
-- /See:/ 'vpnGatewayStatusHighAvailabilityRequirementState' smart constructor.
data VPNGatewayStatusHighAvailabilityRequirementState =
  VPNGatewayStatusHighAvailabilityRequirementState'
    { _vgsharsState :: !(Maybe VPNGatewayStatusHighAvailabilityRequirementStateState)
    , _vgsharsUnsatisfiedReason :: !(Maybe VPNGatewayStatusHighAvailabilityRequirementStateUnsatisfiedReason)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNGatewayStatusHighAvailabilityRequirementState' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vgsharsState'
--
-- * 'vgsharsUnsatisfiedReason'
vpnGatewayStatusHighAvailabilityRequirementState
    :: VPNGatewayStatusHighAvailabilityRequirementState
vpnGatewayStatusHighAvailabilityRequirementState =
  VPNGatewayStatusHighAvailabilityRequirementState'
    {_vgsharsState = Nothing, _vgsharsUnsatisfiedReason = Nothing}


-- | Indicates the high availability requirement state for the VPN
-- connection. Valid values are CONNECTION_REDUNDANCY_MET,
-- CONNECTION_REDUNDANCY_NOT_MET.
vgsharsState :: Lens' VPNGatewayStatusHighAvailabilityRequirementState (Maybe VPNGatewayStatusHighAvailabilityRequirementStateState)
vgsharsState
  = lens _vgsharsState (\ s a -> s{_vgsharsState = a})

-- | Indicates the reason why the VPN connection does not meet the high
-- availability redundancy criteria\/requirement. Valid values is
-- INCOMPLETE_TUNNELS_COVERAGE.
vgsharsUnsatisfiedReason :: Lens' VPNGatewayStatusHighAvailabilityRequirementState (Maybe VPNGatewayStatusHighAvailabilityRequirementStateUnsatisfiedReason)
vgsharsUnsatisfiedReason
  = lens _vgsharsUnsatisfiedReason
      (\ s a -> s{_vgsharsUnsatisfiedReason = a})

instance FromJSON
           VPNGatewayStatusHighAvailabilityRequirementState
         where
        parseJSON
          = withObject
              "VPNGatewayStatusHighAvailabilityRequirementState"
              (\ o ->
                 VPNGatewayStatusHighAvailabilityRequirementState' <$>
                   (o .:? "state") <*> (o .:? "unsatisfiedReason"))

instance ToJSON
           VPNGatewayStatusHighAvailabilityRequirementState
         where
        toJSON
          VPNGatewayStatusHighAvailabilityRequirementState'{..}
          = object
              (catMaybes
                 [("state" .=) <$> _vgsharsState,
                  ("unsatisfiedReason" .=) <$>
                    _vgsharsUnsatisfiedReason])

-- | A list of PublicDelegatedPrefixesScopedList resources.
--
-- /See:/ 'publicDelegatedPrefixAggregatedListItems' smart constructor.
newtype PublicDelegatedPrefixAggregatedListItems =
  PublicDelegatedPrefixAggregatedListItems'
    { _pdpaliAddtional :: HashMap Text PublicDelegatedPrefixesScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PublicDelegatedPrefixAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pdpaliAddtional'
publicDelegatedPrefixAggregatedListItems
    :: HashMap Text PublicDelegatedPrefixesScopedList -- ^ 'pdpaliAddtional'
    -> PublicDelegatedPrefixAggregatedListItems
publicDelegatedPrefixAggregatedListItems pPdpaliAddtional_ =
  PublicDelegatedPrefixAggregatedListItems'
    {_pdpaliAddtional = _Coerce # pPdpaliAddtional_}


-- | [Output Only] Name of the scope containing this set of
-- PublicDelegatedPrefixes.
pdpaliAddtional :: Lens' PublicDelegatedPrefixAggregatedListItems (HashMap Text PublicDelegatedPrefixesScopedList)
pdpaliAddtional
  = lens _pdpaliAddtional
      (\ s a -> s{_pdpaliAddtional = a})
      . _Coerce

instance FromJSON
           PublicDelegatedPrefixAggregatedListItems
         where
        parseJSON
          = withObject
              "PublicDelegatedPrefixAggregatedListItems"
              (\ o ->
                 PublicDelegatedPrefixAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON
           PublicDelegatedPrefixAggregatedListItems
         where
        toJSON = toJSON . _pdpaliAddtional

-- | Contains a list of TargetVpnGateway resources.
--
-- /See:/ 'targetVPNGatewayList' smart constructor.
data TargetVPNGatewayList =
  TargetVPNGatewayList'
    { _tvglNextPageToken :: !(Maybe Text)
    , _tvglKind :: !Text
    , _tvglItems :: !(Maybe [TargetVPNGateway])
    , _tvglSelfLink :: !(Maybe Text)
    , _tvglWarning :: !(Maybe TargetVPNGatewayListWarning)
    , _tvglId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetVPNGatewayList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tvglNextPageToken'
--
-- * 'tvglKind'
--
-- * 'tvglItems'
--
-- * 'tvglSelfLink'
--
-- * 'tvglWarning'
--
-- * 'tvglId'
targetVPNGatewayList
    :: TargetVPNGatewayList
targetVPNGatewayList =
  TargetVPNGatewayList'
    { _tvglNextPageToken = Nothing
    , _tvglKind = "compute#targetVpnGatewayList"
    , _tvglItems = Nothing
    , _tvglSelfLink = Nothing
    , _tvglWarning = Nothing
    , _tvglId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
tvglNextPageToken :: Lens' TargetVPNGatewayList (Maybe Text)
tvglNextPageToken
  = lens _tvglNextPageToken
      (\ s a -> s{_tvglNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#targetVpnGateway for
-- target VPN gateways.
tvglKind :: Lens' TargetVPNGatewayList Text
tvglKind = lens _tvglKind (\ s a -> s{_tvglKind = a})

-- | A list of TargetVpnGateway resources.
tvglItems :: Lens' TargetVPNGatewayList [TargetVPNGateway]
tvglItems
  = lens _tvglItems (\ s a -> s{_tvglItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
tvglSelfLink :: Lens' TargetVPNGatewayList (Maybe Text)
tvglSelfLink
  = lens _tvglSelfLink (\ s a -> s{_tvglSelfLink = a})

-- | [Output Only] Informational warning message.
tvglWarning :: Lens' TargetVPNGatewayList (Maybe TargetVPNGatewayListWarning)
tvglWarning
  = lens _tvglWarning (\ s a -> s{_tvglWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
tvglId :: Lens' TargetVPNGatewayList (Maybe Text)
tvglId = lens _tvglId (\ s a -> s{_tvglId = a})

instance FromJSON TargetVPNGatewayList where
        parseJSON
          = withObject "TargetVPNGatewayList"
              (\ o ->
                 TargetVPNGatewayList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#targetVpnGatewayList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON TargetVPNGatewayList where
        toJSON TargetVPNGatewayList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _tvglNextPageToken,
                  Just ("kind" .= _tvglKind),
                  ("items" .=) <$> _tvglItems,
                  ("selfLink" .=) <$> _tvglSelfLink,
                  ("warning" .=) <$> _tvglWarning,
                  ("id" .=) <$> _tvglId])

--
-- /See:/ 'regionURLMapsValidateRequest' smart constructor.
newtype RegionURLMapsValidateRequest =
  RegionURLMapsValidateRequest'
    { _rumvrResource :: Maybe URLMap
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionURLMapsValidateRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rumvrResource'
regionURLMapsValidateRequest
    :: RegionURLMapsValidateRequest
regionURLMapsValidateRequest =
  RegionURLMapsValidateRequest' {_rumvrResource = Nothing}


-- | Content of the UrlMap to be validated.
rumvrResource :: Lens' RegionURLMapsValidateRequest (Maybe URLMap)
rumvrResource
  = lens _rumvrResource
      (\ s a -> s{_rumvrResource = a})

instance FromJSON RegionURLMapsValidateRequest where
        parseJSON
          = withObject "RegionURLMapsValidateRequest"
              (\ o ->
                 RegionURLMapsValidateRequest' <$> (o .:? "resource"))

instance ToJSON RegionURLMapsValidateRequest where
        toJSON RegionURLMapsValidateRequest'{..}
          = object
              (catMaybes [("resource" .=) <$> _rumvrResource])

-- | Contains a list of SslCertificate resources.
--
-- /See:/ 'sslCertificateList' smart constructor.
data SSLCertificateList =
  SSLCertificateList'
    { _sclNextPageToken :: !(Maybe Text)
    , _sclKind :: !Text
    , _sclItems :: !(Maybe [SSLCertificate])
    , _sclSelfLink :: !(Maybe Text)
    , _sclWarning :: !(Maybe SSLCertificateListWarning)
    , _sclId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SSLCertificateList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sclNextPageToken'
--
-- * 'sclKind'
--
-- * 'sclItems'
--
-- * 'sclSelfLink'
--
-- * 'sclWarning'
--
-- * 'sclId'
sslCertificateList
    :: SSLCertificateList
sslCertificateList =
  SSLCertificateList'
    { _sclNextPageToken = Nothing
    , _sclKind = "compute#sslCertificateList"
    , _sclItems = Nothing
    , _sclSelfLink = Nothing
    , _sclWarning = Nothing
    , _sclId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
sclNextPageToken :: Lens' SSLCertificateList (Maybe Text)
sclNextPageToken
  = lens _sclNextPageToken
      (\ s a -> s{_sclNextPageToken = a})

-- | Type of resource.
sclKind :: Lens' SSLCertificateList Text
sclKind = lens _sclKind (\ s a -> s{_sclKind = a})

-- | A list of SslCertificate resources.
sclItems :: Lens' SSLCertificateList [SSLCertificate]
sclItems
  = lens _sclItems (\ s a -> s{_sclItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
sclSelfLink :: Lens' SSLCertificateList (Maybe Text)
sclSelfLink
  = lens _sclSelfLink (\ s a -> s{_sclSelfLink = a})

-- | [Output Only] Informational warning message.
sclWarning :: Lens' SSLCertificateList (Maybe SSLCertificateListWarning)
sclWarning
  = lens _sclWarning (\ s a -> s{_sclWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
sclId :: Lens' SSLCertificateList (Maybe Text)
sclId = lens _sclId (\ s a -> s{_sclId = a})

instance FromJSON SSLCertificateList where
        parseJSON
          = withObject "SSLCertificateList"
              (\ o ->
                 SSLCertificateList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#sslCertificateList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON SSLCertificateList where
        toJSON SSLCertificateList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _sclNextPageToken,
                  Just ("kind" .= _sclKind),
                  ("items" .=) <$> _sclItems,
                  ("selfLink" .=) <$> _sclSelfLink,
                  ("warning" .=) <$> _sclWarning,
                  ("id" .=) <$> _sclId])

-- | The authentication and authorization settings for a BackendService.
--
-- /See:/ 'securitySettings' smart constructor.
data SecuritySettings =
  SecuritySettings'
    { _ssClientTLSPolicy :: !(Maybe Text)
    , _ssSubjectAltNames :: !(Maybe [Text])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SecuritySettings' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ssClientTLSPolicy'
--
-- * 'ssSubjectAltNames'
securitySettings
    :: SecuritySettings
securitySettings =
  SecuritySettings' {_ssClientTLSPolicy = Nothing, _ssSubjectAltNames = Nothing}


-- | Optional. A URL referring to a networksecurity.ClientTlsPolicy resource
-- that describes how clients should authenticate with this service\'s
-- backends. clientTlsPolicy only applies to a global BackendService with
-- the loadBalancingScheme set to INTERNAL_SELF_MANAGED. If left blank,
-- communications are not encrypted. Note: This field currently has no
-- impact.
ssClientTLSPolicy :: Lens' SecuritySettings (Maybe Text)
ssClientTLSPolicy
  = lens _ssClientTLSPolicy
      (\ s a -> s{_ssClientTLSPolicy = a})

-- | Optional. A list of Subject Alternative Names (SANs) that the client
-- verifies during a mutual TLS handshake with an server\/endpoint for this
-- BackendService. When the server presents its X.509 certificate to the
-- client, the client inspects the certificate\'s subjectAltName field. If
-- the field contains one of the specified values, the communication
-- continues. Otherwise, it fails. This additional check enables the client
-- to verify that the server is authorized to run the requested service.
-- Note that the contents of the server certificate\'s subjectAltName field
-- are configured by the Public Key Infrastructure which provisions server
-- identities. Only applies to a global BackendService with
-- loadBalancingScheme set to INTERNAL_SELF_MANAGED. Only applies when
-- BackendService has an attached clientTlsPolicy with clientCertificate
-- (mTLS mode). Note: This field currently has no impact.
ssSubjectAltNames :: Lens' SecuritySettings [Text]
ssSubjectAltNames
  = lens _ssSubjectAltNames
      (\ s a -> s{_ssSubjectAltNames = a})
      . _Default
      . _Coerce

instance FromJSON SecuritySettings where
        parseJSON
          = withObject "SecuritySettings"
              (\ o ->
                 SecuritySettings' <$>
                   (o .:? "clientTlsPolicy") <*>
                     (o .:? "subjectAltNames" .!= mempty))

instance ToJSON SecuritySettings where
        toJSON SecuritySettings'{..}
          = object
              (catMaybes
                 [("clientTlsPolicy" .=) <$> _ssClientTLSPolicy,
                  ("subjectAltNames" .=) <$> _ssSubjectAltNames])

--
-- /See:/ 'firewallAllowedItem' smart constructor.
data FirewallAllowedItem =
  FirewallAllowedItem'
    { _faiIPProtocol :: !(Maybe Text)
    , _faiPorts :: !(Maybe [Text])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'FirewallAllowedItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'faiIPProtocol'
--
-- * 'faiPorts'
firewallAllowedItem
    :: FirewallAllowedItem
firewallAllowedItem =
  FirewallAllowedItem' {_faiIPProtocol = Nothing, _faiPorts = Nothing}


-- | The IP protocol to which this rule applies. The protocol type is
-- required when creating a firewall rule. This value can either be one of
-- the following well known protocol strings (tcp, udp, icmp, esp, ah,
-- ipip, sctp) or the IP protocol number.
faiIPProtocol :: Lens' FirewallAllowedItem (Maybe Text)
faiIPProtocol
  = lens _faiIPProtocol
      (\ s a -> s{_faiIPProtocol = a})

-- | An optional list of ports to which this rule applies. This field is only
-- applicable for the UDP or TCP protocol. Each entry must be either an
-- integer or a range. If not specified, this rule applies to connections
-- through any port. Example inputs include: [\"22\"], [\"80\",\"443\"],
-- and [\"12345-12349\"].
faiPorts :: Lens' FirewallAllowedItem [Text]
faiPorts
  = lens _faiPorts (\ s a -> s{_faiPorts = a}) .
      _Default
      . _Coerce

instance FromJSON FirewallAllowedItem where
        parseJSON
          = withObject "FirewallAllowedItem"
              (\ o ->
                 FirewallAllowedItem' <$>
                   (o .:? "IPProtocol") <*> (o .:? "ports" .!= mempty))

instance ToJSON FirewallAllowedItem where
        toJSON FirewallAllowedItem'{..}
          = object
              (catMaybes
                 [("IPProtocol" .=) <$> _faiIPProtocol,
                  ("ports" .=) <$> _faiPorts])

-- | Description-tagged IP ranges for the router to advertise.
--
-- /See:/ 'routerAdvertisedIPRange' smart constructor.
data RouterAdvertisedIPRange =
  RouterAdvertisedIPRange'
    { _rairRange :: !(Maybe Text)
    , _rairDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RouterAdvertisedIPRange' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rairRange'
--
-- * 'rairDescription'
routerAdvertisedIPRange
    :: RouterAdvertisedIPRange
routerAdvertisedIPRange =
  RouterAdvertisedIPRange' {_rairRange = Nothing, _rairDescription = Nothing}


-- | The IP range to advertise. The value must be a CIDR-formatted string.
rairRange :: Lens' RouterAdvertisedIPRange (Maybe Text)
rairRange
  = lens _rairRange (\ s a -> s{_rairRange = a})

-- | User-specified description for the IP range.
rairDescription :: Lens' RouterAdvertisedIPRange (Maybe Text)
rairDescription
  = lens _rairDescription
      (\ s a -> s{_rairDescription = a})

instance FromJSON RouterAdvertisedIPRange where
        parseJSON
          = withObject "RouterAdvertisedIPRange"
              (\ o ->
                 RouterAdvertisedIPRange' <$>
                   (o .:? "range") <*> (o .:? "description"))

instance ToJSON RouterAdvertisedIPRange where
        toJSON RouterAdvertisedIPRange'{..}
          = object
              (catMaybes
                 [("range" .=) <$> _rairRange,
                  ("description" .=) <$> _rairDescription])

-- | A schedule for disks where the schedueled operations are performed.
--
-- /See:/ 'resourcePolicySnapshotSchedulePolicySchedule' smart constructor.
data ResourcePolicySnapshotSchedulePolicySchedule =
  ResourcePolicySnapshotSchedulePolicySchedule'
    { _rpsspsDailySchedule :: !(Maybe ResourcePolicyDailyCycle)
    , _rpsspsHourlySchedule :: !(Maybe ResourcePolicyHourlyCycle)
    , _rpsspsWeeklySchedule :: !(Maybe ResourcePolicyWeeklyCycle)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePolicySnapshotSchedulePolicySchedule' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rpsspsDailySchedule'
--
-- * 'rpsspsHourlySchedule'
--
-- * 'rpsspsWeeklySchedule'
resourcePolicySnapshotSchedulePolicySchedule
    :: ResourcePolicySnapshotSchedulePolicySchedule
resourcePolicySnapshotSchedulePolicySchedule =
  ResourcePolicySnapshotSchedulePolicySchedule'
    { _rpsspsDailySchedule = Nothing
    , _rpsspsHourlySchedule = Nothing
    , _rpsspsWeeklySchedule = Nothing
    }


rpsspsDailySchedule :: Lens' ResourcePolicySnapshotSchedulePolicySchedule (Maybe ResourcePolicyDailyCycle)
rpsspsDailySchedule
  = lens _rpsspsDailySchedule
      (\ s a -> s{_rpsspsDailySchedule = a})

rpsspsHourlySchedule :: Lens' ResourcePolicySnapshotSchedulePolicySchedule (Maybe ResourcePolicyHourlyCycle)
rpsspsHourlySchedule
  = lens _rpsspsHourlySchedule
      (\ s a -> s{_rpsspsHourlySchedule = a})

rpsspsWeeklySchedule :: Lens' ResourcePolicySnapshotSchedulePolicySchedule (Maybe ResourcePolicyWeeklyCycle)
rpsspsWeeklySchedule
  = lens _rpsspsWeeklySchedule
      (\ s a -> s{_rpsspsWeeklySchedule = a})

instance FromJSON
           ResourcePolicySnapshotSchedulePolicySchedule
         where
        parseJSON
          = withObject
              "ResourcePolicySnapshotSchedulePolicySchedule"
              (\ o ->
                 ResourcePolicySnapshotSchedulePolicySchedule' <$>
                   (o .:? "dailySchedule") <*> (o .:? "hourlySchedule")
                     <*> (o .:? "weeklySchedule"))

instance ToJSON
           ResourcePolicySnapshotSchedulePolicySchedule
         where
        toJSON
          ResourcePolicySnapshotSchedulePolicySchedule'{..}
          = object
              (catMaybes
                 [("dailySchedule" .=) <$> _rpsspsDailySchedule,
                  ("hourlySchedule" .=) <$> _rpsspsHourlySchedule,
                  ("weeklySchedule" .=) <$> _rpsspsWeeklySchedule])

--
-- /See:/ 'routerListWarningDataItem' smart constructor.
data RouterListWarningDataItem =
  RouterListWarningDataItem'
    { _rouValue :: !(Maybe Text)
    , _rouKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RouterListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rouValue'
--
-- * 'rouKey'
routerListWarningDataItem
    :: RouterListWarningDataItem
routerListWarningDataItem =
  RouterListWarningDataItem' {_rouValue = Nothing, _rouKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
rouValue :: Lens' RouterListWarningDataItem (Maybe Text)
rouValue = lens _rouValue (\ s a -> s{_rouValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
rouKey :: Lens' RouterListWarningDataItem (Maybe Text)
rouKey = lens _rouKey (\ s a -> s{_rouKey = a})

instance FromJSON RouterListWarningDataItem where
        parseJSON
          = withObject "RouterListWarningDataItem"
              (\ o ->
                 RouterListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON RouterListWarningDataItem where
        toJSON RouterListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _rouValue, ("key" .=) <$> _rouKey])

-- | A rule to be applied in a Policy.
--
-- /See:/ 'rule' smart constructor.
data Rule =
  Rule'
    { _rAction :: !(Maybe RuleAction)
    , _rNotIns :: !(Maybe [Text])
    , _rIns :: !(Maybe [Text])
    , _rLogConfigs :: !(Maybe [LogConfig])
    , _rConditions :: !(Maybe [Condition])
    , _rPermissions :: !(Maybe [Text])
    , _rDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Rule' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rAction'
--
-- * 'rNotIns'
--
-- * 'rIns'
--
-- * 'rLogConfigs'
--
-- * 'rConditions'
--
-- * 'rPermissions'
--
-- * 'rDescription'
rule
    :: Rule
rule =
  Rule'
    { _rAction = Nothing
    , _rNotIns = Nothing
    , _rIns = Nothing
    , _rLogConfigs = Nothing
    , _rConditions = Nothing
    , _rPermissions = Nothing
    , _rDescription = Nothing
    }


-- | Required
rAction :: Lens' Rule (Maybe RuleAction)
rAction = lens _rAction (\ s a -> s{_rAction = a})

-- | If one or more \'not_in\' clauses are specified, the rule matches if the
-- PRINCIPAL\/AUTHORITY_SELECTOR is in none of the entries.
rNotIns :: Lens' Rule [Text]
rNotIns
  = lens _rNotIns (\ s a -> s{_rNotIns = a}) . _Default
      . _Coerce

-- | If one or more \'in\' clauses are specified, the rule matches if the
-- PRINCIPAL\/AUTHORITY_SELECTOR is in at least one of these entries.
rIns :: Lens' Rule [Text]
rIns
  = lens _rIns (\ s a -> s{_rIns = a}) . _Default .
      _Coerce

-- | The config returned to callers of tech.iam.IAM.CheckPolicy for any
-- entries that match the LOG action.
rLogConfigs :: Lens' Rule [LogConfig]
rLogConfigs
  = lens _rLogConfigs (\ s a -> s{_rLogConfigs = a}) .
      _Default
      . _Coerce

-- | Additional restrictions that must be met. All conditions must pass for
-- the rule to match.
rConditions :: Lens' Rule [Condition]
rConditions
  = lens _rConditions (\ s a -> s{_rConditions = a}) .
      _Default
      . _Coerce

-- | A permission is a string of form \'..\' (e.g.,
-- \'storage.buckets.list\'). A value of \'*\' matches all permissions, and
-- a verb part of \'*\' (e.g., \'storage.buckets.*\') matches all verbs.
rPermissions :: Lens' Rule [Text]
rPermissions
  = lens _rPermissions (\ s a -> s{_rPermissions = a})
      . _Default
      . _Coerce

-- | Human-readable description of the rule.
rDescription :: Lens' Rule (Maybe Text)
rDescription
  = lens _rDescription (\ s a -> s{_rDescription = a})

instance FromJSON Rule where
        parseJSON
          = withObject "Rule"
              (\ o ->
                 Rule' <$>
                   (o .:? "action") <*> (o .:? "notIns" .!= mempty) <*>
                     (o .:? "ins" .!= mempty)
                     <*> (o .:? "logConfigs" .!= mempty)
                     <*> (o .:? "conditions" .!= mempty)
                     <*> (o .:? "permissions" .!= mempty)
                     <*> (o .:? "description"))

instance ToJSON Rule where
        toJSON Rule'{..}
          = object
              (catMaybes
                 [("action" .=) <$> _rAction,
                  ("notIns" .=) <$> _rNotIns, ("ins" .=) <$> _rIns,
                  ("logConfigs" .=) <$> _rLogConfigs,
                  ("conditions" .=) <$> _rConditions,
                  ("permissions" .=) <$> _rPermissions,
                  ("description" .=) <$> _rDescription])

--
-- /See:/ 'packetMirroringsScopedList' smart constructor.
data PacketMirroringsScopedList =
  PacketMirroringsScopedList'
    { _pmslPacketMirrorings :: !(Maybe [PacketMirroring])
    , _pmslWarning :: !(Maybe PacketMirroringsScopedListWarning)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PacketMirroringsScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pmslPacketMirrorings'
--
-- * 'pmslWarning'
packetMirroringsScopedList
    :: PacketMirroringsScopedList
packetMirroringsScopedList =
  PacketMirroringsScopedList'
    {_pmslPacketMirrorings = Nothing, _pmslWarning = Nothing}


-- | A list of packetMirrorings contained in this scope.
pmslPacketMirrorings :: Lens' PacketMirroringsScopedList [PacketMirroring]
pmslPacketMirrorings
  = lens _pmslPacketMirrorings
      (\ s a -> s{_pmslPacketMirrorings = a})
      . _Default
      . _Coerce

-- | Informational warning which replaces the list of packetMirrorings when
-- the list is empty.
pmslWarning :: Lens' PacketMirroringsScopedList (Maybe PacketMirroringsScopedListWarning)
pmslWarning
  = lens _pmslWarning (\ s a -> s{_pmslWarning = a})

instance FromJSON PacketMirroringsScopedList where
        parseJSON
          = withObject "PacketMirroringsScopedList"
              (\ o ->
                 PacketMirroringsScopedList' <$>
                   (o .:? "packetMirrorings" .!= mempty) <*>
                     (o .:? "warning"))

instance ToJSON PacketMirroringsScopedList where
        toJSON PacketMirroringsScopedList'{..}
          = object
              (catMaybes
                 [("packetMirrorings" .=) <$> _pmslPacketMirrorings,
                  ("warning" .=) <$> _pmslWarning])

-- | Contains a list of BackendServicesScopedList.
--
-- /See:/ 'backendServiceAggregatedList' smart constructor.
data BackendServiceAggregatedList =
  BackendServiceAggregatedList'
    { _bsalUnreachables :: !(Maybe [Text])
    , _bsalNextPageToken :: !(Maybe Text)
    , _bsalKind :: !Text
    , _bsalItems :: !(Maybe BackendServiceAggregatedListItems)
    , _bsalSelfLink :: !(Maybe Text)
    , _bsalWarning :: !(Maybe BackendServiceAggregatedListWarning)
    , _bsalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendServiceAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bsalUnreachables'
--
-- * 'bsalNextPageToken'
--
-- * 'bsalKind'
--
-- * 'bsalItems'
--
-- * 'bsalSelfLink'
--
-- * 'bsalWarning'
--
-- * 'bsalId'
backendServiceAggregatedList
    :: BackendServiceAggregatedList
backendServiceAggregatedList =
  BackendServiceAggregatedList'
    { _bsalUnreachables = Nothing
    , _bsalNextPageToken = Nothing
    , _bsalKind = "compute#backendServiceAggregatedList"
    , _bsalItems = Nothing
    , _bsalSelfLink = Nothing
    , _bsalWarning = Nothing
    , _bsalId = Nothing
    }


-- | [Output Only] Unreachable resources.
bsalUnreachables :: Lens' BackendServiceAggregatedList [Text]
bsalUnreachables
  = lens _bsalUnreachables
      (\ s a -> s{_bsalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
bsalNextPageToken :: Lens' BackendServiceAggregatedList (Maybe Text)
bsalNextPageToken
  = lens _bsalNextPageToken
      (\ s a -> s{_bsalNextPageToken = a})

-- | Type of resource.
bsalKind :: Lens' BackendServiceAggregatedList Text
bsalKind = lens _bsalKind (\ s a -> s{_bsalKind = a})

-- | A list of BackendServicesScopedList resources.
bsalItems :: Lens' BackendServiceAggregatedList (Maybe BackendServiceAggregatedListItems)
bsalItems
  = lens _bsalItems (\ s a -> s{_bsalItems = a})

-- | [Output Only] Server-defined URL for this resource.
bsalSelfLink :: Lens' BackendServiceAggregatedList (Maybe Text)
bsalSelfLink
  = lens _bsalSelfLink (\ s a -> s{_bsalSelfLink = a})

-- | [Output Only] Informational warning message.
bsalWarning :: Lens' BackendServiceAggregatedList (Maybe BackendServiceAggregatedListWarning)
bsalWarning
  = lens _bsalWarning (\ s a -> s{_bsalWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
bsalId :: Lens' BackendServiceAggregatedList (Maybe Text)
bsalId = lens _bsalId (\ s a -> s{_bsalId = a})

instance FromJSON BackendServiceAggregatedList where
        parseJSON
          = withObject "BackendServiceAggregatedList"
              (\ o ->
                 BackendServiceAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!=
                        "compute#backendServiceAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON BackendServiceAggregatedList where
        toJSON BackendServiceAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _bsalUnreachables,
                  ("nextPageToken" .=) <$> _bsalNextPageToken,
                  Just ("kind" .= _bsalKind),
                  ("items" .=) <$> _bsalItems,
                  ("selfLink" .=) <$> _bsalSelfLink,
                  ("warning" .=) <$> _bsalWarning,
                  ("id" .=) <$> _bsalId])

-- | Represents a VPC Network resource. Networks connect resources to each
-- other and to the internet. For more information, read Virtual Private
-- Cloud (VPC) Network. (== resource_for {$api_version}.networks ==)
--
-- /See:/ 'network' smart constructor.
data Network =
  Network'
    { _nMtu :: !(Maybe (Textual Int32))
    , _nAutoCreateSubnetworks :: !(Maybe Bool)
    , _nKind :: !Text
    , _nRoutingConfig :: !(Maybe NetworkRoutingConfig)
    , _nSubnetworks :: !(Maybe [Text])
    , _nIPv4Range :: !(Maybe Text)
    , _nSelfLink :: !(Maybe Text)
    , _nName :: !(Maybe Text)
    , _nCreationTimestamp :: !(Maybe Text)
    , _nId :: !(Maybe (Textual Word64))
    , _nGatewayIPv4 :: !(Maybe Text)
    , _nDescription :: !(Maybe Text)
    , _nPeerings :: !(Maybe [NetworkPeering])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Network' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nMtu'
--
-- * 'nAutoCreateSubnetworks'
--
-- * 'nKind'
--
-- * 'nRoutingConfig'
--
-- * 'nSubnetworks'
--
-- * 'nIPv4Range'
--
-- * 'nSelfLink'
--
-- * 'nName'
--
-- * 'nCreationTimestamp'
--
-- * 'nId'
--
-- * 'nGatewayIPv4'
--
-- * 'nDescription'
--
-- * 'nPeerings'
network
    :: Network
network =
  Network'
    { _nMtu = Nothing
    , _nAutoCreateSubnetworks = Nothing
    , _nKind = "compute#network"
    , _nRoutingConfig = Nothing
    , _nSubnetworks = Nothing
    , _nIPv4Range = Nothing
    , _nSelfLink = Nothing
    , _nName = Nothing
    , _nCreationTimestamp = Nothing
    , _nId = Nothing
    , _nGatewayIPv4 = Nothing
    , _nDescription = Nothing
    , _nPeerings = Nothing
    }


-- | Maximum Transmission Unit in bytes. The minimum value for this field is
-- 1460 and the maximum value is 1500 bytes.
nMtu :: Lens' Network (Maybe Int32)
nMtu
  = lens _nMtu (\ s a -> s{_nMtu = a}) .
      mapping _Coerce

-- | Must be set to create a VPC network. If not set, a legacy network is
-- created. When set to true, the VPC network is created in auto mode. When
-- set to false, the VPC network is created in custom mode. An auto mode
-- VPC network starts with one subnet per region. Each subnet has a
-- predetermined range as described in Auto mode VPC network IP ranges. For
-- custom mode VPC networks, you can add subnets using the subnetworks
-- insert method.
nAutoCreateSubnetworks :: Lens' Network (Maybe Bool)
nAutoCreateSubnetworks
  = lens _nAutoCreateSubnetworks
      (\ s a -> s{_nAutoCreateSubnetworks = a})

-- | [Output Only] Type of the resource. Always compute#network for networks.
nKind :: Lens' Network Text
nKind = lens _nKind (\ s a -> s{_nKind = a})

-- | The network-level routing configuration for this network. Used by Cloud
-- Router to determine what type of network-wide routing behavior to
-- enforce.
nRoutingConfig :: Lens' Network (Maybe NetworkRoutingConfig)
nRoutingConfig
  = lens _nRoutingConfig
      (\ s a -> s{_nRoutingConfig = a})

-- | [Output Only] Server-defined fully-qualified URLs for all subnetworks in
-- this VPC network.
nSubnetworks :: Lens' Network [Text]
nSubnetworks
  = lens _nSubnetworks (\ s a -> s{_nSubnetworks = a})
      . _Default
      . _Coerce

-- | Deprecated in favor of subnet mode networks. The range of internal
-- addresses that are legal on this network. This range is a CIDR
-- specification, for example: 192.168.0.0\/16. Provided by the client when
-- the network is created.
nIPv4Range :: Lens' Network (Maybe Text)
nIPv4Range
  = lens _nIPv4Range (\ s a -> s{_nIPv4Range = a})

-- | [Output Only] Server-defined URL for the resource.
nSelfLink :: Lens' Network (Maybe Text)
nSelfLink
  = lens _nSelfLink (\ s a -> s{_nSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\`. The first character
-- must be a lowercase letter, and all following characters (except for the
-- last character) must be a dash, lowercase letter, or digit. The last
-- character must be a lowercase letter or digit.
nName :: Lens' Network (Maybe Text)
nName = lens _nName (\ s a -> s{_nName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
nCreationTimestamp :: Lens' Network (Maybe Text)
nCreationTimestamp
  = lens _nCreationTimestamp
      (\ s a -> s{_nCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
nId :: Lens' Network (Maybe Word64)
nId
  = lens _nId (\ s a -> s{_nId = a}) . mapping _Coerce

-- | [Output Only] The gateway address for default routing out of the
-- network, selected by GCP.
nGatewayIPv4 :: Lens' Network (Maybe Text)
nGatewayIPv4
  = lens _nGatewayIPv4 (\ s a -> s{_nGatewayIPv4 = a})

-- | An optional description of this resource. Provide this field when you
-- create the resource.
nDescription :: Lens' Network (Maybe Text)
nDescription
  = lens _nDescription (\ s a -> s{_nDescription = a})

-- | [Output Only] A list of network peerings for the resource.
nPeerings :: Lens' Network [NetworkPeering]
nPeerings
  = lens _nPeerings (\ s a -> s{_nPeerings = a}) .
      _Default
      . _Coerce

instance FromJSON Network where
        parseJSON
          = withObject "Network"
              (\ o ->
                 Network' <$>
                   (o .:? "mtu") <*> (o .:? "autoCreateSubnetworks") <*>
                     (o .:? "kind" .!= "compute#network")
                     <*> (o .:? "routingConfig")
                     <*> (o .:? "subnetworks" .!= mempty)
                     <*> (o .:? "IPv4Range")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "gatewayIPv4")
                     <*> (o .:? "description")
                     <*> (o .:? "peerings" .!= mempty))

instance ToJSON Network where
        toJSON Network'{..}
          = object
              (catMaybes
                 [("mtu" .=) <$> _nMtu,
                  ("autoCreateSubnetworks" .=) <$>
                    _nAutoCreateSubnetworks,
                  Just ("kind" .= _nKind),
                  ("routingConfig" .=) <$> _nRoutingConfig,
                  ("subnetworks" .=) <$> _nSubnetworks,
                  ("IPv4Range" .=) <$> _nIPv4Range,
                  ("selfLink" .=) <$> _nSelfLink,
                  ("name" .=) <$> _nName,
                  ("creationTimestamp" .=) <$> _nCreationTimestamp,
                  ("id" .=) <$> _nId,
                  ("gatewayIPv4" .=) <$> _nGatewayIPv4,
                  ("description" .=) <$> _nDescription,
                  ("peerings" .=) <$> _nPeerings])

-- | Metadata defined as annotations on the network endpoint group.
--
-- /See:/ 'networkEndpointGroupAnnotations' smart constructor.
newtype NetworkEndpointGroupAnnotations =
  NetworkEndpointGroupAnnotations'
    { _negaAddtional :: HashMap Text Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkEndpointGroupAnnotations' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'negaAddtional'
networkEndpointGroupAnnotations
    :: HashMap Text Text -- ^ 'negaAddtional'
    -> NetworkEndpointGroupAnnotations
networkEndpointGroupAnnotations pNegaAddtional_ =
  NetworkEndpointGroupAnnotations' {_negaAddtional = _Coerce # pNegaAddtional_}


negaAddtional :: Lens' NetworkEndpointGroupAnnotations (HashMap Text Text)
negaAddtional
  = lens _negaAddtional
      (\ s a -> s{_negaAddtional = a})
      . _Coerce

instance FromJSON NetworkEndpointGroupAnnotations
         where
        parseJSON
          = withObject "NetworkEndpointGroupAnnotations"
              (\ o ->
                 NetworkEndpointGroupAnnotations' <$>
                   (parseJSONObject o))

instance ToJSON NetworkEndpointGroupAnnotations where
        toJSON = toJSON . _negaAddtional

-- | Informational warning which replaces the list of routers when the list
-- is empty.
--
-- /See:/ 'routersScopedListWarning' smart constructor.
data RoutersScopedListWarning =
  RoutersScopedListWarning'
    { _rslwData :: !(Maybe [RoutersScopedListWarningDataItem])
    , _rslwCode :: !(Maybe RoutersScopedListWarningCode)
    , _rslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RoutersScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rslwData'
--
-- * 'rslwCode'
--
-- * 'rslwMessage'
routersScopedListWarning
    :: RoutersScopedListWarning
routersScopedListWarning =
  RoutersScopedListWarning'
    {_rslwData = Nothing, _rslwCode = Nothing, _rslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
rslwData :: Lens' RoutersScopedListWarning [RoutersScopedListWarningDataItem]
rslwData
  = lens _rslwData (\ s a -> s{_rslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
rslwCode :: Lens' RoutersScopedListWarning (Maybe RoutersScopedListWarningCode)
rslwCode = lens _rslwCode (\ s a -> s{_rslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
rslwMessage :: Lens' RoutersScopedListWarning (Maybe Text)
rslwMessage
  = lens _rslwMessage (\ s a -> s{_rslwMessage = a})

instance FromJSON RoutersScopedListWarning where
        parseJSON
          = withObject "RoutersScopedListWarning"
              (\ o ->
                 RoutersScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON RoutersScopedListWarning where
        toJSON RoutersScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _rslwData,
                  ("code" .=) <$> _rslwCode,
                  ("message" .=) <$> _rslwMessage])

-- | Subnetwork which the current user has compute.subnetworks.use permission
-- on.
--
-- /See:/ 'usableSubnetwork' smart constructor.
data UsableSubnetwork =
  UsableSubnetwork'
    { _usNetwork :: !(Maybe Text)
    , _usSecondaryIPRanges :: !(Maybe [UsableSubnetworkSecondaryRange])
    , _usIPCIdRRange :: !(Maybe Text)
    , _usSubnetwork :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'UsableSubnetwork' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'usNetwork'
--
-- * 'usSecondaryIPRanges'
--
-- * 'usIPCIdRRange'
--
-- * 'usSubnetwork'
usableSubnetwork
    :: UsableSubnetwork
usableSubnetwork =
  UsableSubnetwork'
    { _usNetwork = Nothing
    , _usSecondaryIPRanges = Nothing
    , _usIPCIdRRange = Nothing
    , _usSubnetwork = Nothing
    }


-- | Network URL.
usNetwork :: Lens' UsableSubnetwork (Maybe Text)
usNetwork
  = lens _usNetwork (\ s a -> s{_usNetwork = a})

-- | Secondary IP ranges.
usSecondaryIPRanges :: Lens' UsableSubnetwork [UsableSubnetworkSecondaryRange]
usSecondaryIPRanges
  = lens _usSecondaryIPRanges
      (\ s a -> s{_usSecondaryIPRanges = a})
      . _Default
      . _Coerce

-- | The range of internal addresses that are owned by this subnetwork.
usIPCIdRRange :: Lens' UsableSubnetwork (Maybe Text)
usIPCIdRRange
  = lens _usIPCIdRRange
      (\ s a -> s{_usIPCIdRRange = a})

-- | Subnetwork URL.
usSubnetwork :: Lens' UsableSubnetwork (Maybe Text)
usSubnetwork
  = lens _usSubnetwork (\ s a -> s{_usSubnetwork = a})

instance FromJSON UsableSubnetwork where
        parseJSON
          = withObject "UsableSubnetwork"
              (\ o ->
                 UsableSubnetwork' <$>
                   (o .:? "network") <*>
                     (o .:? "secondaryIpRanges" .!= mempty)
                     <*> (o .:? "ipCidrRange")
                     <*> (o .:? "subnetwork"))

instance ToJSON UsableSubnetwork where
        toJSON UsableSubnetwork'{..}
          = object
              (catMaybes
                 [("network" .=) <$> _usNetwork,
                  ("secondaryIpRanges" .=) <$> _usSecondaryIPRanges,
                  ("ipCidrRange" .=) <$> _usIPCIdRRange,
                  ("subnetwork" .=) <$> _usSubnetwork])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'targetHTTPSProxyListWarning' smart constructor.
data TargetHTTPSProxyListWarning =
  TargetHTTPSProxyListWarning'
    { _thplwData :: !(Maybe [TargetHTTPSProxyListWarningDataItem])
    , _thplwCode :: !(Maybe TargetHTTPSProxyListWarningCode)
    , _thplwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetHTTPSProxyListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'thplwData'
--
-- * 'thplwCode'
--
-- * 'thplwMessage'
targetHTTPSProxyListWarning
    :: TargetHTTPSProxyListWarning
targetHTTPSProxyListWarning =
  TargetHTTPSProxyListWarning'
    {_thplwData = Nothing, _thplwCode = Nothing, _thplwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
thplwData :: Lens' TargetHTTPSProxyListWarning [TargetHTTPSProxyListWarningDataItem]
thplwData
  = lens _thplwData (\ s a -> s{_thplwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
thplwCode :: Lens' TargetHTTPSProxyListWarning (Maybe TargetHTTPSProxyListWarningCode)
thplwCode
  = lens _thplwCode (\ s a -> s{_thplwCode = a})

-- | [Output Only] A human-readable description of the warning code.
thplwMessage :: Lens' TargetHTTPSProxyListWarning (Maybe Text)
thplwMessage
  = lens _thplwMessage (\ s a -> s{_thplwMessage = a})

instance FromJSON TargetHTTPSProxyListWarning where
        parseJSON
          = withObject "TargetHTTPSProxyListWarning"
              (\ o ->
                 TargetHTTPSProxyListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON TargetHTTPSProxyListWarning where
        toJSON TargetHTTPSProxyListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _thplwData,
                  ("code" .=) <$> _thplwCode,
                  ("message" .=) <$> _thplwMessage])

-- | [Output Only] Informational warning which replaces the list of addresses
-- when the list is empty.
--
-- /See:/ 'addressesScopedListWarning' smart constructor.
data AddressesScopedListWarning =
  AddressesScopedListWarning'
    { _aData :: !(Maybe [AddressesScopedListWarningDataItem])
    , _aCode :: !(Maybe AddressesScopedListWarningCode)
    , _aMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AddressesScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'aData'
--
-- * 'aCode'
--
-- * 'aMessage'
addressesScopedListWarning
    :: AddressesScopedListWarning
addressesScopedListWarning =
  AddressesScopedListWarning'
    {_aData = Nothing, _aCode = Nothing, _aMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
aData :: Lens' AddressesScopedListWarning [AddressesScopedListWarningDataItem]
aData
  = lens _aData (\ s a -> s{_aData = a}) . _Default .
      _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
aCode :: Lens' AddressesScopedListWarning (Maybe AddressesScopedListWarningCode)
aCode = lens _aCode (\ s a -> s{_aCode = a})

-- | [Output Only] A human-readable description of the warning code.
aMessage :: Lens' AddressesScopedListWarning (Maybe Text)
aMessage = lens _aMessage (\ s a -> s{_aMessage = a})

instance FromJSON AddressesScopedListWarning where
        parseJSON
          = withObject "AddressesScopedListWarning"
              (\ o ->
                 AddressesScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON AddressesScopedListWarning where
        toJSON AddressesScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _aData, ("code" .=) <$> _aCode,
                  ("message" .=) <$> _aMessage])

-- | Represents a Google Cloud Armor security policy resource. Only external
-- backend services that use load balancers can reference a security
-- policy. For more information, see Google Cloud Armor security policy
-- overview. (== resource_for {$api_version}.securityPolicies ==)
--
-- /See:/ 'securityPolicy' smart constructor.
data SecurityPolicy =
  SecurityPolicy'
    { _secAdvancedOptionsConfig :: !(Maybe SecurityPolicyAdvancedOptionsConfig)
    , _secRules :: !(Maybe [SecurityPolicyRule])
    , _secKind :: !Text
    , _secFingerprint :: !(Maybe Bytes)
    , _secSelfLink :: !(Maybe Text)
    , _secName :: !(Maybe Text)
    , _secCreationTimestamp :: !(Maybe Text)
    , _secId :: !(Maybe (Textual Word64))
    , _secDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SecurityPolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'secAdvancedOptionsConfig'
--
-- * 'secRules'
--
-- * 'secKind'
--
-- * 'secFingerprint'
--
-- * 'secSelfLink'
--
-- * 'secName'
--
-- * 'secCreationTimestamp'
--
-- * 'secId'
--
-- * 'secDescription'
securityPolicy
    :: SecurityPolicy
securityPolicy =
  SecurityPolicy'
    { _secAdvancedOptionsConfig = Nothing
    , _secRules = Nothing
    , _secKind = "compute#securityPolicy"
    , _secFingerprint = Nothing
    , _secSelfLink = Nothing
    , _secName = Nothing
    , _secCreationTimestamp = Nothing
    , _secId = Nothing
    , _secDescription = Nothing
    }


secAdvancedOptionsConfig :: Lens' SecurityPolicy (Maybe SecurityPolicyAdvancedOptionsConfig)
secAdvancedOptionsConfig
  = lens _secAdvancedOptionsConfig
      (\ s a -> s{_secAdvancedOptionsConfig = a})

-- | A list of rules that belong to this policy. There must always be a
-- default rule (rule with priority 2147483647 and match \"*\"). If no
-- rules are provided when creating a security policy, a default rule with
-- action \"allow\" will be added.
secRules :: Lens' SecurityPolicy [SecurityPolicyRule]
secRules
  = lens _secRules (\ s a -> s{_secRules = a}) .
      _Default
      . _Coerce

-- | [Output only] Type of the resource. Always compute#securityPolicyfor
-- security policies
secKind :: Lens' SecurityPolicy Text
secKind = lens _secKind (\ s a -> s{_secKind = a})

-- | Specifies a fingerprint for this resource, which is essentially a hash
-- of the metadata\'s contents and used for optimistic locking. The
-- fingerprint is initially generated by Compute Engine and changes after
-- every request to modify or update metadata. You must always provide an
-- up-to-date fingerprint hash in order to update or change metadata,
-- otherwise the request will fail with error 412 conditionNotMet. To see
-- the latest fingerprint, make get() request to the security policy.
secFingerprint :: Lens' SecurityPolicy (Maybe ByteString)
secFingerprint
  = lens _secFingerprint
      (\ s a -> s{_secFingerprint = a})
      . mapping _Bytes

-- | [Output Only] Server-defined URL for the resource.
secSelfLink :: Lens' SecurityPolicy (Maybe Text)
secSelfLink
  = lens _secSelfLink (\ s a -> s{_secSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
secName :: Lens' SecurityPolicy (Maybe Text)
secName = lens _secName (\ s a -> s{_secName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
secCreationTimestamp :: Lens' SecurityPolicy (Maybe Text)
secCreationTimestamp
  = lens _secCreationTimestamp
      (\ s a -> s{_secCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
secId :: Lens' SecurityPolicy (Maybe Word64)
secId
  = lens _secId (\ s a -> s{_secId = a}) .
      mapping _Coerce

-- | An optional description of this resource. Provide this property when you
-- create the resource.
secDescription :: Lens' SecurityPolicy (Maybe Text)
secDescription
  = lens _secDescription
      (\ s a -> s{_secDescription = a})

instance FromJSON SecurityPolicy where
        parseJSON
          = withObject "SecurityPolicy"
              (\ o ->
                 SecurityPolicy' <$>
                   (o .:? "advancedOptionsConfig") <*>
                     (o .:? "rules" .!= mempty)
                     <*> (o .:? "kind" .!= "compute#securityPolicy")
                     <*> (o .:? "fingerprint")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "description"))

instance ToJSON SecurityPolicy where
        toJSON SecurityPolicy'{..}
          = object
              (catMaybes
                 [("advancedOptionsConfig" .=) <$>
                    _secAdvancedOptionsConfig,
                  ("rules" .=) <$> _secRules,
                  Just ("kind" .= _secKind),
                  ("fingerprint" .=) <$> _secFingerprint,
                  ("selfLink" .=) <$> _secSelfLink,
                  ("name" .=) <$> _secName,
                  ("creationTimestamp" .=) <$> _secCreationTimestamp,
                  ("id" .=) <$> _secId,
                  ("description" .=) <$> _secDescription])

--
-- /See:/ 'instanceGroupAggregatedListWarningDataItem' smart constructor.
data InstanceGroupAggregatedListWarningDataItem =
  InstanceGroupAggregatedListWarningDataItem'
    { _igalwdiValue :: !(Maybe Text)
    , _igalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igalwdiValue'
--
-- * 'igalwdiKey'
instanceGroupAggregatedListWarningDataItem
    :: InstanceGroupAggregatedListWarningDataItem
instanceGroupAggregatedListWarningDataItem =
  InstanceGroupAggregatedListWarningDataItem'
    {_igalwdiValue = Nothing, _igalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
igalwdiValue :: Lens' InstanceGroupAggregatedListWarningDataItem (Maybe Text)
igalwdiValue
  = lens _igalwdiValue (\ s a -> s{_igalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
igalwdiKey :: Lens' InstanceGroupAggregatedListWarningDataItem (Maybe Text)
igalwdiKey
  = lens _igalwdiKey (\ s a -> s{_igalwdiKey = a})

instance FromJSON
           InstanceGroupAggregatedListWarningDataItem
         where
        parseJSON
          = withObject
              "InstanceGroupAggregatedListWarningDataItem"
              (\ o ->
                 InstanceGroupAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           InstanceGroupAggregatedListWarningDataItem
         where
        toJSON
          InstanceGroupAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _igalwdiValue,
                  ("key" .=) <$> _igalwdiKey])

-- | Time window specified for daily maintenance operations. GCE\'s internal
-- maintenance will be performed within this window.
--
-- /See:/ 'nodeGroupMaintenanceWindow' smart constructor.
data NodeGroupMaintenanceWindow =
  NodeGroupMaintenanceWindow'
    { _ngmwStartTime :: !(Maybe Text)
    , _ngmwMaintenanceDuration :: !(Maybe Duration)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeGroupMaintenanceWindow' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ngmwStartTime'
--
-- * 'ngmwMaintenanceDuration'
nodeGroupMaintenanceWindow
    :: NodeGroupMaintenanceWindow
nodeGroupMaintenanceWindow =
  NodeGroupMaintenanceWindow'
    {_ngmwStartTime = Nothing, _ngmwMaintenanceDuration = Nothing}


-- | Start time of the window. This must be in UTC format that resolves to
-- one of 00:00, 04:00, 08:00, 12:00, 16:00, or 20:00. For example, both
-- 13:00-5 and 08:00 are valid.
ngmwStartTime :: Lens' NodeGroupMaintenanceWindow (Maybe Text)
ngmwStartTime
  = lens _ngmwStartTime
      (\ s a -> s{_ngmwStartTime = a})

-- | [Output only] A predetermined duration for the window, automatically
-- chosen to be the smallest possible in the given scenario.
ngmwMaintenanceDuration :: Lens' NodeGroupMaintenanceWindow (Maybe Duration)
ngmwMaintenanceDuration
  = lens _ngmwMaintenanceDuration
      (\ s a -> s{_ngmwMaintenanceDuration = a})

instance FromJSON NodeGroupMaintenanceWindow where
        parseJSON
          = withObject "NodeGroupMaintenanceWindow"
              (\ o ->
                 NodeGroupMaintenanceWindow' <$>
                   (o .:? "startTime") <*>
                     (o .:? "maintenanceDuration"))

instance ToJSON NodeGroupMaintenanceWindow where
        toJSON NodeGroupMaintenanceWindow'{..}
          = object
              (catMaybes
                 [("startTime" .=) <$> _ngmwStartTime,
                  ("maintenanceDuration" .=) <$>
                    _ngmwMaintenanceDuration])

-- | The parameters of the raw disk image.
--
-- /See:/ 'imageRawDisk' smart constructor.
data ImageRawDisk =
  ImageRawDisk'
    { _irdContainerType :: !(Maybe ImageRawDiskContainerType)
    , _irdSource :: !(Maybe Text)
    , _irdSha1Checksum :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ImageRawDisk' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'irdContainerType'
--
-- * 'irdSource'
--
-- * 'irdSha1Checksum'
imageRawDisk
    :: ImageRawDisk
imageRawDisk =
  ImageRawDisk'
    { _irdContainerType = Nothing
    , _irdSource = Nothing
    , _irdSha1Checksum = Nothing
    }


-- | The format used to encode and transmit the block device, which should be
-- TAR. This is just a container and transmission format and not a runtime
-- format. Provided by the client when the disk image is created.
irdContainerType :: Lens' ImageRawDisk (Maybe ImageRawDiskContainerType)
irdContainerType
  = lens _irdContainerType
      (\ s a -> s{_irdContainerType = a})

-- | The full Google Cloud Storage URL where the disk image is stored. In
-- order to create an image, you must provide the full or partial URL of
-- one of the following: - The rawDisk.source URL - The sourceDisk URL -
-- The sourceImage URL - The sourceSnapshot URL
irdSource :: Lens' ImageRawDisk (Maybe Text)
irdSource
  = lens _irdSource (\ s a -> s{_irdSource = a})

-- | [Deprecated] This field is deprecated. An optional SHA1 checksum of the
-- disk image before unpackaging provided by the client when the disk image
-- is created.
irdSha1Checksum :: Lens' ImageRawDisk (Maybe Text)
irdSha1Checksum
  = lens _irdSha1Checksum
      (\ s a -> s{_irdSha1Checksum = a})

instance FromJSON ImageRawDisk where
        parseJSON
          = withObject "ImageRawDisk"
              (\ o ->
                 ImageRawDisk' <$>
                   (o .:? "containerType") <*> (o .:? "source") <*>
                     (o .:? "sha1Checksum"))

instance ToJSON ImageRawDisk where
        toJSON ImageRawDisk'{..}
          = object
              (catMaybes
                 [("containerType" .=) <$> _irdContainerType,
                  ("source" .=) <$> _irdSource,
                  ("sha1Checksum" .=) <$> _irdSha1Checksum])

--
-- /See:/ 'instanceAggregatedList' smart constructor.
data InstanceAggregatedList =
  InstanceAggregatedList'
    { _ialUnreachables :: !(Maybe [Text])
    , _ialNextPageToken :: !(Maybe Text)
    , _ialKind :: !Text
    , _ialItems :: !(Maybe InstanceAggregatedListItems)
    , _ialSelfLink :: !(Maybe Text)
    , _ialWarning :: !(Maybe InstanceAggregatedListWarning)
    , _ialId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ialUnreachables'
--
-- * 'ialNextPageToken'
--
-- * 'ialKind'
--
-- * 'ialItems'
--
-- * 'ialSelfLink'
--
-- * 'ialWarning'
--
-- * 'ialId'
instanceAggregatedList
    :: InstanceAggregatedList
instanceAggregatedList =
  InstanceAggregatedList'
    { _ialUnreachables = Nothing
    , _ialNextPageToken = Nothing
    , _ialKind = "compute#instanceAggregatedList"
    , _ialItems = Nothing
    , _ialSelfLink = Nothing
    , _ialWarning = Nothing
    , _ialId = Nothing
    }


-- | [Output Only] Unreachable resources.
ialUnreachables :: Lens' InstanceAggregatedList [Text]
ialUnreachables
  = lens _ialUnreachables
      (\ s a -> s{_ialUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
ialNextPageToken :: Lens' InstanceAggregatedList (Maybe Text)
ialNextPageToken
  = lens _ialNextPageToken
      (\ s a -> s{_ialNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#instanceAggregatedList
-- for aggregated lists of Instance resources.
ialKind :: Lens' InstanceAggregatedList Text
ialKind = lens _ialKind (\ s a -> s{_ialKind = a})

-- | An object that contains a list of instances scoped by zone.
ialItems :: Lens' InstanceAggregatedList (Maybe InstanceAggregatedListItems)
ialItems = lens _ialItems (\ s a -> s{_ialItems = a})

-- | [Output Only] Server-defined URL for this resource.
ialSelfLink :: Lens' InstanceAggregatedList (Maybe Text)
ialSelfLink
  = lens _ialSelfLink (\ s a -> s{_ialSelfLink = a})

-- | [Output Only] Informational warning message.
ialWarning :: Lens' InstanceAggregatedList (Maybe InstanceAggregatedListWarning)
ialWarning
  = lens _ialWarning (\ s a -> s{_ialWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
ialId :: Lens' InstanceAggregatedList (Maybe Text)
ialId = lens _ialId (\ s a -> s{_ialId = a})

instance FromJSON InstanceAggregatedList where
        parseJSON
          = withObject "InstanceAggregatedList"
              (\ o ->
                 InstanceAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!= "compute#instanceAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON InstanceAggregatedList where
        toJSON InstanceAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _ialUnreachables,
                  ("nextPageToken" .=) <$> _ialNextPageToken,
                  Just ("kind" .= _ialKind),
                  ("items" .=) <$> _ialItems,
                  ("selfLink" .=) <$> _ialSelfLink,
                  ("warning" .=) <$> _ialWarning,
                  ("id" .=) <$> _ialId])

--
-- /See:/ 'forwardingRuleReference' smart constructor.
newtype ForwardingRuleReference =
  ForwardingRuleReference'
    { _frrForwardingRule :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ForwardingRuleReference' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'frrForwardingRule'
forwardingRuleReference
    :: ForwardingRuleReference
forwardingRuleReference =
  ForwardingRuleReference' {_frrForwardingRule = Nothing}


frrForwardingRule :: Lens' ForwardingRuleReference (Maybe Text)
frrForwardingRule
  = lens _frrForwardingRule
      (\ s a -> s{_frrForwardingRule = a})

instance FromJSON ForwardingRuleReference where
        parseJSON
          = withObject "ForwardingRuleReference"
              (\ o ->
                 ForwardingRuleReference' <$>
                   (o .:? "forwardingRule"))

instance ToJSON ForwardingRuleReference where
        toJSON ForwardingRuleReference'{..}
          = object
              (catMaybes
                 [("forwardingRule" .=) <$> _frrForwardingRule])

-- | Represents a notification endpoint. A notification endpoint resource
-- defines an endpoint to receive notifications when there are status
-- changes detected by the associated health check service. For more
-- information, see Health checks overview. (== resource_for
-- {$api_version}.notificationEndpoint ==) (== resource_for
-- {$api_version}.regionNotificationEndpoints ==)
--
-- /See:/ 'notificationEndpoint' smart constructor.
data NotificationEndpoint =
  NotificationEndpoint'
    { _neKind :: !Text
    , _neSelfLink :: !(Maybe Text)
    , _neName :: !(Maybe Text)
    , _neCreationTimestamp :: !(Maybe Text)
    , _neId :: !(Maybe (Textual Word64))
    , _neRegion :: !(Maybe Text)
    , _neGrpcSettings :: !(Maybe NotificationEndpointGrpcSettings)
    , _neDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NotificationEndpoint' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'neKind'
--
-- * 'neSelfLink'
--
-- * 'neName'
--
-- * 'neCreationTimestamp'
--
-- * 'neId'
--
-- * 'neRegion'
--
-- * 'neGrpcSettings'
--
-- * 'neDescription'
notificationEndpoint
    :: NotificationEndpoint
notificationEndpoint =
  NotificationEndpoint'
    { _neKind = "compute#notificationEndpoint"
    , _neSelfLink = Nothing
    , _neName = Nothing
    , _neCreationTimestamp = Nothing
    , _neId = Nothing
    , _neRegion = Nothing
    , _neGrpcSettings = Nothing
    , _neDescription = Nothing
    }


-- | [Output Only] Type of the resource. Always compute#notificationEndpoint
-- for notification endpoints.
neKind :: Lens' NotificationEndpoint Text
neKind = lens _neKind (\ s a -> s{_neKind = a})

-- | [Output Only] Server-defined URL for the resource.
neSelfLink :: Lens' NotificationEndpoint (Maybe Text)
neSelfLink
  = lens _neSelfLink (\ s a -> s{_neSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
neName :: Lens' NotificationEndpoint (Maybe Text)
neName = lens _neName (\ s a -> s{_neName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
neCreationTimestamp :: Lens' NotificationEndpoint (Maybe Text)
neCreationTimestamp
  = lens _neCreationTimestamp
      (\ s a -> s{_neCreationTimestamp = a})

-- | [Output Only] A unique identifier for this resource type. The server
-- generates this identifier.
neId :: Lens' NotificationEndpoint (Maybe Word64)
neId
  = lens _neId (\ s a -> s{_neId = a}) .
      mapping _Coerce

-- | [Output Only] URL of the region where the notification endpoint resides.
-- This field applies only to the regional resource. You must specify this
-- field as part of the HTTP request URL. It is not settable as a field in
-- the request body.
neRegion :: Lens' NotificationEndpoint (Maybe Text)
neRegion = lens _neRegion (\ s a -> s{_neRegion = a})

-- | Settings of the gRPC notification endpoint including the endpoint URL
-- and the retry duration.
neGrpcSettings :: Lens' NotificationEndpoint (Maybe NotificationEndpointGrpcSettings)
neGrpcSettings
  = lens _neGrpcSettings
      (\ s a -> s{_neGrpcSettings = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource.
neDescription :: Lens' NotificationEndpoint (Maybe Text)
neDescription
  = lens _neDescription
      (\ s a -> s{_neDescription = a})

instance FromJSON NotificationEndpoint where
        parseJSON
          = withObject "NotificationEndpoint"
              (\ o ->
                 NotificationEndpoint' <$>
                   (o .:? "kind" .!= "compute#notificationEndpoint") <*>
                     (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "region")
                     <*> (o .:? "grpcSettings")
                     <*> (o .:? "description"))

instance ToJSON NotificationEndpoint where
        toJSON NotificationEndpoint'{..}
          = object
              (catMaybes
                 [Just ("kind" .= _neKind),
                  ("selfLink" .=) <$> _neSelfLink,
                  ("name" .=) <$> _neName,
                  ("creationTimestamp" .=) <$> _neCreationTimestamp,
                  ("id" .=) <$> _neId, ("region" .=) <$> _neRegion,
                  ("grpcSettings" .=) <$> _neGrpcSettings,
                  ("description" .=) <$> _neDescription])

--
-- /See:/ 'targetTCPProxiesSetBackendServiceRequest' smart constructor.
newtype TargetTCPProxiesSetBackendServiceRequest =
  TargetTCPProxiesSetBackendServiceRequest'
    { _ttpsbsrService :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetTCPProxiesSetBackendServiceRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ttpsbsrService'
targetTCPProxiesSetBackendServiceRequest
    :: TargetTCPProxiesSetBackendServiceRequest
targetTCPProxiesSetBackendServiceRequest =
  TargetTCPProxiesSetBackendServiceRequest' {_ttpsbsrService = Nothing}


-- | The URL of the new BackendService resource for the targetTcpProxy.
ttpsbsrService :: Lens' TargetTCPProxiesSetBackendServiceRequest (Maybe Text)
ttpsbsrService
  = lens _ttpsbsrService
      (\ s a -> s{_ttpsbsrService = a})

instance FromJSON
           TargetTCPProxiesSetBackendServiceRequest
         where
        parseJSON
          = withObject
              "TargetTCPProxiesSetBackendServiceRequest"
              (\ o ->
                 TargetTCPProxiesSetBackendServiceRequest' <$>
                   (o .:? "service"))

instance ToJSON
           TargetTCPProxiesSetBackendServiceRequest
         where
        toJSON TargetTCPProxiesSetBackendServiceRequest'{..}
          = object
              (catMaybes [("service" .=) <$> _ttpsbsrService])

-- | RegionInstanceGroupManagers.patchPerInstanceConfigs
--
-- /See:/ 'regionInstanceGroupManagerPatchInstanceConfigReq' smart constructor.
newtype RegionInstanceGroupManagerPatchInstanceConfigReq =
  RegionInstanceGroupManagerPatchInstanceConfigReq'
    { _rigmpicrPerInstanceConfigs :: Maybe [PerInstanceConfig]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupManagerPatchInstanceConfigReq' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rigmpicrPerInstanceConfigs'
regionInstanceGroupManagerPatchInstanceConfigReq
    :: RegionInstanceGroupManagerPatchInstanceConfigReq
regionInstanceGroupManagerPatchInstanceConfigReq =
  RegionInstanceGroupManagerPatchInstanceConfigReq'
    {_rigmpicrPerInstanceConfigs = Nothing}


-- | The list of per-instance configs to insert or patch on this managed
-- instance group.
rigmpicrPerInstanceConfigs :: Lens' RegionInstanceGroupManagerPatchInstanceConfigReq [PerInstanceConfig]
rigmpicrPerInstanceConfigs
  = lens _rigmpicrPerInstanceConfigs
      (\ s a -> s{_rigmpicrPerInstanceConfigs = a})
      . _Default
      . _Coerce

instance FromJSON
           RegionInstanceGroupManagerPatchInstanceConfigReq
         where
        parseJSON
          = withObject
              "RegionInstanceGroupManagerPatchInstanceConfigReq"
              (\ o ->
                 RegionInstanceGroupManagerPatchInstanceConfigReq' <$>
                   (o .:? "perInstanceConfigs" .!= mempty))

instance ToJSON
           RegionInstanceGroupManagerPatchInstanceConfigReq
         where
        toJSON
          RegionInstanceGroupManagerPatchInstanceConfigReq'{..}
          = object
              (catMaybes
                 [("perInstanceConfigs" .=) <$>
                    _rigmpicrPerInstanceConfigs])

--
-- /See:/ 'sslHealthCheck' smart constructor.
data SSLHealthCheck =
  SSLHealthCheck'
    { _shcResponse :: !(Maybe Text)
    , _shcPortSpecification :: !(Maybe SSLHealthCheckPortSpecification)
    , _shcProxyHeader :: !(Maybe SSLHealthCheckProxyHeader)
    , _shcPortName :: !(Maybe Text)
    , _shcPort :: !(Maybe (Textual Int32))
    , _shcRequest :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SSLHealthCheck' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'shcResponse'
--
-- * 'shcPortSpecification'
--
-- * 'shcProxyHeader'
--
-- * 'shcPortName'
--
-- * 'shcPort'
--
-- * 'shcRequest'
sslHealthCheck
    :: SSLHealthCheck
sslHealthCheck =
  SSLHealthCheck'
    { _shcResponse = Nothing
    , _shcPortSpecification = Nothing
    , _shcProxyHeader = Nothing
    , _shcPortName = Nothing
    , _shcPort = Nothing
    , _shcRequest = Nothing
    }


-- | The bytes to match against the beginning of the response data. If left
-- empty (the default value), any response will indicate health. The
-- response data can only be ASCII.
shcResponse :: Lens' SSLHealthCheck (Maybe Text)
shcResponse
  = lens _shcResponse (\ s a -> s{_shcResponse = a})

-- | Specifies how port is selected for health checking, can be one of
-- following values: USE_FIXED_PORT: The port number in port is used for
-- health checking. USE_NAMED_PORT: The portName is used for health
-- checking. USE_SERVING_PORT: For NetworkEndpointGroup, the port specified
-- for each network endpoint is used for health checking. For other
-- backends, the port or named port specified in the Backend Service is
-- used for health checking. If not specified, SSL health check follows
-- behavior specified in port and portName fields.
shcPortSpecification :: Lens' SSLHealthCheck (Maybe SSLHealthCheckPortSpecification)
shcPortSpecification
  = lens _shcPortSpecification
      (\ s a -> s{_shcPortSpecification = a})

-- | Specifies the type of proxy header to append before sending data to the
-- backend, either NONE or PROXY_V1. The default is NONE.
shcProxyHeader :: Lens' SSLHealthCheck (Maybe SSLHealthCheckProxyHeader)
shcProxyHeader
  = lens _shcProxyHeader
      (\ s a -> s{_shcProxyHeader = a})

-- | Port name as defined in InstanceGroup#NamedPort#name. If both port and
-- port_name are defined, port takes precedence.
shcPortName :: Lens' SSLHealthCheck (Maybe Text)
shcPortName
  = lens _shcPortName (\ s a -> s{_shcPortName = a})

-- | The TCP port number for the health check request. The default value is
-- 443. Valid values are 1 through 65535.
shcPort :: Lens' SSLHealthCheck (Maybe Int32)
shcPort
  = lens _shcPort (\ s a -> s{_shcPort = a}) .
      mapping _Coerce

-- | The application data to send once the SSL connection has been
-- established (default value is empty). If both request and response are
-- empty, the connection establishment alone will indicate health. The
-- request data can only be ASCII.
shcRequest :: Lens' SSLHealthCheck (Maybe Text)
shcRequest
  = lens _shcRequest (\ s a -> s{_shcRequest = a})

instance FromJSON SSLHealthCheck where
        parseJSON
          = withObject "SSLHealthCheck"
              (\ o ->
                 SSLHealthCheck' <$>
                   (o .:? "response") <*> (o .:? "portSpecification")
                     <*> (o .:? "proxyHeader")
                     <*> (o .:? "portName")
                     <*> (o .:? "port")
                     <*> (o .:? "request"))

instance ToJSON SSLHealthCheck where
        toJSON SSLHealthCheck'{..}
          = object
              (catMaybes
                 [("response" .=) <$> _shcResponse,
                  ("portSpecification" .=) <$> _shcPortSpecification,
                  ("proxyHeader" .=) <$> _shcProxyHeader,
                  ("portName" .=) <$> _shcPortName,
                  ("port" .=) <$> _shcPort,
                  ("request" .=) <$> _shcRequest])

-- | Use global external addresses for GFE-based external HTTP(S) load
-- balancers in Premium Tier. Use global internal addresses for reserved
-- peering network range. Use regional external addresses for the following
-- resources: - External IP addresses for VM instances - Regional external
-- forwarding rules - Cloud NAT external IP addresses - GFE based LBs in
-- Standard Tier - Network LBs in Premium or Standard Tier - Cloud VPN
-- gateways (both Classic and HA) Use regional internal IP addresses for
-- subnet IP ranges (primary and secondary). This includes: - Internal IP
-- addresses for VM instances - Alias IP ranges of VM instances (\/32 only)
-- - Regional internal forwarding rules - Internal TCP\/UDP load balancer
-- addresses - Internal HTTP(S) load balancer addresses - Cloud DNS inbound
-- forwarding IP addresses For more information, read reserved IP address.
-- (== resource_for {$api_version}.addresses ==) (== resource_for
-- {$api_version}.globalAddresses ==)
--
-- /See:/ 'address' smart constructor.
data Address =
  Address'
    { _aPrefixLength :: !(Maybe (Textual Int32))
    , _aNetworkTier :: !(Maybe AddressNetworkTier)
    , _aStatus :: !(Maybe AddressStatus)
    , _aUsers :: !(Maybe [Text])
    , _aKind :: !Text
    , _aIPVersion :: !(Maybe AddressIPVersion)
    , _aNetwork :: !(Maybe Text)
    , _aAddress :: !(Maybe Text)
    , _aPurpose :: !(Maybe AddressPurpose)
    , _aSelfLink :: !(Maybe Text)
    , _aName :: !(Maybe Text)
    , _aCreationTimestamp :: !(Maybe Text)
    , _aSubnetwork :: !(Maybe Text)
    , _aId :: !(Maybe (Textual Word64))
    , _aRegion :: !(Maybe Text)
    , _aDescription :: !(Maybe Text)
    , _aAddressType :: !(Maybe AddressAddressType)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Address' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'aPrefixLength'
--
-- * 'aNetworkTier'
--
-- * 'aStatus'
--
-- * 'aUsers'
--
-- * 'aKind'
--
-- * 'aIPVersion'
--
-- * 'aNetwork'
--
-- * 'aAddress'
--
-- * 'aPurpose'
--
-- * 'aSelfLink'
--
-- * 'aName'
--
-- * 'aCreationTimestamp'
--
-- * 'aSubnetwork'
--
-- * 'aId'
--
-- * 'aRegion'
--
-- * 'aDescription'
--
-- * 'aAddressType'
address
    :: Address
address =
  Address'
    { _aPrefixLength = Nothing
    , _aNetworkTier = Nothing
    , _aStatus = Nothing
    , _aUsers = Nothing
    , _aKind = "compute#address"
    , _aIPVersion = Nothing
    , _aNetwork = Nothing
    , _aAddress = Nothing
    , _aPurpose = Nothing
    , _aSelfLink = Nothing
    , _aName = Nothing
    , _aCreationTimestamp = Nothing
    , _aSubnetwork = Nothing
    , _aId = Nothing
    , _aRegion = Nothing
    , _aDescription = Nothing
    , _aAddressType = Nothing
    }


-- | The prefix length if the resource represents an IP range.
aPrefixLength :: Lens' Address (Maybe Int32)
aPrefixLength
  = lens _aPrefixLength
      (\ s a -> s{_aPrefixLength = a})
      . mapping _Coerce

-- | This signifies the networking tier used for configuring this address and
-- can only take the following values: PREMIUM or STANDARD. Global
-- forwarding rules can only be Premium Tier. Regional forwarding rules can
-- be either Premium or Standard Tier. Standard Tier addresses applied to
-- regional forwarding rules can be used with any external load balancer.
-- Regional forwarding rules in Premium Tier can only be used with a
-- network load balancer. If this field is not specified, it is assumed to
-- be PREMIUM.
aNetworkTier :: Lens' Address (Maybe AddressNetworkTier)
aNetworkTier
  = lens _aNetworkTier (\ s a -> s{_aNetworkTier = a})

-- | [Output Only] The status of the address, which can be one of RESERVING,
-- RESERVED, or IN_USE. An address that is RESERVING is currently in the
-- process of being reserved. A RESERVED address is currently reserved and
-- available to use. An IN_USE address is currently being used by another
-- resource and is not available.
aStatus :: Lens' Address (Maybe AddressStatus)
aStatus = lens _aStatus (\ s a -> s{_aStatus = a})

-- | [Output Only] The URLs of the resources that are using this address.
aUsers :: Lens' Address [Text]
aUsers
  = lens _aUsers (\ s a -> s{_aUsers = a}) . _Default .
      _Coerce

-- | [Output Only] Type of the resource. Always compute#address for
-- addresses.
aKind :: Lens' Address Text
aKind = lens _aKind (\ s a -> s{_aKind = a})

-- | The IP version that will be used by this address. Valid options are IPV4
-- or IPV6. This can only be specified for a global address.
aIPVersion :: Lens' Address (Maybe AddressIPVersion)
aIPVersion
  = lens _aIPVersion (\ s a -> s{_aIPVersion = a})

-- | The URL of the network in which to reserve the address. This field can
-- only be used with INTERNAL type with the VPC_PEERING purpose.
aNetwork :: Lens' Address (Maybe Text)
aNetwork = lens _aNetwork (\ s a -> s{_aNetwork = a})

-- | The static IP address represented by this resource.
aAddress :: Lens' Address (Maybe Text)
aAddress = lens _aAddress (\ s a -> s{_aAddress = a})

-- | The purpose of this resource, which can be one of the following values:
-- - \`GCE_ENDPOINT\` for addresses that are used by VM instances, alias IP
-- ranges, internal load balancers, and similar resources. -
-- \`DNS_RESOLVER\` for a DNS resolver address in a subnetwork -
-- \`VPC_PEERING\` for addresses that are reserved for VPC peer networks. -
-- \`NAT_AUTO\` for addresses that are external IP addresses automatically
-- reserved for Cloud NAT. - \`IPSEC_INTERCONNECT\` for addresses created
-- from a private IP range that are reserved for a VLAN attachment in an
-- IPsec-encrypted Cloud Interconnect configuration. These addresses are
-- regional resources. Not currently available publicly.
aPurpose :: Lens' Address (Maybe AddressPurpose)
aPurpose = lens _aPurpose (\ s a -> s{_aPurpose = a})

-- | [Output Only] Server-defined URL for the resource.
aSelfLink :: Lens' Address (Maybe Text)
aSelfLink
  = lens _aSelfLink (\ s a -> s{_aSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\`. The first character
-- must be a lowercase letter, and all following characters (except for the
-- last character) must be a dash, lowercase letter, or digit. The last
-- character must be a lowercase letter or digit.
aName :: Lens' Address (Maybe Text)
aName = lens _aName (\ s a -> s{_aName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
aCreationTimestamp :: Lens' Address (Maybe Text)
aCreationTimestamp
  = lens _aCreationTimestamp
      (\ s a -> s{_aCreationTimestamp = a})

-- | The URL of the subnetwork in which to reserve the address. If an IP
-- address is specified, it must be within the subnetwork\'s IP range. This
-- field can only be used with INTERNAL type with a GCE_ENDPOINT or
-- DNS_RESOLVER purpose.
aSubnetwork :: Lens' Address (Maybe Text)
aSubnetwork
  = lens _aSubnetwork (\ s a -> s{_aSubnetwork = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
aId :: Lens' Address (Maybe Word64)
aId
  = lens _aId (\ s a -> s{_aId = a}) . mapping _Coerce

-- | [Output Only] The URL of the region where a regional address resides.
-- For regional addresses, you must specify the region as a path parameter
-- in the HTTP request URL. This field is not applicable to global
-- addresses.
aRegion :: Lens' Address (Maybe Text)
aRegion = lens _aRegion (\ s a -> s{_aRegion = a})

-- | An optional description of this resource. Provide this field when you
-- create the resource.
aDescription :: Lens' Address (Maybe Text)
aDescription
  = lens _aDescription (\ s a -> s{_aDescription = a})

-- | The type of address to reserve, either INTERNAL or EXTERNAL. If
-- unspecified, defaults to EXTERNAL.
aAddressType :: Lens' Address (Maybe AddressAddressType)
aAddressType
  = lens _aAddressType (\ s a -> s{_aAddressType = a})

instance FromJSON Address where
        parseJSON
          = withObject "Address"
              (\ o ->
                 Address' <$>
                   (o .:? "prefixLength") <*> (o .:? "networkTier") <*>
                     (o .:? "status")
                     <*> (o .:? "users" .!= mempty)
                     <*> (o .:? "kind" .!= "compute#address")
                     <*> (o .:? "ipVersion")
                     <*> (o .:? "network")
                     <*> (o .:? "address")
                     <*> (o .:? "purpose")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "subnetwork")
                     <*> (o .:? "id")
                     <*> (o .:? "region")
                     <*> (o .:? "description")
                     <*> (o .:? "addressType"))

instance ToJSON Address where
        toJSON Address'{..}
          = object
              (catMaybes
                 [("prefixLength" .=) <$> _aPrefixLength,
                  ("networkTier" .=) <$> _aNetworkTier,
                  ("status" .=) <$> _aStatus, ("users" .=) <$> _aUsers,
                  Just ("kind" .= _aKind),
                  ("ipVersion" .=) <$> _aIPVersion,
                  ("network" .=) <$> _aNetwork,
                  ("address" .=) <$> _aAddress,
                  ("purpose" .=) <$> _aPurpose,
                  ("selfLink" .=) <$> _aSelfLink,
                  ("name" .=) <$> _aName,
                  ("creationTimestamp" .=) <$> _aCreationTimestamp,
                  ("subnetwork" .=) <$> _aSubnetwork,
                  ("id" .=) <$> _aId, ("region" .=) <$> _aRegion,
                  ("description" .=) <$> _aDescription,
                  ("addressType" .=) <$> _aAddressType])

-- | A list of NodeGroupsScopedList resources.
--
-- /See:/ 'nodeGroupAggregatedListItems' smart constructor.
newtype NodeGroupAggregatedListItems =
  NodeGroupAggregatedListItems'
    { _ngaliAddtional :: HashMap Text NodeGroupsScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeGroupAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ngaliAddtional'
nodeGroupAggregatedListItems
    :: HashMap Text NodeGroupsScopedList -- ^ 'ngaliAddtional'
    -> NodeGroupAggregatedListItems
nodeGroupAggregatedListItems pNgaliAddtional_ =
  NodeGroupAggregatedListItems' {_ngaliAddtional = _Coerce # pNgaliAddtional_}


-- | [Output Only] Name of the scope containing this set of node groups.
ngaliAddtional :: Lens' NodeGroupAggregatedListItems (HashMap Text NodeGroupsScopedList)
ngaliAddtional
  = lens _ngaliAddtional
      (\ s a -> s{_ngaliAddtional = a})
      . _Coerce

instance FromJSON NodeGroupAggregatedListItems where
        parseJSON
          = withObject "NodeGroupAggregatedListItems"
              (\ o ->
                 NodeGroupAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON NodeGroupAggregatedListItems where
        toJSON = toJSON . _ngaliAddtional

-- | [Output Only] Informational warning message.
--
-- /See:/ 'instanceGroupListWarning' smart constructor.
data InstanceGroupListWarning =
  InstanceGroupListWarning'
    { _iglwData :: !(Maybe [InstanceGroupListWarningDataItem])
    , _iglwCode :: !(Maybe InstanceGroupListWarningCode)
    , _iglwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iglwData'
--
-- * 'iglwCode'
--
-- * 'iglwMessage'
instanceGroupListWarning
    :: InstanceGroupListWarning
instanceGroupListWarning =
  InstanceGroupListWarning'
    {_iglwData = Nothing, _iglwCode = Nothing, _iglwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
iglwData :: Lens' InstanceGroupListWarning [InstanceGroupListWarningDataItem]
iglwData
  = lens _iglwData (\ s a -> s{_iglwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
iglwCode :: Lens' InstanceGroupListWarning (Maybe InstanceGroupListWarningCode)
iglwCode = lens _iglwCode (\ s a -> s{_iglwCode = a})

-- | [Output Only] A human-readable description of the warning code.
iglwMessage :: Lens' InstanceGroupListWarning (Maybe Text)
iglwMessage
  = lens _iglwMessage (\ s a -> s{_iglwMessage = a})

instance FromJSON InstanceGroupListWarning where
        parseJSON
          = withObject "InstanceGroupListWarning"
              (\ o ->
                 InstanceGroupListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON InstanceGroupListWarning where
        toJSON InstanceGroupListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _iglwData,
                  ("code" .=) <$> _iglwCode,
                  ("message" .=) <$> _iglwMessage])

-- | Labels to apply to this disk. These can be later modified by the
-- disks.setLabels method. This field is only applicable for persistent
-- disks.
--
-- /See:/ 'attachedDiskInitializeParamsLabels' smart constructor.
newtype AttachedDiskInitializeParamsLabels =
  AttachedDiskInitializeParamsLabels'
    { _adiplAddtional :: HashMap Text Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AttachedDiskInitializeParamsLabels' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'adiplAddtional'
attachedDiskInitializeParamsLabels
    :: HashMap Text Text -- ^ 'adiplAddtional'
    -> AttachedDiskInitializeParamsLabels
attachedDiskInitializeParamsLabels pAdiplAddtional_ =
  AttachedDiskInitializeParamsLabels'
    {_adiplAddtional = _Coerce # pAdiplAddtional_}


adiplAddtional :: Lens' AttachedDiskInitializeParamsLabels (HashMap Text Text)
adiplAddtional
  = lens _adiplAddtional
      (\ s a -> s{_adiplAddtional = a})
      . _Coerce

instance FromJSON AttachedDiskInitializeParamsLabels
         where
        parseJSON
          = withObject "AttachedDiskInitializeParamsLabels"
              (\ o ->
                 AttachedDiskInitializeParamsLabels' <$>
                   (parseJSONObject o))

instance ToJSON AttachedDiskInitializeParamsLabels
         where
        toJSON = toJSON . _adiplAddtional

-- | InstanceGroupManagers.deletePerInstanceConfigs
--
-- /See:/ 'instanceGroupManagersDeletePerInstanceConfigsReq' smart constructor.
newtype InstanceGroupManagersDeletePerInstanceConfigsReq =
  InstanceGroupManagersDeletePerInstanceConfigsReq'
    { _igmdpicrNames :: Maybe [Text]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagersDeletePerInstanceConfigsReq' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmdpicrNames'
instanceGroupManagersDeletePerInstanceConfigsReq
    :: InstanceGroupManagersDeletePerInstanceConfigsReq
instanceGroupManagersDeletePerInstanceConfigsReq =
  InstanceGroupManagersDeletePerInstanceConfigsReq' {_igmdpicrNames = Nothing}


-- | The list of instance names for which we want to delete per-instance
-- configs on this managed instance group.
igmdpicrNames :: Lens' InstanceGroupManagersDeletePerInstanceConfigsReq [Text]
igmdpicrNames
  = lens _igmdpicrNames
      (\ s a -> s{_igmdpicrNames = a})
      . _Default
      . _Coerce

instance FromJSON
           InstanceGroupManagersDeletePerInstanceConfigsReq
         where
        parseJSON
          = withObject
              "InstanceGroupManagersDeletePerInstanceConfigsReq"
              (\ o ->
                 InstanceGroupManagersDeletePerInstanceConfigsReq' <$>
                   (o .:? "names" .!= mempty))

instance ToJSON
           InstanceGroupManagersDeletePerInstanceConfigsReq
         where
        toJSON
          InstanceGroupManagersDeletePerInstanceConfigsReq'{..}
          = object
              (catMaybes [("names" .=) <$> _igmdpicrNames])

--
-- /See:/ 'statefulPolicyPreservedStateDiskDevice' smart constructor.
newtype StatefulPolicyPreservedStateDiskDevice =
  StatefulPolicyPreservedStateDiskDevice'
    { _sppsddAutoDelete :: Maybe StatefulPolicyPreservedStateDiskDeviceAutoDelete
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'StatefulPolicyPreservedStateDiskDevice' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sppsddAutoDelete'
statefulPolicyPreservedStateDiskDevice
    :: StatefulPolicyPreservedStateDiskDevice
statefulPolicyPreservedStateDiskDevice =
  StatefulPolicyPreservedStateDiskDevice' {_sppsddAutoDelete = Nothing}


-- | These stateful disks will never be deleted during autohealing, update or
-- VM instance recreate operations. This flag is used to configure if the
-- disk should be deleted after it is no longer used by the group, e.g.
-- when the given instance or the whole group is deleted. Note: disks
-- attached in READ_ONLY mode cannot be auto-deleted.
sppsddAutoDelete :: Lens' StatefulPolicyPreservedStateDiskDevice (Maybe StatefulPolicyPreservedStateDiskDeviceAutoDelete)
sppsddAutoDelete
  = lens _sppsddAutoDelete
      (\ s a -> s{_sppsddAutoDelete = a})

instance FromJSON
           StatefulPolicyPreservedStateDiskDevice
         where
        parseJSON
          = withObject "StatefulPolicyPreservedStateDiskDevice"
              (\ o ->
                 StatefulPolicyPreservedStateDiskDevice' <$>
                   (o .:? "autoDelete"))

instance ToJSON
           StatefulPolicyPreservedStateDiskDevice
         where
        toJSON StatefulPolicyPreservedStateDiskDevice'{..}
          = object
              (catMaybes [("autoDelete" .=) <$> _sppsddAutoDelete])

-- | Represents a Zone resource. A zone is a deployment area. These
-- deployment areas are subsets of a region. For example the zone
-- us-east1-a is located in the us-east1 region. For more information, read
-- Regions and Zones. (== resource_for {$api_version}.zones ==)
--
-- /See:/ 'zone' smart constructor.
data Zone =
  Zone'
    { _zStatus :: !(Maybe ZoneStatus)
    , _zKind :: !Text
    , _zSelfLink :: !(Maybe Text)
    , _zName :: !(Maybe Text)
    , _zCreationTimestamp :: !(Maybe Text)
    , _zSupportsPzs :: !(Maybe Bool)
    , _zId :: !(Maybe (Textual Word64))
    , _zRegion :: !(Maybe Text)
    , _zAvailableCPUPlatforms :: !(Maybe [Text])
    , _zDescription :: !(Maybe Text)
    , _zDeprecated :: !(Maybe DeprecationStatus)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Zone' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'zStatus'
--
-- * 'zKind'
--
-- * 'zSelfLink'
--
-- * 'zName'
--
-- * 'zCreationTimestamp'
--
-- * 'zSupportsPzs'
--
-- * 'zId'
--
-- * 'zRegion'
--
-- * 'zAvailableCPUPlatforms'
--
-- * 'zDescription'
--
-- * 'zDeprecated'
zone
    :: Zone
zone =
  Zone'
    { _zStatus = Nothing
    , _zKind = "compute#zone"
    , _zSelfLink = Nothing
    , _zName = Nothing
    , _zCreationTimestamp = Nothing
    , _zSupportsPzs = Nothing
    , _zId = Nothing
    , _zRegion = Nothing
    , _zAvailableCPUPlatforms = Nothing
    , _zDescription = Nothing
    , _zDeprecated = Nothing
    }


-- | [Output Only] Status of the zone, either UP or DOWN.
zStatus :: Lens' Zone (Maybe ZoneStatus)
zStatus = lens _zStatus (\ s a -> s{_zStatus = a})

-- | [Output Only] Type of the resource. Always compute#zone for zones.
zKind :: Lens' Zone Text
zKind = lens _zKind (\ s a -> s{_zKind = a})

-- | [Output Only] Server-defined URL for the resource.
zSelfLink :: Lens' Zone (Maybe Text)
zSelfLink
  = lens _zSelfLink (\ s a -> s{_zSelfLink = a})

-- | [Output Only] Name of the resource.
zName :: Lens' Zone (Maybe Text)
zName = lens _zName (\ s a -> s{_zName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
zCreationTimestamp :: Lens' Zone (Maybe Text)
zCreationTimestamp
  = lens _zCreationTimestamp
      (\ s a -> s{_zCreationTimestamp = a})

-- | [Output Only] Reserved for future use.
zSupportsPzs :: Lens' Zone (Maybe Bool)
zSupportsPzs
  = lens _zSupportsPzs (\ s a -> s{_zSupportsPzs = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
zId :: Lens' Zone (Maybe Word64)
zId
  = lens _zId (\ s a -> s{_zId = a}) . mapping _Coerce

-- | [Output Only] Full URL reference to the region which hosts the zone.
zRegion :: Lens' Zone (Maybe Text)
zRegion = lens _zRegion (\ s a -> s{_zRegion = a})

-- | [Output Only] Available cpu\/platform selections for the zone.
zAvailableCPUPlatforms :: Lens' Zone [Text]
zAvailableCPUPlatforms
  = lens _zAvailableCPUPlatforms
      (\ s a -> s{_zAvailableCPUPlatforms = a})
      . _Default
      . _Coerce

-- | [Output Only] Textual description of the resource.
zDescription :: Lens' Zone (Maybe Text)
zDescription
  = lens _zDescription (\ s a -> s{_zDescription = a})

-- | [Output Only] The deprecation status associated with this zone.
zDeprecated :: Lens' Zone (Maybe DeprecationStatus)
zDeprecated
  = lens _zDeprecated (\ s a -> s{_zDeprecated = a})

instance FromJSON Zone where
        parseJSON
          = withObject "Zone"
              (\ o ->
                 Zone' <$>
                   (o .:? "status") <*>
                     (o .:? "kind" .!= "compute#zone")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "supportsPzs")
                     <*> (o .:? "id")
                     <*> (o .:? "region")
                     <*> (o .:? "availableCpuPlatforms" .!= mempty)
                     <*> (o .:? "description")
                     <*> (o .:? "deprecated"))

instance ToJSON Zone where
        toJSON Zone'{..}
          = object
              (catMaybes
                 [("status" .=) <$> _zStatus, Just ("kind" .= _zKind),
                  ("selfLink" .=) <$> _zSelfLink,
                  ("name" .=) <$> _zName,
                  ("creationTimestamp" .=) <$> _zCreationTimestamp,
                  ("supportsPzs" .=) <$> _zSupportsPzs,
                  ("id" .=) <$> _zId, ("region" .=) <$> _zRegion,
                  ("availableCpuPlatforms" .=) <$>
                    _zAvailableCPUPlatforms,
                  ("description" .=) <$> _zDescription,
                  ("deprecated" .=) <$> _zDeprecated])

--
-- /See:/ 'routerBGP' smart constructor.
data RouterBGP =
  RouterBGP'
    { _rbKeepaliveInterval :: !(Maybe (Textual Word32))
    , _rbASN :: !(Maybe (Textual Word32))
    , _rbAdvertiseMode :: !(Maybe RouterBGPAdvertiseMode)
    , _rbAdvertisedGroups :: !(Maybe [RouterBGPAdvertisedGroupsItem])
    , _rbAdvertisedIPRanges :: !(Maybe [RouterAdvertisedIPRange])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RouterBGP' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rbKeepaliveInterval'
--
-- * 'rbASN'
--
-- * 'rbAdvertiseMode'
--
-- * 'rbAdvertisedGroups'
--
-- * 'rbAdvertisedIPRanges'
routerBGP
    :: RouterBGP
routerBGP =
  RouterBGP'
    { _rbKeepaliveInterval = Nothing
    , _rbASN = Nothing
    , _rbAdvertiseMode = Nothing
    , _rbAdvertisedGroups = Nothing
    , _rbAdvertisedIPRanges = Nothing
    }


-- | The interval in seconds between BGP keepalive messages that are sent to
-- the peer. Hold time is three times the interval at which keepalive
-- messages are sent, and the hold time is the maximum number of seconds
-- allowed to elapse between successive keepalive messages that BGP
-- receives from a peer. BGP will use the smaller of either the local hold
-- time value or the peer\'s hold time value as the hold time for the BGP
-- connection between the two peers. If set, this value must be between 20
-- and 60. The default is 20.
rbKeepaliveInterval :: Lens' RouterBGP (Maybe Word32)
rbKeepaliveInterval
  = lens _rbKeepaliveInterval
      (\ s a -> s{_rbKeepaliveInterval = a})
      . mapping _Coerce

-- | Local BGP Autonomous System Number (ASN). Must be an RFC6996 private
-- ASN, either 16-bit or 32-bit. The value will be fixed for this router
-- resource. All VPN tunnels that link to this router will have the same
-- local ASN.
rbASN :: Lens' RouterBGP (Maybe Word32)
rbASN
  = lens _rbASN (\ s a -> s{_rbASN = a}) .
      mapping _Coerce

-- | User-specified flag to indicate which mode to use for advertisement. The
-- options are DEFAULT or CUSTOM.
rbAdvertiseMode :: Lens' RouterBGP (Maybe RouterBGPAdvertiseMode)
rbAdvertiseMode
  = lens _rbAdvertiseMode
      (\ s a -> s{_rbAdvertiseMode = a})

-- | User-specified list of prefix groups to advertise in custom mode. This
-- field can only be populated if advertise_mode is CUSTOM and is
-- advertised to all peers of the router. These groups will be advertised
-- in addition to any specified prefixes. Leave this field blank to
-- advertise no custom groups.
rbAdvertisedGroups :: Lens' RouterBGP [RouterBGPAdvertisedGroupsItem]
rbAdvertisedGroups
  = lens _rbAdvertisedGroups
      (\ s a -> s{_rbAdvertisedGroups = a})
      . _Default
      . _Coerce

-- | User-specified list of individual IP ranges to advertise in custom mode.
-- This field can only be populated if advertise_mode is CUSTOM and is
-- advertised to all peers of the router. These IP ranges will be
-- advertised in addition to any specified groups. Leave this field blank
-- to advertise no custom IP ranges.
rbAdvertisedIPRanges :: Lens' RouterBGP [RouterAdvertisedIPRange]
rbAdvertisedIPRanges
  = lens _rbAdvertisedIPRanges
      (\ s a -> s{_rbAdvertisedIPRanges = a})
      . _Default
      . _Coerce

instance FromJSON RouterBGP where
        parseJSON
          = withObject "RouterBGP"
              (\ o ->
                 RouterBGP' <$>
                   (o .:? "keepaliveInterval") <*> (o .:? "asn") <*>
                     (o .:? "advertiseMode")
                     <*> (o .:? "advertisedGroups" .!= mempty)
                     <*> (o .:? "advertisedIpRanges" .!= mempty))

instance ToJSON RouterBGP where
        toJSON RouterBGP'{..}
          = object
              (catMaybes
                 [("keepaliveInterval" .=) <$> _rbKeepaliveInterval,
                  ("asn" .=) <$> _rbASN,
                  ("advertiseMode" .=) <$> _rbAdvertiseMode,
                  ("advertisedGroups" .=) <$> _rbAdvertisedGroups,
                  ("advertisedIpRanges" .=) <$> _rbAdvertisedIPRanges])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'firewallListWarning' smart constructor.
data FirewallListWarning =
  FirewallListWarning'
    { _flwData :: !(Maybe [FirewallListWarningDataItem])
    , _flwCode :: !(Maybe FirewallListWarningCode)
    , _flwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'FirewallListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'flwData'
--
-- * 'flwCode'
--
-- * 'flwMessage'
firewallListWarning
    :: FirewallListWarning
firewallListWarning =
  FirewallListWarning'
    {_flwData = Nothing, _flwCode = Nothing, _flwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
flwData :: Lens' FirewallListWarning [FirewallListWarningDataItem]
flwData
  = lens _flwData (\ s a -> s{_flwData = a}) . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
flwCode :: Lens' FirewallListWarning (Maybe FirewallListWarningCode)
flwCode = lens _flwCode (\ s a -> s{_flwCode = a})

-- | [Output Only] A human-readable description of the warning code.
flwMessage :: Lens' FirewallListWarning (Maybe Text)
flwMessage
  = lens _flwMessage (\ s a -> s{_flwMessage = a})

instance FromJSON FirewallListWarning where
        parseJSON
          = withObject "FirewallListWarning"
              (\ o ->
                 FirewallListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON FirewallListWarning where
        toJSON FirewallListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _flwData, ("code" .=) <$> _flwCode,
                  ("message" .=) <$> _flwMessage])

--
-- /See:/ 'backendServicesScopedList' smart constructor.
data BackendServicesScopedList =
  BackendServicesScopedList'
    { _bsslWarning :: !(Maybe BackendServicesScopedListWarning)
    , _bsslBackendServices :: !(Maybe [BackendService])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendServicesScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bsslWarning'
--
-- * 'bsslBackendServices'
backendServicesScopedList
    :: BackendServicesScopedList
backendServicesScopedList =
  BackendServicesScopedList'
    {_bsslWarning = Nothing, _bsslBackendServices = Nothing}


-- | Informational warning which replaces the list of backend services when
-- the list is empty.
bsslWarning :: Lens' BackendServicesScopedList (Maybe BackendServicesScopedListWarning)
bsslWarning
  = lens _bsslWarning (\ s a -> s{_bsslWarning = a})

-- | A list of BackendServices contained in this scope.
bsslBackendServices :: Lens' BackendServicesScopedList [BackendService]
bsslBackendServices
  = lens _bsslBackendServices
      (\ s a -> s{_bsslBackendServices = a})
      . _Default
      . _Coerce

instance FromJSON BackendServicesScopedList where
        parseJSON
          = withObject "BackendServicesScopedList"
              (\ o ->
                 BackendServicesScopedList' <$>
                   (o .:? "warning") <*>
                     (o .:? "backendServices" .!= mempty))

instance ToJSON BackendServicesScopedList where
        toJSON BackendServicesScopedList'{..}
          = object
              (catMaybes
                 [("warning" .=) <$> _bsslWarning,
                  ("backendServices" .=) <$> _bsslBackendServices])

-- | Contains a list of packetMirrorings.
--
-- /See:/ 'packetMirroringAggregatedList' smart constructor.
data PacketMirroringAggregatedList =
  PacketMirroringAggregatedList'
    { _pmalUnreachables :: !(Maybe [Text])
    , _pmalNextPageToken :: !(Maybe Text)
    , _pmalKind :: !Text
    , _pmalItems :: !(Maybe PacketMirroringAggregatedListItems)
    , _pmalSelfLink :: !(Maybe Text)
    , _pmalWarning :: !(Maybe PacketMirroringAggregatedListWarning)
    , _pmalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PacketMirroringAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pmalUnreachables'
--
-- * 'pmalNextPageToken'
--
-- * 'pmalKind'
--
-- * 'pmalItems'
--
-- * 'pmalSelfLink'
--
-- * 'pmalWarning'
--
-- * 'pmalId'
packetMirroringAggregatedList
    :: PacketMirroringAggregatedList
packetMirroringAggregatedList =
  PacketMirroringAggregatedList'
    { _pmalUnreachables = Nothing
    , _pmalNextPageToken = Nothing
    , _pmalKind = "compute#packetMirroringAggregatedList"
    , _pmalItems = Nothing
    , _pmalSelfLink = Nothing
    , _pmalWarning = Nothing
    , _pmalId = Nothing
    }


-- | [Output Only] Unreachable resources.
pmalUnreachables :: Lens' PacketMirroringAggregatedList [Text]
pmalUnreachables
  = lens _pmalUnreachables
      (\ s a -> s{_pmalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
pmalNextPageToken :: Lens' PacketMirroringAggregatedList (Maybe Text)
pmalNextPageToken
  = lens _pmalNextPageToken
      (\ s a -> s{_pmalNextPageToken = a})

-- | Type of resource.
pmalKind :: Lens' PacketMirroringAggregatedList Text
pmalKind = lens _pmalKind (\ s a -> s{_pmalKind = a})

-- | A list of PacketMirroring resources.
pmalItems :: Lens' PacketMirroringAggregatedList (Maybe PacketMirroringAggregatedListItems)
pmalItems
  = lens _pmalItems (\ s a -> s{_pmalItems = a})

-- | [Output Only] Server-defined URL for this resource.
pmalSelfLink :: Lens' PacketMirroringAggregatedList (Maybe Text)
pmalSelfLink
  = lens _pmalSelfLink (\ s a -> s{_pmalSelfLink = a})

-- | [Output Only] Informational warning message.
pmalWarning :: Lens' PacketMirroringAggregatedList (Maybe PacketMirroringAggregatedListWarning)
pmalWarning
  = lens _pmalWarning (\ s a -> s{_pmalWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
pmalId :: Lens' PacketMirroringAggregatedList (Maybe Text)
pmalId = lens _pmalId (\ s a -> s{_pmalId = a})

instance FromJSON PacketMirroringAggregatedList where
        parseJSON
          = withObject "PacketMirroringAggregatedList"
              (\ o ->
                 PacketMirroringAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!=
                        "compute#packetMirroringAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON PacketMirroringAggregatedList where
        toJSON PacketMirroringAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _pmalUnreachables,
                  ("nextPageToken" .=) <$> _pmalNextPageToken,
                  Just ("kind" .= _pmalKind),
                  ("items" .=) <$> _pmalItems,
                  ("selfLink" .=) <$> _pmalSelfLink,
                  ("warning" .=) <$> _pmalWarning,
                  ("id" .=) <$> _pmalId])

--
-- /See:/ 'instanceGroupManagersRecreateInstancesRequest' smart constructor.
newtype InstanceGroupManagersRecreateInstancesRequest =
  InstanceGroupManagersRecreateInstancesRequest'
    { _igmrirInstances :: Maybe [Text]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagersRecreateInstancesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmrirInstances'
instanceGroupManagersRecreateInstancesRequest
    :: InstanceGroupManagersRecreateInstancesRequest
instanceGroupManagersRecreateInstancesRequest =
  InstanceGroupManagersRecreateInstancesRequest' {_igmrirInstances = Nothing}


-- | The URLs of one or more instances to recreate. This can be a full URL or
-- a partial URL, such as zones\/[ZONE]\/instances\/[INSTANCE_NAME].
igmrirInstances :: Lens' InstanceGroupManagersRecreateInstancesRequest [Text]
igmrirInstances
  = lens _igmrirInstances
      (\ s a -> s{_igmrirInstances = a})
      . _Default
      . _Coerce

instance FromJSON
           InstanceGroupManagersRecreateInstancesRequest
         where
        parseJSON
          = withObject
              "InstanceGroupManagersRecreateInstancesRequest"
              (\ o ->
                 InstanceGroupManagersRecreateInstancesRequest' <$>
                   (o .:? "instances" .!= mempty))

instance ToJSON
           InstanceGroupManagersRecreateInstancesRequest
         where
        toJSON
          InstanceGroupManagersRecreateInstancesRequest'{..}
          = object
              (catMaybes [("instances" .=) <$> _igmrirInstances])

-- | Metadata defined as annotations on the network endpoint group.
--
-- /See:/ 'backendServiceGroupHealthAnnotations' smart constructor.
newtype BackendServiceGroupHealthAnnotations =
  BackendServiceGroupHealthAnnotations'
    { _bsghaAddtional :: HashMap Text Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendServiceGroupHealthAnnotations' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bsghaAddtional'
backendServiceGroupHealthAnnotations
    :: HashMap Text Text -- ^ 'bsghaAddtional'
    -> BackendServiceGroupHealthAnnotations
backendServiceGroupHealthAnnotations pBsghaAddtional_ =
  BackendServiceGroupHealthAnnotations'
    {_bsghaAddtional = _Coerce # pBsghaAddtional_}


bsghaAddtional :: Lens' BackendServiceGroupHealthAnnotations (HashMap Text Text)
bsghaAddtional
  = lens _bsghaAddtional
      (\ s a -> s{_bsghaAddtional = a})
      . _Coerce

instance FromJSON
           BackendServiceGroupHealthAnnotations
         where
        parseJSON
          = withObject "BackendServiceGroupHealthAnnotations"
              (\ o ->
                 BackendServiceGroupHealthAnnotations' <$>
                   (parseJSONObject o))

instance ToJSON BackendServiceGroupHealthAnnotations
         where
        toJSON = toJSON . _bsghaAddtional

--
-- /See:/ 'healthChecksAggregatedList' smart constructor.
data HealthChecksAggregatedList =
  HealthChecksAggregatedList'
    { _hcalUnreachables :: !(Maybe [Text])
    , _hcalNextPageToken :: !(Maybe Text)
    , _hcalKind :: !Text
    , _hcalItems :: !(Maybe HealthChecksAggregatedListItems)
    , _hcalSelfLink :: !(Maybe Text)
    , _hcalWarning :: !(Maybe HealthChecksAggregatedListWarning)
    , _hcalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HealthChecksAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hcalUnreachables'
--
-- * 'hcalNextPageToken'
--
-- * 'hcalKind'
--
-- * 'hcalItems'
--
-- * 'hcalSelfLink'
--
-- * 'hcalWarning'
--
-- * 'hcalId'
healthChecksAggregatedList
    :: HealthChecksAggregatedList
healthChecksAggregatedList =
  HealthChecksAggregatedList'
    { _hcalUnreachables = Nothing
    , _hcalNextPageToken = Nothing
    , _hcalKind = "compute#healthChecksAggregatedList"
    , _hcalItems = Nothing
    , _hcalSelfLink = Nothing
    , _hcalWarning = Nothing
    , _hcalId = Nothing
    }


-- | [Output Only] Unreachable resources.
hcalUnreachables :: Lens' HealthChecksAggregatedList [Text]
hcalUnreachables
  = lens _hcalUnreachables
      (\ s a -> s{_hcalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
hcalNextPageToken :: Lens' HealthChecksAggregatedList (Maybe Text)
hcalNextPageToken
  = lens _hcalNextPageToken
      (\ s a -> s{_hcalNextPageToken = a})

-- | Type of resource.
hcalKind :: Lens' HealthChecksAggregatedList Text
hcalKind = lens _hcalKind (\ s a -> s{_hcalKind = a})

-- | A list of HealthChecksScopedList resources.
hcalItems :: Lens' HealthChecksAggregatedList (Maybe HealthChecksAggregatedListItems)
hcalItems
  = lens _hcalItems (\ s a -> s{_hcalItems = a})

-- | [Output Only] Server-defined URL for this resource.
hcalSelfLink :: Lens' HealthChecksAggregatedList (Maybe Text)
hcalSelfLink
  = lens _hcalSelfLink (\ s a -> s{_hcalSelfLink = a})

-- | [Output Only] Informational warning message.
hcalWarning :: Lens' HealthChecksAggregatedList (Maybe HealthChecksAggregatedListWarning)
hcalWarning
  = lens _hcalWarning (\ s a -> s{_hcalWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
hcalId :: Lens' HealthChecksAggregatedList (Maybe Text)
hcalId = lens _hcalId (\ s a -> s{_hcalId = a})

instance FromJSON HealthChecksAggregatedList where
        parseJSON
          = withObject "HealthChecksAggregatedList"
              (\ o ->
                 HealthChecksAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!=
                        "compute#healthChecksAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON HealthChecksAggregatedList where
        toJSON HealthChecksAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _hcalUnreachables,
                  ("nextPageToken" .=) <$> _hcalNextPageToken,
                  Just ("kind" .= _hcalKind),
                  ("items" .=) <$> _hcalItems,
                  ("selfLink" .=) <$> _hcalSelfLink,
                  ("warning" .=) <$> _hcalWarning,
                  ("id" .=) <$> _hcalId])

-- | InstanceGroupManagers.updatePerInstanceConfigs
--
-- /See:/ 'instanceGroupManagersUpdatePerInstanceConfigsReq' smart constructor.
newtype InstanceGroupManagersUpdatePerInstanceConfigsReq =
  InstanceGroupManagersUpdatePerInstanceConfigsReq'
    { _igmupicrPerInstanceConfigs :: Maybe [PerInstanceConfig]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagersUpdatePerInstanceConfigsReq' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmupicrPerInstanceConfigs'
instanceGroupManagersUpdatePerInstanceConfigsReq
    :: InstanceGroupManagersUpdatePerInstanceConfigsReq
instanceGroupManagersUpdatePerInstanceConfigsReq =
  InstanceGroupManagersUpdatePerInstanceConfigsReq'
    {_igmupicrPerInstanceConfigs = Nothing}


-- | The list of per-instance configs to insert or patch on this managed
-- instance group.
igmupicrPerInstanceConfigs :: Lens' InstanceGroupManagersUpdatePerInstanceConfigsReq [PerInstanceConfig]
igmupicrPerInstanceConfigs
  = lens _igmupicrPerInstanceConfigs
      (\ s a -> s{_igmupicrPerInstanceConfigs = a})
      . _Default
      . _Coerce

instance FromJSON
           InstanceGroupManagersUpdatePerInstanceConfigsReq
         where
        parseJSON
          = withObject
              "InstanceGroupManagersUpdatePerInstanceConfigsReq"
              (\ o ->
                 InstanceGroupManagersUpdatePerInstanceConfigsReq' <$>
                   (o .:? "perInstanceConfigs" .!= mempty))

instance ToJSON
           InstanceGroupManagersUpdatePerInstanceConfigsReq
         where
        toJSON
          InstanceGroupManagersUpdatePerInstanceConfigsReq'{..}
          = object
              (catMaybes
                 [("perInstanceConfigs" .=) <$>
                    _igmupicrPerInstanceConfigs])

--
-- /See:/ 'targetSSLProxiesSetSSLCertificatesRequest' smart constructor.
newtype TargetSSLProxiesSetSSLCertificatesRequest =
  TargetSSLProxiesSetSSLCertificatesRequest'
    { _tspsscrSSLCertificates :: Maybe [Text]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetSSLProxiesSetSSLCertificatesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tspsscrSSLCertificates'
targetSSLProxiesSetSSLCertificatesRequest
    :: TargetSSLProxiesSetSSLCertificatesRequest
targetSSLProxiesSetSSLCertificatesRequest =
  TargetSSLProxiesSetSSLCertificatesRequest' {_tspsscrSSLCertificates = Nothing}


-- | New set of URLs to SslCertificate resources to associate with this
-- TargetSslProxy. At least one SSL certificate must be specified.
-- Currently, you may specify up to 15 SSL certificates.
tspsscrSSLCertificates :: Lens' TargetSSLProxiesSetSSLCertificatesRequest [Text]
tspsscrSSLCertificates
  = lens _tspsscrSSLCertificates
      (\ s a -> s{_tspsscrSSLCertificates = a})
      . _Default
      . _Coerce

instance FromJSON
           TargetSSLProxiesSetSSLCertificatesRequest
         where
        parseJSON
          = withObject
              "TargetSSLProxiesSetSSLCertificatesRequest"
              (\ o ->
                 TargetSSLProxiesSetSSLCertificatesRequest' <$>
                   (o .:? "sslCertificates" .!= mempty))

instance ToJSON
           TargetSSLProxiesSetSSLCertificatesRequest
         where
        toJSON TargetSSLProxiesSetSSLCertificatesRequest'{..}
          = object
              (catMaybes
                 [("sslCertificates" .=) <$> _tspsscrSSLCertificates])

--
-- /See:/ 'healthStatusForNetworkEndpoint' smart constructor.
data HealthStatusForNetworkEndpoint =
  HealthStatusForNetworkEndpoint'
    { _hsfneHealthCheckService :: !(Maybe HealthCheckServiceReference)
    , _hsfneHealthCheck :: !(Maybe HealthCheckReference)
    , _hsfneForwardingRule :: !(Maybe ForwardingRuleReference)
    , _hsfneHealthState :: !(Maybe HealthStatusForNetworkEndpointHealthState)
    , _hsfneBackendService :: !(Maybe BackendServiceReference)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HealthStatusForNetworkEndpoint' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hsfneHealthCheckService'
--
-- * 'hsfneHealthCheck'
--
-- * 'hsfneForwardingRule'
--
-- * 'hsfneHealthState'
--
-- * 'hsfneBackendService'
healthStatusForNetworkEndpoint
    :: HealthStatusForNetworkEndpoint
healthStatusForNetworkEndpoint =
  HealthStatusForNetworkEndpoint'
    { _hsfneHealthCheckService = Nothing
    , _hsfneHealthCheck = Nothing
    , _hsfneForwardingRule = Nothing
    , _hsfneHealthState = Nothing
    , _hsfneBackendService = Nothing
    }


-- | URL of the health check service associated with the health state of the
-- network endpoint.
hsfneHealthCheckService :: Lens' HealthStatusForNetworkEndpoint (Maybe HealthCheckServiceReference)
hsfneHealthCheckService
  = lens _hsfneHealthCheckService
      (\ s a -> s{_hsfneHealthCheckService = a})

-- | URL of the health check associated with the health state of the network
-- endpoint.
hsfneHealthCheck :: Lens' HealthStatusForNetworkEndpoint (Maybe HealthCheckReference)
hsfneHealthCheck
  = lens _hsfneHealthCheck
      (\ s a -> s{_hsfneHealthCheck = a})

-- | URL of the forwarding rule associated with the health state of the
-- network endpoint.
hsfneForwardingRule :: Lens' HealthStatusForNetworkEndpoint (Maybe ForwardingRuleReference)
hsfneForwardingRule
  = lens _hsfneForwardingRule
      (\ s a -> s{_hsfneForwardingRule = a})

-- | Health state of the network endpoint determined based on the health
-- checks configured.
hsfneHealthState :: Lens' HealthStatusForNetworkEndpoint (Maybe HealthStatusForNetworkEndpointHealthState)
hsfneHealthState
  = lens _hsfneHealthState
      (\ s a -> s{_hsfneHealthState = a})

-- | URL of the backend service associated with the health state of the
-- network endpoint.
hsfneBackendService :: Lens' HealthStatusForNetworkEndpoint (Maybe BackendServiceReference)
hsfneBackendService
  = lens _hsfneBackendService
      (\ s a -> s{_hsfneBackendService = a})

instance FromJSON HealthStatusForNetworkEndpoint
         where
        parseJSON
          = withObject "HealthStatusForNetworkEndpoint"
              (\ o ->
                 HealthStatusForNetworkEndpoint' <$>
                   (o .:? "healthCheckService") <*>
                     (o .:? "healthCheck")
                     <*> (o .:? "forwardingRule")
                     <*> (o .:? "healthState")
                     <*> (o .:? "backendService"))

instance ToJSON HealthStatusForNetworkEndpoint where
        toJSON HealthStatusForNetworkEndpoint'{..}
          = object
              (catMaybes
                 [("healthCheckService" .=) <$>
                    _hsfneHealthCheckService,
                  ("healthCheck" .=) <$> _hsfneHealthCheck,
                  ("forwardingRule" .=) <$> _hsfneForwardingRule,
                  ("healthState" .=) <$> _hsfneHealthState,
                  ("backendService" .=) <$> _hsfneBackendService])

-- | Represents a Firewall Policy resource. (== resource_for
-- {$api_version}.firewallPolicies ==)
--
-- /See:/ 'firewallPolicy' smart constructor.
data FirewallPolicy =
  FirewallPolicy'
    { _fpParent :: !(Maybe Text)
    , _fpRules :: !(Maybe [FirewallPolicyRule])
    , _fpShortName :: !(Maybe Text)
    , _fpKind :: !Text
    , _fpFingerprint :: !(Maybe Bytes)
    , _fpSelfLinkWithId :: !(Maybe Text)
    , _fpSelfLink :: !(Maybe Text)
    , _fpName :: !(Maybe Text)
    , _fpCreationTimestamp :: !(Maybe Text)
    , _fpAssociations :: !(Maybe [FirewallPolicyAssociation])
    , _fpDisplayName :: !(Maybe Text)
    , _fpId :: !(Maybe (Textual Word64))
    , _fpRuleTupleCount :: !(Maybe (Textual Int32))
    , _fpDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'FirewallPolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'fpParent'
--
-- * 'fpRules'
--
-- * 'fpShortName'
--
-- * 'fpKind'
--
-- * 'fpFingerprint'
--
-- * 'fpSelfLinkWithId'
--
-- * 'fpSelfLink'
--
-- * 'fpName'
--
-- * 'fpCreationTimestamp'
--
-- * 'fpAssociations'
--
-- * 'fpDisplayName'
--
-- * 'fpId'
--
-- * 'fpRuleTupleCount'
--
-- * 'fpDescription'
firewallPolicy
    :: FirewallPolicy
firewallPolicy =
  FirewallPolicy'
    { _fpParent = Nothing
    , _fpRules = Nothing
    , _fpShortName = Nothing
    , _fpKind = "compute#firewallPolicy"
    , _fpFingerprint = Nothing
    , _fpSelfLinkWithId = Nothing
    , _fpSelfLink = Nothing
    , _fpName = Nothing
    , _fpCreationTimestamp = Nothing
    , _fpAssociations = Nothing
    , _fpDisplayName = Nothing
    , _fpId = Nothing
    , _fpRuleTupleCount = Nothing
    , _fpDescription = Nothing
    }


-- | [Output Only] The parent of the firewall policy.
fpParent :: Lens' FirewallPolicy (Maybe Text)
fpParent = lens _fpParent (\ s a -> s{_fpParent = a})

-- | A list of rules that belong to this policy. There must always be a
-- default rule (rule with priority 2147483647 and match \"*\"). If no
-- rules are provided when creating a firewall policy, a default rule with
-- action \"allow\" will be added.
fpRules :: Lens' FirewallPolicy [FirewallPolicyRule]
fpRules
  = lens _fpRules (\ s a -> s{_fpRules = a}) . _Default
      . _Coerce

-- | User-provided name of the Organization firewall plicy. The name should
-- be unique in the organization in which the firewall policy is created.
-- The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
fpShortName :: Lens' FirewallPolicy (Maybe Text)
fpShortName
  = lens _fpShortName (\ s a -> s{_fpShortName = a})

-- | [Output only] Type of the resource. Always compute#firewallPolicyfor
-- firewall policies
fpKind :: Lens' FirewallPolicy Text
fpKind = lens _fpKind (\ s a -> s{_fpKind = a})

-- | Specifies a fingerprint for this resource, which is essentially a hash
-- of the metadata\'s contents and used for optimistic locking. The
-- fingerprint is initially generated by Compute Engine and changes after
-- every request to modify or update metadata. You must always provide an
-- up-to-date fingerprint hash in order to update or change metadata,
-- otherwise the request will fail with error 412 conditionNotMet. To see
-- the latest fingerprint, make get() request to the firewall policy.
fpFingerprint :: Lens' FirewallPolicy (Maybe ByteString)
fpFingerprint
  = lens _fpFingerprint
      (\ s a -> s{_fpFingerprint = a})
      . mapping _Bytes

-- | [Output Only] Server-defined URL for this resource with the resource id.
fpSelfLinkWithId :: Lens' FirewallPolicy (Maybe Text)
fpSelfLinkWithId
  = lens _fpSelfLinkWithId
      (\ s a -> s{_fpSelfLinkWithId = a})

-- | [Output Only] Server-defined URL for the resource.
fpSelfLink :: Lens' FirewallPolicy (Maybe Text)
fpSelfLink
  = lens _fpSelfLink (\ s a -> s{_fpSelfLink = a})

-- | [Output Only] Name of the resource. It is a numeric ID allocated by GCP
-- which uniquely identifies the Firewall Policy.
fpName :: Lens' FirewallPolicy (Maybe Text)
fpName = lens _fpName (\ s a -> s{_fpName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
fpCreationTimestamp :: Lens' FirewallPolicy (Maybe Text)
fpCreationTimestamp
  = lens _fpCreationTimestamp
      (\ s a -> s{_fpCreationTimestamp = a})

-- | A list of associations that belong to this firewall policy.
fpAssociations :: Lens' FirewallPolicy [FirewallPolicyAssociation]
fpAssociations
  = lens _fpAssociations
      (\ s a -> s{_fpAssociations = a})
      . _Default
      . _Coerce

-- | Depreacted, please use short name instead. User-provided name of the
-- Organization firewall plicy. The name should be unique in the
-- organization in which the firewall policy is created. The name must be
-- 1-63 characters long, and comply with RFC1035. Specifically, the name
-- must be 1-63 characters long and match the regular expression
-- \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first character must be a
-- lowercase letter, and all following characters must be a dash, lowercase
-- letter, or digit, except the last character, which cannot be a dash.
fpDisplayName :: Lens' FirewallPolicy (Maybe Text)
fpDisplayName
  = lens _fpDisplayName
      (\ s a -> s{_fpDisplayName = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
fpId :: Lens' FirewallPolicy (Maybe Word64)
fpId
  = lens _fpId (\ s a -> s{_fpId = a}) .
      mapping _Coerce

-- | [Output Only] Total count of all firewall policy rule tuples. A firewall
-- policy can not exceed a set number of tuples.
fpRuleTupleCount :: Lens' FirewallPolicy (Maybe Int32)
fpRuleTupleCount
  = lens _fpRuleTupleCount
      (\ s a -> s{_fpRuleTupleCount = a})
      . mapping _Coerce

-- | An optional description of this resource. Provide this property when you
-- create the resource.
fpDescription :: Lens' FirewallPolicy (Maybe Text)
fpDescription
  = lens _fpDescription
      (\ s a -> s{_fpDescription = a})

instance FromJSON FirewallPolicy where
        parseJSON
          = withObject "FirewallPolicy"
              (\ o ->
                 FirewallPolicy' <$>
                   (o .:? "parent") <*> (o .:? "rules" .!= mempty) <*>
                     (o .:? "shortName")
                     <*> (o .:? "kind" .!= "compute#firewallPolicy")
                     <*> (o .:? "fingerprint")
                     <*> (o .:? "selfLinkWithId")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "associations" .!= mempty)
                     <*> (o .:? "displayName")
                     <*> (o .:? "id")
                     <*> (o .:? "ruleTupleCount")
                     <*> (o .:? "description"))

instance ToJSON FirewallPolicy where
        toJSON FirewallPolicy'{..}
          = object
              (catMaybes
                 [("parent" .=) <$> _fpParent,
                  ("rules" .=) <$> _fpRules,
                  ("shortName" .=) <$> _fpShortName,
                  Just ("kind" .= _fpKind),
                  ("fingerprint" .=) <$> _fpFingerprint,
                  ("selfLinkWithId" .=) <$> _fpSelfLinkWithId,
                  ("selfLink" .=) <$> _fpSelfLink,
                  ("name" .=) <$> _fpName,
                  ("creationTimestamp" .=) <$> _fpCreationTimestamp,
                  ("associations" .=) <$> _fpAssociations,
                  ("displayName" .=) <$> _fpDisplayName,
                  ("id" .=) <$> _fpId,
                  ("ruleTupleCount" .=) <$> _fpRuleTupleCount,
                  ("description" .=) <$> _fpDescription])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'routerAggregatedListWarning' smart constructor.
data RouterAggregatedListWarning =
  RouterAggregatedListWarning'
    { _ralwaData :: !(Maybe [RouterAggregatedListWarningDataItem])
    , _ralwaCode :: !(Maybe RouterAggregatedListWarningCode)
    , _ralwaMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RouterAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ralwaData'
--
-- * 'ralwaCode'
--
-- * 'ralwaMessage'
routerAggregatedListWarning
    :: RouterAggregatedListWarning
routerAggregatedListWarning =
  RouterAggregatedListWarning'
    {_ralwaData = Nothing, _ralwaCode = Nothing, _ralwaMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
ralwaData :: Lens' RouterAggregatedListWarning [RouterAggregatedListWarningDataItem]
ralwaData
  = lens _ralwaData (\ s a -> s{_ralwaData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
ralwaCode :: Lens' RouterAggregatedListWarning (Maybe RouterAggregatedListWarningCode)
ralwaCode
  = lens _ralwaCode (\ s a -> s{_ralwaCode = a})

-- | [Output Only] A human-readable description of the warning code.
ralwaMessage :: Lens' RouterAggregatedListWarning (Maybe Text)
ralwaMessage
  = lens _ralwaMessage (\ s a -> s{_ralwaMessage = a})

instance FromJSON RouterAggregatedListWarning where
        parseJSON
          = withObject "RouterAggregatedListWarning"
              (\ o ->
                 RouterAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON RouterAggregatedListWarning where
        toJSON RouterAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _ralwaData,
                  ("code" .=) <$> _ralwaCode,
                  ("message" .=) <$> _ralwaMessage])

--
-- /See:/ 'targetHTTPSProxyAggregatedListWarningDataItem' smart constructor.
data TargetHTTPSProxyAggregatedListWarningDataItem =
  TargetHTTPSProxyAggregatedListWarningDataItem'
    { _thpalwdiValue :: !(Maybe Text)
    , _thpalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetHTTPSProxyAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'thpalwdiValue'
--
-- * 'thpalwdiKey'
targetHTTPSProxyAggregatedListWarningDataItem
    :: TargetHTTPSProxyAggregatedListWarningDataItem
targetHTTPSProxyAggregatedListWarningDataItem =
  TargetHTTPSProxyAggregatedListWarningDataItem'
    {_thpalwdiValue = Nothing, _thpalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
thpalwdiValue :: Lens' TargetHTTPSProxyAggregatedListWarningDataItem (Maybe Text)
thpalwdiValue
  = lens _thpalwdiValue
      (\ s a -> s{_thpalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
thpalwdiKey :: Lens' TargetHTTPSProxyAggregatedListWarningDataItem (Maybe Text)
thpalwdiKey
  = lens _thpalwdiKey (\ s a -> s{_thpalwdiKey = a})

instance FromJSON
           TargetHTTPSProxyAggregatedListWarningDataItem
         where
        parseJSON
          = withObject
              "TargetHTTPSProxyAggregatedListWarningDataItem"
              (\ o ->
                 TargetHTTPSProxyAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           TargetHTTPSProxyAggregatedListWarningDataItem
         where
        toJSON
          TargetHTTPSProxyAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _thpalwdiValue,
                  ("key" .=) <$> _thpalwdiKey])

--
-- /See:/ 'instancesScopedList' smart constructor.
data InstancesScopedList =
  InstancesScopedList'
    { _islWarning :: !(Maybe InstancesScopedListWarning)
    , _islInstances :: !(Maybe [Instance])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstancesScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'islWarning'
--
-- * 'islInstances'
instancesScopedList
    :: InstancesScopedList
instancesScopedList =
  InstancesScopedList' {_islWarning = Nothing, _islInstances = Nothing}


-- | [Output Only] Informational warning which replaces the list of instances
-- when the list is empty.
islWarning :: Lens' InstancesScopedList (Maybe InstancesScopedListWarning)
islWarning
  = lens _islWarning (\ s a -> s{_islWarning = a})

-- | [Output Only] A list of instances contained in this scope.
islInstances :: Lens' InstancesScopedList [Instance]
islInstances
  = lens _islInstances (\ s a -> s{_islInstances = a})
      . _Default
      . _Coerce

instance FromJSON InstancesScopedList where
        parseJSON
          = withObject "InstancesScopedList"
              (\ o ->
                 InstancesScopedList' <$>
                   (o .:? "warning") <*> (o .:? "instances" .!= mempty))

instance ToJSON InstancesScopedList where
        toJSON InstancesScopedList'{..}
          = object
              (catMaybes
                 [("warning" .=) <$> _islWarning,
                  ("instances" .=) <$> _islInstances])

-- | A list of AcceleratorTypesScopedList resources.
--
-- /See:/ 'acceleratorTypeAggregatedListItems' smart constructor.
newtype AcceleratorTypeAggregatedListItems =
  AcceleratorTypeAggregatedListItems'
    { _ataliAddtional :: HashMap Text AcceleratorTypesScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AcceleratorTypeAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ataliAddtional'
acceleratorTypeAggregatedListItems
    :: HashMap Text AcceleratorTypesScopedList -- ^ 'ataliAddtional'
    -> AcceleratorTypeAggregatedListItems
acceleratorTypeAggregatedListItems pAtaliAddtional_ =
  AcceleratorTypeAggregatedListItems'
    {_ataliAddtional = _Coerce # pAtaliAddtional_}


-- | [Output Only] Name of the scope containing this set of accelerator
-- types.
ataliAddtional :: Lens' AcceleratorTypeAggregatedListItems (HashMap Text AcceleratorTypesScopedList)
ataliAddtional
  = lens _ataliAddtional
      (\ s a -> s{_ataliAddtional = a})
      . _Coerce

instance FromJSON AcceleratorTypeAggregatedListItems
         where
        parseJSON
          = withObject "AcceleratorTypeAggregatedListItems"
              (\ o ->
                 AcceleratorTypeAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON AcceleratorTypeAggregatedListItems
         where
        toJSON = toJSON . _ataliAddtional

--
-- /See:/ 'targetVPNGatewayAggregatedListWarningDataItem' smart constructor.
data TargetVPNGatewayAggregatedListWarningDataItem =
  TargetVPNGatewayAggregatedListWarningDataItem'
    { _tvgalwdiValue :: !(Maybe Text)
    , _tvgalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetVPNGatewayAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tvgalwdiValue'
--
-- * 'tvgalwdiKey'
targetVPNGatewayAggregatedListWarningDataItem
    :: TargetVPNGatewayAggregatedListWarningDataItem
targetVPNGatewayAggregatedListWarningDataItem =
  TargetVPNGatewayAggregatedListWarningDataItem'
    {_tvgalwdiValue = Nothing, _tvgalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
tvgalwdiValue :: Lens' TargetVPNGatewayAggregatedListWarningDataItem (Maybe Text)
tvgalwdiValue
  = lens _tvgalwdiValue
      (\ s a -> s{_tvgalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
tvgalwdiKey :: Lens' TargetVPNGatewayAggregatedListWarningDataItem (Maybe Text)
tvgalwdiKey
  = lens _tvgalwdiKey (\ s a -> s{_tvgalwdiKey = a})

instance FromJSON
           TargetVPNGatewayAggregatedListWarningDataItem
         where
        parseJSON
          = withObject
              "TargetVPNGatewayAggregatedListWarningDataItem"
              (\ o ->
                 TargetVPNGatewayAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           TargetVPNGatewayAggregatedListWarningDataItem
         where
        toJSON
          TargetVPNGatewayAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _tvgalwdiValue,
                  ("key" .=) <$> _tvgalwdiKey])

-- | A full or valid partial URL to a health check. For example, the
-- following are valid URLs: -
-- https:\/\/www.googleapis.com\/compute\/beta\/projects\/project-id\/global\/httpHealthChecks\/health-check
-- - projects\/project-id\/global\/httpHealthChecks\/health-check -
-- global\/httpHealthChecks\/health-check
--
-- /See:/ 'healthCheckReference' smart constructor.
newtype HealthCheckReference =
  HealthCheckReference'
    { _hcrHealthCheck :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HealthCheckReference' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hcrHealthCheck'
healthCheckReference
    :: HealthCheckReference
healthCheckReference = HealthCheckReference' {_hcrHealthCheck = Nothing}


hcrHealthCheck :: Lens' HealthCheckReference (Maybe Text)
hcrHealthCheck
  = lens _hcrHealthCheck
      (\ s a -> s{_hcrHealthCheck = a})

instance FromJSON HealthCheckReference where
        parseJSON
          = withObject "HealthCheckReference"
              (\ o ->
                 HealthCheckReference' <$> (o .:? "healthCheck"))

instance ToJSON HealthCheckReference where
        toJSON HealthCheckReference'{..}
          = object
              (catMaybes [("healthCheck" .=) <$> _hcrHealthCheck])

-- | A set of Confidential Instance options.
--
-- /See:/ 'confidentialInstanceConfig' smart constructor.
newtype ConfidentialInstanceConfig =
  ConfidentialInstanceConfig'
    { _cicEnableConfidentialCompute :: Maybe Bool
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ConfidentialInstanceConfig' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'cicEnableConfidentialCompute'
confidentialInstanceConfig
    :: ConfidentialInstanceConfig
confidentialInstanceConfig =
  ConfidentialInstanceConfig' {_cicEnableConfidentialCompute = Nothing}


-- | Defines whether the instance should have confidential compute enabled.
cicEnableConfidentialCompute :: Lens' ConfidentialInstanceConfig (Maybe Bool)
cicEnableConfidentialCompute
  = lens _cicEnableConfidentialCompute
      (\ s a -> s{_cicEnableConfidentialCompute = a})

instance FromJSON ConfidentialInstanceConfig where
        parseJSON
          = withObject "ConfidentialInstanceConfig"
              (\ o ->
                 ConfidentialInstanceConfig' <$>
                   (o .:? "enableConfidentialCompute"))

instance ToJSON ConfidentialInstanceConfig where
        toJSON ConfidentialInstanceConfig'{..}
          = object
              (catMaybes
                 [("enableConfidentialCompute" .=) <$>
                    _cicEnableConfidentialCompute])

-- | A list of TargetInstance resources.
--
-- /See:/ 'targetInstanceAggregatedListItems' smart constructor.
newtype TargetInstanceAggregatedListItems =
  TargetInstanceAggregatedListItems'
    { _tialiAddtional :: HashMap Text TargetInstancesScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetInstanceAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tialiAddtional'
targetInstanceAggregatedListItems
    :: HashMap Text TargetInstancesScopedList -- ^ 'tialiAddtional'
    -> TargetInstanceAggregatedListItems
targetInstanceAggregatedListItems pTialiAddtional_ =
  TargetInstanceAggregatedListItems'
    {_tialiAddtional = _Coerce # pTialiAddtional_}


-- | Name of the scope containing this set of target instances.
tialiAddtional :: Lens' TargetInstanceAggregatedListItems (HashMap Text TargetInstancesScopedList)
tialiAddtional
  = lens _tialiAddtional
      (\ s a -> s{_tialiAddtional = a})
      . _Coerce

instance FromJSON TargetInstanceAggregatedListItems
         where
        parseJSON
          = withObject "TargetInstanceAggregatedListItems"
              (\ o ->
                 TargetInstanceAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON TargetInstanceAggregatedListItems
         where
        toJSON = toJSON . _tialiAddtional

--
-- /See:/ 'targetHTTPSProxiesSetQuicOverrideRequest' smart constructor.
newtype TargetHTTPSProxiesSetQuicOverrideRequest =
  TargetHTTPSProxiesSetQuicOverrideRequest'
    { _thpsqorQuicOverride :: Maybe TargetHTTPSProxiesSetQuicOverrideRequestQuicOverride
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetHTTPSProxiesSetQuicOverrideRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'thpsqorQuicOverride'
targetHTTPSProxiesSetQuicOverrideRequest
    :: TargetHTTPSProxiesSetQuicOverrideRequest
targetHTTPSProxiesSetQuicOverrideRequest =
  TargetHTTPSProxiesSetQuicOverrideRequest' {_thpsqorQuicOverride = Nothing}


-- | QUIC policy for the TargetHttpsProxy resource.
thpsqorQuicOverride :: Lens' TargetHTTPSProxiesSetQuicOverrideRequest (Maybe TargetHTTPSProxiesSetQuicOverrideRequestQuicOverride)
thpsqorQuicOverride
  = lens _thpsqorQuicOverride
      (\ s a -> s{_thpsqorQuicOverride = a})

instance FromJSON
           TargetHTTPSProxiesSetQuicOverrideRequest
         where
        parseJSON
          = withObject
              "TargetHTTPSProxiesSetQuicOverrideRequest"
              (\ o ->
                 TargetHTTPSProxiesSetQuicOverrideRequest' <$>
                   (o .:? "quicOverride"))

instance ToJSON
           TargetHTTPSProxiesSetQuicOverrideRequest
         where
        toJSON TargetHTTPSProxiesSetQuicOverrideRequest'{..}
          = object
              (catMaybes
                 [("quicOverride" .=) <$> _thpsqorQuicOverride])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'targetSSLProxyListWarning' smart constructor.
data TargetSSLProxyListWarning =
  TargetSSLProxyListWarning'
    { _tsplwData :: !(Maybe [TargetSSLProxyListWarningDataItem])
    , _tsplwCode :: !(Maybe TargetSSLProxyListWarningCode)
    , _tsplwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetSSLProxyListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tsplwData'
--
-- * 'tsplwCode'
--
-- * 'tsplwMessage'
targetSSLProxyListWarning
    :: TargetSSLProxyListWarning
targetSSLProxyListWarning =
  TargetSSLProxyListWarning'
    {_tsplwData = Nothing, _tsplwCode = Nothing, _tsplwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
tsplwData :: Lens' TargetSSLProxyListWarning [TargetSSLProxyListWarningDataItem]
tsplwData
  = lens _tsplwData (\ s a -> s{_tsplwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
tsplwCode :: Lens' TargetSSLProxyListWarning (Maybe TargetSSLProxyListWarningCode)
tsplwCode
  = lens _tsplwCode (\ s a -> s{_tsplwCode = a})

-- | [Output Only] A human-readable description of the warning code.
tsplwMessage :: Lens' TargetSSLProxyListWarning (Maybe Text)
tsplwMessage
  = lens _tsplwMessage (\ s a -> s{_tsplwMessage = a})

instance FromJSON TargetSSLProxyListWarning where
        parseJSON
          = withObject "TargetSSLProxyListWarning"
              (\ o ->
                 TargetSSLProxyListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON TargetSSLProxyListWarning where
        toJSON TargetSSLProxyListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _tsplwData,
                  ("code" .=) <$> _tsplwCode,
                  ("message" .=) <$> _tsplwMessage])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'instanceTemplateListWarning' smart constructor.
data InstanceTemplateListWarning =
  InstanceTemplateListWarning'
    { _itlwData :: !(Maybe [InstanceTemplateListWarningDataItem])
    , _itlwCode :: !(Maybe InstanceTemplateListWarningCode)
    , _itlwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceTemplateListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'itlwData'
--
-- * 'itlwCode'
--
-- * 'itlwMessage'
instanceTemplateListWarning
    :: InstanceTemplateListWarning
instanceTemplateListWarning =
  InstanceTemplateListWarning'
    {_itlwData = Nothing, _itlwCode = Nothing, _itlwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
itlwData :: Lens' InstanceTemplateListWarning [InstanceTemplateListWarningDataItem]
itlwData
  = lens _itlwData (\ s a -> s{_itlwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
itlwCode :: Lens' InstanceTemplateListWarning (Maybe InstanceTemplateListWarningCode)
itlwCode = lens _itlwCode (\ s a -> s{_itlwCode = a})

-- | [Output Only] A human-readable description of the warning code.
itlwMessage :: Lens' InstanceTemplateListWarning (Maybe Text)
itlwMessage
  = lens _itlwMessage (\ s a -> s{_itlwMessage = a})

instance FromJSON InstanceTemplateListWarning where
        parseJSON
          = withObject "InstanceTemplateListWarning"
              (\ o ->
                 InstanceTemplateListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON InstanceTemplateListWarning where
        toJSON InstanceTemplateListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _itlwData,
                  ("code" .=) <$> _itlwCode,
                  ("message" .=) <$> _itlwMessage])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'instanceListReferrersWarning' smart constructor.
data InstanceListReferrersWarning =
  InstanceListReferrersWarning'
    { _ilrwData :: !(Maybe [InstanceListReferrersWarningDataItem])
    , _ilrwCode :: !(Maybe InstanceListReferrersWarningCode)
    , _ilrwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceListReferrersWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ilrwData'
--
-- * 'ilrwCode'
--
-- * 'ilrwMessage'
instanceListReferrersWarning
    :: InstanceListReferrersWarning
instanceListReferrersWarning =
  InstanceListReferrersWarning'
    {_ilrwData = Nothing, _ilrwCode = Nothing, _ilrwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
ilrwData :: Lens' InstanceListReferrersWarning [InstanceListReferrersWarningDataItem]
ilrwData
  = lens _ilrwData (\ s a -> s{_ilrwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
ilrwCode :: Lens' InstanceListReferrersWarning (Maybe InstanceListReferrersWarningCode)
ilrwCode = lens _ilrwCode (\ s a -> s{_ilrwCode = a})

-- | [Output Only] A human-readable description of the warning code.
ilrwMessage :: Lens' InstanceListReferrersWarning (Maybe Text)
ilrwMessage
  = lens _ilrwMessage (\ s a -> s{_ilrwMessage = a})

instance FromJSON InstanceListReferrersWarning where
        parseJSON
          = withObject "InstanceListReferrersWarning"
              (\ o ->
                 InstanceListReferrersWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON InstanceListReferrersWarning where
        toJSON InstanceListReferrersWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _ilrwData,
                  ("code" .=) <$> _ilrwCode,
                  ("message" .=) <$> _ilrwMessage])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'urlMapsAggregatedListWarning' smart constructor.
data URLMapsAggregatedListWarning =
  URLMapsAggregatedListWarning'
    { _umalwData :: !(Maybe [URLMapsAggregatedListWarningDataItem])
    , _umalwCode :: !(Maybe URLMapsAggregatedListWarningCode)
    , _umalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'URLMapsAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'umalwData'
--
-- * 'umalwCode'
--
-- * 'umalwMessage'
urlMapsAggregatedListWarning
    :: URLMapsAggregatedListWarning
urlMapsAggregatedListWarning =
  URLMapsAggregatedListWarning'
    {_umalwData = Nothing, _umalwCode = Nothing, _umalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
umalwData :: Lens' URLMapsAggregatedListWarning [URLMapsAggregatedListWarningDataItem]
umalwData
  = lens _umalwData (\ s a -> s{_umalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
umalwCode :: Lens' URLMapsAggregatedListWarning (Maybe URLMapsAggregatedListWarningCode)
umalwCode
  = lens _umalwCode (\ s a -> s{_umalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
umalwMessage :: Lens' URLMapsAggregatedListWarning (Maybe Text)
umalwMessage
  = lens _umalwMessage (\ s a -> s{_umalwMessage = a})

instance FromJSON URLMapsAggregatedListWarning where
        parseJSON
          = withObject "URLMapsAggregatedListWarning"
              (\ o ->
                 URLMapsAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON URLMapsAggregatedListWarning where
        toJSON URLMapsAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _umalwData,
                  ("code" .=) <$> _umalwCode,
                  ("message" .=) <$> _umalwMessage])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'routeListWarning' smart constructor.
data RouteListWarning =
  RouteListWarning'
    { _rlwlData :: !(Maybe [RouteListWarningDataItem])
    , _rlwlCode :: !(Maybe RouteListWarningCode)
    , _rlwlMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RouteListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rlwlData'
--
-- * 'rlwlCode'
--
-- * 'rlwlMessage'
routeListWarning
    :: RouteListWarning
routeListWarning =
  RouteListWarning'
    {_rlwlData = Nothing, _rlwlCode = Nothing, _rlwlMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
rlwlData :: Lens' RouteListWarning [RouteListWarningDataItem]
rlwlData
  = lens _rlwlData (\ s a -> s{_rlwlData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
rlwlCode :: Lens' RouteListWarning (Maybe RouteListWarningCode)
rlwlCode = lens _rlwlCode (\ s a -> s{_rlwlCode = a})

-- | [Output Only] A human-readable description of the warning code.
rlwlMessage :: Lens' RouteListWarning (Maybe Text)
rlwlMessage
  = lens _rlwlMessage (\ s a -> s{_rlwlMessage = a})

instance FromJSON RouteListWarning where
        parseJSON
          = withObject "RouteListWarning"
              (\ o ->
                 RouteListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON RouteListWarning where
        toJSON RouteListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _rlwlData,
                  ("code" .=) <$> _rlwlCode,
                  ("message" .=) <$> _rlwlMessage])

--
-- /See:/ 'instanceGroupAggregatedList' smart constructor.
data InstanceGroupAggregatedList =
  InstanceGroupAggregatedList'
    { _igalUnreachables :: !(Maybe [Text])
    , _igalNextPageToken :: !(Maybe Text)
    , _igalKind :: !Text
    , _igalItems :: !(Maybe InstanceGroupAggregatedListItems)
    , _igalSelfLink :: !(Maybe Text)
    , _igalWarning :: !(Maybe InstanceGroupAggregatedListWarning)
    , _igalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igalUnreachables'
--
-- * 'igalNextPageToken'
--
-- * 'igalKind'
--
-- * 'igalItems'
--
-- * 'igalSelfLink'
--
-- * 'igalWarning'
--
-- * 'igalId'
instanceGroupAggregatedList
    :: InstanceGroupAggregatedList
instanceGroupAggregatedList =
  InstanceGroupAggregatedList'
    { _igalUnreachables = Nothing
    , _igalNextPageToken = Nothing
    , _igalKind = "compute#instanceGroupAggregatedList"
    , _igalItems = Nothing
    , _igalSelfLink = Nothing
    , _igalWarning = Nothing
    , _igalId = Nothing
    }


-- | [Output Only] Unreachable resources.
igalUnreachables :: Lens' InstanceGroupAggregatedList [Text]
igalUnreachables
  = lens _igalUnreachables
      (\ s a -> s{_igalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
igalNextPageToken :: Lens' InstanceGroupAggregatedList (Maybe Text)
igalNextPageToken
  = lens _igalNextPageToken
      (\ s a -> s{_igalNextPageToken = a})

-- | [Output Only] The resource type, which is always
-- compute#instanceGroupAggregatedList for aggregated lists of instance
-- groups.
igalKind :: Lens' InstanceGroupAggregatedList Text
igalKind = lens _igalKind (\ s a -> s{_igalKind = a})

-- | A list of InstanceGroupsScopedList resources.
igalItems :: Lens' InstanceGroupAggregatedList (Maybe InstanceGroupAggregatedListItems)
igalItems
  = lens _igalItems (\ s a -> s{_igalItems = a})

-- | [Output Only] Server-defined URL for this resource.
igalSelfLink :: Lens' InstanceGroupAggregatedList (Maybe Text)
igalSelfLink
  = lens _igalSelfLink (\ s a -> s{_igalSelfLink = a})

-- | [Output Only] Informational warning message.
igalWarning :: Lens' InstanceGroupAggregatedList (Maybe InstanceGroupAggregatedListWarning)
igalWarning
  = lens _igalWarning (\ s a -> s{_igalWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
igalId :: Lens' InstanceGroupAggregatedList (Maybe Text)
igalId = lens _igalId (\ s a -> s{_igalId = a})

instance FromJSON InstanceGroupAggregatedList where
        parseJSON
          = withObject "InstanceGroupAggregatedList"
              (\ o ->
                 InstanceGroupAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!=
                        "compute#instanceGroupAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON InstanceGroupAggregatedList where
        toJSON InstanceGroupAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _igalUnreachables,
                  ("nextPageToken" .=) <$> _igalNextPageToken,
                  Just ("kind" .= _igalKind),
                  ("items" .=) <$> _igalItems,
                  ("selfLink" .=) <$> _igalSelfLink,
                  ("warning" .=) <$> _igalWarning,
                  ("id" .=) <$> _igalId])

-- | Represents a Route resource. A route defines a path from VM instances in
-- the VPC network to a specific destination. This destination can be
-- inside or outside the VPC network. For more information, read the Routes
-- overview. (== resource_for {$api_version}.routes ==)
--
-- /See:/ 'route' smart constructor.
data Route =
  Route'
    { _r1NextHopIlb :: !(Maybe Text)
    , _r1NextHopPeering :: !(Maybe Text)
    , _r1Priority :: !(Maybe (Textual Word32))
    , _r1Kind :: !Text
    , _r1NextHopGateway :: !(Maybe Text)
    , _r1NextHopNetwork :: !(Maybe Text)
    , _r1Network :: !(Maybe Text)
    , _r1Warnings :: !(Maybe [RouteWarningsItem])
    , _r1NextHopIP :: !(Maybe Text)
    , _r1DestRange :: !(Maybe Text)
    , _r1SelfLink :: !(Maybe Text)
    , _r1Name :: !(Maybe Text)
    , _r1CreationTimestamp :: !(Maybe Text)
    , _r1Id :: !(Maybe (Textual Word64))
    , _r1NextHopVPNTunnel :: !(Maybe Text)
    , _r1Description :: !(Maybe Text)
    , _r1Tags :: !(Maybe [Text])
    , _r1NextHopInstance :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Route' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'r1NextHopIlb'
--
-- * 'r1NextHopPeering'
--
-- * 'r1Priority'
--
-- * 'r1Kind'
--
-- * 'r1NextHopGateway'
--
-- * 'r1NextHopNetwork'
--
-- * 'r1Network'
--
-- * 'r1Warnings'
--
-- * 'r1NextHopIP'
--
-- * 'r1DestRange'
--
-- * 'r1SelfLink'
--
-- * 'r1Name'
--
-- * 'r1CreationTimestamp'
--
-- * 'r1Id'
--
-- * 'r1NextHopVPNTunnel'
--
-- * 'r1Description'
--
-- * 'r1Tags'
--
-- * 'r1NextHopInstance'
route
    :: Route
route =
  Route'
    { _r1NextHopIlb = Nothing
    , _r1NextHopPeering = Nothing
    , _r1Priority = Nothing
    , _r1Kind = "compute#route"
    , _r1NextHopGateway = Nothing
    , _r1NextHopNetwork = Nothing
    , _r1Network = Nothing
    , _r1Warnings = Nothing
    , _r1NextHopIP = Nothing
    , _r1DestRange = Nothing
    , _r1SelfLink = Nothing
    , _r1Name = Nothing
    , _r1CreationTimestamp = Nothing
    , _r1Id = Nothing
    , _r1NextHopVPNTunnel = Nothing
    , _r1Description = Nothing
    , _r1Tags = Nothing
    , _r1NextHopInstance = Nothing
    }


-- | The URL to a forwarding rule of type loadBalancingScheme=INTERNAL that
-- should handle matching packets or the IP address of the forwarding Rule.
-- For example, the following are all valid URLs: - 10.128.0.56 -
-- https:\/\/www.googleapis.com\/compute\/v1\/projects\/project\/regions\/region\/forwardingRules\/forwardingRule
-- - regions\/region\/forwardingRules\/forwardingRule
r1NextHopIlb :: Lens' Route (Maybe Text)
r1NextHopIlb
  = lens _r1NextHopIlb (\ s a -> s{_r1NextHopIlb = a})

-- | [Output Only] The network peering name that should handle matching
-- packets, which should conform to RFC1035.
r1NextHopPeering :: Lens' Route (Maybe Text)
r1NextHopPeering
  = lens _r1NextHopPeering
      (\ s a -> s{_r1NextHopPeering = a})

-- | The priority of this route. Priority is used to break ties in cases
-- where there is more than one matching route of equal prefix length. In
-- cases where multiple routes have equal prefix length, the one with the
-- lowest-numbered priority value wins. The default value is \`1000\`. The
-- priority value must be from \`0\` to \`65535\`, inclusive.
r1Priority :: Lens' Route (Maybe Word32)
r1Priority
  = lens _r1Priority (\ s a -> s{_r1Priority = a}) .
      mapping _Coerce

-- | [Output Only] Type of this resource. Always compute#routes for Route
-- resources.
r1Kind :: Lens' Route Text
r1Kind = lens _r1Kind (\ s a -> s{_r1Kind = a})

-- | The URL to a gateway that should handle matching packets. You can only
-- specify the internet gateway using a full or partial valid URL:
-- projects\/project\/global\/gateways\/default-internet-gateway
r1NextHopGateway :: Lens' Route (Maybe Text)
r1NextHopGateway
  = lens _r1NextHopGateway
      (\ s a -> s{_r1NextHopGateway = a})

-- | The URL of the local network if it should handle matching packets.
r1NextHopNetwork :: Lens' Route (Maybe Text)
r1NextHopNetwork
  = lens _r1NextHopNetwork
      (\ s a -> s{_r1NextHopNetwork = a})

-- | Fully-qualified URL of the network that this route applies to.
r1Network :: Lens' Route (Maybe Text)
r1Network
  = lens _r1Network (\ s a -> s{_r1Network = a})

-- | [Output Only] If potential misconfigurations are detected for this
-- route, this field will be populated with warning messages.
r1Warnings :: Lens' Route [RouteWarningsItem]
r1Warnings
  = lens _r1Warnings (\ s a -> s{_r1Warnings = a}) .
      _Default
      . _Coerce

-- | The network IP address of an instance that should handle matching
-- packets. Only IPv4 is supported.
r1NextHopIP :: Lens' Route (Maybe Text)
r1NextHopIP
  = lens _r1NextHopIP (\ s a -> s{_r1NextHopIP = a})

-- | The destination range of outgoing packets that this route applies to.
-- Both IPv4 and IPv6 are supported.
r1DestRange :: Lens' Route (Maybe Text)
r1DestRange
  = lens _r1DestRange (\ s a -> s{_r1DestRange = a})

-- | [Output Only] Server-defined fully-qualified URL for this resource.
r1SelfLink :: Lens' Route (Maybe Text)
r1SelfLink
  = lens _r1SelfLink (\ s a -> s{_r1SelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\`. The first character
-- must be a lowercase letter, and all following characters (except for the
-- last character) must be a dash, lowercase letter, or digit. The last
-- character must be a lowercase letter or digit.
r1Name :: Lens' Route (Maybe Text)
r1Name = lens _r1Name (\ s a -> s{_r1Name = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
r1CreationTimestamp :: Lens' Route (Maybe Text)
r1CreationTimestamp
  = lens _r1CreationTimestamp
      (\ s a -> s{_r1CreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
r1Id :: Lens' Route (Maybe Word64)
r1Id
  = lens _r1Id (\ s a -> s{_r1Id = a}) .
      mapping _Coerce

-- | The URL to a VpnTunnel that should handle matching packets.
r1NextHopVPNTunnel :: Lens' Route (Maybe Text)
r1NextHopVPNTunnel
  = lens _r1NextHopVPNTunnel
      (\ s a -> s{_r1NextHopVPNTunnel = a})

-- | An optional description of this resource. Provide this field when you
-- create the resource.
r1Description :: Lens' Route (Maybe Text)
r1Description
  = lens _r1Description
      (\ s a -> s{_r1Description = a})

-- | A list of instance tags to which this route applies.
r1Tags :: Lens' Route [Text]
r1Tags
  = lens _r1Tags (\ s a -> s{_r1Tags = a}) . _Default .
      _Coerce

-- | The URL to an instance that should handle matching packets. You can
-- specify this as a full or partial URL. For example:
-- https:\/\/www.googleapis.com\/compute\/v1\/projects\/project\/zones\/zone\/instances\/
r1NextHopInstance :: Lens' Route (Maybe Text)
r1NextHopInstance
  = lens _r1NextHopInstance
      (\ s a -> s{_r1NextHopInstance = a})

instance FromJSON Route where
        parseJSON
          = withObject "Route"
              (\ o ->
                 Route' <$>
                   (o .:? "nextHopIlb") <*> (o .:? "nextHopPeering") <*>
                     (o .:? "priority")
                     <*> (o .:? "kind" .!= "compute#route")
                     <*> (o .:? "nextHopGateway")
                     <*> (o .:? "nextHopNetwork")
                     <*> (o .:? "network")
                     <*> (o .:? "warnings" .!= mempty)
                     <*> (o .:? "nextHopIp")
                     <*> (o .:? "destRange")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "nextHopVpnTunnel")
                     <*> (o .:? "description")
                     <*> (o .:? "tags" .!= mempty)
                     <*> (o .:? "nextHopInstance"))

instance ToJSON Route where
        toJSON Route'{..}
          = object
              (catMaybes
                 [("nextHopIlb" .=) <$> _r1NextHopIlb,
                  ("nextHopPeering" .=) <$> _r1NextHopPeering,
                  ("priority" .=) <$> _r1Priority,
                  Just ("kind" .= _r1Kind),
                  ("nextHopGateway" .=) <$> _r1NextHopGateway,
                  ("nextHopNetwork" .=) <$> _r1NextHopNetwork,
                  ("network" .=) <$> _r1Network,
                  ("warnings" .=) <$> _r1Warnings,
                  ("nextHopIp" .=) <$> _r1NextHopIP,
                  ("destRange" .=) <$> _r1DestRange,
                  ("selfLink" .=) <$> _r1SelfLink,
                  ("name" .=) <$> _r1Name,
                  ("creationTimestamp" .=) <$> _r1CreationTimestamp,
                  ("id" .=) <$> _r1Id,
                  ("nextHopVpnTunnel" .=) <$> _r1NextHopVPNTunnel,
                  ("description" .=) <$> _r1Description,
                  ("tags" .=) <$> _r1Tags,
                  ("nextHopInstance" .=) <$> _r1NextHopInstance])

-- | The spec for modifying the path before sending the request to the
-- matched backend service.
--
-- /See:/ 'urlRewrite' smart constructor.
data URLRewrite =
  URLRewrite'
    { _urPathPrefixRewrite :: !(Maybe Text)
    , _urHostRewrite :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'URLRewrite' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'urPathPrefixRewrite'
--
-- * 'urHostRewrite'
urlRewrite
    :: URLRewrite
urlRewrite =
  URLRewrite' {_urPathPrefixRewrite = Nothing, _urHostRewrite = Nothing}


-- | Prior to forwarding the request to the selected backend service, the
-- matching portion of the request\'s path is replaced by
-- pathPrefixRewrite. The value must be between 1 and 1024 characters.
urPathPrefixRewrite :: Lens' URLRewrite (Maybe Text)
urPathPrefixRewrite
  = lens _urPathPrefixRewrite
      (\ s a -> s{_urPathPrefixRewrite = a})

-- | Prior to forwarding the request to the selected service, the request\'s
-- host header is replaced with contents of hostRewrite. The value must be
-- between 1 and 255 characters.
urHostRewrite :: Lens' URLRewrite (Maybe Text)
urHostRewrite
  = lens _urHostRewrite
      (\ s a -> s{_urHostRewrite = a})

instance FromJSON URLRewrite where
        parseJSON
          = withObject "URLRewrite"
              (\ o ->
                 URLRewrite' <$>
                   (o .:? "pathPrefixRewrite") <*>
                     (o .:? "hostRewrite"))

instance ToJSON URLRewrite where
        toJSON URLRewrite'{..}
          = object
              (catMaybes
                 [("pathPrefixRewrite" .=) <$> _urPathPrefixRewrite,
                  ("hostRewrite" .=) <$> _urHostRewrite])

--
-- /See:/ 'targetVPNGatewaysScopedListWarningDataItem' smart constructor.
data TargetVPNGatewaysScopedListWarningDataItem =
  TargetVPNGatewaysScopedListWarningDataItem'
    { _tvgslwdiValue :: !(Maybe Text)
    , _tvgslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetVPNGatewaysScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tvgslwdiValue'
--
-- * 'tvgslwdiKey'
targetVPNGatewaysScopedListWarningDataItem
    :: TargetVPNGatewaysScopedListWarningDataItem
targetVPNGatewaysScopedListWarningDataItem =
  TargetVPNGatewaysScopedListWarningDataItem'
    {_tvgslwdiValue = Nothing, _tvgslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
tvgslwdiValue :: Lens' TargetVPNGatewaysScopedListWarningDataItem (Maybe Text)
tvgslwdiValue
  = lens _tvgslwdiValue
      (\ s a -> s{_tvgslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
tvgslwdiKey :: Lens' TargetVPNGatewaysScopedListWarningDataItem (Maybe Text)
tvgslwdiKey
  = lens _tvgslwdiKey (\ s a -> s{_tvgslwdiKey = a})

instance FromJSON
           TargetVPNGatewaysScopedListWarningDataItem
         where
        parseJSON
          = withObject
              "TargetVPNGatewaysScopedListWarningDataItem"
              (\ o ->
                 TargetVPNGatewaysScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           TargetVPNGatewaysScopedListWarningDataItem
         where
        toJSON
          TargetVPNGatewaysScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _tvgslwdiValue,
                  ("key" .=) <$> _tvgslwdiKey])

-- | Properties of the SKU instances being reserved. Next ID: 9
--
-- /See:/ 'allocationSpecificSKUAllocationReservedInstanceProperties' smart constructor.
data AllocationSpecificSKUAllocationReservedInstanceProperties =
  AllocationSpecificSKUAllocationReservedInstanceProperties'
    { _asskuaripGuestAccelerators :: !(Maybe [AcceleratorConfig])
    , _asskuaripLocalSsds :: !(Maybe [AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk])
    , _asskuaripMachineType :: !(Maybe Text)
    , _asskuaripMinCPUPlatform :: !(Maybe Text)
    , _asskuaripLocationHint :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AllocationSpecificSKUAllocationReservedInstanceProperties' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'asskuaripGuestAccelerators'
--
-- * 'asskuaripLocalSsds'
--
-- * 'asskuaripMachineType'
--
-- * 'asskuaripMinCPUPlatform'
--
-- * 'asskuaripLocationHint'
allocationSpecificSKUAllocationReservedInstanceProperties
    :: AllocationSpecificSKUAllocationReservedInstanceProperties
allocationSpecificSKUAllocationReservedInstanceProperties =
  AllocationSpecificSKUAllocationReservedInstanceProperties'
    { _asskuaripGuestAccelerators = Nothing
    , _asskuaripLocalSsds = Nothing
    , _asskuaripMachineType = Nothing
    , _asskuaripMinCPUPlatform = Nothing
    , _asskuaripLocationHint = Nothing
    }


-- | Specifies accelerator type and count.
asskuaripGuestAccelerators :: Lens' AllocationSpecificSKUAllocationReservedInstanceProperties [AcceleratorConfig]
asskuaripGuestAccelerators
  = lens _asskuaripGuestAccelerators
      (\ s a -> s{_asskuaripGuestAccelerators = a})
      . _Default
      . _Coerce

-- | Specifies amount of local ssd to reserve with each instance. The type of
-- disk is local-ssd.
asskuaripLocalSsds :: Lens' AllocationSpecificSKUAllocationReservedInstanceProperties [AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk]
asskuaripLocalSsds
  = lens _asskuaripLocalSsds
      (\ s a -> s{_asskuaripLocalSsds = a})
      . _Default
      . _Coerce

-- | Specifies type of machine (name only) which has fixed number of vCPUs
-- and fixed amount of memory. This also includes specifying custom machine
-- type following custom-NUMBER_OF_CPUS-AMOUNT_OF_MEMORY pattern.
asskuaripMachineType :: Lens' AllocationSpecificSKUAllocationReservedInstanceProperties (Maybe Text)
asskuaripMachineType
  = lens _asskuaripMachineType
      (\ s a -> s{_asskuaripMachineType = a})

-- | Minimum cpu platform the reservation.
asskuaripMinCPUPlatform :: Lens' AllocationSpecificSKUAllocationReservedInstanceProperties (Maybe Text)
asskuaripMinCPUPlatform
  = lens _asskuaripMinCPUPlatform
      (\ s a -> s{_asskuaripMinCPUPlatform = a})

-- | An opaque location hint used to place the allocation close to other
-- resources. This field is for use by internal tools that use the public
-- API.
asskuaripLocationHint :: Lens' AllocationSpecificSKUAllocationReservedInstanceProperties (Maybe Text)
asskuaripLocationHint
  = lens _asskuaripLocationHint
      (\ s a -> s{_asskuaripLocationHint = a})

instance FromJSON
           AllocationSpecificSKUAllocationReservedInstanceProperties
         where
        parseJSON
          = withObject
              "AllocationSpecificSKUAllocationReservedInstanceProperties"
              (\ o ->
                 AllocationSpecificSKUAllocationReservedInstanceProperties'
                   <$>
                   (o .:? "guestAccelerators" .!= mempty) <*>
                     (o .:? "localSsds" .!= mempty)
                     <*> (o .:? "machineType")
                     <*> (o .:? "minCpuPlatform")
                     <*> (o .:? "locationHint"))

instance ToJSON
           AllocationSpecificSKUAllocationReservedInstanceProperties
         where
        toJSON
          AllocationSpecificSKUAllocationReservedInstanceProperties'{..}
          = object
              (catMaybes
                 [("guestAccelerators" .=) <$>
                    _asskuaripGuestAccelerators,
                  ("localSsds" .=) <$> _asskuaripLocalSsds,
                  ("machineType" .=) <$> _asskuaripMachineType,
                  ("minCpuPlatform" .=) <$> _asskuaripMinCPUPlatform,
                  ("locationHint" .=) <$> _asskuaripLocationHint])

-- | Information about any potential InterconnectAttachments between an
-- Interconnect at a specific InterconnectLocation, and a specific Cloud
-- Region.
--
-- /See:/ 'interconnectLocationRegionInfo' smart constructor.
data InterconnectLocationRegionInfo =
  InterconnectLocationRegionInfo'
    { _ilriLocationPresence :: !(Maybe InterconnectLocationRegionInfoLocationPresence)
    , _ilriExpectedRttMs :: !(Maybe (Textual Int64))
    , _ilriRegion :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectLocationRegionInfo' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ilriLocationPresence'
--
-- * 'ilriExpectedRttMs'
--
-- * 'ilriRegion'
interconnectLocationRegionInfo
    :: InterconnectLocationRegionInfo
interconnectLocationRegionInfo =
  InterconnectLocationRegionInfo'
    { _ilriLocationPresence = Nothing
    , _ilriExpectedRttMs = Nothing
    , _ilriRegion = Nothing
    }


-- | Identifies the network presence of this location.
ilriLocationPresence :: Lens' InterconnectLocationRegionInfo (Maybe InterconnectLocationRegionInfoLocationPresence)
ilriLocationPresence
  = lens _ilriLocationPresence
      (\ s a -> s{_ilriLocationPresence = a})

-- | Expected round-trip time in milliseconds, from this InterconnectLocation
-- to a VM in this region.
ilriExpectedRttMs :: Lens' InterconnectLocationRegionInfo (Maybe Int64)
ilriExpectedRttMs
  = lens _ilriExpectedRttMs
      (\ s a -> s{_ilriExpectedRttMs = a})
      . mapping _Coerce

-- | URL for the region of this location.
ilriRegion :: Lens' InterconnectLocationRegionInfo (Maybe Text)
ilriRegion
  = lens _ilriRegion (\ s a -> s{_ilriRegion = a})

instance FromJSON InterconnectLocationRegionInfo
         where
        parseJSON
          = withObject "InterconnectLocationRegionInfo"
              (\ o ->
                 InterconnectLocationRegionInfo' <$>
                   (o .:? "locationPresence") <*>
                     (o .:? "expectedRttMs")
                     <*> (o .:? "region"))

instance ToJSON InterconnectLocationRegionInfo where
        toJSON InterconnectLocationRegionInfo'{..}
          = object
              (catMaybes
                 [("locationPresence" .=) <$> _ilriLocationPresence,
                  ("expectedRttMs" .=) <$> _ilriExpectedRttMs,
                  ("region" .=) <$> _ilriRegion])

-- | Configuration for a Cloud Function network endpoint group (NEG). The
-- function must be provided explicitly or in the URL mask. Note: Cloud
-- Function must be in the same project and located in the same region as
-- the Serverless NEG.
--
-- /See:/ 'networkEndpointGroupCloudFunction' smart constructor.
data NetworkEndpointGroupCloudFunction =
  NetworkEndpointGroupCloudFunction'
    { _negcfFunction :: !(Maybe Text)
    , _negcfURLMask :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkEndpointGroupCloudFunction' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'negcfFunction'
--
-- * 'negcfURLMask'
networkEndpointGroupCloudFunction
    :: NetworkEndpointGroupCloudFunction
networkEndpointGroupCloudFunction =
  NetworkEndpointGroupCloudFunction'
    {_negcfFunction = Nothing, _negcfURLMask = Nothing}


-- | A user-defined name of the Cloud Function. The function name is
-- case-sensitive and must be 1-63 characters long. Example value:
-- \"func1\".
negcfFunction :: Lens' NetworkEndpointGroupCloudFunction (Maybe Text)
negcfFunction
  = lens _negcfFunction
      (\ s a -> s{_negcfFunction = a})

-- | A template to parse function field from a request URL. URL mask allows
-- for routing to multiple Cloud Functions without having to create
-- multiple Network Endpoint Groups and backend services. For example,
-- request URLs \"mydomain.com\/function1\" and \"mydomain.com\/function2\"
-- can be backed by the same Serverless NEG with URL mask \"\/\". The URL
-- mask will parse them to { function = \"function1\" } and { function =
-- \"function2\" } respectively.
negcfURLMask :: Lens' NetworkEndpointGroupCloudFunction (Maybe Text)
negcfURLMask
  = lens _negcfURLMask (\ s a -> s{_negcfURLMask = a})

instance FromJSON NetworkEndpointGroupCloudFunction
         where
        parseJSON
          = withObject "NetworkEndpointGroupCloudFunction"
              (\ o ->
                 NetworkEndpointGroupCloudFunction' <$>
                   (o .:? "function") <*> (o .:? "urlMask"))

instance ToJSON NetworkEndpointGroupCloudFunction
         where
        toJSON NetworkEndpointGroupCloudFunction'{..}
          = object
              (catMaybes
                 [("function" .=) <$> _negcfFunction,
                  ("urlMask" .=) <$> _negcfURLMask])

--
-- /See:/ 'targetHTTPSProxiesSetSSLCertificatesRequest' smart constructor.
newtype TargetHTTPSProxiesSetSSLCertificatesRequest =
  TargetHTTPSProxiesSetSSLCertificatesRequest'
    { _thpsscrSSLCertificates :: Maybe [Text]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetHTTPSProxiesSetSSLCertificatesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'thpsscrSSLCertificates'
targetHTTPSProxiesSetSSLCertificatesRequest
    :: TargetHTTPSProxiesSetSSLCertificatesRequest
targetHTTPSProxiesSetSSLCertificatesRequest =
  TargetHTTPSProxiesSetSSLCertificatesRequest'
    {_thpsscrSSLCertificates = Nothing}


-- | New set of SslCertificate resources to associate with this
-- TargetHttpsProxy resource. At least one SSL certificate must be
-- specified. Currently, you may specify up to 15 SSL certificates.
thpsscrSSLCertificates :: Lens' TargetHTTPSProxiesSetSSLCertificatesRequest [Text]
thpsscrSSLCertificates
  = lens _thpsscrSSLCertificates
      (\ s a -> s{_thpsscrSSLCertificates = a})
      . _Default
      . _Coerce

instance FromJSON
           TargetHTTPSProxiesSetSSLCertificatesRequest
         where
        parseJSON
          = withObject
              "TargetHTTPSProxiesSetSSLCertificatesRequest"
              (\ o ->
                 TargetHTTPSProxiesSetSSLCertificatesRequest' <$>
                   (o .:? "sslCertificates" .!= mempty))

instance ToJSON
           TargetHTTPSProxiesSetSSLCertificatesRequest
         where
        toJSON
          TargetHTTPSProxiesSetSSLCertificatesRequest'{..}
          = object
              (catMaybes
                 [("sslCertificates" .=) <$> _thpsscrSSLCertificates])

--
-- /See:/ 'instancesRemoveResourcePoliciesRequest' smart constructor.
newtype InstancesRemoveResourcePoliciesRequest =
  InstancesRemoveResourcePoliciesRequest'
    { _irrprResourcePolicies :: Maybe [Text]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstancesRemoveResourcePoliciesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'irrprResourcePolicies'
instancesRemoveResourcePoliciesRequest
    :: InstancesRemoveResourcePoliciesRequest
instancesRemoveResourcePoliciesRequest =
  InstancesRemoveResourcePoliciesRequest' {_irrprResourcePolicies = Nothing}


-- | Resource policies to be removed from this instance.
irrprResourcePolicies :: Lens' InstancesRemoveResourcePoliciesRequest [Text]
irrprResourcePolicies
  = lens _irrprResourcePolicies
      (\ s a -> s{_irrprResourcePolicies = a})
      . _Default
      . _Coerce

instance FromJSON
           InstancesRemoveResourcePoliciesRequest
         where
        parseJSON
          = withObject "InstancesRemoveResourcePoliciesRequest"
              (\ o ->
                 InstancesRemoveResourcePoliciesRequest' <$>
                   (o .:? "resourcePolicies" .!= mempty))

instance ToJSON
           InstancesRemoveResourcePoliciesRequest
         where
        toJSON InstancesRemoveResourcePoliciesRequest'{..}
          = object
              (catMaybes
                 [("resourcePolicies" .=) <$> _irrprResourcePolicies])

-- | InstanceGroupManagers.patchPerInstanceConfigs
--
-- /See:/ 'instanceGroupManagersPatchPerInstanceConfigsReq' smart constructor.
newtype InstanceGroupManagersPatchPerInstanceConfigsReq =
  InstanceGroupManagersPatchPerInstanceConfigsReq'
    { _igmppicrPerInstanceConfigs :: Maybe [PerInstanceConfig]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagersPatchPerInstanceConfigsReq' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmppicrPerInstanceConfigs'
instanceGroupManagersPatchPerInstanceConfigsReq
    :: InstanceGroupManagersPatchPerInstanceConfigsReq
instanceGroupManagersPatchPerInstanceConfigsReq =
  InstanceGroupManagersPatchPerInstanceConfigsReq'
    {_igmppicrPerInstanceConfigs = Nothing}


-- | The list of per-instance configs to insert or patch on this managed
-- instance group.
igmppicrPerInstanceConfigs :: Lens' InstanceGroupManagersPatchPerInstanceConfigsReq [PerInstanceConfig]
igmppicrPerInstanceConfigs
  = lens _igmppicrPerInstanceConfigs
      (\ s a -> s{_igmppicrPerInstanceConfigs = a})
      . _Default
      . _Coerce

instance FromJSON
           InstanceGroupManagersPatchPerInstanceConfigsReq
         where
        parseJSON
          = withObject
              "InstanceGroupManagersPatchPerInstanceConfigsReq"
              (\ o ->
                 InstanceGroupManagersPatchPerInstanceConfigsReq' <$>
                   (o .:? "perInstanceConfigs" .!= mempty))

instance ToJSON
           InstanceGroupManagersPatchPerInstanceConfigsReq
         where
        toJSON
          InstanceGroupManagersPatchPerInstanceConfigsReq'{..}
          = object
              (catMaybes
                 [("perInstanceConfigs" .=) <$>
                    _igmppicrPerInstanceConfigs])

-- | Represents an Instance Template resource. You can use instance templates
-- to create VM instances and managed instance groups. For more
-- information, read Instance Templates. (== resource_for
-- {$api_version}.instanceTemplates ==)
--
-- /See:/ 'instanceTemplate' smart constructor.
data InstanceTemplate =
  InstanceTemplate'
    { _itSourceInstance :: !(Maybe Text)
    , _itKind :: !Text
    , _itSelfLink :: !(Maybe Text)
    , _itName :: !(Maybe Text)
    , _itCreationTimestamp :: !(Maybe Text)
    , _itId :: !(Maybe (Textual Word64))
    , _itSourceInstanceParams :: !(Maybe SourceInstanceParams)
    , _itDescription :: !(Maybe Text)
    , _itProperties :: !(Maybe InstanceProperties)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceTemplate' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'itSourceInstance'
--
-- * 'itKind'
--
-- * 'itSelfLink'
--
-- * 'itName'
--
-- * 'itCreationTimestamp'
--
-- * 'itId'
--
-- * 'itSourceInstanceParams'
--
-- * 'itDescription'
--
-- * 'itProperties'
instanceTemplate
    :: InstanceTemplate
instanceTemplate =
  InstanceTemplate'
    { _itSourceInstance = Nothing
    , _itKind = "compute#instanceTemplate"
    , _itSelfLink = Nothing
    , _itName = Nothing
    , _itCreationTimestamp = Nothing
    , _itId = Nothing
    , _itSourceInstanceParams = Nothing
    , _itDescription = Nothing
    , _itProperties = Nothing
    }


-- | The source instance used to create the template. You can provide this as
-- a partial or full URL to the resource. For example, the following are
-- valid values: -
-- https:\/\/www.googleapis.com\/compute\/v1\/projects\/project\/zones\/zone\/instances\/instance
-- - projects\/project\/zones\/zone\/instances\/instance
itSourceInstance :: Lens' InstanceTemplate (Maybe Text)
itSourceInstance
  = lens _itSourceInstance
      (\ s a -> s{_itSourceInstance = a})

-- | [Output Only] The resource type, which is always
-- compute#instanceTemplate for instance templates.
itKind :: Lens' InstanceTemplate Text
itKind = lens _itKind (\ s a -> s{_itKind = a})

-- | [Output Only] The URL for this instance template. The server defines
-- this URL.
itSelfLink :: Lens' InstanceTemplate (Maybe Text)
itSelfLink
  = lens _itSelfLink (\ s a -> s{_itSelfLink = a})

-- | Name of the resource; provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
itName :: Lens' InstanceTemplate (Maybe Text)
itName = lens _itName (\ s a -> s{_itName = a})

-- | [Output Only] The creation timestamp for this instance template in
-- RFC3339 text format.
itCreationTimestamp :: Lens' InstanceTemplate (Maybe Text)
itCreationTimestamp
  = lens _itCreationTimestamp
      (\ s a -> s{_itCreationTimestamp = a})

-- | [Output Only] A unique identifier for this instance template. The server
-- defines this identifier.
itId :: Lens' InstanceTemplate (Maybe Word64)
itId
  = lens _itId (\ s a -> s{_itId = a}) .
      mapping _Coerce

-- | The source instance params to use to create this instance template.
itSourceInstanceParams :: Lens' InstanceTemplate (Maybe SourceInstanceParams)
itSourceInstanceParams
  = lens _itSourceInstanceParams
      (\ s a -> s{_itSourceInstanceParams = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource.
itDescription :: Lens' InstanceTemplate (Maybe Text)
itDescription
  = lens _itDescription
      (\ s a -> s{_itDescription = a})

-- | The instance properties for this instance template.
itProperties :: Lens' InstanceTemplate (Maybe InstanceProperties)
itProperties
  = lens _itProperties (\ s a -> s{_itProperties = a})

instance FromJSON InstanceTemplate where
        parseJSON
          = withObject "InstanceTemplate"
              (\ o ->
                 InstanceTemplate' <$>
                   (o .:? "sourceInstance") <*>
                     (o .:? "kind" .!= "compute#instanceTemplate")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "sourceInstanceParams")
                     <*> (o .:? "description")
                     <*> (o .:? "properties"))

instance ToJSON InstanceTemplate where
        toJSON InstanceTemplate'{..}
          = object
              (catMaybes
                 [("sourceInstance" .=) <$> _itSourceInstance,
                  Just ("kind" .= _itKind),
                  ("selfLink" .=) <$> _itSelfLink,
                  ("name" .=) <$> _itName,
                  ("creationTimestamp" .=) <$> _itCreationTimestamp,
                  ("id" .=) <$> _itId,
                  ("sourceInstanceParams" .=) <$>
                    _itSourceInstanceParams,
                  ("description" .=) <$> _itDescription,
                  ("properties" .=) <$> _itProperties])

-- | Service resource (a.k.a service project) ID.
--
-- /See:/ 'xpnResourceId' smart constructor.
data XpnResourceId =
  XpnResourceId'
    { _xriId :: !(Maybe Text)
    , _xriType :: !(Maybe XpnResourceIdType)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'XpnResourceId' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'xriId'
--
-- * 'xriType'
xpnResourceId
    :: XpnResourceId
xpnResourceId = XpnResourceId' {_xriId = Nothing, _xriType = Nothing}


-- | The ID of the service resource. In the case of projects, this field
-- supports project id (e.g., my-project-123) and project number (e.g.
-- 12345678).
xriId :: Lens' XpnResourceId (Maybe Text)
xriId = lens _xriId (\ s a -> s{_xriId = a})

-- | The type of the service resource.
xriType :: Lens' XpnResourceId (Maybe XpnResourceIdType)
xriType = lens _xriType (\ s a -> s{_xriType = a})

instance FromJSON XpnResourceId where
        parseJSON
          = withObject "XpnResourceId"
              (\ o ->
                 XpnResourceId' <$> (o .:? "id") <*> (o .:? "type"))

instance ToJSON XpnResourceId where
        toJSON XpnResourceId'{..}
          = object
              (catMaybes
                 [("id" .=) <$> _xriId, ("type" .=) <$> _xriType])

-- | Contains a list of Router resources.
--
-- /See:/ 'routerList' smart constructor.
data RouterList =
  RouterList'
    { _rllNextPageToken :: !(Maybe Text)
    , _rllKind :: !Text
    , _rllItems :: !(Maybe [Router])
    , _rllSelfLink :: !(Maybe Text)
    , _rllWarning :: !(Maybe RouterListWarning)
    , _rllId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RouterList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rllNextPageToken'
--
-- * 'rllKind'
--
-- * 'rllItems'
--
-- * 'rllSelfLink'
--
-- * 'rllWarning'
--
-- * 'rllId'
routerList
    :: RouterList
routerList =
  RouterList'
    { _rllNextPageToken = Nothing
    , _rllKind = "compute#routerList"
    , _rllItems = Nothing
    , _rllSelfLink = Nothing
    , _rllWarning = Nothing
    , _rllId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
rllNextPageToken :: Lens' RouterList (Maybe Text)
rllNextPageToken
  = lens _rllNextPageToken
      (\ s a -> s{_rllNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#router for routers.
rllKind :: Lens' RouterList Text
rllKind = lens _rllKind (\ s a -> s{_rllKind = a})

-- | A list of Router resources.
rllItems :: Lens' RouterList [Router]
rllItems
  = lens _rllItems (\ s a -> s{_rllItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
rllSelfLink :: Lens' RouterList (Maybe Text)
rllSelfLink
  = lens _rllSelfLink (\ s a -> s{_rllSelfLink = a})

-- | [Output Only] Informational warning message.
rllWarning :: Lens' RouterList (Maybe RouterListWarning)
rllWarning
  = lens _rllWarning (\ s a -> s{_rllWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
rllId :: Lens' RouterList (Maybe Text)
rllId = lens _rllId (\ s a -> s{_rllId = a})

instance FromJSON RouterList where
        parseJSON
          = withObject "RouterList"
              (\ o ->
                 RouterList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#routerList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON RouterList where
        toJSON RouterList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _rllNextPageToken,
                  Just ("kind" .= _rllKind),
                  ("items" .=) <$> _rllItems,
                  ("selfLink" .=) <$> _rllSelfLink,
                  ("warning" .=) <$> _rllWarning,
                  ("id" .=) <$> _rllId])

-- | Represents a Target SSL Proxy resource. A target SSL proxy is a
-- component of a SSL Proxy load balancer. Global forwarding rules
-- reference a target SSL proxy, and the target proxy then references an
-- external backend service. For more information, read Using Target
-- Proxies. (== resource_for {$api_version}.targetSslProxies ==)
--
-- /See:/ 'targetSSLProxy' smart constructor.
data TargetSSLProxy =
  TargetSSLProxy'
    { _tspSSLPolicy :: !(Maybe Text)
    , _tspSSLCertificates :: !(Maybe [Text])
    , _tspService :: !(Maybe Text)
    , _tspKind :: !Text
    , _tspSelfLink :: !(Maybe Text)
    , _tspName :: !(Maybe Text)
    , _tspCreationTimestamp :: !(Maybe Text)
    , _tspId :: !(Maybe (Textual Word64))
    , _tspProxyHeader :: !(Maybe TargetSSLProxyProxyHeader)
    , _tspDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetSSLProxy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tspSSLPolicy'
--
-- * 'tspSSLCertificates'
--
-- * 'tspService'
--
-- * 'tspKind'
--
-- * 'tspSelfLink'
--
-- * 'tspName'
--
-- * 'tspCreationTimestamp'
--
-- * 'tspId'
--
-- * 'tspProxyHeader'
--
-- * 'tspDescription'
targetSSLProxy
    :: TargetSSLProxy
targetSSLProxy =
  TargetSSLProxy'
    { _tspSSLPolicy = Nothing
    , _tspSSLCertificates = Nothing
    , _tspService = Nothing
    , _tspKind = "compute#targetSslProxy"
    , _tspSelfLink = Nothing
    , _tspName = Nothing
    , _tspCreationTimestamp = Nothing
    , _tspId = Nothing
    , _tspProxyHeader = Nothing
    , _tspDescription = Nothing
    }


-- | URL of SslPolicy resource that will be associated with the
-- TargetSslProxy resource. If not set, the TargetSslProxy resource will
-- not have any SSL policy configured.
tspSSLPolicy :: Lens' TargetSSLProxy (Maybe Text)
tspSSLPolicy
  = lens _tspSSLPolicy (\ s a -> s{_tspSSLPolicy = a})

-- | URLs to SslCertificate resources that are used to authenticate
-- connections to Backends. At least one SSL certificate must be specified.
-- Currently, you may specify up to 15 SSL certificates. sslCertificates do
-- not apply when the load balancing scheme is set to
-- INTERNAL_SELF_MANAGED.
tspSSLCertificates :: Lens' TargetSSLProxy [Text]
tspSSLCertificates
  = lens _tspSSLCertificates
      (\ s a -> s{_tspSSLCertificates = a})
      . _Default
      . _Coerce

-- | URL to the BackendService resource.
tspService :: Lens' TargetSSLProxy (Maybe Text)
tspService
  = lens _tspService (\ s a -> s{_tspService = a})

-- | [Output Only] Type of the resource. Always compute#targetSslProxy for
-- target SSL proxies.
tspKind :: Lens' TargetSSLProxy Text
tspKind = lens _tspKind (\ s a -> s{_tspKind = a})

-- | [Output Only] Server-defined URL for the resource.
tspSelfLink :: Lens' TargetSSLProxy (Maybe Text)
tspSelfLink
  = lens _tspSelfLink (\ s a -> s{_tspSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
tspName :: Lens' TargetSSLProxy (Maybe Text)
tspName = lens _tspName (\ s a -> s{_tspName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
tspCreationTimestamp :: Lens' TargetSSLProxy (Maybe Text)
tspCreationTimestamp
  = lens _tspCreationTimestamp
      (\ s a -> s{_tspCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
tspId :: Lens' TargetSSLProxy (Maybe Word64)
tspId
  = lens _tspId (\ s a -> s{_tspId = a}) .
      mapping _Coerce

-- | Specifies the type of proxy header to append before sending data to the
-- backend, either NONE or PROXY_V1. The default is NONE.
tspProxyHeader :: Lens' TargetSSLProxy (Maybe TargetSSLProxyProxyHeader)
tspProxyHeader
  = lens _tspProxyHeader
      (\ s a -> s{_tspProxyHeader = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource.
tspDescription :: Lens' TargetSSLProxy (Maybe Text)
tspDescription
  = lens _tspDescription
      (\ s a -> s{_tspDescription = a})

instance FromJSON TargetSSLProxy where
        parseJSON
          = withObject "TargetSSLProxy"
              (\ o ->
                 TargetSSLProxy' <$>
                   (o .:? "sslPolicy") <*>
                     (o .:? "sslCertificates" .!= mempty)
                     <*> (o .:? "service")
                     <*> (o .:? "kind" .!= "compute#targetSslProxy")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "proxyHeader")
                     <*> (o .:? "description"))

instance ToJSON TargetSSLProxy where
        toJSON TargetSSLProxy'{..}
          = object
              (catMaybes
                 [("sslPolicy" .=) <$> _tspSSLPolicy,
                  ("sslCertificates" .=) <$> _tspSSLCertificates,
                  ("service" .=) <$> _tspService,
                  Just ("kind" .= _tspKind),
                  ("selfLink" .=) <$> _tspSelfLink,
                  ("name" .=) <$> _tspName,
                  ("creationTimestamp" .=) <$> _tspCreationTimestamp,
                  ("id" .=) <$> _tspId,
                  ("proxyHeader" .=) <$> _tspProxyHeader,
                  ("description" .=) <$> _tspDescription])

--
-- /See:/ 'instanceGroupManagerStatus' smart constructor.
data InstanceGroupManagerStatus =
  InstanceGroupManagerStatus'
    { _igmsVersionTarget :: !(Maybe InstanceGroupManagerStatusVersionTarget)
    , _igmsIsStable :: !(Maybe Bool)
    , _igmsAutoscaler :: !(Maybe Text)
    , _igmsStateful :: !(Maybe InstanceGroupManagerStatusStateful)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagerStatus' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmsVersionTarget'
--
-- * 'igmsIsStable'
--
-- * 'igmsAutoscaler'
--
-- * 'igmsStateful'
instanceGroupManagerStatus
    :: InstanceGroupManagerStatus
instanceGroupManagerStatus =
  InstanceGroupManagerStatus'
    { _igmsVersionTarget = Nothing
    , _igmsIsStable = Nothing
    , _igmsAutoscaler = Nothing
    , _igmsStateful = Nothing
    }


-- | [Output Only] A status of consistency of Instances\' versions with their
-- target version specified by version field on Instance Group Manager.
igmsVersionTarget :: Lens' InstanceGroupManagerStatus (Maybe InstanceGroupManagerStatusVersionTarget)
igmsVersionTarget
  = lens _igmsVersionTarget
      (\ s a -> s{_igmsVersionTarget = a})

-- | [Output Only] A bit indicating whether the managed instance group is in
-- a stable state. A stable state means that: none of the instances in the
-- managed instance group is currently undergoing any type of change (for
-- example, creation, restart, or deletion); no future changes are
-- scheduled for instances in the managed instance group; and the managed
-- instance group itself is not being modified.
igmsIsStable :: Lens' InstanceGroupManagerStatus (Maybe Bool)
igmsIsStable
  = lens _igmsIsStable (\ s a -> s{_igmsIsStable = a})

-- | [Output Only] The URL of the Autoscaler that targets this instance group
-- manager.
igmsAutoscaler :: Lens' InstanceGroupManagerStatus (Maybe Text)
igmsAutoscaler
  = lens _igmsAutoscaler
      (\ s a -> s{_igmsAutoscaler = a})

-- | [Output Only] Stateful status of the given Instance Group Manager.
igmsStateful :: Lens' InstanceGroupManagerStatus (Maybe InstanceGroupManagerStatusStateful)
igmsStateful
  = lens _igmsStateful (\ s a -> s{_igmsStateful = a})

instance FromJSON InstanceGroupManagerStatus where
        parseJSON
          = withObject "InstanceGroupManagerStatus"
              (\ o ->
                 InstanceGroupManagerStatus' <$>
                   (o .:? "versionTarget") <*> (o .:? "isStable") <*>
                     (o .:? "autoscaler")
                     <*> (o .:? "stateful"))

instance ToJSON InstanceGroupManagerStatus where
        toJSON InstanceGroupManagerStatus'{..}
          = object
              (catMaybes
                 [("versionTarget" .=) <$> _igmsVersionTarget,
                  ("isStable" .=) <$> _igmsIsStable,
                  ("autoscaler" .=) <$> _igmsAutoscaler,
                  ("stateful" .=) <$> _igmsStateful])

--
-- /See:/ 'targetHTTPSProxyAggregatedList' smart constructor.
data TargetHTTPSProxyAggregatedList =
  TargetHTTPSProxyAggregatedList'
    { _thpalUnreachables :: !(Maybe [Text])
    , _thpalNextPageToken :: !(Maybe Text)
    , _thpalKind :: !Text
    , _thpalItems :: !(Maybe TargetHTTPSProxyAggregatedListItems)
    , _thpalSelfLink :: !(Maybe Text)
    , _thpalWarning :: !(Maybe TargetHTTPSProxyAggregatedListWarning)
    , _thpalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetHTTPSProxyAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'thpalUnreachables'
--
-- * 'thpalNextPageToken'
--
-- * 'thpalKind'
--
-- * 'thpalItems'
--
-- * 'thpalSelfLink'
--
-- * 'thpalWarning'
--
-- * 'thpalId'
targetHTTPSProxyAggregatedList
    :: TargetHTTPSProxyAggregatedList
targetHTTPSProxyAggregatedList =
  TargetHTTPSProxyAggregatedList'
    { _thpalUnreachables = Nothing
    , _thpalNextPageToken = Nothing
    , _thpalKind = "compute#targetHttpsProxyAggregatedList"
    , _thpalItems = Nothing
    , _thpalSelfLink = Nothing
    , _thpalWarning = Nothing
    , _thpalId = Nothing
    }


-- | [Output Only] Unreachable resources.
thpalUnreachables :: Lens' TargetHTTPSProxyAggregatedList [Text]
thpalUnreachables
  = lens _thpalUnreachables
      (\ s a -> s{_thpalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
thpalNextPageToken :: Lens' TargetHTTPSProxyAggregatedList (Maybe Text)
thpalNextPageToken
  = lens _thpalNextPageToken
      (\ s a -> s{_thpalNextPageToken = a})

-- | [Output Only] Type of resource. Always
-- compute#targetHttpsProxyAggregatedList for lists of Target HTTP Proxies.
thpalKind :: Lens' TargetHTTPSProxyAggregatedList Text
thpalKind
  = lens _thpalKind (\ s a -> s{_thpalKind = a})

-- | A list of TargetHttpsProxiesScopedList resources.
thpalItems :: Lens' TargetHTTPSProxyAggregatedList (Maybe TargetHTTPSProxyAggregatedListItems)
thpalItems
  = lens _thpalItems (\ s a -> s{_thpalItems = a})

-- | [Output Only] Server-defined URL for this resource.
thpalSelfLink :: Lens' TargetHTTPSProxyAggregatedList (Maybe Text)
thpalSelfLink
  = lens _thpalSelfLink
      (\ s a -> s{_thpalSelfLink = a})

-- | [Output Only] Informational warning message.
thpalWarning :: Lens' TargetHTTPSProxyAggregatedList (Maybe TargetHTTPSProxyAggregatedListWarning)
thpalWarning
  = lens _thpalWarning (\ s a -> s{_thpalWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
thpalId :: Lens' TargetHTTPSProxyAggregatedList (Maybe Text)
thpalId = lens _thpalId (\ s a -> s{_thpalId = a})

instance FromJSON TargetHTTPSProxyAggregatedList
         where
        parseJSON
          = withObject "TargetHTTPSProxyAggregatedList"
              (\ o ->
                 TargetHTTPSProxyAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!=
                        "compute#targetHttpsProxyAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON TargetHTTPSProxyAggregatedList where
        toJSON TargetHTTPSProxyAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _thpalUnreachables,
                  ("nextPageToken" .=) <$> _thpalNextPageToken,
                  Just ("kind" .= _thpalKind),
                  ("items" .=) <$> _thpalItems,
                  ("selfLink" .=) <$> _thpalSelfLink,
                  ("warning" .=) <$> _thpalWarning,
                  ("id" .=) <$> _thpalId])

-- | A list of Allocation resources.
--
-- /See:/ 'reservationAggregatedListItems' smart constructor.
newtype ReservationAggregatedListItems =
  ReservationAggregatedListItems'
    { _raliAddtional :: HashMap Text ReservationsScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ReservationAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'raliAddtional'
reservationAggregatedListItems
    :: HashMap Text ReservationsScopedList -- ^ 'raliAddtional'
    -> ReservationAggregatedListItems
reservationAggregatedListItems pRaliAddtional_ =
  ReservationAggregatedListItems' {_raliAddtional = _Coerce # pRaliAddtional_}


-- | Name of the scope containing this set of reservations.
raliAddtional :: Lens' ReservationAggregatedListItems (HashMap Text ReservationsScopedList)
raliAddtional
  = lens _raliAddtional
      (\ s a -> s{_raliAddtional = a})
      . _Coerce

instance FromJSON ReservationAggregatedListItems
         where
        parseJSON
          = withObject "ReservationAggregatedListItems"
              (\ o ->
                 ReservationAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON ReservationAggregatedListItems where
        toJSON = toJSON . _raliAddtional

-- | RegionInstanceGroupManagers.createInstances
--
-- /See:/ 'regionInstanceGroupManagersCreateInstancesRequest' smart constructor.
newtype RegionInstanceGroupManagersCreateInstancesRequest =
  RegionInstanceGroupManagersCreateInstancesRequest'
    { _rigmcirInstances :: Maybe [PerInstanceConfig]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupManagersCreateInstancesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rigmcirInstances'
regionInstanceGroupManagersCreateInstancesRequest
    :: RegionInstanceGroupManagersCreateInstancesRequest
regionInstanceGroupManagersCreateInstancesRequest =
  RegionInstanceGroupManagersCreateInstancesRequest'
    {_rigmcirInstances = Nothing}


-- | [Required] List of specifications of per-instance configs.
rigmcirInstances :: Lens' RegionInstanceGroupManagersCreateInstancesRequest [PerInstanceConfig]
rigmcirInstances
  = lens _rigmcirInstances
      (\ s a -> s{_rigmcirInstances = a})
      . _Default
      . _Coerce

instance FromJSON
           RegionInstanceGroupManagersCreateInstancesRequest
         where
        parseJSON
          = withObject
              "RegionInstanceGroupManagersCreateInstancesRequest"
              (\ o ->
                 RegionInstanceGroupManagersCreateInstancesRequest'
                   <$> (o .:? "instances" .!= mempty))

instance ToJSON
           RegionInstanceGroupManagersCreateInstancesRequest
         where
        toJSON
          RegionInstanceGroupManagersCreateInstancesRequest'{..}
          = object
              (catMaybes [("instances" .=) <$> _rigmcirInstances])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'sslCertificateListWarning' smart constructor.
data SSLCertificateListWarning =
  SSLCertificateListWarning'
    { _sclwData :: !(Maybe [SSLCertificateListWarningDataItem])
    , _sclwCode :: !(Maybe SSLCertificateListWarningCode)
    , _sclwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SSLCertificateListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sclwData'
--
-- * 'sclwCode'
--
-- * 'sclwMessage'
sslCertificateListWarning
    :: SSLCertificateListWarning
sslCertificateListWarning =
  SSLCertificateListWarning'
    {_sclwData = Nothing, _sclwCode = Nothing, _sclwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
sclwData :: Lens' SSLCertificateListWarning [SSLCertificateListWarningDataItem]
sclwData
  = lens _sclwData (\ s a -> s{_sclwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
sclwCode :: Lens' SSLCertificateListWarning (Maybe SSLCertificateListWarningCode)
sclwCode = lens _sclwCode (\ s a -> s{_sclwCode = a})

-- | [Output Only] A human-readable description of the warning code.
sclwMessage :: Lens' SSLCertificateListWarning (Maybe Text)
sclwMessage
  = lens _sclwMessage (\ s a -> s{_sclwMessage = a})

instance FromJSON SSLCertificateListWarning where
        parseJSON
          = withObject "SSLCertificateListWarning"
              (\ o ->
                 SSLCertificateListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON SSLCertificateListWarning where
        toJSON SSLCertificateListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _sclwData,
                  ("code" .=) <$> _sclwCode,
                  ("message" .=) <$> _sclwMessage])

--
-- /See:/ 'snapshotListWarningDataItem' smart constructor.
data SnapshotListWarningDataItem =
  SnapshotListWarningDataItem'
    { _slwdiValue :: !(Maybe Text)
    , _slwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SnapshotListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'slwdiValue'
--
-- * 'slwdiKey'
snapshotListWarningDataItem
    :: SnapshotListWarningDataItem
snapshotListWarningDataItem =
  SnapshotListWarningDataItem' {_slwdiValue = Nothing, _slwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
slwdiValue :: Lens' SnapshotListWarningDataItem (Maybe Text)
slwdiValue
  = lens _slwdiValue (\ s a -> s{_slwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
slwdiKey :: Lens' SnapshotListWarningDataItem (Maybe Text)
slwdiKey = lens _slwdiKey (\ s a -> s{_slwdiKey = a})

instance FromJSON SnapshotListWarningDataItem where
        parseJSON
          = withObject "SnapshotListWarningDataItem"
              (\ o ->
                 SnapshotListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON SnapshotListWarningDataItem where
        toJSON SnapshotListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _slwdiValue,
                  ("key" .=) <$> _slwdiKey])

-- | Represents a Target VPN Gateway resource. The target VPN gateway
-- resource represents a Classic Cloud VPN gateway. For more information,
-- read the the Cloud VPN Overview. (== resource_for
-- {$api_version}.targetVpnGateways ==)
--
-- /See:/ 'targetVPNGateway' smart constructor.
data TargetVPNGateway =
  TargetVPNGateway'
    { _tvgStatus :: !(Maybe TargetVPNGatewayStatus)
    , _tvgKind :: !Text
    , _tvgNetwork :: !(Maybe Text)
    , _tvgSelfLink :: !(Maybe Text)
    , _tvgName :: !(Maybe Text)
    , _tvgCreationTimestamp :: !(Maybe Text)
    , _tvgId :: !(Maybe (Textual Word64))
    , _tvgRegion :: !(Maybe Text)
    , _tvgTunnels :: !(Maybe [Text])
    , _tvgDescription :: !(Maybe Text)
    , _tvgForwardingRules :: !(Maybe [Text])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetVPNGateway' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tvgStatus'
--
-- * 'tvgKind'
--
-- * 'tvgNetwork'
--
-- * 'tvgSelfLink'
--
-- * 'tvgName'
--
-- * 'tvgCreationTimestamp'
--
-- * 'tvgId'
--
-- * 'tvgRegion'
--
-- * 'tvgTunnels'
--
-- * 'tvgDescription'
--
-- * 'tvgForwardingRules'
targetVPNGateway
    :: TargetVPNGateway
targetVPNGateway =
  TargetVPNGateway'
    { _tvgStatus = Nothing
    , _tvgKind = "compute#targetVpnGateway"
    , _tvgNetwork = Nothing
    , _tvgSelfLink = Nothing
    , _tvgName = Nothing
    , _tvgCreationTimestamp = Nothing
    , _tvgId = Nothing
    , _tvgRegion = Nothing
    , _tvgTunnels = Nothing
    , _tvgDescription = Nothing
    , _tvgForwardingRules = Nothing
    }


-- | [Output Only] The status of the VPN gateway, which can be one of the
-- following: CREATING, READY, FAILED, or DELETING.
tvgStatus :: Lens' TargetVPNGateway (Maybe TargetVPNGatewayStatus)
tvgStatus
  = lens _tvgStatus (\ s a -> s{_tvgStatus = a})

-- | [Output Only] Type of resource. Always compute#targetVpnGateway for
-- target VPN gateways.
tvgKind :: Lens' TargetVPNGateway Text
tvgKind = lens _tvgKind (\ s a -> s{_tvgKind = a})

-- | URL of the network to which this VPN gateway is attached. Provided by
-- the client when the VPN gateway is created.
tvgNetwork :: Lens' TargetVPNGateway (Maybe Text)
tvgNetwork
  = lens _tvgNetwork (\ s a -> s{_tvgNetwork = a})

-- | [Output Only] Server-defined URL for the resource.
tvgSelfLink :: Lens' TargetVPNGateway (Maybe Text)
tvgSelfLink
  = lens _tvgSelfLink (\ s a -> s{_tvgSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
tvgName :: Lens' TargetVPNGateway (Maybe Text)
tvgName = lens _tvgName (\ s a -> s{_tvgName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
tvgCreationTimestamp :: Lens' TargetVPNGateway (Maybe Text)
tvgCreationTimestamp
  = lens _tvgCreationTimestamp
      (\ s a -> s{_tvgCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
tvgId :: Lens' TargetVPNGateway (Maybe Word64)
tvgId
  = lens _tvgId (\ s a -> s{_tvgId = a}) .
      mapping _Coerce

-- | [Output Only] URL of the region where the target VPN gateway resides.
-- You must specify this field as part of the HTTP request URL. It is not
-- settable as a field in the request body.
tvgRegion :: Lens' TargetVPNGateway (Maybe Text)
tvgRegion
  = lens _tvgRegion (\ s a -> s{_tvgRegion = a})

-- | [Output Only] A list of URLs to VpnTunnel resources. VpnTunnels are
-- created using the compute.vpntunnels.insert method and associated with a
-- VPN gateway.
tvgTunnels :: Lens' TargetVPNGateway [Text]
tvgTunnels
  = lens _tvgTunnels (\ s a -> s{_tvgTunnels = a}) .
      _Default
      . _Coerce

-- | An optional description of this resource. Provide this property when you
-- create the resource.
tvgDescription :: Lens' TargetVPNGateway (Maybe Text)
tvgDescription
  = lens _tvgDescription
      (\ s a -> s{_tvgDescription = a})

-- | [Output Only] A list of URLs to the ForwardingRule resources.
-- ForwardingRules are created using compute.forwardingRules.insert and
-- associated with a VPN gateway.
tvgForwardingRules :: Lens' TargetVPNGateway [Text]
tvgForwardingRules
  = lens _tvgForwardingRules
      (\ s a -> s{_tvgForwardingRules = a})
      . _Default
      . _Coerce

instance FromJSON TargetVPNGateway where
        parseJSON
          = withObject "TargetVPNGateway"
              (\ o ->
                 TargetVPNGateway' <$>
                   (o .:? "status") <*>
                     (o .:? "kind" .!= "compute#targetVpnGateway")
                     <*> (o .:? "network")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "region")
                     <*> (o .:? "tunnels" .!= mempty)
                     <*> (o .:? "description")
                     <*> (o .:? "forwardingRules" .!= mempty))

instance ToJSON TargetVPNGateway where
        toJSON TargetVPNGateway'{..}
          = object
              (catMaybes
                 [("status" .=) <$> _tvgStatus,
                  Just ("kind" .= _tvgKind),
                  ("network" .=) <$> _tvgNetwork,
                  ("selfLink" .=) <$> _tvgSelfLink,
                  ("name" .=) <$> _tvgName,
                  ("creationTimestamp" .=) <$> _tvgCreationTimestamp,
                  ("id" .=) <$> _tvgId, ("region" .=) <$> _tvgRegion,
                  ("tunnels" .=) <$> _tvgTunnels,
                  ("description" .=) <$> _tvgDescription,
                  ("forwardingRules" .=) <$> _tvgForwardingRules])

-- | Bypass the cache when the specified request headers are present, e.g.
-- Pragma or Authorization headers. Values are case insensitive. The
-- presence of such a header overrides the cache_mode setting.
--
-- /See:/ 'backendServiceCdnPolicyBypassCacheOnRequestHeader' smart constructor.
newtype BackendServiceCdnPolicyBypassCacheOnRequestHeader =
  BackendServiceCdnPolicyBypassCacheOnRequestHeader'
    { _bscpbcorhHeaderName :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendServiceCdnPolicyBypassCacheOnRequestHeader' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bscpbcorhHeaderName'
backendServiceCdnPolicyBypassCacheOnRequestHeader
    :: BackendServiceCdnPolicyBypassCacheOnRequestHeader
backendServiceCdnPolicyBypassCacheOnRequestHeader =
  BackendServiceCdnPolicyBypassCacheOnRequestHeader'
    {_bscpbcorhHeaderName = Nothing}


-- | The header field name to match on when bypassing cache. Values are
-- case-insensitive.
bscpbcorhHeaderName :: Lens' BackendServiceCdnPolicyBypassCacheOnRequestHeader (Maybe Text)
bscpbcorhHeaderName
  = lens _bscpbcorhHeaderName
      (\ s a -> s{_bscpbcorhHeaderName = a})

instance FromJSON
           BackendServiceCdnPolicyBypassCacheOnRequestHeader
         where
        parseJSON
          = withObject
              "BackendServiceCdnPolicyBypassCacheOnRequestHeader"
              (\ o ->
                 BackendServiceCdnPolicyBypassCacheOnRequestHeader'
                   <$> (o .:? "headerName"))

instance ToJSON
           BackendServiceCdnPolicyBypassCacheOnRequestHeader
         where
        toJSON
          BackendServiceCdnPolicyBypassCacheOnRequestHeader'{..}
          = object
              (catMaybes
                 [("headerName" .=) <$> _bscpbcorhHeaderName])

-- | Configuration and status of a self-managed SSL certificate.
--
-- /See:/ 'sslCertificateSelfManagedSSLCertificate' smart constructor.
data SSLCertificateSelfManagedSSLCertificate =
  SSLCertificateSelfManagedSSLCertificate'
    { _scsmscPrivateKey :: !(Maybe Text)
    , _scsmscCertificate :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SSLCertificateSelfManagedSSLCertificate' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'scsmscPrivateKey'
--
-- * 'scsmscCertificate'
sslCertificateSelfManagedSSLCertificate
    :: SSLCertificateSelfManagedSSLCertificate
sslCertificateSelfManagedSSLCertificate =
  SSLCertificateSelfManagedSSLCertificate'
    {_scsmscPrivateKey = Nothing, _scsmscCertificate = Nothing}


-- | A write-only private key in PEM format. Only insert requests will
-- include this field.
scsmscPrivateKey :: Lens' SSLCertificateSelfManagedSSLCertificate (Maybe Text)
scsmscPrivateKey
  = lens _scsmscPrivateKey
      (\ s a -> s{_scsmscPrivateKey = a})

-- | A local certificate file. The certificate must be in PEM format. The
-- certificate chain must be no greater than 5 certs long. The chain must
-- include at least one intermediate cert.
scsmscCertificate :: Lens' SSLCertificateSelfManagedSSLCertificate (Maybe Text)
scsmscCertificate
  = lens _scsmscCertificate
      (\ s a -> s{_scsmscCertificate = a})

instance FromJSON
           SSLCertificateSelfManagedSSLCertificate
         where
        parseJSON
          = withObject
              "SSLCertificateSelfManagedSSLCertificate"
              (\ o ->
                 SSLCertificateSelfManagedSSLCertificate' <$>
                   (o .:? "privateKey") <*> (o .:? "certificate"))

instance ToJSON
           SSLCertificateSelfManagedSSLCertificate
         where
        toJSON SSLCertificateSelfManagedSSLCertificate'{..}
          = object
              (catMaybes
                 [("privateKey" .=) <$> _scsmscPrivateKey,
                  ("certificate" .=) <$> _scsmscCertificate])

-- | Commitment for a particular resource (a Commitment is composed of one or
-- more of these).
--
-- /See:/ 'resourceCommitment' smart constructor.
data ResourceCommitment =
  ResourceCommitment'
    { _rcAmount :: !(Maybe (Textual Int64))
    , _rcAcceleratorType :: !(Maybe Text)
    , _rcType :: !(Maybe ResourceCommitmentType)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourceCommitment' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rcAmount'
--
-- * 'rcAcceleratorType'
--
-- * 'rcType'
resourceCommitment
    :: ResourceCommitment
resourceCommitment =
  ResourceCommitment'
    {_rcAmount = Nothing, _rcAcceleratorType = Nothing, _rcType = Nothing}


-- | The amount of the resource purchased (in a type-dependent unit, such as
-- bytes). For vCPUs, this can just be an integer. For memory, this must be
-- provided in MB. Memory must be a multiple of 256 MB, with up to 6.5GB of
-- memory per every vCPU.
rcAmount :: Lens' ResourceCommitment (Maybe Int64)
rcAmount
  = lens _rcAmount (\ s a -> s{_rcAmount = a}) .
      mapping _Coerce

-- | Name of the accelerator type resource. Applicable only when the type is
-- ACCELERATOR.
rcAcceleratorType :: Lens' ResourceCommitment (Maybe Text)
rcAcceleratorType
  = lens _rcAcceleratorType
      (\ s a -> s{_rcAcceleratorType = a})

-- | Type of resource for which this commitment applies. Possible values are
-- VCPU and MEMORY
rcType :: Lens' ResourceCommitment (Maybe ResourceCommitmentType)
rcType = lens _rcType (\ s a -> s{_rcType = a})

instance FromJSON ResourceCommitment where
        parseJSON
          = withObject "ResourceCommitment"
              (\ o ->
                 ResourceCommitment' <$>
                   (o .:? "amount") <*> (o .:? "acceleratorType") <*>
                     (o .:? "type"))

instance ToJSON ResourceCommitment where
        toJSON ResourceCommitment'{..}
          = object
              (catMaybes
                 [("amount" .=) <$> _rcAmount,
                  ("acceleratorType" .=) <$> _rcAcceleratorType,
                  ("type" .=) <$> _rcType])

-- | The information about the HTTP Cookie on which the hash function is
-- based for load balancing policies that use a consistent hash.
--
-- /See:/ 'consistentHashLoadBalancerSettingsHTTPCookie' smart constructor.
data ConsistentHashLoadBalancerSettingsHTTPCookie =
  ConsistentHashLoadBalancerSettingsHTTPCookie'
    { _chlbshttpcTtl :: !(Maybe Duration)
    , _chlbshttpcPath :: !(Maybe Text)
    , _chlbshttpcName :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ConsistentHashLoadBalancerSettingsHTTPCookie' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'chlbshttpcTtl'
--
-- * 'chlbshttpcPath'
--
-- * 'chlbshttpcName'
consistentHashLoadBalancerSettingsHTTPCookie
    :: ConsistentHashLoadBalancerSettingsHTTPCookie
consistentHashLoadBalancerSettingsHTTPCookie =
  ConsistentHashLoadBalancerSettingsHTTPCookie'
    { _chlbshttpcTtl = Nothing
    , _chlbshttpcPath = Nothing
    , _chlbshttpcName = Nothing
    }


-- | Lifetime of the cookie.
chlbshttpcTtl :: Lens' ConsistentHashLoadBalancerSettingsHTTPCookie (Maybe Duration)
chlbshttpcTtl
  = lens _chlbshttpcTtl
      (\ s a -> s{_chlbshttpcTtl = a})

-- | Path to set for the cookie.
chlbshttpcPath :: Lens' ConsistentHashLoadBalancerSettingsHTTPCookie (Maybe Text)
chlbshttpcPath
  = lens _chlbshttpcPath
      (\ s a -> s{_chlbshttpcPath = a})

-- | Name of the cookie.
chlbshttpcName :: Lens' ConsistentHashLoadBalancerSettingsHTTPCookie (Maybe Text)
chlbshttpcName
  = lens _chlbshttpcName
      (\ s a -> s{_chlbshttpcName = a})

instance FromJSON
           ConsistentHashLoadBalancerSettingsHTTPCookie
         where
        parseJSON
          = withObject
              "ConsistentHashLoadBalancerSettingsHTTPCookie"
              (\ o ->
                 ConsistentHashLoadBalancerSettingsHTTPCookie' <$>
                   (o .:? "ttl") <*> (o .:? "path") <*> (o .:? "name"))

instance ToJSON
           ConsistentHashLoadBalancerSettingsHTTPCookie
         where
        toJSON
          ConsistentHashLoadBalancerSettingsHTTPCookie'{..}
          = object
              (catMaybes
                 [("ttl" .=) <$> _chlbshttpcTtl,
                  ("path" .=) <$> _chlbshttpcPath,
                  ("name" .=) <$> _chlbshttpcName])

-- | Identity-Aware Proxy
--
-- /See:/ 'backendServiceIAP' smart constructor.
data BackendServiceIAP =
  BackendServiceIAP'
    { _bsiapEnabled :: !(Maybe Bool)
    , _bsiapOAuth2ClientSecretSha256 :: !(Maybe Text)
    , _bsiapOAuth2ClientSecret :: !(Maybe Text)
    , _bsiapOAuth2ClientId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendServiceIAP' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bsiapEnabled'
--
-- * 'bsiapOAuth2ClientSecretSha256'
--
-- * 'bsiapOAuth2ClientSecret'
--
-- * 'bsiapOAuth2ClientId'
backendServiceIAP
    :: BackendServiceIAP
backendServiceIAP =
  BackendServiceIAP'
    { _bsiapEnabled = Nothing
    , _bsiapOAuth2ClientSecretSha256 = Nothing
    , _bsiapOAuth2ClientSecret = Nothing
    , _bsiapOAuth2ClientId = Nothing
    }


-- | Whether the serving infrastructure will authenticate and authorize all
-- incoming requests. If true, the oauth2ClientId and oauth2ClientSecret
-- fields must be non-empty.
bsiapEnabled :: Lens' BackendServiceIAP (Maybe Bool)
bsiapEnabled
  = lens _bsiapEnabled (\ s a -> s{_bsiapEnabled = a})

-- | [Output Only] SHA256 hash value for the field oauth2_client_secret
-- above.
bsiapOAuth2ClientSecretSha256 :: Lens' BackendServiceIAP (Maybe Text)
bsiapOAuth2ClientSecretSha256
  = lens _bsiapOAuth2ClientSecretSha256
      (\ s a -> s{_bsiapOAuth2ClientSecretSha256 = a})

-- | OAuth2 client secret to use for the authentication flow. For security
-- reasons, this value cannot be retrieved via the API. Instead, the
-- SHA-256 hash of the value is returned in the oauth2ClientSecretSha256
-- field.
bsiapOAuth2ClientSecret :: Lens' BackendServiceIAP (Maybe Text)
bsiapOAuth2ClientSecret
  = lens _bsiapOAuth2ClientSecret
      (\ s a -> s{_bsiapOAuth2ClientSecret = a})

-- | OAuth2 client ID to use for the authentication flow.
bsiapOAuth2ClientId :: Lens' BackendServiceIAP (Maybe Text)
bsiapOAuth2ClientId
  = lens _bsiapOAuth2ClientId
      (\ s a -> s{_bsiapOAuth2ClientId = a})

instance FromJSON BackendServiceIAP where
        parseJSON
          = withObject "BackendServiceIAP"
              (\ o ->
                 BackendServiceIAP' <$>
                   (o .:? "enabled") <*>
                     (o .:? "oauth2ClientSecretSha256")
                     <*> (o .:? "oauth2ClientSecret")
                     <*> (o .:? "oauth2ClientId"))

instance ToJSON BackendServiceIAP where
        toJSON BackendServiceIAP'{..}
          = object
              (catMaybes
                 [("enabled" .=) <$> _bsiapEnabled,
                  ("oauth2ClientSecretSha256" .=) <$>
                    _bsiapOAuth2ClientSecretSha256,
                  ("oauth2ClientSecret" .=) <$>
                    _bsiapOAuth2ClientSecret,
                  ("oauth2ClientId" .=) <$> _bsiapOAuth2ClientId])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'targetVPNGatewayListWarning' smart constructor.
data TargetVPNGatewayListWarning =
  TargetVPNGatewayListWarning'
    { _tvglwData :: !(Maybe [TargetVPNGatewayListWarningDataItem])
    , _tvglwCode :: !(Maybe TargetVPNGatewayListWarningCode)
    , _tvglwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetVPNGatewayListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tvglwData'
--
-- * 'tvglwCode'
--
-- * 'tvglwMessage'
targetVPNGatewayListWarning
    :: TargetVPNGatewayListWarning
targetVPNGatewayListWarning =
  TargetVPNGatewayListWarning'
    {_tvglwData = Nothing, _tvglwCode = Nothing, _tvglwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
tvglwData :: Lens' TargetVPNGatewayListWarning [TargetVPNGatewayListWarningDataItem]
tvglwData
  = lens _tvglwData (\ s a -> s{_tvglwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
tvglwCode :: Lens' TargetVPNGatewayListWarning (Maybe TargetVPNGatewayListWarningCode)
tvglwCode
  = lens _tvglwCode (\ s a -> s{_tvglwCode = a})

-- | [Output Only] A human-readable description of the warning code.
tvglwMessage :: Lens' TargetVPNGatewayListWarning (Maybe Text)
tvglwMessage
  = lens _tvglwMessage (\ s a -> s{_tvglwMessage = a})

instance FromJSON TargetVPNGatewayListWarning where
        parseJSON
          = withObject "TargetVPNGatewayListWarning"
              (\ o ->
                 TargetVPNGatewayListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON TargetVPNGatewayListWarning where
        toJSON TargetVPNGatewayListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _tvglwData,
                  ("code" .=) <$> _tvglwCode,
                  ("message" .=) <$> _tvglwMessage])

--
-- /See:/ 'securityPoliciesListPreConfiguredExpressionSetsResponse' smart constructor.
newtype SecurityPoliciesListPreConfiguredExpressionSetsResponse =
  SecurityPoliciesListPreConfiguredExpressionSetsResponse'
    { _splpcesrPreConfiguredExpressionSets :: Maybe SecurityPoliciesWafConfig
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SecurityPoliciesListPreConfiguredExpressionSetsResponse' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'splpcesrPreConfiguredExpressionSets'
securityPoliciesListPreConfiguredExpressionSetsResponse
    :: SecurityPoliciesListPreConfiguredExpressionSetsResponse
securityPoliciesListPreConfiguredExpressionSetsResponse =
  SecurityPoliciesListPreConfiguredExpressionSetsResponse'
    {_splpcesrPreConfiguredExpressionSets = Nothing}


splpcesrPreConfiguredExpressionSets :: Lens' SecurityPoliciesListPreConfiguredExpressionSetsResponse (Maybe SecurityPoliciesWafConfig)
splpcesrPreConfiguredExpressionSets
  = lens _splpcesrPreConfiguredExpressionSets
      (\ s a ->
         s{_splpcesrPreConfiguredExpressionSets = a})

instance FromJSON
           SecurityPoliciesListPreConfiguredExpressionSetsResponse
         where
        parseJSON
          = withObject
              "SecurityPoliciesListPreConfiguredExpressionSetsResponse"
              (\ o ->
                 SecurityPoliciesListPreConfiguredExpressionSetsResponse'
                   <$> (o .:? "preconfiguredExpressionSets"))

instance ToJSON
           SecurityPoliciesListPreConfiguredExpressionSetsResponse
         where
        toJSON
          SecurityPoliciesListPreConfiguredExpressionSetsResponse'{..}
          = object
              (catMaybes
                 [("preconfiguredExpressionSets" .=) <$>
                    _splpcesrPreConfiguredExpressionSets])

--
-- /See:/ 'sslCertificateAggregatedListWarningDataItem' smart constructor.
data SSLCertificateAggregatedListWarningDataItem =
  SSLCertificateAggregatedListWarningDataItem'
    { _scalwdiValue :: !(Maybe Text)
    , _scalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SSLCertificateAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'scalwdiValue'
--
-- * 'scalwdiKey'
sslCertificateAggregatedListWarningDataItem
    :: SSLCertificateAggregatedListWarningDataItem
sslCertificateAggregatedListWarningDataItem =
  SSLCertificateAggregatedListWarningDataItem'
    {_scalwdiValue = Nothing, _scalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
scalwdiValue :: Lens' SSLCertificateAggregatedListWarningDataItem (Maybe Text)
scalwdiValue
  = lens _scalwdiValue (\ s a -> s{_scalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
scalwdiKey :: Lens' SSLCertificateAggregatedListWarningDataItem (Maybe Text)
scalwdiKey
  = lens _scalwdiKey (\ s a -> s{_scalwdiKey = a})

instance FromJSON
           SSLCertificateAggregatedListWarningDataItem
         where
        parseJSON
          = withObject
              "SSLCertificateAggregatedListWarningDataItem"
              (\ o ->
                 SSLCertificateAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           SSLCertificateAggregatedListWarningDataItem
         where
        toJSON
          SSLCertificateAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _scalwdiValue,
                  ("key" .=) <$> _scalwdiKey])

--
-- /See:/ 'vMEndpointNATMAppingsListWarningDataItem' smart constructor.
data VMEndpointNATMAppingsListWarningDataItem =
  VMEndpointNATMAppingsListWarningDataItem'
    { _vmenatmalwdiValue :: !(Maybe Text)
    , _vmenatmalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VMEndpointNATMAppingsListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vmenatmalwdiValue'
--
-- * 'vmenatmalwdiKey'
vMEndpointNATMAppingsListWarningDataItem
    :: VMEndpointNATMAppingsListWarningDataItem
vMEndpointNATMAppingsListWarningDataItem =
  VMEndpointNATMAppingsListWarningDataItem'
    {_vmenatmalwdiValue = Nothing, _vmenatmalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
vmenatmalwdiValue :: Lens' VMEndpointNATMAppingsListWarningDataItem (Maybe Text)
vmenatmalwdiValue
  = lens _vmenatmalwdiValue
      (\ s a -> s{_vmenatmalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
vmenatmalwdiKey :: Lens' VMEndpointNATMAppingsListWarningDataItem (Maybe Text)
vmenatmalwdiKey
  = lens _vmenatmalwdiKey
      (\ s a -> s{_vmenatmalwdiKey = a})

instance FromJSON
           VMEndpointNATMAppingsListWarningDataItem
         where
        parseJSON
          = withObject
              "VMEndpointNATMAppingsListWarningDataItem"
              (\ o ->
                 VMEndpointNATMAppingsListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           VMEndpointNATMAppingsListWarningDataItem
         where
        toJSON VMEndpointNATMAppingsListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _vmenatmalwdiValue,
                  ("key" .=) <$> _vmenatmalwdiKey])

--
-- /See:/ 'healthCheckServicesListWarningDataItem' smart constructor.
data HealthCheckServicesListWarningDataItem =
  HealthCheckServicesListWarningDataItem'
    { _hValue :: !(Maybe Text)
    , _hKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HealthCheckServicesListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hValue'
--
-- * 'hKey'
healthCheckServicesListWarningDataItem
    :: HealthCheckServicesListWarningDataItem
healthCheckServicesListWarningDataItem =
  HealthCheckServicesListWarningDataItem' {_hValue = Nothing, _hKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
hValue :: Lens' HealthCheckServicesListWarningDataItem (Maybe Text)
hValue = lens _hValue (\ s a -> s{_hValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
hKey :: Lens' HealthCheckServicesListWarningDataItem (Maybe Text)
hKey = lens _hKey (\ s a -> s{_hKey = a})

instance FromJSON
           HealthCheckServicesListWarningDataItem
         where
        parseJSON
          = withObject "HealthCheckServicesListWarningDataItem"
              (\ o ->
                 HealthCheckServicesListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           HealthCheckServicesListWarningDataItem
         where
        toJSON HealthCheckServicesListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _hValue, ("key" .=) <$> _hKey])

--
-- /See:/ 'urlMapsValidateResponse' smart constructor.
newtype URLMapsValidateResponse =
  URLMapsValidateResponse'
    { _umvrResult :: Maybe URLMapValidationResult
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'URLMapsValidateResponse' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'umvrResult'
urlMapsValidateResponse
    :: URLMapsValidateResponse
urlMapsValidateResponse = URLMapsValidateResponse' {_umvrResult = Nothing}


umvrResult :: Lens' URLMapsValidateResponse (Maybe URLMapValidationResult)
umvrResult
  = lens _umvrResult (\ s a -> s{_umvrResult = a})

instance FromJSON URLMapsValidateResponse where
        parseJSON
          = withObject "URLMapsValidateResponse"
              (\ o ->
                 URLMapsValidateResponse' <$> (o .:? "result"))

instance ToJSON URLMapsValidateResponse where
        toJSON URLMapsValidateResponse'{..}
          = object (catMaybes [("result" .=) <$> _umvrResult])

-- | Represents an SSL Certificate resource. Google Compute Engine has two
-- SSL Certificate resources: *
-- [Global](\/compute\/docs\/reference\/rest\/{$api_version}\/sslCertificates)
-- *
-- [Regional](\/compute\/docs\/reference\/rest\/{$api_version}\/regionSslCertificates)
-- The sslCertificates are used by: - external HTTPS load balancers - SSL
-- proxy load balancers The regionSslCertificates are used by internal
-- HTTPS load balancers. Optionally, certificate file contents that you
-- upload can contain a set of up to five PEM-encoded certificates. The API
-- call creates an object (sslCertificate) that holds this data. You can
-- use SSL keys and certificates to secure connections to a load balancer.
-- For more information, read Creating and using SSL certificates, SSL
-- certificates quotas and limits, and Troubleshooting SSL certificates.
-- (== resource_for {$api_version}.sslCertificates ==) (== resource_for
-- {$api_version}.regionSslCertificates ==)
--
-- /See:/ 'sslCertificate' smart constructor.
data SSLCertificate =
  SSLCertificate'
    { _scSubjectAlternativeNames :: !(Maybe [Text])
    , _scPrivateKey :: !(Maybe Text)
    , _scManaged :: !(Maybe SSLCertificateManagedSSLCertificate)
    , _scKind :: !Text
    , _scSelfLink :: !(Maybe Text)
    , _scName :: !(Maybe Text)
    , _scCreationTimestamp :: !(Maybe Text)
    , _scId :: !(Maybe (Textual Word64))
    , _scCertificate :: !(Maybe Text)
    , _scRegion :: !(Maybe Text)
    , _scType :: !(Maybe SSLCertificateType)
    , _scExpireTime :: !(Maybe Text)
    , _scDescription :: !(Maybe Text)
    , _scSelfManaged :: !(Maybe SSLCertificateSelfManagedSSLCertificate)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SSLCertificate' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'scSubjectAlternativeNames'
--
-- * 'scPrivateKey'
--
-- * 'scManaged'
--
-- * 'scKind'
--
-- * 'scSelfLink'
--
-- * 'scName'
--
-- * 'scCreationTimestamp'
--
-- * 'scId'
--
-- * 'scCertificate'
--
-- * 'scRegion'
--
-- * 'scType'
--
-- * 'scExpireTime'
--
-- * 'scDescription'
--
-- * 'scSelfManaged'
sslCertificate
    :: SSLCertificate
sslCertificate =
  SSLCertificate'
    { _scSubjectAlternativeNames = Nothing
    , _scPrivateKey = Nothing
    , _scManaged = Nothing
    , _scKind = "compute#sslCertificate"
    , _scSelfLink = Nothing
    , _scName = Nothing
    , _scCreationTimestamp = Nothing
    , _scId = Nothing
    , _scCertificate = Nothing
    , _scRegion = Nothing
    , _scType = Nothing
    , _scExpireTime = Nothing
    , _scDescription = Nothing
    , _scSelfManaged = Nothing
    }


-- | [Output Only] Domains associated with the certificate via Subject
-- Alternative Name.
scSubjectAlternativeNames :: Lens' SSLCertificate [Text]
scSubjectAlternativeNames
  = lens _scSubjectAlternativeNames
      (\ s a -> s{_scSubjectAlternativeNames = a})
      . _Default
      . _Coerce

-- | A value read into memory from a write-only private key file. The private
-- key file must be in PEM format. For security, only insert requests
-- include this field.
scPrivateKey :: Lens' SSLCertificate (Maybe Text)
scPrivateKey
  = lens _scPrivateKey (\ s a -> s{_scPrivateKey = a})

-- | Configuration and status of a managed SSL certificate.
scManaged :: Lens' SSLCertificate (Maybe SSLCertificateManagedSSLCertificate)
scManaged
  = lens _scManaged (\ s a -> s{_scManaged = a})

-- | [Output Only] Type of the resource. Always compute#sslCertificate for
-- SSL certificates.
scKind :: Lens' SSLCertificate Text
scKind = lens _scKind (\ s a -> s{_scKind = a})

-- | [Output only] Server-defined URL for the resource.
scSelfLink :: Lens' SSLCertificate (Maybe Text)
scSelfLink
  = lens _scSelfLink (\ s a -> s{_scSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
scName :: Lens' SSLCertificate (Maybe Text)
scName = lens _scName (\ s a -> s{_scName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
scCreationTimestamp :: Lens' SSLCertificate (Maybe Text)
scCreationTimestamp
  = lens _scCreationTimestamp
      (\ s a -> s{_scCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
scId :: Lens' SSLCertificate (Maybe Word64)
scId
  = lens _scId (\ s a -> s{_scId = a}) .
      mapping _Coerce

-- | A value read into memory from a certificate file. The certificate file
-- must be in PEM format. The certificate chain must be no greater than 5
-- certs long. The chain must include at least one intermediate cert.
scCertificate :: Lens' SSLCertificate (Maybe Text)
scCertificate
  = lens _scCertificate
      (\ s a -> s{_scCertificate = a})

-- | [Output Only] URL of the region where the regional SSL Certificate
-- resides. This field is not applicable to global SSL Certificate.
scRegion :: Lens' SSLCertificate (Maybe Text)
scRegion = lens _scRegion (\ s a -> s{_scRegion = a})

-- | (Optional) Specifies the type of SSL certificate, either
-- \"SELF_MANAGED\" or \"MANAGED\". If not specified, the certificate is
-- self-managed and the fields certificate and private_key are used.
scType :: Lens' SSLCertificate (Maybe SSLCertificateType)
scType = lens _scType (\ s a -> s{_scType = a})

-- | [Output Only] Expire time of the certificate. RFC3339
scExpireTime :: Lens' SSLCertificate (Maybe Text)
scExpireTime
  = lens _scExpireTime (\ s a -> s{_scExpireTime = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource.
scDescription :: Lens' SSLCertificate (Maybe Text)
scDescription
  = lens _scDescription
      (\ s a -> s{_scDescription = a})

-- | Configuration and status of a self-managed SSL certificate.
scSelfManaged :: Lens' SSLCertificate (Maybe SSLCertificateSelfManagedSSLCertificate)
scSelfManaged
  = lens _scSelfManaged
      (\ s a -> s{_scSelfManaged = a})

instance FromJSON SSLCertificate where
        parseJSON
          = withObject "SSLCertificate"
              (\ o ->
                 SSLCertificate' <$>
                   (o .:? "subjectAlternativeNames" .!= mempty) <*>
                     (o .:? "privateKey")
                     <*> (o .:? "managed")
                     <*> (o .:? "kind" .!= "compute#sslCertificate")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "certificate")
                     <*> (o .:? "region")
                     <*> (o .:? "type")
                     <*> (o .:? "expireTime")
                     <*> (o .:? "description")
                     <*> (o .:? "selfManaged"))

instance ToJSON SSLCertificate where
        toJSON SSLCertificate'{..}
          = object
              (catMaybes
                 [("subjectAlternativeNames" .=) <$>
                    _scSubjectAlternativeNames,
                  ("privateKey" .=) <$> _scPrivateKey,
                  ("managed" .=) <$> _scManaged,
                  Just ("kind" .= _scKind),
                  ("selfLink" .=) <$> _scSelfLink,
                  ("name" .=) <$> _scName,
                  ("creationTimestamp" .=) <$> _scCreationTimestamp,
                  ("id" .=) <$> _scId,
                  ("certificate" .=) <$> _scCertificate,
                  ("region" .=) <$> _scRegion, ("type" .=) <$> _scType,
                  ("expireTime" .=) <$> _scExpireTime,
                  ("description" .=) <$> _scDescription,
                  ("selfManaged" .=) <$> _scSelfManaged])

--
-- /See:/ 'sslCertificatesScopedListWarningDataItem' smart constructor.
data SSLCertificatesScopedListWarningDataItem =
  SSLCertificatesScopedListWarningDataItem'
    { _scslwdiValue :: !(Maybe Text)
    , _scslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SSLCertificatesScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'scslwdiValue'
--
-- * 'scslwdiKey'
sslCertificatesScopedListWarningDataItem
    :: SSLCertificatesScopedListWarningDataItem
sslCertificatesScopedListWarningDataItem =
  SSLCertificatesScopedListWarningDataItem'
    {_scslwdiValue = Nothing, _scslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
scslwdiValue :: Lens' SSLCertificatesScopedListWarningDataItem (Maybe Text)
scslwdiValue
  = lens _scslwdiValue (\ s a -> s{_scslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
scslwdiKey :: Lens' SSLCertificatesScopedListWarningDataItem (Maybe Text)
scslwdiKey
  = lens _scslwdiKey (\ s a -> s{_scslwdiKey = a})

instance FromJSON
           SSLCertificatesScopedListWarningDataItem
         where
        parseJSON
          = withObject
              "SSLCertificatesScopedListWarningDataItem"
              (\ o ->
                 SSLCertificatesScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           SSLCertificatesScopedListWarningDataItem
         where
        toJSON SSLCertificatesScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _scslwdiValue,
                  ("key" .=) <$> _scslwdiKey])

--
-- /See:/ 'packetMirroringFilter' smart constructor.
data PacketMirroringFilter =
  PacketMirroringFilter'
    { _pmfDirection :: !(Maybe PacketMirroringFilterDirection)
    , _pmfCIdRRanges :: !(Maybe [Text])
    , _pmfIPProtocols :: !(Maybe [Text])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PacketMirroringFilter' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pmfDirection'
--
-- * 'pmfCIdRRanges'
--
-- * 'pmfIPProtocols'
packetMirroringFilter
    :: PacketMirroringFilter
packetMirroringFilter =
  PacketMirroringFilter'
    { _pmfDirection = Nothing
    , _pmfCIdRRanges = Nothing
    , _pmfIPProtocols = Nothing
    }


-- | Direction of traffic to mirror, either INGRESS, EGRESS, or BOTH. The
-- default is BOTH.
pmfDirection :: Lens' PacketMirroringFilter (Maybe PacketMirroringFilterDirection)
pmfDirection
  = lens _pmfDirection (\ s a -> s{_pmfDirection = a})

-- | IP CIDR ranges that apply as filter on the source (ingress) or
-- destination (egress) IP in the IP header. Only IPv4 is supported. If no
-- ranges are specified, all traffic that matches the specified IPProtocols
-- is mirrored. If neither cidrRanges nor IPProtocols is specified, all
-- traffic is mirrored.
pmfCIdRRanges :: Lens' PacketMirroringFilter [Text]
pmfCIdRRanges
  = lens _pmfCIdRRanges
      (\ s a -> s{_pmfCIdRRanges = a})
      . _Default
      . _Coerce

-- | Protocols that apply as filter on mirrored traffic. If no protocols are
-- specified, all traffic that matches the specified CIDR ranges is
-- mirrored. If neither cidrRanges nor IPProtocols is specified, all
-- traffic is mirrored.
pmfIPProtocols :: Lens' PacketMirroringFilter [Text]
pmfIPProtocols
  = lens _pmfIPProtocols
      (\ s a -> s{_pmfIPProtocols = a})
      . _Default
      . _Coerce

instance FromJSON PacketMirroringFilter where
        parseJSON
          = withObject "PacketMirroringFilter"
              (\ o ->
                 PacketMirroringFilter' <$>
                   (o .:? "direction") <*>
                     (o .:? "cidrRanges" .!= mempty)
                     <*> (o .:? "IPProtocols" .!= mempty))

instance ToJSON PacketMirroringFilter where
        toJSON PacketMirroringFilter'{..}
          = object
              (catMaybes
                 [("direction" .=) <$> _pmfDirection,
                  ("cidrRanges" .=) <$> _pmfCIdRRanges,
                  ("IPProtocols" .=) <$> _pmfIPProtocols])

-- | RegionInstanceGroupManagers.applyUpdatesToInstances
--
-- /See:/ 'regionInstanceGroupManagersApplyUpdatesRequest' smart constructor.
data RegionInstanceGroupManagersApplyUpdatesRequest =
  RegionInstanceGroupManagersApplyUpdatesRequest'
    { _rigmaurAllInstances :: !(Maybe Bool)
    , _rigmaurMostDisruptiveAllowedAction :: !(Maybe RegionInstanceGroupManagersApplyUpdatesRequestMostDisruptiveAllowedAction)
    , _rigmaurInstances :: !(Maybe [Text])
    , _rigmaurMinimalAction :: !(Maybe RegionInstanceGroupManagersApplyUpdatesRequestMinimalAction)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupManagersApplyUpdatesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rigmaurAllInstances'
--
-- * 'rigmaurMostDisruptiveAllowedAction'
--
-- * 'rigmaurInstances'
--
-- * 'rigmaurMinimalAction'
regionInstanceGroupManagersApplyUpdatesRequest
    :: RegionInstanceGroupManagersApplyUpdatesRequest
regionInstanceGroupManagersApplyUpdatesRequest =
  RegionInstanceGroupManagersApplyUpdatesRequest'
    { _rigmaurAllInstances = Nothing
    , _rigmaurMostDisruptiveAllowedAction = Nothing
    , _rigmaurInstances = Nothing
    , _rigmaurMinimalAction = Nothing
    }


-- | Flag to update all instances instead of specified list of ?instances?.
-- If the flag is set to true then the instances may not be specified in
-- the request.
rigmaurAllInstances :: Lens' RegionInstanceGroupManagersApplyUpdatesRequest (Maybe Bool)
rigmaurAllInstances
  = lens _rigmaurAllInstances
      (\ s a -> s{_rigmaurAllInstances = a})

-- | The most disruptive action that you want to perform on each instance
-- during the update: - REPLACE: Delete the instance and create it again. -
-- RESTART: Stop the instance and start it again. - REFRESH: Do not stop
-- the instance. - NONE: Do not disrupt the instance at all. By default,
-- the most disruptive allowed action is REPLACE. If your update requires a
-- more disruptive action than you set with this flag, the update request
-- will fail.
rigmaurMostDisruptiveAllowedAction :: Lens' RegionInstanceGroupManagersApplyUpdatesRequest (Maybe RegionInstanceGroupManagersApplyUpdatesRequestMostDisruptiveAllowedAction)
rigmaurMostDisruptiveAllowedAction
  = lens _rigmaurMostDisruptiveAllowedAction
      (\ s a -> s{_rigmaurMostDisruptiveAllowedAction = a})

-- | The list of URLs of one or more instances for which you want to apply
-- updates. Each URL can be a full URL or a partial URL, such as
-- zones\/[ZONE]\/instances\/[INSTANCE_NAME].
rigmaurInstances :: Lens' RegionInstanceGroupManagersApplyUpdatesRequest [Text]
rigmaurInstances
  = lens _rigmaurInstances
      (\ s a -> s{_rigmaurInstances = a})
      . _Default
      . _Coerce

-- | The minimal action that you want to perform on each instance during the
-- update: - REPLACE: At minimum, delete the instance and create it again.
-- - RESTART: Stop the instance and start it again. - REFRESH: Do not stop
-- the instance. - NONE: Do not disrupt the instance at all. By default,
-- the minimum action is NONE. If your update requires a more disruptive
-- action than you set with this flag, the necessary action is performed to
-- execute the update.
rigmaurMinimalAction :: Lens' RegionInstanceGroupManagersApplyUpdatesRequest (Maybe RegionInstanceGroupManagersApplyUpdatesRequestMinimalAction)
rigmaurMinimalAction
  = lens _rigmaurMinimalAction
      (\ s a -> s{_rigmaurMinimalAction = a})

instance FromJSON
           RegionInstanceGroupManagersApplyUpdatesRequest
         where
        parseJSON
          = withObject
              "RegionInstanceGroupManagersApplyUpdatesRequest"
              (\ o ->
                 RegionInstanceGroupManagersApplyUpdatesRequest' <$>
                   (o .:? "allInstances") <*>
                     (o .:? "mostDisruptiveAllowedAction")
                     <*> (o .:? "instances" .!= mempty)
                     <*> (o .:? "minimalAction"))

instance ToJSON
           RegionInstanceGroupManagersApplyUpdatesRequest
         where
        toJSON
          RegionInstanceGroupManagersApplyUpdatesRequest'{..}
          = object
              (catMaybes
                 [("allInstances" .=) <$> _rigmaurAllInstances,
                  ("mostDisruptiveAllowedAction" .=) <$>
                    _rigmaurMostDisruptiveAllowedAction,
                  ("instances" .=) <$> _rigmaurInstances,
                  ("minimalAction" .=) <$> _rigmaurMinimalAction])

-- | A GroupPlacementPolicy specifies resource placement configuration. It
-- specifies the failure bucket separation as well as network locality
--
-- /See:/ 'resourcePolicyGroupPlacementPolicy' smart constructor.
data ResourcePolicyGroupPlacementPolicy =
  ResourcePolicyGroupPlacementPolicy'
    { _rpgppAvailabilityDomainCount :: !(Maybe (Textual Int32))
    , _rpgppCollocation :: !(Maybe ResourcePolicyGroupPlacementPolicyCollocation)
    , _rpgppVMCount :: !(Maybe (Textual Int32))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePolicyGroupPlacementPolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rpgppAvailabilityDomainCount'
--
-- * 'rpgppCollocation'
--
-- * 'rpgppVMCount'
resourcePolicyGroupPlacementPolicy
    :: ResourcePolicyGroupPlacementPolicy
resourcePolicyGroupPlacementPolicy =
  ResourcePolicyGroupPlacementPolicy'
    { _rpgppAvailabilityDomainCount = Nothing
    , _rpgppCollocation = Nothing
    , _rpgppVMCount = Nothing
    }


-- | The number of availability domains instances will be spread across. If
-- two instances are in different availability domain, they will not be put
-- in the same low latency network
rpgppAvailabilityDomainCount :: Lens' ResourcePolicyGroupPlacementPolicy (Maybe Int32)
rpgppAvailabilityDomainCount
  = lens _rpgppAvailabilityDomainCount
      (\ s a -> s{_rpgppAvailabilityDomainCount = a})
      . mapping _Coerce

-- | Specifies network collocation
rpgppCollocation :: Lens' ResourcePolicyGroupPlacementPolicy (Maybe ResourcePolicyGroupPlacementPolicyCollocation)
rpgppCollocation
  = lens _rpgppCollocation
      (\ s a -> s{_rpgppCollocation = a})

-- | Number of vms in this placement group
rpgppVMCount :: Lens' ResourcePolicyGroupPlacementPolicy (Maybe Int32)
rpgppVMCount
  = lens _rpgppVMCount (\ s a -> s{_rpgppVMCount = a})
      . mapping _Coerce

instance FromJSON ResourcePolicyGroupPlacementPolicy
         where
        parseJSON
          = withObject "ResourcePolicyGroupPlacementPolicy"
              (\ o ->
                 ResourcePolicyGroupPlacementPolicy' <$>
                   (o .:? "availabilityDomainCount") <*>
                     (o .:? "collocation")
                     <*> (o .:? "vmCount"))

instance ToJSON ResourcePolicyGroupPlacementPolicy
         where
        toJSON ResourcePolicyGroupPlacementPolicy'{..}
          = object
              (catMaybes
                 [("availabilityDomainCount" .=) <$>
                    _rpgppAvailabilityDomainCount,
                  ("collocation" .=) <$> _rpgppCollocation,
                  ("vmCount" .=) <$> _rpgppVMCount])

--
-- /See:/ 'routerStatusBGPPeerStatus' smart constructor.
data RouterStatusBGPPeerStatus =
  RouterStatusBGPPeerStatus'
    { _rsbpsStatus :: !(Maybe RouterStatusBGPPeerStatusStatus)
    , _rsbpsIPAddress :: !(Maybe Text)
    , _rsbpsState :: !(Maybe Text)
    , _rsbpsPeerIPAddress :: !(Maybe Text)
    , _rsbpsUptime :: !(Maybe Text)
    , _rsbpsNumLearnedRoutes :: !(Maybe (Textual Word32))
    , _rsbpsName :: !(Maybe Text)
    , _rsbpsUptimeSeconds :: !(Maybe Text)
    , _rsbpsAdvertisedRoutes :: !(Maybe [Route])
    , _rsbpsLinkedVPNTunnel :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RouterStatusBGPPeerStatus' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rsbpsStatus'
--
-- * 'rsbpsIPAddress'
--
-- * 'rsbpsState'
--
-- * 'rsbpsPeerIPAddress'
--
-- * 'rsbpsUptime'
--
-- * 'rsbpsNumLearnedRoutes'
--
-- * 'rsbpsName'
--
-- * 'rsbpsUptimeSeconds'
--
-- * 'rsbpsAdvertisedRoutes'
--
-- * 'rsbpsLinkedVPNTunnel'
routerStatusBGPPeerStatus
    :: RouterStatusBGPPeerStatus
routerStatusBGPPeerStatus =
  RouterStatusBGPPeerStatus'
    { _rsbpsStatus = Nothing
    , _rsbpsIPAddress = Nothing
    , _rsbpsState = Nothing
    , _rsbpsPeerIPAddress = Nothing
    , _rsbpsUptime = Nothing
    , _rsbpsNumLearnedRoutes = Nothing
    , _rsbpsName = Nothing
    , _rsbpsUptimeSeconds = Nothing
    , _rsbpsAdvertisedRoutes = Nothing
    , _rsbpsLinkedVPNTunnel = Nothing
    }


-- | Status of the BGP peer: {UP, DOWN}
rsbpsStatus :: Lens' RouterStatusBGPPeerStatus (Maybe RouterStatusBGPPeerStatusStatus)
rsbpsStatus
  = lens _rsbpsStatus (\ s a -> s{_rsbpsStatus = a})

-- | IP address of the local BGP interface.
rsbpsIPAddress :: Lens' RouterStatusBGPPeerStatus (Maybe Text)
rsbpsIPAddress
  = lens _rsbpsIPAddress
      (\ s a -> s{_rsbpsIPAddress = a})

-- | BGP state as specified in RFC1771.
rsbpsState :: Lens' RouterStatusBGPPeerStatus (Maybe Text)
rsbpsState
  = lens _rsbpsState (\ s a -> s{_rsbpsState = a})

-- | IP address of the remote BGP interface.
rsbpsPeerIPAddress :: Lens' RouterStatusBGPPeerStatus (Maybe Text)
rsbpsPeerIPAddress
  = lens _rsbpsPeerIPAddress
      (\ s a -> s{_rsbpsPeerIPAddress = a})

-- | Time this session has been up. Format: 14 years, 51 weeks, 6 days, 23
-- hours, 59 minutes, 59 seconds
rsbpsUptime :: Lens' RouterStatusBGPPeerStatus (Maybe Text)
rsbpsUptime
  = lens _rsbpsUptime (\ s a -> s{_rsbpsUptime = a})

-- | Number of routes learned from the remote BGP Peer.
rsbpsNumLearnedRoutes :: Lens' RouterStatusBGPPeerStatus (Maybe Word32)
rsbpsNumLearnedRoutes
  = lens _rsbpsNumLearnedRoutes
      (\ s a -> s{_rsbpsNumLearnedRoutes = a})
      . mapping _Coerce

-- | Name of this BGP peer. Unique within the Routers resource.
rsbpsName :: Lens' RouterStatusBGPPeerStatus (Maybe Text)
rsbpsName
  = lens _rsbpsName (\ s a -> s{_rsbpsName = a})

-- | Time this session has been up, in seconds. Format: 145
rsbpsUptimeSeconds :: Lens' RouterStatusBGPPeerStatus (Maybe Text)
rsbpsUptimeSeconds
  = lens _rsbpsUptimeSeconds
      (\ s a -> s{_rsbpsUptimeSeconds = a})

-- | Routes that were advertised to the remote BGP peer
rsbpsAdvertisedRoutes :: Lens' RouterStatusBGPPeerStatus [Route]
rsbpsAdvertisedRoutes
  = lens _rsbpsAdvertisedRoutes
      (\ s a -> s{_rsbpsAdvertisedRoutes = a})
      . _Default
      . _Coerce

-- | URL of the VPN tunnel that this BGP peer controls.
rsbpsLinkedVPNTunnel :: Lens' RouterStatusBGPPeerStatus (Maybe Text)
rsbpsLinkedVPNTunnel
  = lens _rsbpsLinkedVPNTunnel
      (\ s a -> s{_rsbpsLinkedVPNTunnel = a})

instance FromJSON RouterStatusBGPPeerStatus where
        parseJSON
          = withObject "RouterStatusBGPPeerStatus"
              (\ o ->
                 RouterStatusBGPPeerStatus' <$>
                   (o .:? "status") <*> (o .:? "ipAddress") <*>
                     (o .:? "state")
                     <*> (o .:? "peerIpAddress")
                     <*> (o .:? "uptime")
                     <*> (o .:? "numLearnedRoutes")
                     <*> (o .:? "name")
                     <*> (o .:? "uptimeSeconds")
                     <*> (o .:? "advertisedRoutes" .!= mempty)
                     <*> (o .:? "linkedVpnTunnel"))

instance ToJSON RouterStatusBGPPeerStatus where
        toJSON RouterStatusBGPPeerStatus'{..}
          = object
              (catMaybes
                 [("status" .=) <$> _rsbpsStatus,
                  ("ipAddress" .=) <$> _rsbpsIPAddress,
                  ("state" .=) <$> _rsbpsState,
                  ("peerIpAddress" .=) <$> _rsbpsPeerIPAddress,
                  ("uptime" .=) <$> _rsbpsUptime,
                  ("numLearnedRoutes" .=) <$> _rsbpsNumLearnedRoutes,
                  ("name" .=) <$> _rsbpsName,
                  ("uptimeSeconds" .=) <$> _rsbpsUptimeSeconds,
                  ("advertisedRoutes" .=) <$> _rsbpsAdvertisedRoutes,
                  ("linkedVpnTunnel" .=) <$> _rsbpsLinkedVPNTunnel])

-- | Informational warning which replaces the list of backend services when
-- the list is empty.
--
-- /See:/ 'sslCertificatesScopedListWarning' smart constructor.
data SSLCertificatesScopedListWarning =
  SSLCertificatesScopedListWarning'
    { _scslwData :: !(Maybe [SSLCertificatesScopedListWarningDataItem])
    , _scslwCode :: !(Maybe SSLCertificatesScopedListWarningCode)
    , _scslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SSLCertificatesScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'scslwData'
--
-- * 'scslwCode'
--
-- * 'scslwMessage'
sslCertificatesScopedListWarning
    :: SSLCertificatesScopedListWarning
sslCertificatesScopedListWarning =
  SSLCertificatesScopedListWarning'
    {_scslwData = Nothing, _scslwCode = Nothing, _scslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
scslwData :: Lens' SSLCertificatesScopedListWarning [SSLCertificatesScopedListWarningDataItem]
scslwData
  = lens _scslwData (\ s a -> s{_scslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
scslwCode :: Lens' SSLCertificatesScopedListWarning (Maybe SSLCertificatesScopedListWarningCode)
scslwCode
  = lens _scslwCode (\ s a -> s{_scslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
scslwMessage :: Lens' SSLCertificatesScopedListWarning (Maybe Text)
scslwMessage
  = lens _scslwMessage (\ s a -> s{_scslwMessage = a})

instance FromJSON SSLCertificatesScopedListWarning
         where
        parseJSON
          = withObject "SSLCertificatesScopedListWarning"
              (\ o ->
                 SSLCertificatesScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON SSLCertificatesScopedListWarning
         where
        toJSON SSLCertificatesScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _scslwData,
                  ("code" .=) <$> _scslwCode,
                  ("message" .=) <$> _scslwMessage])

--
-- /See:/ 'urlMapReference' smart constructor.
newtype URLMapReference =
  URLMapReference'
    { _umrURLMap :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'URLMapReference' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'umrURLMap'
urlMapReference
    :: URLMapReference
urlMapReference = URLMapReference' {_umrURLMap = Nothing}


umrURLMap :: Lens' URLMapReference (Maybe Text)
umrURLMap
  = lens _umrURLMap (\ s a -> s{_umrURLMap = a})

instance FromJSON URLMapReference where
        parseJSON
          = withObject "URLMapReference"
              (\ o -> URLMapReference' <$> (o .:? "urlMap"))

instance ToJSON URLMapReference where
        toJSON URLMapReference'{..}
          = object (catMaybes [("urlMap" .=) <$> _umrURLMap])

--
-- /See:/ 'targetPoolsAddHealthCheckRequest' smart constructor.
newtype TargetPoolsAddHealthCheckRequest =
  TargetPoolsAddHealthCheckRequest'
    { _tpahcrHealthChecks :: Maybe [HealthCheckReference]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetPoolsAddHealthCheckRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tpahcrHealthChecks'
targetPoolsAddHealthCheckRequest
    :: TargetPoolsAddHealthCheckRequest
targetPoolsAddHealthCheckRequest =
  TargetPoolsAddHealthCheckRequest' {_tpahcrHealthChecks = Nothing}


-- | The HttpHealthCheck to add to the target pool.
tpahcrHealthChecks :: Lens' TargetPoolsAddHealthCheckRequest [HealthCheckReference]
tpahcrHealthChecks
  = lens _tpahcrHealthChecks
      (\ s a -> s{_tpahcrHealthChecks = a})
      . _Default
      . _Coerce

instance FromJSON TargetPoolsAddHealthCheckRequest
         where
        parseJSON
          = withObject "TargetPoolsAddHealthCheckRequest"
              (\ o ->
                 TargetPoolsAddHealthCheckRequest' <$>
                   (o .:? "healthChecks" .!= mempty))

instance ToJSON TargetPoolsAddHealthCheckRequest
         where
        toJSON TargetPoolsAddHealthCheckRequest'{..}
          = object
              (catMaybes
                 [("healthChecks" .=) <$> _tpahcrHealthChecks])

-- | Specifies settings for an HTTP redirect.
--
-- /See:/ 'hTTPRedirectAction' smart constructor.
data HTTPRedirectAction =
  HTTPRedirectAction'
    { _httpraRedirectResponseCode :: !(Maybe HTTPRedirectActionRedirectResponseCode)
    , _httpraHostRedirect :: !(Maybe Text)
    , _httpraPathRedirect :: !(Maybe Text)
    , _httpraPrefixRedirect :: !(Maybe Text)
    , _httpraStripQuery :: !(Maybe Bool)
    , _httpraHTTPSRedirect :: !(Maybe Bool)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HTTPRedirectAction' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'httpraRedirectResponseCode'
--
-- * 'httpraHostRedirect'
--
-- * 'httpraPathRedirect'
--
-- * 'httpraPrefixRedirect'
--
-- * 'httpraStripQuery'
--
-- * 'httpraHTTPSRedirect'
hTTPRedirectAction
    :: HTTPRedirectAction
hTTPRedirectAction =
  HTTPRedirectAction'
    { _httpraRedirectResponseCode = Nothing
    , _httpraHostRedirect = Nothing
    , _httpraPathRedirect = Nothing
    , _httpraPrefixRedirect = Nothing
    , _httpraStripQuery = Nothing
    , _httpraHTTPSRedirect = Nothing
    }


-- | The HTTP Status code to use for this RedirectAction. Supported values
-- are: - MOVED_PERMANENTLY_DEFAULT, which is the default value and
-- corresponds to 301. - FOUND, which corresponds to 302. - SEE_OTHER which
-- corresponds to 303. - TEMPORARY_REDIRECT, which corresponds to 307. In
-- this case, the request method will be retained. - PERMANENT_REDIRECT,
-- which corresponds to 308. In this case, the request method will be
-- retained.
httpraRedirectResponseCode :: Lens' HTTPRedirectAction (Maybe HTTPRedirectActionRedirectResponseCode)
httpraRedirectResponseCode
  = lens _httpraRedirectResponseCode
      (\ s a -> s{_httpraRedirectResponseCode = a})

-- | The host that will be used in the redirect response instead of the one
-- that was supplied in the request. The value must be between 1 and 255
-- characters.
httpraHostRedirect :: Lens' HTTPRedirectAction (Maybe Text)
httpraHostRedirect
  = lens _httpraHostRedirect
      (\ s a -> s{_httpraHostRedirect = a})

-- | The path that will be used in the redirect response instead of the one
-- that was supplied in the request. pathRedirect cannot be supplied
-- together with prefixRedirect. Supply one alone or neither. If neither is
-- supplied, the path of the original request will be used for the
-- redirect. The value must be between 1 and 1024 characters.
httpraPathRedirect :: Lens' HTTPRedirectAction (Maybe Text)
httpraPathRedirect
  = lens _httpraPathRedirect
      (\ s a -> s{_httpraPathRedirect = a})

-- | The prefix that replaces the prefixMatch specified in the
-- HttpRouteRuleMatch, retaining the remaining portion of the URL before
-- redirecting the request. prefixRedirect cannot be supplied together with
-- pathRedirect. Supply one alone or neither. If neither is supplied, the
-- path of the original request will be used for the redirect. The value
-- must be between 1 and 1024 characters.
httpraPrefixRedirect :: Lens' HTTPRedirectAction (Maybe Text)
httpraPrefixRedirect
  = lens _httpraPrefixRedirect
      (\ s a -> s{_httpraPrefixRedirect = a})

-- | If set to true, any accompanying query portion of the original URL is
-- removed prior to redirecting the request. If set to false, the query
-- portion of the original URL is retained. The default is set to false.
httpraStripQuery :: Lens' HTTPRedirectAction (Maybe Bool)
httpraStripQuery
  = lens _httpraStripQuery
      (\ s a -> s{_httpraStripQuery = a})

-- | If set to true, the URL scheme in the redirected request is set to
-- https. If set to false, the URL scheme of the redirected request will
-- remain the same as that of the request. This must only be set for
-- UrlMaps used in TargetHttpProxys. Setting this true for TargetHttpsProxy
-- is not permitted. The default is set to false.
httpraHTTPSRedirect :: Lens' HTTPRedirectAction (Maybe Bool)
httpraHTTPSRedirect
  = lens _httpraHTTPSRedirect
      (\ s a -> s{_httpraHTTPSRedirect = a})

instance FromJSON HTTPRedirectAction where
        parseJSON
          = withObject "HTTPRedirectAction"
              (\ o ->
                 HTTPRedirectAction' <$>
                   (o .:? "redirectResponseCode") <*>
                     (o .:? "hostRedirect")
                     <*> (o .:? "pathRedirect")
                     <*> (o .:? "prefixRedirect")
                     <*> (o .:? "stripQuery")
                     <*> (o .:? "httpsRedirect"))

instance ToJSON HTTPRedirectAction where
        toJSON HTTPRedirectAction'{..}
          = object
              (catMaybes
                 [("redirectResponseCode" .=) <$>
                    _httpraRedirectResponseCode,
                  ("hostRedirect" .=) <$> _httpraHostRedirect,
                  ("pathRedirect" .=) <$> _httpraPathRedirect,
                  ("prefixRedirect" .=) <$> _httpraPrefixRedirect,
                  ("stripQuery" .=) <$> _httpraStripQuery,
                  ("httpsRedirect" .=) <$> _httpraHTTPSRedirect])

--
-- /See:/ 'serverBinding' smart constructor.
newtype ServerBinding =
  ServerBinding'
    { _sbType :: Maybe ServerBindingType
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ServerBinding' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sbType'
serverBinding
    :: ServerBinding
serverBinding = ServerBinding' {_sbType = Nothing}


sbType :: Lens' ServerBinding (Maybe ServerBindingType)
sbType = lens _sbType (\ s a -> s{_sbType = a})

instance FromJSON ServerBinding where
        parseJSON
          = withObject "ServerBinding"
              (\ o -> ServerBinding' <$> (o .:? "type"))

instance ToJSON ServerBinding where
        toJSON ServerBinding'{..}
          = object (catMaybes [("type" .=) <$> _sbType])

--
-- /See:/ 'commitmentsScopedList' smart constructor.
data CommitmentsScopedList =
  CommitmentsScopedList'
    { _cslWarning :: !(Maybe CommitmentsScopedListWarning)
    , _cslCommitments :: !(Maybe [Commitment])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'CommitmentsScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'cslWarning'
--
-- * 'cslCommitments'
commitmentsScopedList
    :: CommitmentsScopedList
commitmentsScopedList =
  CommitmentsScopedList' {_cslWarning = Nothing, _cslCommitments = Nothing}


-- | [Output Only] Informational warning which replaces the list of
-- commitments when the list is empty.
cslWarning :: Lens' CommitmentsScopedList (Maybe CommitmentsScopedListWarning)
cslWarning
  = lens _cslWarning (\ s a -> s{_cslWarning = a})

-- | [Output Only] A list of commitments contained in this scope.
cslCommitments :: Lens' CommitmentsScopedList [Commitment]
cslCommitments
  = lens _cslCommitments
      (\ s a -> s{_cslCommitments = a})
      . _Default
      . _Coerce

instance FromJSON CommitmentsScopedList where
        parseJSON
          = withObject "CommitmentsScopedList"
              (\ o ->
                 CommitmentsScopedList' <$>
                   (o .:? "warning") <*>
                     (o .:? "commitments" .!= mempty))

instance ToJSON CommitmentsScopedList where
        toJSON CommitmentsScopedList'{..}
          = object
              (catMaybes
                 [("warning" .=) <$> _cslWarning,
                  ("commitments" .=) <$> _cslCommitments])

-- | A list of DisksScopedList resources.
--
-- /See:/ 'diskAggregatedListItems' smart constructor.
newtype DiskAggregatedListItems =
  DiskAggregatedListItems'
    { _daliAddtional :: HashMap Text DisksScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DiskAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'daliAddtional'
diskAggregatedListItems
    :: HashMap Text DisksScopedList -- ^ 'daliAddtional'
    -> DiskAggregatedListItems
diskAggregatedListItems pDaliAddtional_ =
  DiskAggregatedListItems' {_daliAddtional = _Coerce # pDaliAddtional_}


-- | [Output Only] Name of the scope containing this set of disks.
daliAddtional :: Lens' DiskAggregatedListItems (HashMap Text DisksScopedList)
daliAddtional
  = lens _daliAddtional
      (\ s a -> s{_daliAddtional = a})
      . _Coerce

instance FromJSON DiskAggregatedListItems where
        parseJSON
          = withObject "DiskAggregatedListItems"
              (\ o ->
                 DiskAggregatedListItems' <$> (parseJSONObject o))

instance ToJSON DiskAggregatedListItems where
        toJSON = toJSON . _daliAddtional

-- | [Output Only] Informational warning message.
--
-- /See:/ 'targetVPNGatewayAggregatedListWarning' smart constructor.
data TargetVPNGatewayAggregatedListWarning =
  TargetVPNGatewayAggregatedListWarning'
    { _tvgalwData :: !(Maybe [TargetVPNGatewayAggregatedListWarningDataItem])
    , _tvgalwCode :: !(Maybe TargetVPNGatewayAggregatedListWarningCode)
    , _tvgalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetVPNGatewayAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tvgalwData'
--
-- * 'tvgalwCode'
--
-- * 'tvgalwMessage'
targetVPNGatewayAggregatedListWarning
    :: TargetVPNGatewayAggregatedListWarning
targetVPNGatewayAggregatedListWarning =
  TargetVPNGatewayAggregatedListWarning'
    {_tvgalwData = Nothing, _tvgalwCode = Nothing, _tvgalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
tvgalwData :: Lens' TargetVPNGatewayAggregatedListWarning [TargetVPNGatewayAggregatedListWarningDataItem]
tvgalwData
  = lens _tvgalwData (\ s a -> s{_tvgalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
tvgalwCode :: Lens' TargetVPNGatewayAggregatedListWarning (Maybe TargetVPNGatewayAggregatedListWarningCode)
tvgalwCode
  = lens _tvgalwCode (\ s a -> s{_tvgalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
tvgalwMessage :: Lens' TargetVPNGatewayAggregatedListWarning (Maybe Text)
tvgalwMessage
  = lens _tvgalwMessage
      (\ s a -> s{_tvgalwMessage = a})

instance FromJSON
           TargetVPNGatewayAggregatedListWarning
         where
        parseJSON
          = withObject "TargetVPNGatewayAggregatedListWarning"
              (\ o ->
                 TargetVPNGatewayAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON TargetVPNGatewayAggregatedListWarning
         where
        toJSON TargetVPNGatewayAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _tvgalwData,
                  ("code" .=) <$> _tvgalwCode,
                  ("message" .=) <$> _tvgalwMessage])

-- | The location in Cloud Storage and naming method of the daily usage
-- report. Contains bucket_name and report_name prefix.
--
-- /See:/ 'usageExportLocation' smart constructor.
data UsageExportLocation =
  UsageExportLocation'
    { _uelReportNamePrefix :: !(Maybe Text)
    , _uelBucketName :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'UsageExportLocation' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'uelReportNamePrefix'
--
-- * 'uelBucketName'
usageExportLocation
    :: UsageExportLocation
usageExportLocation =
  UsageExportLocation'
    {_uelReportNamePrefix = Nothing, _uelBucketName = Nothing}


-- | An optional prefix for the name of the usage report object stored in
-- bucketName. If not supplied, defaults to usage. The report is stored as
-- a CSV file named report_name_prefix_gce_YYYYMMDD.csv where YYYYMMDD is
-- the day of the usage according to Pacific Time. If you supply a prefix,
-- it should conform to Cloud Storage object naming conventions.
uelReportNamePrefix :: Lens' UsageExportLocation (Maybe Text)
uelReportNamePrefix
  = lens _uelReportNamePrefix
      (\ s a -> s{_uelReportNamePrefix = a})

-- | The name of an existing bucket in Cloud Storage where the usage report
-- object is stored. The Google Service Account is granted write access to
-- this bucket. This can either be the bucket name by itself, such as
-- example-bucket, or the bucket name with gs:\/\/ or
-- https:\/\/storage.googleapis.com\/ in front of it, such as
-- gs:\/\/example-bucket.
uelBucketName :: Lens' UsageExportLocation (Maybe Text)
uelBucketName
  = lens _uelBucketName
      (\ s a -> s{_uelBucketName = a})

instance FromJSON UsageExportLocation where
        parseJSON
          = withObject "UsageExportLocation"
              (\ o ->
                 UsageExportLocation' <$>
                   (o .:? "reportNamePrefix") <*> (o .:? "bucketName"))

instance ToJSON UsageExportLocation where
        toJSON UsageExportLocation'{..}
          = object
              (catMaybes
                 [("reportNamePrefix" .=) <$> _uelReportNamePrefix,
                  ("bucketName" .=) <$> _uelBucketName])

-- | Contains a list of zone resources.
--
-- /See:/ 'zoneList' smart constructor.
data ZoneList =
  ZoneList'
    { _zlNextPageToken :: !(Maybe Text)
    , _zlKind :: !Text
    , _zlItems :: !(Maybe [Zone])
    , _zlSelfLink :: !(Maybe Text)
    , _zlWarning :: !(Maybe ZoneListWarning)
    , _zlId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ZoneList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'zlNextPageToken'
--
-- * 'zlKind'
--
-- * 'zlItems'
--
-- * 'zlSelfLink'
--
-- * 'zlWarning'
--
-- * 'zlId'
zoneList
    :: ZoneList
zoneList =
  ZoneList'
    { _zlNextPageToken = Nothing
    , _zlKind = "compute#zoneList"
    , _zlItems = Nothing
    , _zlSelfLink = Nothing
    , _zlWarning = Nothing
    , _zlId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
zlNextPageToken :: Lens' ZoneList (Maybe Text)
zlNextPageToken
  = lens _zlNextPageToken
      (\ s a -> s{_zlNextPageToken = a})

-- | Type of resource.
zlKind :: Lens' ZoneList Text
zlKind = lens _zlKind (\ s a -> s{_zlKind = a})

-- | A list of Zone resources.
zlItems :: Lens' ZoneList [Zone]
zlItems
  = lens _zlItems (\ s a -> s{_zlItems = a}) . _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
zlSelfLink :: Lens' ZoneList (Maybe Text)
zlSelfLink
  = lens _zlSelfLink (\ s a -> s{_zlSelfLink = a})

-- | [Output Only] Informational warning message.
zlWarning :: Lens' ZoneList (Maybe ZoneListWarning)
zlWarning
  = lens _zlWarning (\ s a -> s{_zlWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
zlId :: Lens' ZoneList (Maybe Text)
zlId = lens _zlId (\ s a -> s{_zlId = a})

instance FromJSON ZoneList where
        parseJSON
          = withObject "ZoneList"
              (\ o ->
                 ZoneList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#zoneList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON ZoneList where
        toJSON ZoneList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _zlNextPageToken,
                  Just ("kind" .= _zlKind), ("items" .=) <$> _zlItems,
                  ("selfLink" .=) <$> _zlSelfLink,
                  ("warning" .=) <$> _zlWarning, ("id" .=) <$> _zlId])

--
-- /See:/ 'sslCertificateListWarningDataItem' smart constructor.
data SSLCertificateListWarningDataItem =
  SSLCertificateListWarningDataItem'
    { _sclwdiValue :: !(Maybe Text)
    , _sclwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SSLCertificateListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sclwdiValue'
--
-- * 'sclwdiKey'
sslCertificateListWarningDataItem
    :: SSLCertificateListWarningDataItem
sslCertificateListWarningDataItem =
  SSLCertificateListWarningDataItem'
    {_sclwdiValue = Nothing, _sclwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
sclwdiValue :: Lens' SSLCertificateListWarningDataItem (Maybe Text)
sclwdiValue
  = lens _sclwdiValue (\ s a -> s{_sclwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
sclwdiKey :: Lens' SSLCertificateListWarningDataItem (Maybe Text)
sclwdiKey
  = lens _sclwdiKey (\ s a -> s{_sclwdiKey = a})

instance FromJSON SSLCertificateListWarningDataItem
         where
        parseJSON
          = withObject "SSLCertificateListWarningDataItem"
              (\ o ->
                 SSLCertificateListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON SSLCertificateListWarningDataItem
         where
        toJSON SSLCertificateListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _sclwdiValue,
                  ("key" .=) <$> _sclwdiKey])

--
-- /See:/ 'gRPCHealthCheck' smart constructor.
data GRPCHealthCheck =
  GRPCHealthCheck'
    { _grpchcGrpcServiceName :: !(Maybe Text)
    , _grpchcPortSpecification :: !(Maybe GRPCHealthCheckPortSpecification)
    , _grpchcPortName :: !(Maybe Text)
    , _grpchcPort :: !(Maybe (Textual Int32))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'GRPCHealthCheck' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'grpchcGrpcServiceName'
--
-- * 'grpchcPortSpecification'
--
-- * 'grpchcPortName'
--
-- * 'grpchcPort'
gRPCHealthCheck
    :: GRPCHealthCheck
gRPCHealthCheck =
  GRPCHealthCheck'
    { _grpchcGrpcServiceName = Nothing
    , _grpchcPortSpecification = Nothing
    , _grpchcPortName = Nothing
    , _grpchcPort = Nothing
    }


-- | The gRPC service name for the health check. This field is optional. The
-- value of grpc_service_name has the following meanings by convention: -
-- Empty service_name means the overall status of all services at the
-- backend. - Non-empty service_name means the health of that gRPC service,
-- as defined by the owner of the service. The grpc_service_name can only
-- be ASCII.
grpchcGrpcServiceName :: Lens' GRPCHealthCheck (Maybe Text)
grpchcGrpcServiceName
  = lens _grpchcGrpcServiceName
      (\ s a -> s{_grpchcGrpcServiceName = a})

-- | Specifies how port is selected for health checking, can be one of
-- following values: USE_FIXED_PORT: The port number in port is used for
-- health checking. USE_NAMED_PORT: The portName is used for health
-- checking. USE_SERVING_PORT: For NetworkEndpointGroup, the port specified
-- for each network endpoint is used for health checking. For other
-- backends, the port or named port specified in the Backend Service is
-- used for health checking. If not specified, gRPC health check follows
-- behavior specified in port and portName fields.
grpchcPortSpecification :: Lens' GRPCHealthCheck (Maybe GRPCHealthCheckPortSpecification)
grpchcPortSpecification
  = lens _grpchcPortSpecification
      (\ s a -> s{_grpchcPortSpecification = a})

-- | Port name as defined in InstanceGroup#NamedPort#name. If both port and
-- port_name are defined, port takes precedence. The port_name should
-- conform to RFC1035.
grpchcPortName :: Lens' GRPCHealthCheck (Maybe Text)
grpchcPortName
  = lens _grpchcPortName
      (\ s a -> s{_grpchcPortName = a})

-- | The port number for the health check request. Must be specified if
-- port_name and port_specification are not set or if port_specification is
-- USE_FIXED_PORT. Valid values are 1 through 65535.
grpchcPort :: Lens' GRPCHealthCheck (Maybe Int32)
grpchcPort
  = lens _grpchcPort (\ s a -> s{_grpchcPort = a}) .
      mapping _Coerce

instance FromJSON GRPCHealthCheck where
        parseJSON
          = withObject "GRPCHealthCheck"
              (\ o ->
                 GRPCHealthCheck' <$>
                   (o .:? "grpcServiceName") <*>
                     (o .:? "portSpecification")
                     <*> (o .:? "portName")
                     <*> (o .:? "port"))

instance ToJSON GRPCHealthCheck where
        toJSON GRPCHealthCheck'{..}
          = object
              (catMaybes
                 [("grpcServiceName" .=) <$> _grpchcGrpcServiceName,
                  ("portSpecification" .=) <$>
                    _grpchcPortSpecification,
                  ("portName" .=) <$> _grpchcPortName,
                  ("port" .=) <$> _grpchcPort])

-- | Metadata defined as annotations for network endpoint.
--
-- /See:/ 'healthStatusAnnotations' smart constructor.
newtype HealthStatusAnnotations =
  HealthStatusAnnotations'
    { _hsaAddtional :: HashMap Text Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HealthStatusAnnotations' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hsaAddtional'
healthStatusAnnotations
    :: HashMap Text Text -- ^ 'hsaAddtional'
    -> HealthStatusAnnotations
healthStatusAnnotations pHsaAddtional_ =
  HealthStatusAnnotations' {_hsaAddtional = _Coerce # pHsaAddtional_}


hsaAddtional :: Lens' HealthStatusAnnotations (HashMap Text Text)
hsaAddtional
  = lens _hsaAddtional (\ s a -> s{_hsaAddtional = a})
      . _Coerce

instance FromJSON HealthStatusAnnotations where
        parseJSON
          = withObject "HealthStatusAnnotations"
              (\ o ->
                 HealthStatusAnnotations' <$> (parseJSONObject o))

instance ToJSON HealthStatusAnnotations where
        toJSON = toJSON . _hsaAddtional

--
-- /See:/ 'notificationEndpointList' smart constructor.
data NotificationEndpointList =
  NotificationEndpointList'
    { _nelNextPageToken :: !(Maybe Text)
    , _nelKind :: !Text
    , _nelItems :: !(Maybe [NotificationEndpoint])
    , _nelSelfLink :: !(Maybe Text)
    , _nelWarning :: !(Maybe NotificationEndpointListWarning)
    , _nelId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NotificationEndpointList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nelNextPageToken'
--
-- * 'nelKind'
--
-- * 'nelItems'
--
-- * 'nelSelfLink'
--
-- * 'nelWarning'
--
-- * 'nelId'
notificationEndpointList
    :: NotificationEndpointList
notificationEndpointList =
  NotificationEndpointList'
    { _nelNextPageToken = Nothing
    , _nelKind = "compute#notificationEndpointList"
    , _nelItems = Nothing
    , _nelSelfLink = Nothing
    , _nelWarning = Nothing
    , _nelId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
nelNextPageToken :: Lens' NotificationEndpointList (Maybe Text)
nelNextPageToken
  = lens _nelNextPageToken
      (\ s a -> s{_nelNextPageToken = a})

-- | [Output Only] Type of the resource. Always compute#notificationEndpoint
-- for notification endpoints.
nelKind :: Lens' NotificationEndpointList Text
nelKind = lens _nelKind (\ s a -> s{_nelKind = a})

-- | A list of NotificationEndpoint resources.
nelItems :: Lens' NotificationEndpointList [NotificationEndpoint]
nelItems
  = lens _nelItems (\ s a -> s{_nelItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
nelSelfLink :: Lens' NotificationEndpointList (Maybe Text)
nelSelfLink
  = lens _nelSelfLink (\ s a -> s{_nelSelfLink = a})

-- | [Output Only] Informational warning message.
nelWarning :: Lens' NotificationEndpointList (Maybe NotificationEndpointListWarning)
nelWarning
  = lens _nelWarning (\ s a -> s{_nelWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
nelId :: Lens' NotificationEndpointList (Maybe Text)
nelId = lens _nelId (\ s a -> s{_nelId = a})

instance FromJSON NotificationEndpointList where
        parseJSON
          = withObject "NotificationEndpointList"
              (\ o ->
                 NotificationEndpointList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#notificationEndpointList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON NotificationEndpointList where
        toJSON NotificationEndpointList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _nelNextPageToken,
                  Just ("kind" .= _nelKind),
                  ("items" .=) <$> _nelItems,
                  ("selfLink" .=) <$> _nelSelfLink,
                  ("warning" .=) <$> _nelWarning,
                  ("id" .=) <$> _nelId])

--
-- /See:/ 'distributionPolicyZoneConfiguration' smart constructor.
newtype DistributionPolicyZoneConfiguration =
  DistributionPolicyZoneConfiguration'
    { _dpzcZone :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DistributionPolicyZoneConfiguration' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dpzcZone'
distributionPolicyZoneConfiguration
    :: DistributionPolicyZoneConfiguration
distributionPolicyZoneConfiguration =
  DistributionPolicyZoneConfiguration' {_dpzcZone = Nothing}


-- | The URL of the zone. The zone must exist in the region where the managed
-- instance group is located.
dpzcZone :: Lens' DistributionPolicyZoneConfiguration (Maybe Text)
dpzcZone = lens _dpzcZone (\ s a -> s{_dpzcZone = a})

instance FromJSON DistributionPolicyZoneConfiguration
         where
        parseJSON
          = withObject "DistributionPolicyZoneConfiguration"
              (\ o ->
                 DistributionPolicyZoneConfiguration' <$>
                   (o .:? "zone"))

instance ToJSON DistributionPolicyZoneConfiguration
         where
        toJSON DistributionPolicyZoneConfiguration'{..}
          = object (catMaybes [("zone" .=) <$> _dpzcZone])

-- | Contains output only fields. Use this sub-message for all output fields
-- set on ResourcePolicy. The internal structure of this \"status\" field
-- should mimic the structure of ResourcePolicy proto specification.
--
-- /See:/ 'resourcePolicyResourceStatus' smart constructor.
newtype ResourcePolicyResourceStatus =
  ResourcePolicyResourceStatus'
    { _rprsInstanceSchedulePolicy :: Maybe ResourcePolicyResourceStatusInstanceSchedulePolicyStatus
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePolicyResourceStatus' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rprsInstanceSchedulePolicy'
resourcePolicyResourceStatus
    :: ResourcePolicyResourceStatus
resourcePolicyResourceStatus =
  ResourcePolicyResourceStatus' {_rprsInstanceSchedulePolicy = Nothing}


-- | [Output Only] Specifies a set of output values reffering to the
-- instance_schedule_policy system status. This field should have the same
-- name as corresponding policy field.
rprsInstanceSchedulePolicy :: Lens' ResourcePolicyResourceStatus (Maybe ResourcePolicyResourceStatusInstanceSchedulePolicyStatus)
rprsInstanceSchedulePolicy
  = lens _rprsInstanceSchedulePolicy
      (\ s a -> s{_rprsInstanceSchedulePolicy = a})

instance FromJSON ResourcePolicyResourceStatus where
        parseJSON
          = withObject "ResourcePolicyResourceStatus"
              (\ o ->
                 ResourcePolicyResourceStatus' <$>
                   (o .:? "instanceSchedulePolicy"))

instance ToJSON ResourcePolicyResourceStatus where
        toJSON ResourcePolicyResourceStatus'{..}
          = object
              (catMaybes
                 [("instanceSchedulePolicy" .=) <$>
                    _rprsInstanceSchedulePolicy])

--
-- /See:/ 'targetTCPProxiesSetProxyHeaderRequest' smart constructor.
newtype TargetTCPProxiesSetProxyHeaderRequest =
  TargetTCPProxiesSetProxyHeaderRequest'
    { _ttpsphrProxyHeader :: Maybe TargetTCPProxiesSetProxyHeaderRequestProxyHeader
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetTCPProxiesSetProxyHeaderRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ttpsphrProxyHeader'
targetTCPProxiesSetProxyHeaderRequest
    :: TargetTCPProxiesSetProxyHeaderRequest
targetTCPProxiesSetProxyHeaderRequest =
  TargetTCPProxiesSetProxyHeaderRequest' {_ttpsphrProxyHeader = Nothing}


-- | The new type of proxy header to append before sending data to the
-- backend. NONE or PROXY_V1 are allowed.
ttpsphrProxyHeader :: Lens' TargetTCPProxiesSetProxyHeaderRequest (Maybe TargetTCPProxiesSetProxyHeaderRequestProxyHeader)
ttpsphrProxyHeader
  = lens _ttpsphrProxyHeader
      (\ s a -> s{_ttpsphrProxyHeader = a})

instance FromJSON
           TargetTCPProxiesSetProxyHeaderRequest
         where
        parseJSON
          = withObject "TargetTCPProxiesSetProxyHeaderRequest"
              (\ o ->
                 TargetTCPProxiesSetProxyHeaderRequest' <$>
                   (o .:? "proxyHeader"))

instance ToJSON TargetTCPProxiesSetProxyHeaderRequest
         where
        toJSON TargetTCPProxiesSetProxyHeaderRequest'{..}
          = object
              (catMaybes
                 [("proxyHeader" .=) <$> _ttpsphrProxyHeader])

--
-- /See:/ 'vpnGatewayStatus' smart constructor.
newtype VPNGatewayStatus =
  VPNGatewayStatus'
    { _vgsVPNConnections :: Maybe [VPNGatewayStatusVPNConnection]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNGatewayStatus' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vgsVPNConnections'
vpnGatewayStatus
    :: VPNGatewayStatus
vpnGatewayStatus = VPNGatewayStatus' {_vgsVPNConnections = Nothing}


-- | List of VPN connection for this VpnGateway.
vgsVPNConnections :: Lens' VPNGatewayStatus [VPNGatewayStatusVPNConnection]
vgsVPNConnections
  = lens _vgsVPNConnections
      (\ s a -> s{_vgsVPNConnections = a})
      . _Default
      . _Coerce

instance FromJSON VPNGatewayStatus where
        parseJSON
          = withObject "VPNGatewayStatus"
              (\ o ->
                 VPNGatewayStatus' <$>
                   (o .:? "vpnConnections" .!= mempty))

instance ToJSON VPNGatewayStatus where
        toJSON VPNGatewayStatus'{..}
          = object
              (catMaybes
                 [("vpnConnections" .=) <$> _vgsVPNConnections])

--
-- /See:/ 'routerBGPPeer' smart constructor.
data RouterBGPPeer =
  RouterBGPPeer'
    { _rbpIPAddress :: !(Maybe Text)
    , _rbpInterfaceName :: !(Maybe Text)
    , _rbpPeerIPAddress :: !(Maybe Text)
    , _rbpAdvertisedRoutePriority :: !(Maybe (Textual Word32))
    , _rbpPeerASN :: !(Maybe (Textual Word32))
    , _rbpEnable :: !(Maybe RouterBGPPeerEnable)
    , _rbpAdvertiseMode :: !(Maybe RouterBGPPeerAdvertiseMode)
    , _rbpName :: !(Maybe Text)
    , _rbpAdvertisedGroups :: !(Maybe [RouterBGPPeerAdvertisedGroupsItem])
    , _rbpManagementType :: !(Maybe RouterBGPPeerManagementType)
    , _rbpAdvertisedIPRanges :: !(Maybe [RouterAdvertisedIPRange])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RouterBGPPeer' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rbpIPAddress'
--
-- * 'rbpInterfaceName'
--
-- * 'rbpPeerIPAddress'
--
-- * 'rbpAdvertisedRoutePriority'
--
-- * 'rbpPeerASN'
--
-- * 'rbpEnable'
--
-- * 'rbpAdvertiseMode'
--
-- * 'rbpName'
--
-- * 'rbpAdvertisedGroups'
--
-- * 'rbpManagementType'
--
-- * 'rbpAdvertisedIPRanges'
routerBGPPeer
    :: RouterBGPPeer
routerBGPPeer =
  RouterBGPPeer'
    { _rbpIPAddress = Nothing
    , _rbpInterfaceName = Nothing
    , _rbpPeerIPAddress = Nothing
    , _rbpAdvertisedRoutePriority = Nothing
    , _rbpPeerASN = Nothing
    , _rbpEnable = Nothing
    , _rbpAdvertiseMode = Nothing
    , _rbpName = Nothing
    , _rbpAdvertisedGroups = Nothing
    , _rbpManagementType = Nothing
    , _rbpAdvertisedIPRanges = Nothing
    }


-- | IP address of the interface inside Google Cloud Platform. Only IPv4 is
-- supported.
rbpIPAddress :: Lens' RouterBGPPeer (Maybe Text)
rbpIPAddress
  = lens _rbpIPAddress (\ s a -> s{_rbpIPAddress = a})

-- | Name of the interface the BGP peer is associated with.
rbpInterfaceName :: Lens' RouterBGPPeer (Maybe Text)
rbpInterfaceName
  = lens _rbpInterfaceName
      (\ s a -> s{_rbpInterfaceName = a})

-- | IP address of the BGP interface outside Google Cloud Platform. Only IPv4
-- is supported.
rbpPeerIPAddress :: Lens' RouterBGPPeer (Maybe Text)
rbpPeerIPAddress
  = lens _rbpPeerIPAddress
      (\ s a -> s{_rbpPeerIPAddress = a})

-- | The priority of routes advertised to this BGP peer. Where there is more
-- than one matching route of maximum length, the routes with the lowest
-- priority value win.
rbpAdvertisedRoutePriority :: Lens' RouterBGPPeer (Maybe Word32)
rbpAdvertisedRoutePriority
  = lens _rbpAdvertisedRoutePriority
      (\ s a -> s{_rbpAdvertisedRoutePriority = a})
      . mapping _Coerce

-- | Peer BGP Autonomous System Number (ASN). Each BGP interface may use a
-- different value.
rbpPeerASN :: Lens' RouterBGPPeer (Maybe Word32)
rbpPeerASN
  = lens _rbpPeerASN (\ s a -> s{_rbpPeerASN = a}) .
      mapping _Coerce

-- | The status of the BGP peer connection. If set to FALSE, any active
-- session with the peer is terminated and all associated routing
-- information is removed. If set to TRUE, the peer connection can be
-- established with routing information. The default is TRUE.
rbpEnable :: Lens' RouterBGPPeer (Maybe RouterBGPPeerEnable)
rbpEnable
  = lens _rbpEnable (\ s a -> s{_rbpEnable = a})

-- | User-specified flag to indicate which mode to use for advertisement.
rbpAdvertiseMode :: Lens' RouterBGPPeer (Maybe RouterBGPPeerAdvertiseMode)
rbpAdvertiseMode
  = lens _rbpAdvertiseMode
      (\ s a -> s{_rbpAdvertiseMode = a})

-- | Name of this BGP peer. The name must be 1-63 characters long, and comply
-- with RFC1035. Specifically, the name must be 1-63 characters long and
-- match the regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means
-- the first character must be a lowercase letter, and all following
-- characters must be a dash, lowercase letter, or digit, except the last
-- character, which cannot be a dash.
rbpName :: Lens' RouterBGPPeer (Maybe Text)
rbpName = lens _rbpName (\ s a -> s{_rbpName = a})

-- | User-specified list of prefix groups to advertise in custom mode, which
-- can take one of the following options: - ALL_SUBNETS: Advertises all
-- available subnets, including peer VPC subnets. - ALL_VPC_SUBNETS:
-- Advertises the router\'s own VPC subnets. Note that this field can only
-- be populated if advertise_mode is CUSTOM and overrides the list defined
-- for the router (in the \"bgp\" message). These groups are advertised in
-- addition to any specified prefixes. Leave this field blank to advertise
-- no custom groups.
rbpAdvertisedGroups :: Lens' RouterBGPPeer [RouterBGPPeerAdvertisedGroupsItem]
rbpAdvertisedGroups
  = lens _rbpAdvertisedGroups
      (\ s a -> s{_rbpAdvertisedGroups = a})
      . _Default
      . _Coerce

-- | [Output Only] The resource that configures and manages this BGP peer. -
-- MANAGED_BY_USER is the default value and can be managed by you or other
-- users - MANAGED_BY_ATTACHMENT is a BGP peer that is configured and
-- managed by Cloud Interconnect, specifically by an InterconnectAttachment
-- of type PARTNER. Google automatically creates, updates, and deletes this
-- type of BGP peer when the PARTNER InterconnectAttachment is created,
-- updated, or deleted.
rbpManagementType :: Lens' RouterBGPPeer (Maybe RouterBGPPeerManagementType)
rbpManagementType
  = lens _rbpManagementType
      (\ s a -> s{_rbpManagementType = a})

-- | User-specified list of individual IP ranges to advertise in custom mode.
-- This field can only be populated if advertise_mode is CUSTOM and
-- overrides the list defined for the router (in the \"bgp\" message).
-- These IP ranges are advertised in addition to any specified groups.
-- Leave this field blank to advertise no custom IP ranges.
rbpAdvertisedIPRanges :: Lens' RouterBGPPeer [RouterAdvertisedIPRange]
rbpAdvertisedIPRanges
  = lens _rbpAdvertisedIPRanges
      (\ s a -> s{_rbpAdvertisedIPRanges = a})
      . _Default
      . _Coerce

instance FromJSON RouterBGPPeer where
        parseJSON
          = withObject "RouterBGPPeer"
              (\ o ->
                 RouterBGPPeer' <$>
                   (o .:? "ipAddress") <*> (o .:? "interfaceName") <*>
                     (o .:? "peerIpAddress")
                     <*> (o .:? "advertisedRoutePriority")
                     <*> (o .:? "peerAsn")
                     <*> (o .:? "enable")
                     <*> (o .:? "advertiseMode")
                     <*> (o .:? "name")
                     <*> (o .:? "advertisedGroups" .!= mempty)
                     <*> (o .:? "managementType")
                     <*> (o .:? "advertisedIpRanges" .!= mempty))

instance ToJSON RouterBGPPeer where
        toJSON RouterBGPPeer'{..}
          = object
              (catMaybes
                 [("ipAddress" .=) <$> _rbpIPAddress,
                  ("interfaceName" .=) <$> _rbpInterfaceName,
                  ("peerIpAddress" .=) <$> _rbpPeerIPAddress,
                  ("advertisedRoutePriority" .=) <$>
                    _rbpAdvertisedRoutePriority,
                  ("peerAsn" .=) <$> _rbpPeerASN,
                  ("enable" .=) <$> _rbpEnable,
                  ("advertiseMode" .=) <$> _rbpAdvertiseMode,
                  ("name" .=) <$> _rbpName,
                  ("advertisedGroups" .=) <$> _rbpAdvertisedGroups,
                  ("managementType" .=) <$> _rbpManagementType,
                  ("advertisedIpRanges" .=) <$>
                    _rbpAdvertisedIPRanges])

--
-- /See:/ 'subnetworksExpandIPCIdRRangeRequest' smart constructor.
newtype SubnetworksExpandIPCIdRRangeRequest =
  SubnetworksExpandIPCIdRRangeRequest'
    { _seicirrrIPCIdRRange :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SubnetworksExpandIPCIdRRangeRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'seicirrrIPCIdRRange'
subnetworksExpandIPCIdRRangeRequest
    :: SubnetworksExpandIPCIdRRangeRequest
subnetworksExpandIPCIdRRangeRequest =
  SubnetworksExpandIPCIdRRangeRequest' {_seicirrrIPCIdRRange = Nothing}


-- | The IP (in CIDR format or netmask) of internal addresses that are legal
-- on this Subnetwork. This range should be disjoint from other subnetworks
-- within this network. This range can only be larger than (i.e. a superset
-- of) the range previously defined before the update.
seicirrrIPCIdRRange :: Lens' SubnetworksExpandIPCIdRRangeRequest (Maybe Text)
seicirrrIPCIdRRange
  = lens _seicirrrIPCIdRRange
      (\ s a -> s{_seicirrrIPCIdRRange = a})

instance FromJSON SubnetworksExpandIPCIdRRangeRequest
         where
        parseJSON
          = withObject "SubnetworksExpandIPCIdRRangeRequest"
              (\ o ->
                 SubnetworksExpandIPCIdRRangeRequest' <$>
                   (o .:? "ipCidrRange"))

instance ToJSON SubnetworksExpandIPCIdRRangeRequest
         where
        toJSON SubnetworksExpandIPCIdRRangeRequest'{..}
          = object
              (catMaybes
                 [("ipCidrRange" .=) <$> _seicirrrIPCIdRRange])

-- | A Managed Instance resource.
--
-- /See:/ 'managedInstance' smart constructor.
data ManagedInstance =
  ManagedInstance'
    { _miLastAttempt :: !(Maybe ManagedInstanceLastAttempt)
    , _miPreservedStateFromConfig :: !(Maybe PreservedState)
    , _miInstanceHealth :: !(Maybe [ManagedInstanceInstanceHealth])
    , _miCurrentAction :: !(Maybe ManagedInstanceCurrentAction)
    , _miVersion :: !(Maybe ManagedInstanceVersion)
    , _miPreservedStateFromPolicy :: !(Maybe PreservedState)
    , _miId :: !(Maybe (Textual Word64))
    , _miInstanceStatus :: !(Maybe ManagedInstanceInstanceStatus)
    , _miInstance :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ManagedInstance' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'miLastAttempt'
--
-- * 'miPreservedStateFromConfig'
--
-- * 'miInstanceHealth'
--
-- * 'miCurrentAction'
--
-- * 'miVersion'
--
-- * 'miPreservedStateFromPolicy'
--
-- * 'miId'
--
-- * 'miInstanceStatus'
--
-- * 'miInstance'
managedInstance
    :: ManagedInstance
managedInstance =
  ManagedInstance'
    { _miLastAttempt = Nothing
    , _miPreservedStateFromConfig = Nothing
    , _miInstanceHealth = Nothing
    , _miCurrentAction = Nothing
    , _miVersion = Nothing
    , _miPreservedStateFromPolicy = Nothing
    , _miId = Nothing
    , _miInstanceStatus = Nothing
    , _miInstance = Nothing
    }


-- | [Output Only] Information about the last attempt to create or delete the
-- instance.
miLastAttempt :: Lens' ManagedInstance (Maybe ManagedInstanceLastAttempt)
miLastAttempt
  = lens _miLastAttempt
      (\ s a -> s{_miLastAttempt = a})

-- | [Output Only] Preserved state applied from per-instance config for this
-- instance.
miPreservedStateFromConfig :: Lens' ManagedInstance (Maybe PreservedState)
miPreservedStateFromConfig
  = lens _miPreservedStateFromConfig
      (\ s a -> s{_miPreservedStateFromConfig = a})

-- | [Output Only] Health state of the instance per health-check.
miInstanceHealth :: Lens' ManagedInstance [ManagedInstanceInstanceHealth]
miInstanceHealth
  = lens _miInstanceHealth
      (\ s a -> s{_miInstanceHealth = a})
      . _Default
      . _Coerce

-- | [Output Only] The current action that the managed instance group has
-- scheduled for the instance. Possible values: - NONE The instance is
-- running, and the managed instance group does not have any scheduled
-- actions for this instance. - CREATING The managed instance group is
-- creating this instance. If the group fails to create this instance, it
-- will try again until it is successful. - CREATING_WITHOUT_RETRIES The
-- managed instance group is attempting to create this instance only once.
-- If the group fails to create this instance, it does not try again and
-- the group\'s targetSize value is decreased instead. - RECREATING The
-- managed instance group is recreating this instance. - DELETING The
-- managed instance group is permanently deleting this instance. -
-- ABANDONING The managed instance group is abandoning this instance. The
-- instance will be removed from the instance group and from any target
-- pools that are associated with this group. - RESTARTING The managed
-- instance group is restarting the instance. - REFRESHING The managed
-- instance group is applying configuration changes to the instance without
-- stopping it. For example, the group can update the target pool list for
-- an instance without stopping that instance. - VERIFYING The managed
-- instance group has created the instance and it is in the process of
-- being verified.
miCurrentAction :: Lens' ManagedInstance (Maybe ManagedInstanceCurrentAction)
miCurrentAction
  = lens _miCurrentAction
      (\ s a -> s{_miCurrentAction = a})

-- | [Output Only] Intended version of this instance.
miVersion :: Lens' ManagedInstance (Maybe ManagedInstanceVersion)
miVersion
  = lens _miVersion (\ s a -> s{_miVersion = a})

-- | [Output Only] Preserved state generated based on stateful policy for
-- this instance.
miPreservedStateFromPolicy :: Lens' ManagedInstance (Maybe PreservedState)
miPreservedStateFromPolicy
  = lens _miPreservedStateFromPolicy
      (\ s a -> s{_miPreservedStateFromPolicy = a})

-- | [Output only] The unique identifier for this resource. This field is
-- empty when instance does not exist.
miId :: Lens' ManagedInstance (Maybe Word64)
miId
  = lens _miId (\ s a -> s{_miId = a}) .
      mapping _Coerce

-- | [Output Only] The status of the instance. This field is empty when the
-- instance does not exist.
miInstanceStatus :: Lens' ManagedInstance (Maybe ManagedInstanceInstanceStatus)
miInstanceStatus
  = lens _miInstanceStatus
      (\ s a -> s{_miInstanceStatus = a})

-- | [Output Only] The URL of the instance. The URL can exist even if the
-- instance has not yet been created.
miInstance :: Lens' ManagedInstance (Maybe Text)
miInstance
  = lens _miInstance (\ s a -> s{_miInstance = a})

instance FromJSON ManagedInstance where
        parseJSON
          = withObject "ManagedInstance"
              (\ o ->
                 ManagedInstance' <$>
                   (o .:? "lastAttempt") <*>
                     (o .:? "preservedStateFromConfig")
                     <*> (o .:? "instanceHealth" .!= mempty)
                     <*> (o .:? "currentAction")
                     <*> (o .:? "version")
                     <*> (o .:? "preservedStateFromPolicy")
                     <*> (o .:? "id")
                     <*> (o .:? "instanceStatus")
                     <*> (o .:? "instance"))

instance ToJSON ManagedInstance where
        toJSON ManagedInstance'{..}
          = object
              (catMaybes
                 [("lastAttempt" .=) <$> _miLastAttempt,
                  ("preservedStateFromConfig" .=) <$>
                    _miPreservedStateFromConfig,
                  ("instanceHealth" .=) <$> _miInstanceHealth,
                  ("currentAction" .=) <$> _miCurrentAction,
                  ("version" .=) <$> _miVersion,
                  ("preservedStateFromPolicy" .=) <$>
                    _miPreservedStateFromPolicy,
                  ("id" .=) <$> _miId,
                  ("instanceStatus" .=) <$> _miInstanceStatus,
                  ("instance" .=) <$> _miInstance])

-- | A list of InstanceGroupManagersScopedList resources.
--
-- /See:/ 'instanceGroupManagerAggregatedListItems' smart constructor.
newtype InstanceGroupManagerAggregatedListItems =
  InstanceGroupManagerAggregatedListItems'
    { _igmaliAddtional :: HashMap Text InstanceGroupManagersScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagerAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmaliAddtional'
instanceGroupManagerAggregatedListItems
    :: HashMap Text InstanceGroupManagersScopedList -- ^ 'igmaliAddtional'
    -> InstanceGroupManagerAggregatedListItems
instanceGroupManagerAggregatedListItems pIgmaliAddtional_ =
  InstanceGroupManagerAggregatedListItems'
    {_igmaliAddtional = _Coerce # pIgmaliAddtional_}


-- | [Output Only] The name of the scope that contains this set of managed
-- instance groups.
igmaliAddtional :: Lens' InstanceGroupManagerAggregatedListItems (HashMap Text InstanceGroupManagersScopedList)
igmaliAddtional
  = lens _igmaliAddtional
      (\ s a -> s{_igmaliAddtional = a})
      . _Coerce

instance FromJSON
           InstanceGroupManagerAggregatedListItems
         where
        parseJSON
          = withObject
              "InstanceGroupManagerAggregatedListItems"
              (\ o ->
                 InstanceGroupManagerAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON
           InstanceGroupManagerAggregatedListItems
         where
        toJSON = toJSON . _igmaliAddtional

-- | Specification determining how headers are added to requests or
-- responses.
--
-- /See:/ 'hTTPHeaderOption' smart constructor.
data HTTPHeaderOption =
  HTTPHeaderOption'
    { _httphoReplace :: !(Maybe Bool)
    , _httphoHeaderValue :: !(Maybe Text)
    , _httphoHeaderName :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HTTPHeaderOption' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'httphoReplace'
--
-- * 'httphoHeaderValue'
--
-- * 'httphoHeaderName'
hTTPHeaderOption
    :: HTTPHeaderOption
hTTPHeaderOption =
  HTTPHeaderOption'
    { _httphoReplace = Nothing
    , _httphoHeaderValue = Nothing
    , _httphoHeaderName = Nothing
    }


-- | If false, headerValue is appended to any values that already exist for
-- the header. If true, headerValue is set for the header, discarding any
-- values that were set for that header. The default value is false.
httphoReplace :: Lens' HTTPHeaderOption (Maybe Bool)
httphoReplace
  = lens _httphoReplace
      (\ s a -> s{_httphoReplace = a})

-- | The value of the header to add.
httphoHeaderValue :: Lens' HTTPHeaderOption (Maybe Text)
httphoHeaderValue
  = lens _httphoHeaderValue
      (\ s a -> s{_httphoHeaderValue = a})

-- | The name of the header.
httphoHeaderName :: Lens' HTTPHeaderOption (Maybe Text)
httphoHeaderName
  = lens _httphoHeaderName
      (\ s a -> s{_httphoHeaderName = a})

instance FromJSON HTTPHeaderOption where
        parseJSON
          = withObject "HTTPHeaderOption"
              (\ o ->
                 HTTPHeaderOption' <$>
                   (o .:? "replace") <*> (o .:? "headerValue") <*>
                     (o .:? "headerName"))

instance ToJSON HTTPHeaderOption where
        toJSON HTTPHeaderOption'{..}
          = object
              (catMaybes
                 [("replace" .=) <$> _httphoReplace,
                  ("headerValue" .=) <$> _httphoHeaderValue,
                  ("headerName" .=) <$> _httphoHeaderName])

--
-- /See:/ 'instanceGroupManagersDeleteInstancesRequest' smart constructor.
newtype InstanceGroupManagersDeleteInstancesRequest =
  InstanceGroupManagersDeleteInstancesRequest'
    { _igmdirInstances :: Maybe [Text]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagersDeleteInstancesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmdirInstances'
instanceGroupManagersDeleteInstancesRequest
    :: InstanceGroupManagersDeleteInstancesRequest
instanceGroupManagersDeleteInstancesRequest =
  InstanceGroupManagersDeleteInstancesRequest' {_igmdirInstances = Nothing}


-- | The URLs of one or more instances to delete. This can be a full URL or a
-- partial URL, such as zones\/[ZONE]\/instances\/[INSTANCE_NAME].
igmdirInstances :: Lens' InstanceGroupManagersDeleteInstancesRequest [Text]
igmdirInstances
  = lens _igmdirInstances
      (\ s a -> s{_igmdirInstances = a})
      . _Default
      . _Coerce

instance FromJSON
           InstanceGroupManagersDeleteInstancesRequest
         where
        parseJSON
          = withObject
              "InstanceGroupManagersDeleteInstancesRequest"
              (\ o ->
                 InstanceGroupManagersDeleteInstancesRequest' <$>
                   (o .:? "instances" .!= mempty))

instance ToJSON
           InstanceGroupManagersDeleteInstancesRequest
         where
        toJSON
          InstanceGroupManagersDeleteInstancesRequest'{..}
          = object
              (catMaybes [("instances" .=) <$> _igmdirInstances])

-- | A full or valid partial URL to a health check service. For example, the
-- following are valid URLs: -
-- https:\/\/www.googleapis.com\/compute\/beta\/projects\/project-id\/regions\/us-west1\/healthCheckServices\/health-check-service
-- -
-- projects\/project-id\/regions\/us-west1\/healthCheckServices\/health-check-service
-- - regions\/us-west1\/healthCheckServices\/health-check-service
--
-- /See:/ 'healthCheckServiceReference' smart constructor.
newtype HealthCheckServiceReference =
  HealthCheckServiceReference'
    { _hcsrHealthCheckService :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HealthCheckServiceReference' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hcsrHealthCheckService'
healthCheckServiceReference
    :: HealthCheckServiceReference
healthCheckServiceReference =
  HealthCheckServiceReference' {_hcsrHealthCheckService = Nothing}


hcsrHealthCheckService :: Lens' HealthCheckServiceReference (Maybe Text)
hcsrHealthCheckService
  = lens _hcsrHealthCheckService
      (\ s a -> s{_hcsrHealthCheckService = a})

instance FromJSON HealthCheckServiceReference where
        parseJSON
          = withObject "HealthCheckServiceReference"
              (\ o ->
                 HealthCheckServiceReference' <$>
                   (o .:? "healthCheckService"))

instance ToJSON HealthCheckServiceReference where
        toJSON HealthCheckServiceReference'{..}
          = object
              (catMaybes
                 [("healthCheckService" .=) <$>
                    _hcsrHealthCheckService])

-- | Message containing information of one individual backend.
--
-- /See:/ 'backend' smart constructor.
data Backend =
  Backend'
    { _bGroup :: !(Maybe Text)
    , _bBalancingMode :: !(Maybe BackendBalancingMode)
    , _bMaxUtilization :: !(Maybe (Textual Double))
    , _bMaxRate :: !(Maybe (Textual Int32))
    , _bMaxConnections :: !(Maybe (Textual Int32))
    , _bFailover :: !(Maybe Bool)
    , _bMaxConnectionsPerInstance :: !(Maybe (Textual Int32))
    , _bMaxRatePerEndpoint :: !(Maybe (Textual Double))
    , _bMaxConnectionsPerEndpoint :: !(Maybe (Textual Int32))
    , _bMaxRatePerInstance :: !(Maybe (Textual Double))
    , _bDescription :: !(Maybe Text)
    , _bCapacityScaler :: !(Maybe (Textual Double))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Backend' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bGroup'
--
-- * 'bBalancingMode'
--
-- * 'bMaxUtilization'
--
-- * 'bMaxRate'
--
-- * 'bMaxConnections'
--
-- * 'bFailover'
--
-- * 'bMaxConnectionsPerInstance'
--
-- * 'bMaxRatePerEndpoint'
--
-- * 'bMaxConnectionsPerEndpoint'
--
-- * 'bMaxRatePerInstance'
--
-- * 'bDescription'
--
-- * 'bCapacityScaler'
backend
    :: Backend
backend =
  Backend'
    { _bGroup = Nothing
    , _bBalancingMode = Nothing
    , _bMaxUtilization = Nothing
    , _bMaxRate = Nothing
    , _bMaxConnections = Nothing
    , _bFailover = Nothing
    , _bMaxConnectionsPerInstance = Nothing
    , _bMaxRatePerEndpoint = Nothing
    , _bMaxConnectionsPerEndpoint = Nothing
    , _bMaxRatePerInstance = Nothing
    , _bDescription = Nothing
    , _bCapacityScaler = Nothing
    }


-- | The fully-qualified URL of an instance group or network endpoint group
-- (NEG) resource. The type of backend that a backend service supports
-- depends on the backend service\'s loadBalancingScheme. - When the
-- loadBalancingScheme for the backend service is EXTERNAL (except Network
-- Load Balancing), INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED , the
-- backend can be either an instance group or a NEG. The backends on the
-- backend service must be either all instance groups or all NEGs. You
-- cannot mix instance group and NEG backends on the same backend service.
-- - When the loadBalancingScheme for the backend service is EXTERNAL for
-- Network Load Balancing or INTERNAL for Internal TCP\/UDP Load Balancing,
-- the backend must be an instance group. NEGs are not supported. For
-- regional services, the backend must be in the same region as the backend
-- service. You must use the fully-qualified URL (starting with
-- https:\/\/www.googleapis.com\/) to specify the instance group or NEG.
-- Partial URLs are not supported.
bGroup :: Lens' Backend (Maybe Text)
bGroup = lens _bGroup (\ s a -> s{_bGroup = a})

-- | Specifies how to determine whether the backend of a load balancer can
-- handle additional traffic or is fully loaded. For usage guidelines, see
-- Connection balancing mode.
bBalancingMode :: Lens' Backend (Maybe BackendBalancingMode)
bBalancingMode
  = lens _bBalancingMode
      (\ s a -> s{_bBalancingMode = a})

bMaxUtilization :: Lens' Backend (Maybe Double)
bMaxUtilization
  = lens _bMaxUtilization
      (\ s a -> s{_bMaxUtilization = a})
      . mapping _Coerce

-- | Defines a maximum number of HTTP requests per second (RPS). For usage
-- guidelines, see Rate balancing mode and Utilization balancing mode. Not
-- available if the backend\'s balancingMode is CONNECTION.
bMaxRate :: Lens' Backend (Maybe Int32)
bMaxRate
  = lens _bMaxRate (\ s a -> s{_bMaxRate = a}) .
      mapping _Coerce

-- | Defines a target maximum number of simultaneous connections. For usage
-- guidelines, see Connection balancing mode and Utilization balancing
-- mode. Not available if the backend\'s balancingMode is RATE. Not
-- supported by: - Internal TCP\/UDP Load Balancing - Network Load
-- Balancing
bMaxConnections :: Lens' Backend (Maybe Int32)
bMaxConnections
  = lens _bMaxConnections
      (\ s a -> s{_bMaxConnections = a})
      . mapping _Coerce

-- | This field designates whether this is a failover backend. More than one
-- failover backend can be configured for a given BackendService.
bFailover :: Lens' Backend (Maybe Bool)
bFailover
  = lens _bFailover (\ s a -> s{_bFailover = a})

-- | Defines a target maximum number of simultaneous connections. For usage
-- guidelines, see Connection balancing mode and Utilization balancing
-- mode. Not available if the backend\'s balancingMode is RATE. Not
-- supported by: - Internal TCP\/UDP Load Balancing - Network Load
-- Balancing.
bMaxConnectionsPerInstance :: Lens' Backend (Maybe Int32)
bMaxConnectionsPerInstance
  = lens _bMaxConnectionsPerInstance
      (\ s a -> s{_bMaxConnectionsPerInstance = a})
      . mapping _Coerce

-- | Defines a maximum target for requests per second (RPS). For usage
-- guidelines, see Rate balancing mode and Utilization balancing mode. Not
-- available if the backend\'s balancingMode is CONNECTION.
bMaxRatePerEndpoint :: Lens' Backend (Maybe Double)
bMaxRatePerEndpoint
  = lens _bMaxRatePerEndpoint
      (\ s a -> s{_bMaxRatePerEndpoint = a})
      . mapping _Coerce

-- | Defines a target maximum number of simultaneous connections. For usage
-- guidelines, see Connection balancing mode and Utilization balancing
-- mode. Not available if the backend\'s balancingMode is RATE. Not
-- supported by: - Internal TCP\/UDP Load Balancing - Network Load
-- Balancing.
bMaxConnectionsPerEndpoint :: Lens' Backend (Maybe Int32)
bMaxConnectionsPerEndpoint
  = lens _bMaxConnectionsPerEndpoint
      (\ s a -> s{_bMaxConnectionsPerEndpoint = a})
      . mapping _Coerce

-- | Defines a maximum target for requests per second (RPS). For usage
-- guidelines, see Rate balancing mode and Utilization balancing mode. Not
-- available if the backend\'s balancingMode is CONNECTION.
bMaxRatePerInstance :: Lens' Backend (Maybe Double)
bMaxRatePerInstance
  = lens _bMaxRatePerInstance
      (\ s a -> s{_bMaxRatePerInstance = a})
      . mapping _Coerce

-- | An optional description of this resource. Provide this property when you
-- create the resource.
bDescription :: Lens' Backend (Maybe Text)
bDescription
  = lens _bDescription (\ s a -> s{_bDescription = a})

-- | A multiplier applied to the backend\'s target capacity of its balancing
-- mode. The default value is 1, which means the group serves up to 100% of
-- its configured capacity (depending on balancingMode). A setting of 0
-- means the group is completely drained, offering 0% of its available
-- capacity. The valid ranges are 0.0 and [0.1,1.0]. You cannot configure a
-- setting larger than 0 and smaller than 0.1. You cannot configure a
-- setting of 0 when there is only one backend attached to the backend
-- service. Not supported by: - Internal TCP\/UDP Load Balancing - Network
-- Load Balancing
bCapacityScaler :: Lens' Backend (Maybe Double)
bCapacityScaler
  = lens _bCapacityScaler
      (\ s a -> s{_bCapacityScaler = a})
      . mapping _Coerce

instance FromJSON Backend where
        parseJSON
          = withObject "Backend"
              (\ o ->
                 Backend' <$>
                   (o .:? "group") <*> (o .:? "balancingMode") <*>
                     (o .:? "maxUtilization")
                     <*> (o .:? "maxRate")
                     <*> (o .:? "maxConnections")
                     <*> (o .:? "failover")
                     <*> (o .:? "maxConnectionsPerInstance")
                     <*> (o .:? "maxRatePerEndpoint")
                     <*> (o .:? "maxConnectionsPerEndpoint")
                     <*> (o .:? "maxRatePerInstance")
                     <*> (o .:? "description")
                     <*> (o .:? "capacityScaler"))

instance ToJSON Backend where
        toJSON Backend'{..}
          = object
              (catMaybes
                 [("group" .=) <$> _bGroup,
                  ("balancingMode" .=) <$> _bBalancingMode,
                  ("maxUtilization" .=) <$> _bMaxUtilization,
                  ("maxRate" .=) <$> _bMaxRate,
                  ("maxConnections" .=) <$> _bMaxConnections,
                  ("failover" .=) <$> _bFailover,
                  ("maxConnectionsPerInstance" .=) <$>
                    _bMaxConnectionsPerInstance,
                  ("maxRatePerEndpoint" .=) <$> _bMaxRatePerEndpoint,
                  ("maxConnectionsPerEndpoint" .=) <$>
                    _bMaxConnectionsPerEndpoint,
                  ("maxRatePerInstance" .=) <$> _bMaxRatePerInstance,
                  ("description" .=) <$> _bDescription,
                  ("capacityScaler" .=) <$> _bCapacityScaler])

-- | [Output Only] Informational warning which replaces the list of addresses
-- when the list is empty.
--
-- /See:/ 'targetVPNGatewaysScopedListWarning' smart constructor.
data TargetVPNGatewaysScopedListWarning =
  TargetVPNGatewaysScopedListWarning'
    { _tvgslwData :: !(Maybe [TargetVPNGatewaysScopedListWarningDataItem])
    , _tvgslwCode :: !(Maybe TargetVPNGatewaysScopedListWarningCode)
    , _tvgslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetVPNGatewaysScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tvgslwData'
--
-- * 'tvgslwCode'
--
-- * 'tvgslwMessage'
targetVPNGatewaysScopedListWarning
    :: TargetVPNGatewaysScopedListWarning
targetVPNGatewaysScopedListWarning =
  TargetVPNGatewaysScopedListWarning'
    {_tvgslwData = Nothing, _tvgslwCode = Nothing, _tvgslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
tvgslwData :: Lens' TargetVPNGatewaysScopedListWarning [TargetVPNGatewaysScopedListWarningDataItem]
tvgslwData
  = lens _tvgslwData (\ s a -> s{_tvgslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
tvgslwCode :: Lens' TargetVPNGatewaysScopedListWarning (Maybe TargetVPNGatewaysScopedListWarningCode)
tvgslwCode
  = lens _tvgslwCode (\ s a -> s{_tvgslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
tvgslwMessage :: Lens' TargetVPNGatewaysScopedListWarning (Maybe Text)
tvgslwMessage
  = lens _tvgslwMessage
      (\ s a -> s{_tvgslwMessage = a})

instance FromJSON TargetVPNGatewaysScopedListWarning
         where
        parseJSON
          = withObject "TargetVPNGatewaysScopedListWarning"
              (\ o ->
                 TargetVPNGatewaysScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON TargetVPNGatewaysScopedListWarning
         where
        toJSON TargetVPNGatewaysScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _tvgslwData,
                  ("code" .=) <$> _tvgslwCode,
                  ("message" .=) <$> _tvgslwMessage])

-- | Contains a list of addresses.
--
-- /See:/ 'addressList' smart constructor.
data AddressList =
  AddressList'
    { _alNextPageToken :: !(Maybe Text)
    , _alKind :: !Text
    , _alItems :: !(Maybe [Address])
    , _alSelfLink :: !(Maybe Text)
    , _alWarning :: !(Maybe AddressListWarning)
    , _alId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AddressList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'alNextPageToken'
--
-- * 'alKind'
--
-- * 'alItems'
--
-- * 'alSelfLink'
--
-- * 'alWarning'
--
-- * 'alId'
addressList
    :: AddressList
addressList =
  AddressList'
    { _alNextPageToken = Nothing
    , _alKind = "compute#addressList"
    , _alItems = Nothing
    , _alSelfLink = Nothing
    , _alWarning = Nothing
    , _alId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
alNextPageToken :: Lens' AddressList (Maybe Text)
alNextPageToken
  = lens _alNextPageToken
      (\ s a -> s{_alNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#addressList for lists of
-- addresses.
alKind :: Lens' AddressList Text
alKind = lens _alKind (\ s a -> s{_alKind = a})

-- | A list of Address resources.
alItems :: Lens' AddressList [Address]
alItems
  = lens _alItems (\ s a -> s{_alItems = a}) . _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
alSelfLink :: Lens' AddressList (Maybe Text)
alSelfLink
  = lens _alSelfLink (\ s a -> s{_alSelfLink = a})

-- | [Output Only] Informational warning message.
alWarning :: Lens' AddressList (Maybe AddressListWarning)
alWarning
  = lens _alWarning (\ s a -> s{_alWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
alId :: Lens' AddressList (Maybe Text)
alId = lens _alId (\ s a -> s{_alId = a})

instance FromJSON AddressList where
        parseJSON
          = withObject "AddressList"
              (\ o ->
                 AddressList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#addressList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON AddressList where
        toJSON AddressList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _alNextPageToken,
                  Just ("kind" .= _alKind), ("items" .=) <$> _alItems,
                  ("selfLink" .=) <$> _alSelfLink,
                  ("warning" .=) <$> _alWarning, ("id" .=) <$> _alId])

--
-- /See:/ 'targetHTTPSProxiesScopedList' smart constructor.
data TargetHTTPSProxiesScopedList =
  TargetHTTPSProxiesScopedList'
    { _thpslWarning :: !(Maybe TargetHTTPSProxiesScopedListWarning)
    , _thpslTargetHTTPSProxies :: !(Maybe [TargetHTTPSProxy])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetHTTPSProxiesScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'thpslWarning'
--
-- * 'thpslTargetHTTPSProxies'
targetHTTPSProxiesScopedList
    :: TargetHTTPSProxiesScopedList
targetHTTPSProxiesScopedList =
  TargetHTTPSProxiesScopedList'
    {_thpslWarning = Nothing, _thpslTargetHTTPSProxies = Nothing}


-- | Informational warning which replaces the list of backend services when
-- the list is empty.
thpslWarning :: Lens' TargetHTTPSProxiesScopedList (Maybe TargetHTTPSProxiesScopedListWarning)
thpslWarning
  = lens _thpslWarning (\ s a -> s{_thpslWarning = a})

-- | A list of TargetHttpsProxies contained in this scope.
thpslTargetHTTPSProxies :: Lens' TargetHTTPSProxiesScopedList [TargetHTTPSProxy]
thpslTargetHTTPSProxies
  = lens _thpslTargetHTTPSProxies
      (\ s a -> s{_thpslTargetHTTPSProxies = a})
      . _Default
      . _Coerce

instance FromJSON TargetHTTPSProxiesScopedList where
        parseJSON
          = withObject "TargetHTTPSProxiesScopedList"
              (\ o ->
                 TargetHTTPSProxiesScopedList' <$>
                   (o .:? "warning") <*>
                     (o .:? "targetHttpsProxies" .!= mempty))

instance ToJSON TargetHTTPSProxiesScopedList where
        toJSON TargetHTTPSProxiesScopedList'{..}
          = object
              (catMaybes
                 [("warning" .=) <$> _thpslWarning,
                  ("targetHttpsProxies" .=) <$>
                    _thpslTargetHTTPSProxies])

--
-- /See:/ 'targetVPNGatewayListWarningDataItem' smart constructor.
data TargetVPNGatewayListWarningDataItem =
  TargetVPNGatewayListWarningDataItem'
    { _tvglwdiValue :: !(Maybe Text)
    , _tvglwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetVPNGatewayListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tvglwdiValue'
--
-- * 'tvglwdiKey'
targetVPNGatewayListWarningDataItem
    :: TargetVPNGatewayListWarningDataItem
targetVPNGatewayListWarningDataItem =
  TargetVPNGatewayListWarningDataItem'
    {_tvglwdiValue = Nothing, _tvglwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
tvglwdiValue :: Lens' TargetVPNGatewayListWarningDataItem (Maybe Text)
tvglwdiValue
  = lens _tvglwdiValue (\ s a -> s{_tvglwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
tvglwdiKey :: Lens' TargetVPNGatewayListWarningDataItem (Maybe Text)
tvglwdiKey
  = lens _tvglwdiKey (\ s a -> s{_tvglwdiKey = a})

instance FromJSON TargetVPNGatewayListWarningDataItem
         where
        parseJSON
          = withObject "TargetVPNGatewayListWarningDataItem"
              (\ o ->
                 TargetVPNGatewayListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON TargetVPNGatewayListWarningDataItem
         where
        toJSON TargetVPNGatewayListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _tvglwdiValue,
                  ("key" .=) <$> _tvglwdiKey])

-- | A list of ForwardingRulesScopedList resources.
--
-- /See:/ 'forwardingRuleAggregatedListItems' smart constructor.
newtype ForwardingRuleAggregatedListItems =
  ForwardingRuleAggregatedListItems'
    { _fraliAddtional :: HashMap Text ForwardingRulesScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ForwardingRuleAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'fraliAddtional'
forwardingRuleAggregatedListItems
    :: HashMap Text ForwardingRulesScopedList -- ^ 'fraliAddtional'
    -> ForwardingRuleAggregatedListItems
forwardingRuleAggregatedListItems pFraliAddtional_ =
  ForwardingRuleAggregatedListItems'
    {_fraliAddtional = _Coerce # pFraliAddtional_}


-- | Name of the scope containing this set of addresses.
fraliAddtional :: Lens' ForwardingRuleAggregatedListItems (HashMap Text ForwardingRulesScopedList)
fraliAddtional
  = lens _fraliAddtional
      (\ s a -> s{_fraliAddtional = a})
      . _Coerce

instance FromJSON ForwardingRuleAggregatedListItems
         where
        parseJSON
          = withObject "ForwardingRuleAggregatedListItems"
              (\ o ->
                 ForwardingRuleAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON ForwardingRuleAggregatedListItems
         where
        toJSON = toJSON . _fraliAddtional

--
-- /See:/ 'interconnectAttachmentAggregatedList' smart constructor.
data InterconnectAttachmentAggregatedList =
  InterconnectAttachmentAggregatedList'
    { _iaalUnreachables :: !(Maybe [Text])
    , _iaalNextPageToken :: !(Maybe Text)
    , _iaalKind :: !Text
    , _iaalItems :: !(Maybe InterconnectAttachmentAggregatedListItems)
    , _iaalSelfLink :: !(Maybe Text)
    , _iaalWarning :: !(Maybe InterconnectAttachmentAggregatedListWarning)
    , _iaalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectAttachmentAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iaalUnreachables'
--
-- * 'iaalNextPageToken'
--
-- * 'iaalKind'
--
-- * 'iaalItems'
--
-- * 'iaalSelfLink'
--
-- * 'iaalWarning'
--
-- * 'iaalId'
interconnectAttachmentAggregatedList
    :: InterconnectAttachmentAggregatedList
interconnectAttachmentAggregatedList =
  InterconnectAttachmentAggregatedList'
    { _iaalUnreachables = Nothing
    , _iaalNextPageToken = Nothing
    , _iaalKind = "compute#interconnectAttachmentAggregatedList"
    , _iaalItems = Nothing
    , _iaalSelfLink = Nothing
    , _iaalWarning = Nothing
    , _iaalId = Nothing
    }


-- | [Output Only] Unreachable resources.
iaalUnreachables :: Lens' InterconnectAttachmentAggregatedList [Text]
iaalUnreachables
  = lens _iaalUnreachables
      (\ s a -> s{_iaalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
iaalNextPageToken :: Lens' InterconnectAttachmentAggregatedList (Maybe Text)
iaalNextPageToken
  = lens _iaalNextPageToken
      (\ s a -> s{_iaalNextPageToken = a})

-- | [Output Only] Type of resource. Always
-- compute#interconnectAttachmentAggregatedList for aggregated lists of
-- interconnect attachments.
iaalKind :: Lens' InterconnectAttachmentAggregatedList Text
iaalKind = lens _iaalKind (\ s a -> s{_iaalKind = a})

-- | A list of InterconnectAttachmentsScopedList resources.
iaalItems :: Lens' InterconnectAttachmentAggregatedList (Maybe InterconnectAttachmentAggregatedListItems)
iaalItems
  = lens _iaalItems (\ s a -> s{_iaalItems = a})

-- | [Output Only] Server-defined URL for this resource.
iaalSelfLink :: Lens' InterconnectAttachmentAggregatedList (Maybe Text)
iaalSelfLink
  = lens _iaalSelfLink (\ s a -> s{_iaalSelfLink = a})

-- | [Output Only] Informational warning message.
iaalWarning :: Lens' InterconnectAttachmentAggregatedList (Maybe InterconnectAttachmentAggregatedListWarning)
iaalWarning
  = lens _iaalWarning (\ s a -> s{_iaalWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
iaalId :: Lens' InterconnectAttachmentAggregatedList (Maybe Text)
iaalId = lens _iaalId (\ s a -> s{_iaalId = a})

instance FromJSON
           InterconnectAttachmentAggregatedList
         where
        parseJSON
          = withObject "InterconnectAttachmentAggregatedList"
              (\ o ->
                 InterconnectAttachmentAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!=
                        "compute#interconnectAttachmentAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON InterconnectAttachmentAggregatedList
         where
        toJSON InterconnectAttachmentAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _iaalUnreachables,
                  ("nextPageToken" .=) <$> _iaalNextPageToken,
                  Just ("kind" .= _iaalKind),
                  ("items" .=) <$> _iaalItems,
                  ("selfLink" .=) <$> _iaalSelfLink,
                  ("warning" .=) <$> _iaalWarning,
                  ("id" .=) <$> _iaalId])

--
-- /See:/ 'firewallPolicyList' smart constructor.
data FirewallPolicyList =
  FirewallPolicyList'
    { _fplNextPageToken :: !(Maybe Text)
    , _fplKind :: !Text
    , _fplItems :: !(Maybe [FirewallPolicy])
    , _fplWarning :: !(Maybe FirewallPolicyListWarning)
    , _fplId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'FirewallPolicyList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'fplNextPageToken'
--
-- * 'fplKind'
--
-- * 'fplItems'
--
-- * 'fplWarning'
--
-- * 'fplId'
firewallPolicyList
    :: FirewallPolicyList
firewallPolicyList =
  FirewallPolicyList'
    { _fplNextPageToken = Nothing
    , _fplKind = "compute#firewallPolicyList"
    , _fplItems = Nothing
    , _fplWarning = Nothing
    , _fplId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
fplNextPageToken :: Lens' FirewallPolicyList (Maybe Text)
fplNextPageToken
  = lens _fplNextPageToken
      (\ s a -> s{_fplNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#firewallPolicyList for
-- listsof FirewallPolicies
fplKind :: Lens' FirewallPolicyList Text
fplKind = lens _fplKind (\ s a -> s{_fplKind = a})

-- | A list of FirewallPolicy resources.
fplItems :: Lens' FirewallPolicyList [FirewallPolicy]
fplItems
  = lens _fplItems (\ s a -> s{_fplItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Informational warning message.
fplWarning :: Lens' FirewallPolicyList (Maybe FirewallPolicyListWarning)
fplWarning
  = lens _fplWarning (\ s a -> s{_fplWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
fplId :: Lens' FirewallPolicyList (Maybe Text)
fplId = lens _fplId (\ s a -> s{_fplId = a})

instance FromJSON FirewallPolicyList where
        parseJSON
          = withObject "FirewallPolicyList"
              (\ o ->
                 FirewallPolicyList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#firewallPolicyList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON FirewallPolicyList where
        toJSON FirewallPolicyList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _fplNextPageToken,
                  Just ("kind" .= _fplKind),
                  ("items" .=) <$> _fplItems,
                  ("warning" .=) <$> _fplWarning,
                  ("id" .=) <$> _fplId])

--
-- /See:/ 'scalingScheduleStatus' smart constructor.
data ScalingScheduleStatus =
  ScalingScheduleStatus'
    { _sssState :: !(Maybe ScalingScheduleStatusState)
    , _sssLastStartTime :: !(Maybe Text)
    , _sssNextStartTime :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ScalingScheduleStatus' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sssState'
--
-- * 'sssLastStartTime'
--
-- * 'sssNextStartTime'
scalingScheduleStatus
    :: ScalingScheduleStatus
scalingScheduleStatus =
  ScalingScheduleStatus'
    { _sssState = Nothing
    , _sssLastStartTime = Nothing
    , _sssNextStartTime = Nothing
    }


-- | [Output Only] The current state of a scaling schedule.
sssState :: Lens' ScalingScheduleStatus (Maybe ScalingScheduleStatusState)
sssState = lens _sssState (\ s a -> s{_sssState = a})

-- | [Output Only] The last time the scaling schedule became active. Note:
-- this is a timestamp when a schedule actually became active, not when it
-- was planned to do so. The timestamp is in RFC3339 text format.
sssLastStartTime :: Lens' ScalingScheduleStatus (Maybe Text)
sssLastStartTime
  = lens _sssLastStartTime
      (\ s a -> s{_sssLastStartTime = a})

-- | [Output Only] The next time the scaling schedule is to become active.
-- Note: this is a timestamp when a schedule is planned to run, but the
-- actual time might be slightly different. The timestamp is in RFC3339
-- text format.
sssNextStartTime :: Lens' ScalingScheduleStatus (Maybe Text)
sssNextStartTime
  = lens _sssNextStartTime
      (\ s a -> s{_sssNextStartTime = a})

instance FromJSON ScalingScheduleStatus where
        parseJSON
          = withObject "ScalingScheduleStatus"
              (\ o ->
                 ScalingScheduleStatus' <$>
                   (o .:? "state") <*> (o .:? "lastStartTime") <*>
                     (o .:? "nextStartTime"))

instance ToJSON ScalingScheduleStatus where
        toJSON ScalingScheduleStatus'{..}
          = object
              (catMaybes
                 [("state" .=) <$> _sssState,
                  ("lastStartTime" .=) <$> _sssLastStartTime,
                  ("nextStartTime" .=) <$> _sssNextStartTime])

-- | [Output Only] A map of scoped operation lists.
--
-- /See:/ 'operationAggregatedListItems' smart constructor.
newtype OperationAggregatedListItems =
  OperationAggregatedListItems'
    { _oaliAddtional :: HashMap Text OperationsScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'OperationAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'oaliAddtional'
operationAggregatedListItems
    :: HashMap Text OperationsScopedList -- ^ 'oaliAddtional'
    -> OperationAggregatedListItems
operationAggregatedListItems pOaliAddtional_ =
  OperationAggregatedListItems' {_oaliAddtional = _Coerce # pOaliAddtional_}


-- | [Output Only] Name of the scope containing this set of operations.
oaliAddtional :: Lens' OperationAggregatedListItems (HashMap Text OperationsScopedList)
oaliAddtional
  = lens _oaliAddtional
      (\ s a -> s{_oaliAddtional = a})
      . _Coerce

instance FromJSON OperationAggregatedListItems where
        parseJSON
          = withObject "OperationAggregatedListItems"
              (\ o ->
                 OperationAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON OperationAggregatedListItems where
        toJSON = toJSON . _oaliAddtional

--
-- /See:/ 'instanceGroupManagerActionsSummary' smart constructor.
data InstanceGroupManagerActionsSummary =
  InstanceGroupManagerActionsSummary'
    { _igmasDeleting :: !(Maybe (Textual Int32))
    , _igmasRestarting :: !(Maybe (Textual Int32))
    , _igmasNone :: !(Maybe (Textual Int32))
    , _igmasCreating :: !(Maybe (Textual Int32))
    , _igmasVerifying :: !(Maybe (Textual Int32))
    , _igmasRefreshing :: !(Maybe (Textual Int32))
    , _igmasCreatingWithoutRetries :: !(Maybe (Textual Int32))
    , _igmasRecreating :: !(Maybe (Textual Int32))
    , _igmasAbandoning :: !(Maybe (Textual Int32))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagerActionsSummary' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmasDeleting'
--
-- * 'igmasRestarting'
--
-- * 'igmasNone'
--
-- * 'igmasCreating'
--
-- * 'igmasVerifying'
--
-- * 'igmasRefreshing'
--
-- * 'igmasCreatingWithoutRetries'
--
-- * 'igmasRecreating'
--
-- * 'igmasAbandoning'
instanceGroupManagerActionsSummary
    :: InstanceGroupManagerActionsSummary
instanceGroupManagerActionsSummary =
  InstanceGroupManagerActionsSummary'
    { _igmasDeleting = Nothing
    , _igmasRestarting = Nothing
    , _igmasNone = Nothing
    , _igmasCreating = Nothing
    , _igmasVerifying = Nothing
    , _igmasRefreshing = Nothing
    , _igmasCreatingWithoutRetries = Nothing
    , _igmasRecreating = Nothing
    , _igmasAbandoning = Nothing
    }


-- | [Output Only] The number of instances in the managed instance group that
-- are scheduled to be deleted or are currently being deleted.
igmasDeleting :: Lens' InstanceGroupManagerActionsSummary (Maybe Int32)
igmasDeleting
  = lens _igmasDeleting
      (\ s a -> s{_igmasDeleting = a})
      . mapping _Coerce

-- | [Output Only] The number of instances in the managed instance group that
-- are scheduled to be restarted or are currently being restarted.
igmasRestarting :: Lens' InstanceGroupManagerActionsSummary (Maybe Int32)
igmasRestarting
  = lens _igmasRestarting
      (\ s a -> s{_igmasRestarting = a})
      . mapping _Coerce

-- | [Output Only] The number of instances in the managed instance group that
-- are running and have no scheduled actions.
igmasNone :: Lens' InstanceGroupManagerActionsSummary (Maybe Int32)
igmasNone
  = lens _igmasNone (\ s a -> s{_igmasNone = a}) .
      mapping _Coerce

-- | [Output Only] The number of instances in the managed instance group that
-- are scheduled to be created or are currently being created. If the group
-- fails to create any of these instances, it tries again until it creates
-- the instance successfully. If you have disabled creation retries, this
-- field will not be populated; instead, the creatingWithoutRetries field
-- will be populated.
igmasCreating :: Lens' InstanceGroupManagerActionsSummary (Maybe Int32)
igmasCreating
  = lens _igmasCreating
      (\ s a -> s{_igmasCreating = a})
      . mapping _Coerce

-- | [Output Only] The number of instances in the managed instance group that
-- are being verified. See the managedInstances[].currentAction property in
-- the listManagedInstances method documentation.
igmasVerifying :: Lens' InstanceGroupManagerActionsSummary (Maybe Int32)
igmasVerifying
  = lens _igmasVerifying
      (\ s a -> s{_igmasVerifying = a})
      . mapping _Coerce

-- | [Output Only] The number of instances in the managed instance group that
-- are being reconfigured with properties that do not require a restart or
-- a recreate action. For example, setting or removing target pools for the
-- instance.
igmasRefreshing :: Lens' InstanceGroupManagerActionsSummary (Maybe Int32)
igmasRefreshing
  = lens _igmasRefreshing
      (\ s a -> s{_igmasRefreshing = a})
      . mapping _Coerce

-- | [Output Only] The number of instances that the managed instance group
-- will attempt to create. The group attempts to create each instance only
-- once. If the group fails to create any of these instances, it decreases
-- the group\'s targetSize value accordingly.
igmasCreatingWithoutRetries :: Lens' InstanceGroupManagerActionsSummary (Maybe Int32)
igmasCreatingWithoutRetries
  = lens _igmasCreatingWithoutRetries
      (\ s a -> s{_igmasCreatingWithoutRetries = a})
      . mapping _Coerce

-- | [Output Only] The number of instances in the managed instance group that
-- are scheduled to be recreated or are currently being being recreated.
-- Recreating an instance deletes the existing root persistent disk and
-- creates a new disk from the image that is defined in the instance
-- template.
igmasRecreating :: Lens' InstanceGroupManagerActionsSummary (Maybe Int32)
igmasRecreating
  = lens _igmasRecreating
      (\ s a -> s{_igmasRecreating = a})
      . mapping _Coerce

-- | [Output Only] The total number of instances in the managed instance
-- group that are scheduled to be abandoned. Abandoning an instance removes
-- it from the managed instance group without deleting it.
igmasAbandoning :: Lens' InstanceGroupManagerActionsSummary (Maybe Int32)
igmasAbandoning
  = lens _igmasAbandoning
      (\ s a -> s{_igmasAbandoning = a})
      . mapping _Coerce

instance FromJSON InstanceGroupManagerActionsSummary
         where
        parseJSON
          = withObject "InstanceGroupManagerActionsSummary"
              (\ o ->
                 InstanceGroupManagerActionsSummary' <$>
                   (o .:? "deleting") <*> (o .:? "restarting") <*>
                     (o .:? "none")
                     <*> (o .:? "creating")
                     <*> (o .:? "verifying")
                     <*> (o .:? "refreshing")
                     <*> (o .:? "creatingWithoutRetries")
                     <*> (o .:? "recreating")
                     <*> (o .:? "abandoning"))

instance ToJSON InstanceGroupManagerActionsSummary
         where
        toJSON InstanceGroupManagerActionsSummary'{..}
          = object
              (catMaybes
                 [("deleting" .=) <$> _igmasDeleting,
                  ("restarting" .=) <$> _igmasRestarting,
                  ("none" .=) <$> _igmasNone,
                  ("creating" .=) <$> _igmasCreating,
                  ("verifying" .=) <$> _igmasVerifying,
                  ("refreshing" .=) <$> _igmasRefreshing,
                  ("creatingWithoutRetries" .=) <$>
                    _igmasCreatingWithoutRetries,
                  ("recreating" .=) <$> _igmasRecreating,
                  ("abandoning" .=) <$> _igmasAbandoning])

--
-- /See:/ 'xpnHostList' smart constructor.
data XpnHostList =
  XpnHostList'
    { _xhlNextPageToken :: !(Maybe Text)
    , _xhlKind :: !Text
    , _xhlItems :: !(Maybe [Project])
    , _xhlSelfLink :: !(Maybe Text)
    , _xhlWarning :: !(Maybe XpnHostListWarning)
    , _xhlId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'XpnHostList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'xhlNextPageToken'
--
-- * 'xhlKind'
--
-- * 'xhlItems'
--
-- * 'xhlSelfLink'
--
-- * 'xhlWarning'
--
-- * 'xhlId'
xpnHostList
    :: XpnHostList
xpnHostList =
  XpnHostList'
    { _xhlNextPageToken = Nothing
    , _xhlKind = "compute#xpnHostList"
    , _xhlItems = Nothing
    , _xhlSelfLink = Nothing
    , _xhlWarning = Nothing
    , _xhlId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
xhlNextPageToken :: Lens' XpnHostList (Maybe Text)
xhlNextPageToken
  = lens _xhlNextPageToken
      (\ s a -> s{_xhlNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#xpnHostList for lists of
-- shared VPC hosts.
xhlKind :: Lens' XpnHostList Text
xhlKind = lens _xhlKind (\ s a -> s{_xhlKind = a})

-- | [Output Only] A list of shared VPC host project URLs.
xhlItems :: Lens' XpnHostList [Project]
xhlItems
  = lens _xhlItems (\ s a -> s{_xhlItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
xhlSelfLink :: Lens' XpnHostList (Maybe Text)
xhlSelfLink
  = lens _xhlSelfLink (\ s a -> s{_xhlSelfLink = a})

-- | [Output Only] Informational warning message.
xhlWarning :: Lens' XpnHostList (Maybe XpnHostListWarning)
xhlWarning
  = lens _xhlWarning (\ s a -> s{_xhlWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
xhlId :: Lens' XpnHostList (Maybe Text)
xhlId = lens _xhlId (\ s a -> s{_xhlId = a})

instance FromJSON XpnHostList where
        parseJSON
          = withObject "XpnHostList"
              (\ o ->
                 XpnHostList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#xpnHostList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON XpnHostList where
        toJSON XpnHostList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _xhlNextPageToken,
                  Just ("kind" .= _xhlKind),
                  ("items" .=) <$> _xhlItems,
                  ("selfLink" .=) <$> _xhlSelfLink,
                  ("warning" .=) <$> _xhlWarning,
                  ("id" .=) <$> _xhlId])

--
-- /See:/ 'instanceManagedByIgmError' smart constructor.
data InstanceManagedByIgmError =
  InstanceManagedByIgmError'
    { _imbieInstanceActionDetails :: !(Maybe InstanceManagedByIgmErrorInstanceActionDetails)
    , _imbieError :: !(Maybe InstanceManagedByIgmErrorManagedInstanceError)
    , _imbieTimestamp :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceManagedByIgmError' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'imbieInstanceActionDetails'
--
-- * 'imbieError'
--
-- * 'imbieTimestamp'
instanceManagedByIgmError
    :: InstanceManagedByIgmError
instanceManagedByIgmError =
  InstanceManagedByIgmError'
    { _imbieInstanceActionDetails = Nothing
    , _imbieError = Nothing
    , _imbieTimestamp = Nothing
    }


-- | [Output Only] Details of the instance action that triggered this error.
-- May be null, if the error was not caused by an action on an instance.
-- This field is optional.
imbieInstanceActionDetails :: Lens' InstanceManagedByIgmError (Maybe InstanceManagedByIgmErrorInstanceActionDetails)
imbieInstanceActionDetails
  = lens _imbieInstanceActionDetails
      (\ s a -> s{_imbieInstanceActionDetails = a})

-- | [Output Only] Contents of the error.
imbieError :: Lens' InstanceManagedByIgmError (Maybe InstanceManagedByIgmErrorManagedInstanceError)
imbieError
  = lens _imbieError (\ s a -> s{_imbieError = a})

-- | [Output Only] The time that this error occurred. This value is in
-- RFC3339 text format.
imbieTimestamp :: Lens' InstanceManagedByIgmError (Maybe Text)
imbieTimestamp
  = lens _imbieTimestamp
      (\ s a -> s{_imbieTimestamp = a})

instance FromJSON InstanceManagedByIgmError where
        parseJSON
          = withObject "InstanceManagedByIgmError"
              (\ o ->
                 InstanceManagedByIgmError' <$>
                   (o .:? "instanceActionDetails") <*> (o .:? "error")
                     <*> (o .:? "timestamp"))

instance ToJSON InstanceManagedByIgmError where
        toJSON InstanceManagedByIgmError'{..}
          = object
              (catMaybes
                 [("instanceActionDetails" .=) <$>
                    _imbieInstanceActionDetails,
                  ("error" .=) <$> _imbieError,
                  ("timestamp" .=) <$> _imbieTimestamp])

--
-- /See:/ 'instanceTemplateListWarningDataItem' smart constructor.
data InstanceTemplateListWarningDataItem =
  InstanceTemplateListWarningDataItem'
    { _itlwdiValue :: !(Maybe Text)
    , _itlwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceTemplateListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'itlwdiValue'
--
-- * 'itlwdiKey'
instanceTemplateListWarningDataItem
    :: InstanceTemplateListWarningDataItem
instanceTemplateListWarningDataItem =
  InstanceTemplateListWarningDataItem'
    {_itlwdiValue = Nothing, _itlwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
itlwdiValue :: Lens' InstanceTemplateListWarningDataItem (Maybe Text)
itlwdiValue
  = lens _itlwdiValue (\ s a -> s{_itlwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
itlwdiKey :: Lens' InstanceTemplateListWarningDataItem (Maybe Text)
itlwdiKey
  = lens _itlwdiKey (\ s a -> s{_itlwdiKey = a})

instance FromJSON InstanceTemplateListWarningDataItem
         where
        parseJSON
          = withObject "InstanceTemplateListWarningDataItem"
              (\ o ->
                 InstanceTemplateListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON InstanceTemplateListWarningDataItem
         where
        toJSON InstanceTemplateListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _itlwdiValue,
                  ("key" .=) <$> _itlwdiKey])

-- | A service account.
--
-- /See:/ 'serviceAccount' smart constructor.
data ServiceAccount =
  ServiceAccount'
    { _saEmail :: !(Maybe Text)
    , _saScopes :: !(Maybe [Text])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ServiceAccount' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'saEmail'
--
-- * 'saScopes'
serviceAccount
    :: ServiceAccount
serviceAccount = ServiceAccount' {_saEmail = Nothing, _saScopes = Nothing}


-- | Email address of the service account.
saEmail :: Lens' ServiceAccount (Maybe Text)
saEmail = lens _saEmail (\ s a -> s{_saEmail = a})

-- | The list of scopes to be made available for this service account.
saScopes :: Lens' ServiceAccount [Text]
saScopes
  = lens _saScopes (\ s a -> s{_saScopes = a}) .
      _Default
      . _Coerce

instance FromJSON ServiceAccount where
        parseJSON
          = withObject "ServiceAccount"
              (\ o ->
                 ServiceAccount' <$>
                   (o .:? "email") <*> (o .:? "scopes" .!= mempty))

instance ToJSON ServiceAccount where
        toJSON ServiceAccount'{..}
          = object
              (catMaybes
                 [("email" .=) <$> _saEmail,
                  ("scopes" .=) <$> _saScopes])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'snapshotListWarning' smart constructor.
data SnapshotListWarning =
  SnapshotListWarning'
    { _sData :: !(Maybe [SnapshotListWarningDataItem])
    , _sCode :: !(Maybe SnapshotListWarningCode)
    , _sMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SnapshotListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sData'
--
-- * 'sCode'
--
-- * 'sMessage'
snapshotListWarning
    :: SnapshotListWarning
snapshotListWarning =
  SnapshotListWarning' {_sData = Nothing, _sCode = Nothing, _sMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
sData :: Lens' SnapshotListWarning [SnapshotListWarningDataItem]
sData
  = lens _sData (\ s a -> s{_sData = a}) . _Default .
      _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
sCode :: Lens' SnapshotListWarning (Maybe SnapshotListWarningCode)
sCode = lens _sCode (\ s a -> s{_sCode = a})

-- | [Output Only] A human-readable description of the warning code.
sMessage :: Lens' SnapshotListWarning (Maybe Text)
sMessage = lens _sMessage (\ s a -> s{_sMessage = a})

instance FromJSON SnapshotListWarning where
        parseJSON
          = withObject "SnapshotListWarning"
              (\ o ->
                 SnapshotListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON SnapshotListWarning where
        toJSON SnapshotListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _sData, ("code" .=) <$> _sCode,
                  ("message" .=) <$> _sMessage])

--
-- /See:/ 'regionInstanceGroupManagersAbandonInstancesRequest' smart constructor.
newtype RegionInstanceGroupManagersAbandonInstancesRequest =
  RegionInstanceGroupManagersAbandonInstancesRequest'
    { _rigmairInstances :: Maybe [Text]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupManagersAbandonInstancesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rigmairInstances'
regionInstanceGroupManagersAbandonInstancesRequest
    :: RegionInstanceGroupManagersAbandonInstancesRequest
regionInstanceGroupManagersAbandonInstancesRequest =
  RegionInstanceGroupManagersAbandonInstancesRequest'
    {_rigmairInstances = Nothing}


-- | The URLs of one or more instances to abandon. This can be a full URL or
-- a partial URL, such as zones\/[ZONE]\/instances\/[INSTANCE_NAME].
rigmairInstances :: Lens' RegionInstanceGroupManagersAbandonInstancesRequest [Text]
rigmairInstances
  = lens _rigmairInstances
      (\ s a -> s{_rigmairInstances = a})
      . _Default
      . _Coerce

instance FromJSON
           RegionInstanceGroupManagersAbandonInstancesRequest
         where
        parseJSON
          = withObject
              "RegionInstanceGroupManagersAbandonInstancesRequest"
              (\ o ->
                 RegionInstanceGroupManagersAbandonInstancesRequest'
                   <$> (o .:? "instances" .!= mempty))

instance ToJSON
           RegionInstanceGroupManagersAbandonInstancesRequest
         where
        toJSON
          RegionInstanceGroupManagersAbandonInstancesRequest'{..}
          = object
              (catMaybes [("instances" .=) <$> _rigmairInstances])

-- | Contains a list of networks.
--
-- /See:/ 'networkList' smart constructor.
data NetworkList =
  NetworkList'
    { _nlNextPageToken :: !(Maybe Text)
    , _nlKind :: !Text
    , _nlItems :: !(Maybe [Network])
    , _nlSelfLink :: !(Maybe Text)
    , _nlWarning :: !(Maybe NetworkListWarning)
    , _nlId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nlNextPageToken'
--
-- * 'nlKind'
--
-- * 'nlItems'
--
-- * 'nlSelfLink'
--
-- * 'nlWarning'
--
-- * 'nlId'
networkList
    :: NetworkList
networkList =
  NetworkList'
    { _nlNextPageToken = Nothing
    , _nlKind = "compute#networkList"
    , _nlItems = Nothing
    , _nlSelfLink = Nothing
    , _nlWarning = Nothing
    , _nlId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
nlNextPageToken :: Lens' NetworkList (Maybe Text)
nlNextPageToken
  = lens _nlNextPageToken
      (\ s a -> s{_nlNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#networkList for lists of
-- networks.
nlKind :: Lens' NetworkList Text
nlKind = lens _nlKind (\ s a -> s{_nlKind = a})

-- | A list of Network resources.
nlItems :: Lens' NetworkList [Network]
nlItems
  = lens _nlItems (\ s a -> s{_nlItems = a}) . _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
nlSelfLink :: Lens' NetworkList (Maybe Text)
nlSelfLink
  = lens _nlSelfLink (\ s a -> s{_nlSelfLink = a})

-- | [Output Only] Informational warning message.
nlWarning :: Lens' NetworkList (Maybe NetworkListWarning)
nlWarning
  = lens _nlWarning (\ s a -> s{_nlWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
nlId :: Lens' NetworkList (Maybe Text)
nlId = lens _nlId (\ s a -> s{_nlId = a})

instance FromJSON NetworkList where
        parseJSON
          = withObject "NetworkList"
              (\ o ->
                 NetworkList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#networkList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON NetworkList where
        toJSON NetworkList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _nlNextPageToken,
                  Just ("kind" .= _nlKind), ("items" .=) <$> _nlItems,
                  ("selfLink" .=) <$> _nlSelfLink,
                  ("warning" .=) <$> _nlWarning, ("id" .=) <$> _nlId])

-- | A network peering attached to a network resource. The message includes
-- the peering name, peer network, peering state, and a flag indicating
-- whether Google Compute Engine should automatically create routes for the
-- peering.
--
-- /See:/ 'networkPeering' smart constructor.
data NetworkPeering =
  NetworkPeering'
    { _netState :: !(Maybe NetworkPeeringState)
    , _netExchangeSubnetRoutes :: !(Maybe Bool)
    , _netExportCustomRoutes :: !(Maybe Bool)
    , _netStateDetails :: !(Maybe Text)
    , _netNetwork :: !(Maybe Text)
    , _netImportCustomRoutes :: !(Maybe Bool)
    , _netName :: !(Maybe Text)
    , _netExportSubnetRoutesWithPublicIP :: !(Maybe Bool)
    , _netImportSubnetRoutesWithPublicIP :: !(Maybe Bool)
    , _netPeerMtu :: !(Maybe (Textual Int32))
    , _netAutoCreateRoutes :: !(Maybe Bool)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkPeering' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'netState'
--
-- * 'netExchangeSubnetRoutes'
--
-- * 'netExportCustomRoutes'
--
-- * 'netStateDetails'
--
-- * 'netNetwork'
--
-- * 'netImportCustomRoutes'
--
-- * 'netName'
--
-- * 'netExportSubnetRoutesWithPublicIP'
--
-- * 'netImportSubnetRoutesWithPublicIP'
--
-- * 'netPeerMtu'
--
-- * 'netAutoCreateRoutes'
networkPeering
    :: NetworkPeering
networkPeering =
  NetworkPeering'
    { _netState = Nothing
    , _netExchangeSubnetRoutes = Nothing
    , _netExportCustomRoutes = Nothing
    , _netStateDetails = Nothing
    , _netNetwork = Nothing
    , _netImportCustomRoutes = Nothing
    , _netName = Nothing
    , _netExportSubnetRoutesWithPublicIP = Nothing
    , _netImportSubnetRoutesWithPublicIP = Nothing
    , _netPeerMtu = Nothing
    , _netAutoCreateRoutes = Nothing
    }


-- | [Output Only] State for the peering, either \`ACTIVE\` or \`INACTIVE\`.
-- The peering is \`ACTIVE\` when there\'s a matching configuration in the
-- peer network.
netState :: Lens' NetworkPeering (Maybe NetworkPeeringState)
netState = lens _netState (\ s a -> s{_netState = a})

-- | Indicates whether full mesh connectivity is created and managed
-- automatically between peered networks. Currently this field should
-- always be true since Google Compute Engine will automatically create and
-- manage subnetwork routes between two networks when peering state is
-- ACTIVE.
netExchangeSubnetRoutes :: Lens' NetworkPeering (Maybe Bool)
netExchangeSubnetRoutes
  = lens _netExchangeSubnetRoutes
      (\ s a -> s{_netExchangeSubnetRoutes = a})

-- | Whether to export the custom routes to peer network.
netExportCustomRoutes :: Lens' NetworkPeering (Maybe Bool)
netExportCustomRoutes
  = lens _netExportCustomRoutes
      (\ s a -> s{_netExportCustomRoutes = a})

-- | [Output Only] Details about the current state of the peering.
netStateDetails :: Lens' NetworkPeering (Maybe Text)
netStateDetails
  = lens _netStateDetails
      (\ s a -> s{_netStateDetails = a})

-- | The URL of the peer network. It can be either full URL or partial URL.
-- The peer network may belong to a different project. If the partial URL
-- does not contain project, it is assumed that the peer network is in the
-- same project as the current network.
netNetwork :: Lens' NetworkPeering (Maybe Text)
netNetwork
  = lens _netNetwork (\ s a -> s{_netNetwork = a})

-- | Whether to import the custom routes from peer network.
netImportCustomRoutes :: Lens' NetworkPeering (Maybe Bool)
netImportCustomRoutes
  = lens _netImportCustomRoutes
      (\ s a -> s{_netImportCustomRoutes = a})

-- | Name of this peering. Provided by the client when the peering is
-- created. The name must comply with RFC1035. Specifically, the name must
-- be 1-63 characters long and match regular expression
-- \`[a-z]([-a-z0-9]*[a-z0-9])?\`. The first character must be a lowercase
-- letter, and all the following characters must be a dash, lowercase
-- letter, or digit, except the last character, which cannot be a dash.
netName :: Lens' NetworkPeering (Maybe Text)
netName = lens _netName (\ s a -> s{_netName = a})

-- | Whether subnet routes with public IP range are exported. The default
-- value is true, all subnet routes are exported. The IPv4 special-use
-- ranges (https:\/\/en.wikipedia.org\/wiki\/IPv4#Special_addresses) are
-- always exported to peers and are not controlled by this field.
netExportSubnetRoutesWithPublicIP :: Lens' NetworkPeering (Maybe Bool)
netExportSubnetRoutesWithPublicIP
  = lens _netExportSubnetRoutesWithPublicIP
      (\ s a -> s{_netExportSubnetRoutesWithPublicIP = a})

-- | Whether subnet routes with public IP range are imported. The default
-- value is false. The IPv4 special-use ranges
-- (https:\/\/en.wikipedia.org\/wiki\/IPv4#Special_addresses) are always
-- imported from peers and are not controlled by this field.
netImportSubnetRoutesWithPublicIP :: Lens' NetworkPeering (Maybe Bool)
netImportSubnetRoutesWithPublicIP
  = lens _netImportSubnetRoutesWithPublicIP
      (\ s a -> s{_netImportSubnetRoutesWithPublicIP = a})

-- | Maximum Transmission Unit in bytes.
netPeerMtu :: Lens' NetworkPeering (Maybe Int32)
netPeerMtu
  = lens _netPeerMtu (\ s a -> s{_netPeerMtu = a}) .
      mapping _Coerce

-- | This field will be deprecated soon. Use the exchange_subnet_routes field
-- instead. Indicates whether full mesh connectivity is created and managed
-- automatically between peered networks. Currently this field should
-- always be true since Google Compute Engine will automatically create and
-- manage subnetwork routes between two networks when peering state is
-- ACTIVE.
netAutoCreateRoutes :: Lens' NetworkPeering (Maybe Bool)
netAutoCreateRoutes
  = lens _netAutoCreateRoutes
      (\ s a -> s{_netAutoCreateRoutes = a})

instance FromJSON NetworkPeering where
        parseJSON
          = withObject "NetworkPeering"
              (\ o ->
                 NetworkPeering' <$>
                   (o .:? "state") <*> (o .:? "exchangeSubnetRoutes")
                     <*> (o .:? "exportCustomRoutes")
                     <*> (o .:? "stateDetails")
                     <*> (o .:? "network")
                     <*> (o .:? "importCustomRoutes")
                     <*> (o .:? "name")
                     <*> (o .:? "exportSubnetRoutesWithPublicIp")
                     <*> (o .:? "importSubnetRoutesWithPublicIp")
                     <*> (o .:? "peerMtu")
                     <*> (o .:? "autoCreateRoutes"))

instance ToJSON NetworkPeering where
        toJSON NetworkPeering'{..}
          = object
              (catMaybes
                 [("state" .=) <$> _netState,
                  ("exchangeSubnetRoutes" .=) <$>
                    _netExchangeSubnetRoutes,
                  ("exportCustomRoutes" .=) <$> _netExportCustomRoutes,
                  ("stateDetails" .=) <$> _netStateDetails,
                  ("network" .=) <$> _netNetwork,
                  ("importCustomRoutes" .=) <$> _netImportCustomRoutes,
                  ("name" .=) <$> _netName,
                  ("exportSubnetRoutesWithPublicIp" .=) <$>
                    _netExportSubnetRoutesWithPublicIP,
                  ("importSubnetRoutesWithPublicIp" .=) <$>
                    _netImportSubnetRoutesWithPublicIP,
                  ("peerMtu" .=) <$> _netPeerMtu,
                  ("autoCreateRoutes" .=) <$> _netAutoCreateRoutes])

--
-- /See:/ 'targetSSLProxyListWarningDataItem' smart constructor.
data TargetSSLProxyListWarningDataItem =
  TargetSSLProxyListWarningDataItem'
    { _tsplwdiValue :: !(Maybe Text)
    , _tsplwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetSSLProxyListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tsplwdiValue'
--
-- * 'tsplwdiKey'
targetSSLProxyListWarningDataItem
    :: TargetSSLProxyListWarningDataItem
targetSSLProxyListWarningDataItem =
  TargetSSLProxyListWarningDataItem'
    {_tsplwdiValue = Nothing, _tsplwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
tsplwdiValue :: Lens' TargetSSLProxyListWarningDataItem (Maybe Text)
tsplwdiValue
  = lens _tsplwdiValue (\ s a -> s{_tsplwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
tsplwdiKey :: Lens' TargetSSLProxyListWarningDataItem (Maybe Text)
tsplwdiKey
  = lens _tsplwdiKey (\ s a -> s{_tsplwdiKey = a})

instance FromJSON TargetSSLProxyListWarningDataItem
         where
        parseJSON
          = withObject "TargetSSLProxyListWarningDataItem"
              (\ o ->
                 TargetSSLProxyListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON TargetSSLProxyListWarningDataItem
         where
        toJSON TargetSSLProxyListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _tsplwdiValue,
                  ("key" .=) <$> _tsplwdiKey])

--
-- /See:/ 'instanceGroupsListInstancesRequest' smart constructor.
newtype InstanceGroupsListInstancesRequest =
  InstanceGroupsListInstancesRequest'
    { _iglirInstanceState :: Maybe InstanceGroupsListInstancesRequestInstanceState
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupsListInstancesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iglirInstanceState'
instanceGroupsListInstancesRequest
    :: InstanceGroupsListInstancesRequest
instanceGroupsListInstancesRequest =
  InstanceGroupsListInstancesRequest' {_iglirInstanceState = Nothing}


-- | A filter for the state of the instances in the instance group. Valid
-- options are ALL or RUNNING. If you do not specify this parameter the
-- list includes all instances regardless of their state.
iglirInstanceState :: Lens' InstanceGroupsListInstancesRequest (Maybe InstanceGroupsListInstancesRequestInstanceState)
iglirInstanceState
  = lens _iglirInstanceState
      (\ s a -> s{_iglirInstanceState = a})

instance FromJSON InstanceGroupsListInstancesRequest
         where
        parseJSON
          = withObject "InstanceGroupsListInstancesRequest"
              (\ o ->
                 InstanceGroupsListInstancesRequest' <$>
                   (o .:? "instanceState"))

instance ToJSON InstanceGroupsListInstancesRequest
         where
        toJSON InstanceGroupsListInstancesRequest'{..}
          = object
              (catMaybes
                 [("instanceState" .=) <$> _iglirInstanceState])

--
-- /See:/ 'machineTypeAcceleratorsItem' smart constructor.
data MachineTypeAcceleratorsItem =
  MachineTypeAcceleratorsItem'
    { _mtaiGuestAcceleratorCount :: !(Maybe (Textual Int32))
    , _mtaiGuestAcceleratorType :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'MachineTypeAcceleratorsItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'mtaiGuestAcceleratorCount'
--
-- * 'mtaiGuestAcceleratorType'
machineTypeAcceleratorsItem
    :: MachineTypeAcceleratorsItem
machineTypeAcceleratorsItem =
  MachineTypeAcceleratorsItem'
    {_mtaiGuestAcceleratorCount = Nothing, _mtaiGuestAcceleratorType = Nothing}


-- | Number of accelerator cards exposed to the guest.
mtaiGuestAcceleratorCount :: Lens' MachineTypeAcceleratorsItem (Maybe Int32)
mtaiGuestAcceleratorCount
  = lens _mtaiGuestAcceleratorCount
      (\ s a -> s{_mtaiGuestAcceleratorCount = a})
      . mapping _Coerce

-- | The accelerator type resource name, not a full URL, e.g.
-- \'nvidia-tesla-k80\'.
mtaiGuestAcceleratorType :: Lens' MachineTypeAcceleratorsItem (Maybe Text)
mtaiGuestAcceleratorType
  = lens _mtaiGuestAcceleratorType
      (\ s a -> s{_mtaiGuestAcceleratorType = a})

instance FromJSON MachineTypeAcceleratorsItem where
        parseJSON
          = withObject "MachineTypeAcceleratorsItem"
              (\ o ->
                 MachineTypeAcceleratorsItem' <$>
                   (o .:? "guestAcceleratorCount") <*>
                     (o .:? "guestAcceleratorType"))

instance ToJSON MachineTypeAcceleratorsItem where
        toJSON MachineTypeAcceleratorsItem'{..}
          = object
              (catMaybes
                 [("guestAcceleratorCount" .=) <$>
                    _mtaiGuestAcceleratorCount,
                  ("guestAcceleratorType" .=) <$>
                    _mtaiGuestAcceleratorType])

-- | Contains some information about a VPN tunnel.
--
-- /See:/ 'vpnGatewayStatusTunnel' smart constructor.
data VPNGatewayStatusTunnel =
  VPNGatewayStatusTunnel'
    { _vgstTunnelURL :: !(Maybe Text)
    , _vgstPeerGatewayInterface :: !(Maybe (Textual Word32))
    , _vgstLocalGatewayInterface :: !(Maybe (Textual Word32))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNGatewayStatusTunnel' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vgstTunnelURL'
--
-- * 'vgstPeerGatewayInterface'
--
-- * 'vgstLocalGatewayInterface'
vpnGatewayStatusTunnel
    :: VPNGatewayStatusTunnel
vpnGatewayStatusTunnel =
  VPNGatewayStatusTunnel'
    { _vgstTunnelURL = Nothing
    , _vgstPeerGatewayInterface = Nothing
    , _vgstLocalGatewayInterface = Nothing
    }


-- | URL reference to the VPN tunnel.
vgstTunnelURL :: Lens' VPNGatewayStatusTunnel (Maybe Text)
vgstTunnelURL
  = lens _vgstTunnelURL
      (\ s a -> s{_vgstTunnelURL = a})

-- | The peer gateway interface this VPN tunnel is connected to, the peer
-- gateway could either be an external VPN gateway or GCP VPN gateway.
vgstPeerGatewayInterface :: Lens' VPNGatewayStatusTunnel (Maybe Word32)
vgstPeerGatewayInterface
  = lens _vgstPeerGatewayInterface
      (\ s a -> s{_vgstPeerGatewayInterface = a})
      . mapping _Coerce

-- | The VPN gateway interface this VPN tunnel is associated with.
vgstLocalGatewayInterface :: Lens' VPNGatewayStatusTunnel (Maybe Word32)
vgstLocalGatewayInterface
  = lens _vgstLocalGatewayInterface
      (\ s a -> s{_vgstLocalGatewayInterface = a})
      . mapping _Coerce

instance FromJSON VPNGatewayStatusTunnel where
        parseJSON
          = withObject "VPNGatewayStatusTunnel"
              (\ o ->
                 VPNGatewayStatusTunnel' <$>
                   (o .:? "tunnelUrl") <*>
                     (o .:? "peerGatewayInterface")
                     <*> (o .:? "localGatewayInterface"))

instance ToJSON VPNGatewayStatusTunnel where
        toJSON VPNGatewayStatusTunnel'{..}
          = object
              (catMaybes
                 [("tunnelUrl" .=) <$> _vgstTunnelURL,
                  ("peerGatewayInterface" .=) <$>
                    _vgstPeerGatewayInterface,
                  ("localGatewayInterface" .=) <$>
                    _vgstLocalGatewayInterface])

--
-- /See:/ 'urlMapsAggregatedListWarningDataItem' smart constructor.
data URLMapsAggregatedListWarningDataItem =
  URLMapsAggregatedListWarningDataItem'
    { _umalwdiValue :: !(Maybe Text)
    , _umalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'URLMapsAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'umalwdiValue'
--
-- * 'umalwdiKey'
urlMapsAggregatedListWarningDataItem
    :: URLMapsAggregatedListWarningDataItem
urlMapsAggregatedListWarningDataItem =
  URLMapsAggregatedListWarningDataItem'
    {_umalwdiValue = Nothing, _umalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
umalwdiValue :: Lens' URLMapsAggregatedListWarningDataItem (Maybe Text)
umalwdiValue
  = lens _umalwdiValue (\ s a -> s{_umalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
umalwdiKey :: Lens' URLMapsAggregatedListWarningDataItem (Maybe Text)
umalwdiKey
  = lens _umalwdiKey (\ s a -> s{_umalwdiKey = a})

instance FromJSON
           URLMapsAggregatedListWarningDataItem
         where
        parseJSON
          = withObject "URLMapsAggregatedListWarningDataItem"
              (\ o ->
                 URLMapsAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON URLMapsAggregatedListWarningDataItem
         where
        toJSON URLMapsAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _umalwdiValue,
                  ("key" .=) <$> _umalwdiKey])

--
-- /See:/ 'instanceListReferrersWarningDataItem' smart constructor.
data InstanceListReferrersWarningDataItem =
  InstanceListReferrersWarningDataItem'
    { _ilrwdiValue :: !(Maybe Text)
    , _ilrwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceListReferrersWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ilrwdiValue'
--
-- * 'ilrwdiKey'
instanceListReferrersWarningDataItem
    :: InstanceListReferrersWarningDataItem
instanceListReferrersWarningDataItem =
  InstanceListReferrersWarningDataItem'
    {_ilrwdiValue = Nothing, _ilrwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
ilrwdiValue :: Lens' InstanceListReferrersWarningDataItem (Maybe Text)
ilrwdiValue
  = lens _ilrwdiValue (\ s a -> s{_ilrwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
ilrwdiKey :: Lens' InstanceListReferrersWarningDataItem (Maybe Text)
ilrwdiKey
  = lens _ilrwdiKey (\ s a -> s{_ilrwdiKey = a})

instance FromJSON
           InstanceListReferrersWarningDataItem
         where
        parseJSON
          = withObject "InstanceListReferrersWarningDataItem"
              (\ o ->
                 InstanceListReferrersWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON InstanceListReferrersWarningDataItem
         where
        toJSON InstanceListReferrersWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _ilrwdiValue,
                  ("key" .=) <$> _ilrwdiKey])

--
-- /See:/ 'routeListWarningDataItem' smart constructor.
data RouteListWarningDataItem =
  RouteListWarningDataItem'
    { _rlwdilValue :: !(Maybe Text)
    , _rlwdilKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RouteListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rlwdilValue'
--
-- * 'rlwdilKey'
routeListWarningDataItem
    :: RouteListWarningDataItem
routeListWarningDataItem =
  RouteListWarningDataItem' {_rlwdilValue = Nothing, _rlwdilKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
rlwdilValue :: Lens' RouteListWarningDataItem (Maybe Text)
rlwdilValue
  = lens _rlwdilValue (\ s a -> s{_rlwdilValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
rlwdilKey :: Lens' RouteListWarningDataItem (Maybe Text)
rlwdilKey
  = lens _rlwdilKey (\ s a -> s{_rlwdilKey = a})

instance FromJSON RouteListWarningDataItem where
        parseJSON
          = withObject "RouteListWarningDataItem"
              (\ o ->
                 RouteListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON RouteListWarningDataItem where
        toJSON RouteListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _rlwdilValue,
                  ("key" .=) <$> _rlwdilKey])

--
-- /See:/ 'interconnectAttachmentsScopedList' smart constructor.
data InterconnectAttachmentsScopedList =
  InterconnectAttachmentsScopedList'
    { _iaslWarning :: !(Maybe InterconnectAttachmentsScopedListWarning)
    , _iaslInterconnectAttachments :: !(Maybe [InterconnectAttachment])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectAttachmentsScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iaslWarning'
--
-- * 'iaslInterconnectAttachments'
interconnectAttachmentsScopedList
    :: InterconnectAttachmentsScopedList
interconnectAttachmentsScopedList =
  InterconnectAttachmentsScopedList'
    {_iaslWarning = Nothing, _iaslInterconnectAttachments = Nothing}


-- | Informational warning which replaces the list of addresses when the list
-- is empty.
iaslWarning :: Lens' InterconnectAttachmentsScopedList (Maybe InterconnectAttachmentsScopedListWarning)
iaslWarning
  = lens _iaslWarning (\ s a -> s{_iaslWarning = a})

-- | A list of interconnect attachments contained in this scope.
iaslInterconnectAttachments :: Lens' InterconnectAttachmentsScopedList [InterconnectAttachment]
iaslInterconnectAttachments
  = lens _iaslInterconnectAttachments
      (\ s a -> s{_iaslInterconnectAttachments = a})
      . _Default
      . _Coerce

instance FromJSON InterconnectAttachmentsScopedList
         where
        parseJSON
          = withObject "InterconnectAttachmentsScopedList"
              (\ o ->
                 InterconnectAttachmentsScopedList' <$>
                   (o .:? "warning") <*>
                     (o .:? "interconnectAttachments" .!= mempty))

instance ToJSON InterconnectAttachmentsScopedList
         where
        toJSON InterconnectAttachmentsScopedList'{..}
          = object
              (catMaybes
                 [("warning" .=) <$> _iaslWarning,
                  ("interconnectAttachments" .=) <$>
                    _iaslInterconnectAttachments])

--
-- /See:/ 'securityPolicyList' smart constructor.
data SecurityPolicyList =
  SecurityPolicyList'
    { _splNextPageToken :: !(Maybe Text)
    , _splKind :: !Text
    , _splItems :: !(Maybe [SecurityPolicy])
    , _splWarning :: !(Maybe SecurityPolicyListWarning)
    , _splId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SecurityPolicyList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'splNextPageToken'
--
-- * 'splKind'
--
-- * 'splItems'
--
-- * 'splWarning'
--
-- * 'splId'
securityPolicyList
    :: SecurityPolicyList
securityPolicyList =
  SecurityPolicyList'
    { _splNextPageToken = Nothing
    , _splKind = "compute#securityPolicyList"
    , _splItems = Nothing
    , _splWarning = Nothing
    , _splId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
splNextPageToken :: Lens' SecurityPolicyList (Maybe Text)
splNextPageToken
  = lens _splNextPageToken
      (\ s a -> s{_splNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#securityPolicyList for
-- listsof securityPolicies
splKind :: Lens' SecurityPolicyList Text
splKind = lens _splKind (\ s a -> s{_splKind = a})

-- | A list of SecurityPolicy resources.
splItems :: Lens' SecurityPolicyList [SecurityPolicy]
splItems
  = lens _splItems (\ s a -> s{_splItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Informational warning message.
splWarning :: Lens' SecurityPolicyList (Maybe SecurityPolicyListWarning)
splWarning
  = lens _splWarning (\ s a -> s{_splWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
splId :: Lens' SecurityPolicyList (Maybe Text)
splId = lens _splId (\ s a -> s{_splId = a})

instance FromJSON SecurityPolicyList where
        parseJSON
          = withObject "SecurityPolicyList"
              (\ o ->
                 SecurityPolicyList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#securityPolicyList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON SecurityPolicyList where
        toJSON SecurityPolicyList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _splNextPageToken,
                  Just ("kind" .= _splKind),
                  ("items" .=) <$> _splItems,
                  ("warning" .=) <$> _splWarning,
                  ("id" .=) <$> _splId])

--
-- /See:/ 'commitmentAggregatedList' smart constructor.
data CommitmentAggregatedList =
  CommitmentAggregatedList'
    { _calUnreachables :: !(Maybe [Text])
    , _calNextPageToken :: !(Maybe Text)
    , _calKind :: !Text
    , _calItems :: !(Maybe CommitmentAggregatedListItems)
    , _calSelfLink :: !(Maybe Text)
    , _calWarning :: !(Maybe CommitmentAggregatedListWarning)
    , _calId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'CommitmentAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'calUnreachables'
--
-- * 'calNextPageToken'
--
-- * 'calKind'
--
-- * 'calItems'
--
-- * 'calSelfLink'
--
-- * 'calWarning'
--
-- * 'calId'
commitmentAggregatedList
    :: CommitmentAggregatedList
commitmentAggregatedList =
  CommitmentAggregatedList'
    { _calUnreachables = Nothing
    , _calNextPageToken = Nothing
    , _calKind = "compute#commitmentAggregatedList"
    , _calItems = Nothing
    , _calSelfLink = Nothing
    , _calWarning = Nothing
    , _calId = Nothing
    }


-- | [Output Only] Unreachable resources.
calUnreachables :: Lens' CommitmentAggregatedList [Text]
calUnreachables
  = lens _calUnreachables
      (\ s a -> s{_calUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
calNextPageToken :: Lens' CommitmentAggregatedList (Maybe Text)
calNextPageToken
  = lens _calNextPageToken
      (\ s a -> s{_calNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#commitmentAggregatedList
-- for aggregated lists of commitments.
calKind :: Lens' CommitmentAggregatedList Text
calKind = lens _calKind (\ s a -> s{_calKind = a})

-- | A list of CommitmentsScopedList resources.
calItems :: Lens' CommitmentAggregatedList (Maybe CommitmentAggregatedListItems)
calItems = lens _calItems (\ s a -> s{_calItems = a})

-- | [Output Only] Server-defined URL for this resource.
calSelfLink :: Lens' CommitmentAggregatedList (Maybe Text)
calSelfLink
  = lens _calSelfLink (\ s a -> s{_calSelfLink = a})

-- | [Output Only] Informational warning message.
calWarning :: Lens' CommitmentAggregatedList (Maybe CommitmentAggregatedListWarning)
calWarning
  = lens _calWarning (\ s a -> s{_calWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
calId :: Lens' CommitmentAggregatedList (Maybe Text)
calId = lens _calId (\ s a -> s{_calId = a})

instance FromJSON CommitmentAggregatedList where
        parseJSON
          = withObject "CommitmentAggregatedList"
              (\ o ->
                 CommitmentAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!= "compute#commitmentAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON CommitmentAggregatedList where
        toJSON CommitmentAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _calUnreachables,
                  ("nextPageToken" .=) <$> _calNextPageToken,
                  Just ("kind" .= _calKind),
                  ("items" .=) <$> _calItems,
                  ("selfLink" .=) <$> _calSelfLink,
                  ("warning" .=) <$> _calWarning,
                  ("id" .=) <$> _calId])

--
-- /See:/ 'instanceGroupManagersListErrorsResponse' smart constructor.
data InstanceGroupManagersListErrorsResponse =
  InstanceGroupManagersListErrorsResponse'
    { _igmlerNextPageToken :: !(Maybe Text)
    , _igmlerItems :: !(Maybe [InstanceManagedByIgmError])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagersListErrorsResponse' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmlerNextPageToken'
--
-- * 'igmlerItems'
instanceGroupManagersListErrorsResponse
    :: InstanceGroupManagersListErrorsResponse
instanceGroupManagersListErrorsResponse =
  InstanceGroupManagersListErrorsResponse'
    {_igmlerNextPageToken = Nothing, _igmlerItems = Nothing}


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
igmlerNextPageToken :: Lens' InstanceGroupManagersListErrorsResponse (Maybe Text)
igmlerNextPageToken
  = lens _igmlerNextPageToken
      (\ s a -> s{_igmlerNextPageToken = a})

-- | [Output Only] The list of errors of the managed instance group.
igmlerItems :: Lens' InstanceGroupManagersListErrorsResponse [InstanceManagedByIgmError]
igmlerItems
  = lens _igmlerItems (\ s a -> s{_igmlerItems = a}) .
      _Default
      . _Coerce

instance FromJSON
           InstanceGroupManagersListErrorsResponse
         where
        parseJSON
          = withObject
              "InstanceGroupManagersListErrorsResponse"
              (\ o ->
                 InstanceGroupManagersListErrorsResponse' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "items" .!= mempty))

instance ToJSON
           InstanceGroupManagersListErrorsResponse
         where
        toJSON InstanceGroupManagersListErrorsResponse'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _igmlerNextPageToken,
                  ("items" .=) <$> _igmlerItems])

-- | Contains a list of InstanceGroup resources.
--
-- /See:/ 'regionInstanceGroupList' smart constructor.
data RegionInstanceGroupList =
  RegionInstanceGroupList'
    { _riglNextPageToken :: !(Maybe Text)
    , _riglKind :: !Text
    , _riglItems :: !(Maybe [InstanceGroup])
    , _riglSelfLink :: !(Maybe Text)
    , _riglWarning :: !(Maybe RegionInstanceGroupListWarning)
    , _riglId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'riglNextPageToken'
--
-- * 'riglKind'
--
-- * 'riglItems'
--
-- * 'riglSelfLink'
--
-- * 'riglWarning'
--
-- * 'riglId'
regionInstanceGroupList
    :: RegionInstanceGroupList
regionInstanceGroupList =
  RegionInstanceGroupList'
    { _riglNextPageToken = Nothing
    , _riglKind = "compute#regionInstanceGroupList"
    , _riglItems = Nothing
    , _riglSelfLink = Nothing
    , _riglWarning = Nothing
    , _riglId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
riglNextPageToken :: Lens' RegionInstanceGroupList (Maybe Text)
riglNextPageToken
  = lens _riglNextPageToken
      (\ s a -> s{_riglNextPageToken = a})

-- | The resource type.
riglKind :: Lens' RegionInstanceGroupList Text
riglKind = lens _riglKind (\ s a -> s{_riglKind = a})

-- | A list of InstanceGroup resources.
riglItems :: Lens' RegionInstanceGroupList [InstanceGroup]
riglItems
  = lens _riglItems (\ s a -> s{_riglItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
riglSelfLink :: Lens' RegionInstanceGroupList (Maybe Text)
riglSelfLink
  = lens _riglSelfLink (\ s a -> s{_riglSelfLink = a})

-- | [Output Only] Informational warning message.
riglWarning :: Lens' RegionInstanceGroupList (Maybe RegionInstanceGroupListWarning)
riglWarning
  = lens _riglWarning (\ s a -> s{_riglWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
riglId :: Lens' RegionInstanceGroupList (Maybe Text)
riglId = lens _riglId (\ s a -> s{_riglId = a})

instance FromJSON RegionInstanceGroupList where
        parseJSON
          = withObject "RegionInstanceGroupList"
              (\ o ->
                 RegionInstanceGroupList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#regionInstanceGroupList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON RegionInstanceGroupList where
        toJSON RegionInstanceGroupList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _riglNextPageToken,
                  Just ("kind" .= _riglKind),
                  ("items" .=) <$> _riglItems,
                  ("selfLink" .=) <$> _riglSelfLink,
                  ("warning" .=) <$> _riglWarning,
                  ("id" .=) <$> _riglId])

-- | The available logging options for this subnetwork.
--
-- /See:/ 'subnetworkLogConfig' smart constructor.
data SubnetworkLogConfig =
  SubnetworkLogConfig'
    { _slcMetadataFields :: !(Maybe [Text])
    , _slcAggregationInterval :: !(Maybe SubnetworkLogConfigAggregationInterval)
    , _slcEnable :: !(Maybe Bool)
    , _slcFilterExpr :: !(Maybe Text)
    , _slcMetadata :: !(Maybe SubnetworkLogConfigMetadata)
    , _slcFlowSampling :: !(Maybe (Textual Double))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SubnetworkLogConfig' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'slcMetadataFields'
--
-- * 'slcAggregationInterval'
--
-- * 'slcEnable'
--
-- * 'slcFilterExpr'
--
-- * 'slcMetadata'
--
-- * 'slcFlowSampling'
subnetworkLogConfig
    :: SubnetworkLogConfig
subnetworkLogConfig =
  SubnetworkLogConfig'
    { _slcMetadataFields = Nothing
    , _slcAggregationInterval = Nothing
    , _slcEnable = Nothing
    , _slcFilterExpr = Nothing
    , _slcMetadata = Nothing
    , _slcFlowSampling = Nothing
    }


-- | Can only be specified if VPC flow logs for this subnetwork is enabled
-- and \"metadata\" was set to CUSTOM_METADATA.
slcMetadataFields :: Lens' SubnetworkLogConfig [Text]
slcMetadataFields
  = lens _slcMetadataFields
      (\ s a -> s{_slcMetadataFields = a})
      . _Default
      . _Coerce

-- | Can only be specified if VPC flow logging for this subnetwork is
-- enabled. Toggles the aggregation interval for collecting flow logs.
-- Increasing the interval time will reduce the amount of generated flow
-- logs for long lasting connections. Default is an interval of 5 seconds
-- per connection.
slcAggregationInterval :: Lens' SubnetworkLogConfig (Maybe SubnetworkLogConfigAggregationInterval)
slcAggregationInterval
  = lens _slcAggregationInterval
      (\ s a -> s{_slcAggregationInterval = a})

-- | Whether to enable flow logging for this subnetwork. If this field is not
-- explicitly set, it will not appear in get listings. If not set the
-- default behavior is to disable flow logging.
slcEnable :: Lens' SubnetworkLogConfig (Maybe Bool)
slcEnable
  = lens _slcEnable (\ s a -> s{_slcEnable = a})

-- | Can only be specified if VPC flow logs for this subnetwork is enabled.
-- Export filter used to define which VPC flow logs should be logged.
slcFilterExpr :: Lens' SubnetworkLogConfig (Maybe Text)
slcFilterExpr
  = lens _slcFilterExpr
      (\ s a -> s{_slcFilterExpr = a})

-- | Can only be specified if VPC flow logs for this subnetwork is enabled.
-- Configures whether all, none or a subset of metadata fields should be
-- added to the reported VPC flow logs. Default is EXCLUDE_ALL_METADATA.
slcMetadata :: Lens' SubnetworkLogConfig (Maybe SubnetworkLogConfigMetadata)
slcMetadata
  = lens _slcMetadata (\ s a -> s{_slcMetadata = a})

-- | Can only be specified if VPC flow logging for this subnetwork is
-- enabled. The value of the field must be in [0, 1]. Set the sampling rate
-- of VPC flow logs within the subnetwork where 1.0 means all collected
-- logs are reported and 0.0 means no logs are reported. Default is 0.5,
-- which means half of all collected logs are reported.
slcFlowSampling :: Lens' SubnetworkLogConfig (Maybe Double)
slcFlowSampling
  = lens _slcFlowSampling
      (\ s a -> s{_slcFlowSampling = a})
      . mapping _Coerce

instance FromJSON SubnetworkLogConfig where
        parseJSON
          = withObject "SubnetworkLogConfig"
              (\ o ->
                 SubnetworkLogConfig' <$>
                   (o .:? "metadataFields" .!= mempty) <*>
                     (o .:? "aggregationInterval")
                     <*> (o .:? "enable")
                     <*> (o .:? "filterExpr")
                     <*> (o .:? "metadata")
                     <*> (o .:? "flowSampling"))

instance ToJSON SubnetworkLogConfig where
        toJSON SubnetworkLogConfig'{..}
          = object
              (catMaybes
                 [("metadataFields" .=) <$> _slcMetadataFields,
                  ("aggregationInterval" .=) <$>
                    _slcAggregationInterval,
                  ("enable" .=) <$> _slcEnable,
                  ("filterExpr" .=) <$> _slcFilterExpr,
                  ("metadata" .=) <$> _slcMetadata,
                  ("flowSampling" .=) <$> _slcFlowSampling])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'vMEndpointNATMAppingsListWarning' smart constructor.
data VMEndpointNATMAppingsListWarning =
  VMEndpointNATMAppingsListWarning'
    { _vmenatmalwData :: !(Maybe [VMEndpointNATMAppingsListWarningDataItem])
    , _vmenatmalwCode :: !(Maybe VMEndpointNATMAppingsListWarningCode)
    , _vmenatmalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VMEndpointNATMAppingsListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vmenatmalwData'
--
-- * 'vmenatmalwCode'
--
-- * 'vmenatmalwMessage'
vMEndpointNATMAppingsListWarning
    :: VMEndpointNATMAppingsListWarning
vMEndpointNATMAppingsListWarning =
  VMEndpointNATMAppingsListWarning'
    { _vmenatmalwData = Nothing
    , _vmenatmalwCode = Nothing
    , _vmenatmalwMessage = Nothing
    }


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
vmenatmalwData :: Lens' VMEndpointNATMAppingsListWarning [VMEndpointNATMAppingsListWarningDataItem]
vmenatmalwData
  = lens _vmenatmalwData
      (\ s a -> s{_vmenatmalwData = a})
      . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
vmenatmalwCode :: Lens' VMEndpointNATMAppingsListWarning (Maybe VMEndpointNATMAppingsListWarningCode)
vmenatmalwCode
  = lens _vmenatmalwCode
      (\ s a -> s{_vmenatmalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
vmenatmalwMessage :: Lens' VMEndpointNATMAppingsListWarning (Maybe Text)
vmenatmalwMessage
  = lens _vmenatmalwMessage
      (\ s a -> s{_vmenatmalwMessage = a})

instance FromJSON VMEndpointNATMAppingsListWarning
         where
        parseJSON
          = withObject "VMEndpointNATMAppingsListWarning"
              (\ o ->
                 VMEndpointNATMAppingsListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON VMEndpointNATMAppingsListWarning
         where
        toJSON VMEndpointNATMAppingsListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _vmenatmalwData,
                  ("code" .=) <$> _vmenatmalwCode,
                  ("message" .=) <$> _vmenatmalwMessage])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'healthCheckServicesListWarning' smart constructor.
data HealthCheckServicesListWarning =
  HealthCheckServicesListWarning'
    { _hcslwData :: !(Maybe [HealthCheckServicesListWarningDataItem])
    , _hcslwCode :: !(Maybe HealthCheckServicesListWarningCode)
    , _hcslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HealthCheckServicesListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hcslwData'
--
-- * 'hcslwCode'
--
-- * 'hcslwMessage'
healthCheckServicesListWarning
    :: HealthCheckServicesListWarning
healthCheckServicesListWarning =
  HealthCheckServicesListWarning'
    {_hcslwData = Nothing, _hcslwCode = Nothing, _hcslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
hcslwData :: Lens' HealthCheckServicesListWarning [HealthCheckServicesListWarningDataItem]
hcslwData
  = lens _hcslwData (\ s a -> s{_hcslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
hcslwCode :: Lens' HealthCheckServicesListWarning (Maybe HealthCheckServicesListWarningCode)
hcslwCode
  = lens _hcslwCode (\ s a -> s{_hcslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
hcslwMessage :: Lens' HealthCheckServicesListWarning (Maybe Text)
hcslwMessage
  = lens _hcslwMessage (\ s a -> s{_hcslwMessage = a})

instance FromJSON HealthCheckServicesListWarning
         where
        parseJSON
          = withObject "HealthCheckServicesListWarning"
              (\ o ->
                 HealthCheckServicesListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON HealthCheckServicesListWarning where
        toJSON HealthCheckServicesListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _hcslwData,
                  ("code" .=) <$> _hcslwCode,
                  ("message" .=) <$> _hcslwMessage])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'sslCertificateAggregatedListWarning' smart constructor.
data SSLCertificateAggregatedListWarning =
  SSLCertificateAggregatedListWarning'
    { _scalwData :: !(Maybe [SSLCertificateAggregatedListWarningDataItem])
    , _scalwCode :: !(Maybe SSLCertificateAggregatedListWarningCode)
    , _scalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SSLCertificateAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'scalwData'
--
-- * 'scalwCode'
--
-- * 'scalwMessage'
sslCertificateAggregatedListWarning
    :: SSLCertificateAggregatedListWarning
sslCertificateAggregatedListWarning =
  SSLCertificateAggregatedListWarning'
    {_scalwData = Nothing, _scalwCode = Nothing, _scalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
scalwData :: Lens' SSLCertificateAggregatedListWarning [SSLCertificateAggregatedListWarningDataItem]
scalwData
  = lens _scalwData (\ s a -> s{_scalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
scalwCode :: Lens' SSLCertificateAggregatedListWarning (Maybe SSLCertificateAggregatedListWarningCode)
scalwCode
  = lens _scalwCode (\ s a -> s{_scalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
scalwMessage :: Lens' SSLCertificateAggregatedListWarning (Maybe Text)
scalwMessage
  = lens _scalwMessage (\ s a -> s{_scalwMessage = a})

instance FromJSON SSLCertificateAggregatedListWarning
         where
        parseJSON
          = withObject "SSLCertificateAggregatedListWarning"
              (\ o ->
                 SSLCertificateAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON SSLCertificateAggregatedListWarning
         where
        toJSON SSLCertificateAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _scalwData,
                  ("code" .=) <$> _scalwCode,
                  ("message" .=) <$> _scalwMessage])

--
-- /See:/ 'resourcePolicyResourceStatusInstanceSchedulePolicyStatus' smart constructor.
data ResourcePolicyResourceStatusInstanceSchedulePolicyStatus =
  ResourcePolicyResourceStatusInstanceSchedulePolicyStatus'
    { _rprsispsNextRunStartTime :: !(Maybe Text)
    , _rprsispsLastRunStartTime :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePolicyResourceStatusInstanceSchedulePolicyStatus' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rprsispsNextRunStartTime'
--
-- * 'rprsispsLastRunStartTime'
resourcePolicyResourceStatusInstanceSchedulePolicyStatus
    :: ResourcePolicyResourceStatusInstanceSchedulePolicyStatus
resourcePolicyResourceStatusInstanceSchedulePolicyStatus =
  ResourcePolicyResourceStatusInstanceSchedulePolicyStatus'
    {_rprsispsNextRunStartTime = Nothing, _rprsispsLastRunStartTime = Nothing}


-- | [Output Only] The next time the schedule is planned to run. The actual
-- time might be slightly different. The timestamp is an RFC3339 string.
rprsispsNextRunStartTime :: Lens' ResourcePolicyResourceStatusInstanceSchedulePolicyStatus (Maybe Text)
rprsispsNextRunStartTime
  = lens _rprsispsNextRunStartTime
      (\ s a -> s{_rprsispsNextRunStartTime = a})

-- | [Output Only] The last time the schedule successfully ran. The timestamp
-- is an RFC3339 string.
rprsispsLastRunStartTime :: Lens' ResourcePolicyResourceStatusInstanceSchedulePolicyStatus (Maybe Text)
rprsispsLastRunStartTime
  = lens _rprsispsLastRunStartTime
      (\ s a -> s{_rprsispsLastRunStartTime = a})

instance FromJSON
           ResourcePolicyResourceStatusInstanceSchedulePolicyStatus
         where
        parseJSON
          = withObject
              "ResourcePolicyResourceStatusInstanceSchedulePolicyStatus"
              (\ o ->
                 ResourcePolicyResourceStatusInstanceSchedulePolicyStatus'
                   <$>
                   (o .:? "nextRunStartTime") <*>
                     (o .:? "lastRunStartTime"))

instance ToJSON
           ResourcePolicyResourceStatusInstanceSchedulePolicyStatus
         where
        toJSON
          ResourcePolicyResourceStatusInstanceSchedulePolicyStatus'{..}
          = object
              (catMaybes
                 [("nextRunStartTime" .=) <$>
                    _rprsispsNextRunStartTime,
                  ("lastRunStartTime" .=) <$>
                    _rprsispsLastRunStartTime])

-- | A list of TargetPool resources.
--
-- /See:/ 'targetPoolAggregatedListItems' smart constructor.
newtype TargetPoolAggregatedListItems =
  TargetPoolAggregatedListItems'
    { _tpaliAddtional :: HashMap Text TargetPoolsScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetPoolAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tpaliAddtional'
targetPoolAggregatedListItems
    :: HashMap Text TargetPoolsScopedList -- ^ 'tpaliAddtional'
    -> TargetPoolAggregatedListItems
targetPoolAggregatedListItems pTpaliAddtional_ =
  TargetPoolAggregatedListItems' {_tpaliAddtional = _Coerce # pTpaliAddtional_}


-- | Name of the scope containing this set of target pools.
tpaliAddtional :: Lens' TargetPoolAggregatedListItems (HashMap Text TargetPoolsScopedList)
tpaliAddtional
  = lens _tpaliAddtional
      (\ s a -> s{_tpaliAddtional = a})
      . _Coerce

instance FromJSON TargetPoolAggregatedListItems where
        parseJSON
          = withObject "TargetPoolAggregatedListItems"
              (\ o ->
                 TargetPoolAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON TargetPoolAggregatedListItems where
        toJSON = toJSON . _tpaliAddtional

--
-- /See:/ 'publicDelegatedPrefixesScopedListWarningDataItem' smart constructor.
data PublicDelegatedPrefixesScopedListWarningDataItem =
  PublicDelegatedPrefixesScopedListWarningDataItem'
    { _pdpslwdiValue :: !(Maybe Text)
    , _pdpslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PublicDelegatedPrefixesScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pdpslwdiValue'
--
-- * 'pdpslwdiKey'
publicDelegatedPrefixesScopedListWarningDataItem
    :: PublicDelegatedPrefixesScopedListWarningDataItem
publicDelegatedPrefixesScopedListWarningDataItem =
  PublicDelegatedPrefixesScopedListWarningDataItem'
    {_pdpslwdiValue = Nothing, _pdpslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
pdpslwdiValue :: Lens' PublicDelegatedPrefixesScopedListWarningDataItem (Maybe Text)
pdpslwdiValue
  = lens _pdpslwdiValue
      (\ s a -> s{_pdpslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
pdpslwdiKey :: Lens' PublicDelegatedPrefixesScopedListWarningDataItem (Maybe Text)
pdpslwdiKey
  = lens _pdpslwdiKey (\ s a -> s{_pdpslwdiKey = a})

instance FromJSON
           PublicDelegatedPrefixesScopedListWarningDataItem
         where
        parseJSON
          = withObject
              "PublicDelegatedPrefixesScopedListWarningDataItem"
              (\ o ->
                 PublicDelegatedPrefixesScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           PublicDelegatedPrefixesScopedListWarningDataItem
         where
        toJSON
          PublicDelegatedPrefixesScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _pdpslwdiValue,
                  ("key" .=) <$> _pdpslwdiKey])

--
-- /See:/ 'resourcePoliciesScopedListWarningDataItem' smart constructor.
data ResourcePoliciesScopedListWarningDataItem =
  ResourcePoliciesScopedListWarningDataItem'
    { _rpslwdiValue :: !(Maybe Text)
    , _rpslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePoliciesScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rpslwdiValue'
--
-- * 'rpslwdiKey'
resourcePoliciesScopedListWarningDataItem
    :: ResourcePoliciesScopedListWarningDataItem
resourcePoliciesScopedListWarningDataItem =
  ResourcePoliciesScopedListWarningDataItem'
    {_rpslwdiValue = Nothing, _rpslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
rpslwdiValue :: Lens' ResourcePoliciesScopedListWarningDataItem (Maybe Text)
rpslwdiValue
  = lens _rpslwdiValue (\ s a -> s{_rpslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
rpslwdiKey :: Lens' ResourcePoliciesScopedListWarningDataItem (Maybe Text)
rpslwdiKey
  = lens _rpslwdiKey (\ s a -> s{_rpslwdiKey = a})

instance FromJSON
           ResourcePoliciesScopedListWarningDataItem
         where
        parseJSON
          = withObject
              "ResourcePoliciesScopedListWarningDataItem"
              (\ o ->
                 ResourcePoliciesScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           ResourcePoliciesScopedListWarningDataItem
         where
        toJSON ResourcePoliciesScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _rpslwdiValue,
                  ("key" .=) <$> _rpslwdiKey])

--
-- /See:/ 'nodeGroupsAddNodesRequest' smart constructor.
newtype NodeGroupsAddNodesRequest =
  NodeGroupsAddNodesRequest'
    { _nganrAdditionalNodeCount :: Maybe (Textual Int32)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeGroupsAddNodesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nganrAdditionalNodeCount'
nodeGroupsAddNodesRequest
    :: NodeGroupsAddNodesRequest
nodeGroupsAddNodesRequest =
  NodeGroupsAddNodesRequest' {_nganrAdditionalNodeCount = Nothing}


-- | Count of additional nodes to be added to the node group.
nganrAdditionalNodeCount :: Lens' NodeGroupsAddNodesRequest (Maybe Int32)
nganrAdditionalNodeCount
  = lens _nganrAdditionalNodeCount
      (\ s a -> s{_nganrAdditionalNodeCount = a})
      . mapping _Coerce

instance FromJSON NodeGroupsAddNodesRequest where
        parseJSON
          = withObject "NodeGroupsAddNodesRequest"
              (\ o ->
                 NodeGroupsAddNodesRequest' <$>
                   (o .:? "additionalNodeCount"))

instance ToJSON NodeGroupsAddNodesRequest where
        toJSON NodeGroupsAddNodesRequest'{..}
          = object
              (catMaybes
                 [("additionalNodeCount" .=) <$>
                    _nganrAdditionalNodeCount])

--
-- /See:/ 'nodeTypeAggregatedList' smart constructor.
data NodeTypeAggregatedList =
  NodeTypeAggregatedList'
    { _ntalUnreachables :: !(Maybe [Text])
    , _ntalNextPageToken :: !(Maybe Text)
    , _ntalKind :: !Text
    , _ntalItems :: !(Maybe NodeTypeAggregatedListItems)
    , _ntalSelfLink :: !(Maybe Text)
    , _ntalWarning :: !(Maybe NodeTypeAggregatedListWarning)
    , _ntalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeTypeAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ntalUnreachables'
--
-- * 'ntalNextPageToken'
--
-- * 'ntalKind'
--
-- * 'ntalItems'
--
-- * 'ntalSelfLink'
--
-- * 'ntalWarning'
--
-- * 'ntalId'
nodeTypeAggregatedList
    :: NodeTypeAggregatedList
nodeTypeAggregatedList =
  NodeTypeAggregatedList'
    { _ntalUnreachables = Nothing
    , _ntalNextPageToken = Nothing
    , _ntalKind = "compute#nodeTypeAggregatedList"
    , _ntalItems = Nothing
    , _ntalSelfLink = Nothing
    , _ntalWarning = Nothing
    , _ntalId = Nothing
    }


-- | [Output Only] Unreachable resources.
ntalUnreachables :: Lens' NodeTypeAggregatedList [Text]
ntalUnreachables
  = lens _ntalUnreachables
      (\ s a -> s{_ntalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
ntalNextPageToken :: Lens' NodeTypeAggregatedList (Maybe Text)
ntalNextPageToken
  = lens _ntalNextPageToken
      (\ s a -> s{_ntalNextPageToken = a})

-- | [Output Only] Type of resource.Always compute#nodeTypeAggregatedList for
-- aggregated lists of node types.
ntalKind :: Lens' NodeTypeAggregatedList Text
ntalKind = lens _ntalKind (\ s a -> s{_ntalKind = a})

-- | A list of NodeTypesScopedList resources.
ntalItems :: Lens' NodeTypeAggregatedList (Maybe NodeTypeAggregatedListItems)
ntalItems
  = lens _ntalItems (\ s a -> s{_ntalItems = a})

-- | [Output Only] Server-defined URL for this resource.
ntalSelfLink :: Lens' NodeTypeAggregatedList (Maybe Text)
ntalSelfLink
  = lens _ntalSelfLink (\ s a -> s{_ntalSelfLink = a})

-- | [Output Only] Informational warning message.
ntalWarning :: Lens' NodeTypeAggregatedList (Maybe NodeTypeAggregatedListWarning)
ntalWarning
  = lens _ntalWarning (\ s a -> s{_ntalWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
ntalId :: Lens' NodeTypeAggregatedList (Maybe Text)
ntalId = lens _ntalId (\ s a -> s{_ntalId = a})

instance FromJSON NodeTypeAggregatedList where
        parseJSON
          = withObject "NodeTypeAggregatedList"
              (\ o ->
                 NodeTypeAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!= "compute#nodeTypeAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON NodeTypeAggregatedList where
        toJSON NodeTypeAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _ntalUnreachables,
                  ("nextPageToken" .=) <$> _ntalNextPageToken,
                  Just ("kind" .= _ntalKind),
                  ("items" .=) <$> _ntalItems,
                  ("selfLink" .=) <$> _ntalSelfLink,
                  ("warning" .=) <$> _ntalWarning,
                  ("id" .=) <$> _ntalId])

--
-- /See:/ 'targetInstancesScopedList' smart constructor.
data TargetInstancesScopedList =
  TargetInstancesScopedList'
    { _tislWarning :: !(Maybe TargetInstancesScopedListWarning)
    , _tislTargetInstances :: !(Maybe [TargetInstance])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetInstancesScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tislWarning'
--
-- * 'tislTargetInstances'
targetInstancesScopedList
    :: TargetInstancesScopedList
targetInstancesScopedList =
  TargetInstancesScopedList'
    {_tislWarning = Nothing, _tislTargetInstances = Nothing}


-- | Informational warning which replaces the list of addresses when the list
-- is empty.
tislWarning :: Lens' TargetInstancesScopedList (Maybe TargetInstancesScopedListWarning)
tislWarning
  = lens _tislWarning (\ s a -> s{_tislWarning = a})

-- | A list of target instances contained in this scope.
tislTargetInstances :: Lens' TargetInstancesScopedList [TargetInstance]
tislTargetInstances
  = lens _tislTargetInstances
      (\ s a -> s{_tislTargetInstances = a})
      . _Default
      . _Coerce

instance FromJSON TargetInstancesScopedList where
        parseJSON
          = withObject "TargetInstancesScopedList"
              (\ o ->
                 TargetInstancesScopedList' <$>
                   (o .:? "warning") <*>
                     (o .:? "targetInstances" .!= mempty))

instance ToJSON TargetInstancesScopedList where
        toJSON TargetInstancesScopedList'{..}
          = object
              (catMaybes
                 [("warning" .=) <$> _tislWarning,
                  ("targetInstances" .=) <$> _tislTargetInstances])

-- | Informational warning which replaces the list of backend services when
-- the list is empty.
--
-- /See:/ 'healthChecksScopedListWarning' smart constructor.
data HealthChecksScopedListWarning =
  HealthChecksScopedListWarning'
    { _hData :: !(Maybe [HealthChecksScopedListWarningDataItem])
    , _hCode :: !(Maybe HealthChecksScopedListWarningCode)
    , _hMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HealthChecksScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hData'
--
-- * 'hCode'
--
-- * 'hMessage'
healthChecksScopedListWarning
    :: HealthChecksScopedListWarning
healthChecksScopedListWarning =
  HealthChecksScopedListWarning'
    {_hData = Nothing, _hCode = Nothing, _hMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
hData :: Lens' HealthChecksScopedListWarning [HealthChecksScopedListWarningDataItem]
hData
  = lens _hData (\ s a -> s{_hData = a}) . _Default .
      _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
hCode :: Lens' HealthChecksScopedListWarning (Maybe HealthChecksScopedListWarningCode)
hCode = lens _hCode (\ s a -> s{_hCode = a})

-- | [Output Only] A human-readable description of the warning code.
hMessage :: Lens' HealthChecksScopedListWarning (Maybe Text)
hMessage = lens _hMessage (\ s a -> s{_hMessage = a})

instance FromJSON HealthChecksScopedListWarning where
        parseJSON
          = withObject "HealthChecksScopedListWarning"
              (\ o ->
                 HealthChecksScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON HealthChecksScopedListWarning where
        toJSON HealthChecksScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _hData, ("code" .=) <$> _hCode,
                  ("message" .=) <$> _hMessage])

--
-- /See:/ 'subnetworkListWarningDataItem' smart constructor.
data SubnetworkListWarningDataItem =
  SubnetworkListWarningDataItem'
    { _sValue :: !(Maybe Text)
    , _sKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SubnetworkListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sValue'
--
-- * 'sKey'
subnetworkListWarningDataItem
    :: SubnetworkListWarningDataItem
subnetworkListWarningDataItem =
  SubnetworkListWarningDataItem' {_sValue = Nothing, _sKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
sValue :: Lens' SubnetworkListWarningDataItem (Maybe Text)
sValue = lens _sValue (\ s a -> s{_sValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
sKey :: Lens' SubnetworkListWarningDataItem (Maybe Text)
sKey = lens _sKey (\ s a -> s{_sKey = a})

instance FromJSON SubnetworkListWarningDataItem where
        parseJSON
          = withObject "SubnetworkListWarningDataItem"
              (\ o ->
                 SubnetworkListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON SubnetworkListWarningDataItem where
        toJSON SubnetworkListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _sValue, ("key" .=) <$> _sKey])

--
-- /See:/ 'networkEndpointGroupListWarningDataItem' smart constructor.
data NetworkEndpointGroupListWarningDataItem =
  NetworkEndpointGroupListWarningDataItem'
    { _neglwdiValue :: !(Maybe Text)
    , _neglwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkEndpointGroupListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'neglwdiValue'
--
-- * 'neglwdiKey'
networkEndpointGroupListWarningDataItem
    :: NetworkEndpointGroupListWarningDataItem
networkEndpointGroupListWarningDataItem =
  NetworkEndpointGroupListWarningDataItem'
    {_neglwdiValue = Nothing, _neglwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
neglwdiValue :: Lens' NetworkEndpointGroupListWarningDataItem (Maybe Text)
neglwdiValue
  = lens _neglwdiValue (\ s a -> s{_neglwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
neglwdiKey :: Lens' NetworkEndpointGroupListWarningDataItem (Maybe Text)
neglwdiKey
  = lens _neglwdiKey (\ s a -> s{_neglwdiKey = a})

instance FromJSON
           NetworkEndpointGroupListWarningDataItem
         where
        parseJSON
          = withObject
              "NetworkEndpointGroupListWarningDataItem"
              (\ o ->
                 NetworkEndpointGroupListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           NetworkEndpointGroupListWarningDataItem
         where
        toJSON NetworkEndpointGroupListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _neglwdiValue,
                  ("key" .=) <$> _neglwdiKey])

--
-- /See:/ 'projectsDisableXpnResourceRequest' smart constructor.
newtype ProjectsDisableXpnResourceRequest =
  ProjectsDisableXpnResourceRequest'
    { _pdxrrXpnResource :: Maybe XpnResourceId
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ProjectsDisableXpnResourceRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pdxrrXpnResource'
projectsDisableXpnResourceRequest
    :: ProjectsDisableXpnResourceRequest
projectsDisableXpnResourceRequest =
  ProjectsDisableXpnResourceRequest' {_pdxrrXpnResource = Nothing}


-- | Service resource (a.k.a service project) ID.
pdxrrXpnResource :: Lens' ProjectsDisableXpnResourceRequest (Maybe XpnResourceId)
pdxrrXpnResource
  = lens _pdxrrXpnResource
      (\ s a -> s{_pdxrrXpnResource = a})

instance FromJSON ProjectsDisableXpnResourceRequest
         where
        parseJSON
          = withObject "ProjectsDisableXpnResourceRequest"
              (\ o ->
                 ProjectsDisableXpnResourceRequest' <$>
                   (o .:? "xpnResource"))

instance ToJSON ProjectsDisableXpnResourceRequest
         where
        toJSON ProjectsDisableXpnResourceRequest'{..}
          = object
              (catMaybes
                 [("xpnResource" .=) <$> _pdxrrXpnResource])

-- | A list of AddressesScopedList resources.
--
-- /See:/ 'addressAggregatedListItems' smart constructor.
newtype AddressAggregatedListItems =
  AddressAggregatedListItems'
    { _aAddtional :: HashMap Text AddressesScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AddressAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'aAddtional'
addressAggregatedListItems
    :: HashMap Text AddressesScopedList -- ^ 'aAddtional'
    -> AddressAggregatedListItems
addressAggregatedListItems pAAddtional_ =
  AddressAggregatedListItems' {_aAddtional = _Coerce # pAAddtional_}


-- | [Output Only] Name of the scope containing this set of addresses.
aAddtional :: Lens' AddressAggregatedListItems (HashMap Text AddressesScopedList)
aAddtional
  = lens _aAddtional (\ s a -> s{_aAddtional = a}) .
      _Coerce

instance FromJSON AddressAggregatedListItems where
        parseJSON
          = withObject "AddressAggregatedListItems"
              (\ o ->
                 AddressAggregatedListItems' <$> (parseJSONObject o))

instance ToJSON AddressAggregatedListItems where
        toJSON = toJSON . _aAddtional

--
-- /See:/ 'instanceGroupManagersListPerInstanceConfigsResp' smart constructor.
data InstanceGroupManagersListPerInstanceConfigsResp =
  InstanceGroupManagersListPerInstanceConfigsResp'
    { _igmlpicrNextPageToken :: !(Maybe Text)
    , _igmlpicrItems :: !(Maybe [PerInstanceConfig])
    , _igmlpicrWarning :: !(Maybe InstanceGroupManagersListPerInstanceConfigsRespWarning)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagersListPerInstanceConfigsResp' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmlpicrNextPageToken'
--
-- * 'igmlpicrItems'
--
-- * 'igmlpicrWarning'
instanceGroupManagersListPerInstanceConfigsResp
    :: InstanceGroupManagersListPerInstanceConfigsResp
instanceGroupManagersListPerInstanceConfigsResp =
  InstanceGroupManagersListPerInstanceConfigsResp'
    { _igmlpicrNextPageToken = Nothing
    , _igmlpicrItems = Nothing
    , _igmlpicrWarning = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
igmlpicrNextPageToken :: Lens' InstanceGroupManagersListPerInstanceConfigsResp (Maybe Text)
igmlpicrNextPageToken
  = lens _igmlpicrNextPageToken
      (\ s a -> s{_igmlpicrNextPageToken = a})

-- | [Output Only] The list of PerInstanceConfig.
igmlpicrItems :: Lens' InstanceGroupManagersListPerInstanceConfigsResp [PerInstanceConfig]
igmlpicrItems
  = lens _igmlpicrItems
      (\ s a -> s{_igmlpicrItems = a})
      . _Default
      . _Coerce

-- | [Output Only] Informational warning message.
igmlpicrWarning :: Lens' InstanceGroupManagersListPerInstanceConfigsResp (Maybe InstanceGroupManagersListPerInstanceConfigsRespWarning)
igmlpicrWarning
  = lens _igmlpicrWarning
      (\ s a -> s{_igmlpicrWarning = a})

instance FromJSON
           InstanceGroupManagersListPerInstanceConfigsResp
         where
        parseJSON
          = withObject
              "InstanceGroupManagersListPerInstanceConfigsResp"
              (\ o ->
                 InstanceGroupManagersListPerInstanceConfigsResp' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "items" .!= mempty)
                     <*> (o .:? "warning"))

instance ToJSON
           InstanceGroupManagersListPerInstanceConfigsResp
         where
        toJSON
          InstanceGroupManagersListPerInstanceConfigsResp'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _igmlpicrNextPageToken,
                  ("items" .=) <$> _igmlpicrItems,
                  ("warning" .=) <$> _igmlpicrWarning])

-- | Contains a list of Autoscaler resources.
--
-- /See:/ 'autoscalerList' smart constructor.
data AutoscalerList =
  AutoscalerList'
    { _autNextPageToken :: !(Maybe Text)
    , _autKind :: !Text
    , _autItems :: !(Maybe [Autoscaler])
    , _autSelfLink :: !(Maybe Text)
    , _autWarning :: !(Maybe AutoscalerListWarning)
    , _autId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AutoscalerList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'autNextPageToken'
--
-- * 'autKind'
--
-- * 'autItems'
--
-- * 'autSelfLink'
--
-- * 'autWarning'
--
-- * 'autId'
autoscalerList
    :: AutoscalerList
autoscalerList =
  AutoscalerList'
    { _autNextPageToken = Nothing
    , _autKind = "compute#autoscalerList"
    , _autItems = Nothing
    , _autSelfLink = Nothing
    , _autWarning = Nothing
    , _autId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
autNextPageToken :: Lens' AutoscalerList (Maybe Text)
autNextPageToken
  = lens _autNextPageToken
      (\ s a -> s{_autNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#autoscalerList for lists
-- of autoscalers.
autKind :: Lens' AutoscalerList Text
autKind = lens _autKind (\ s a -> s{_autKind = a})

-- | A list of Autoscaler resources.
autItems :: Lens' AutoscalerList [Autoscaler]
autItems
  = lens _autItems (\ s a -> s{_autItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
autSelfLink :: Lens' AutoscalerList (Maybe Text)
autSelfLink
  = lens _autSelfLink (\ s a -> s{_autSelfLink = a})

-- | [Output Only] Informational warning message.
autWarning :: Lens' AutoscalerList (Maybe AutoscalerListWarning)
autWarning
  = lens _autWarning (\ s a -> s{_autWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
autId :: Lens' AutoscalerList (Maybe Text)
autId = lens _autId (\ s a -> s{_autId = a})

instance FromJSON AutoscalerList where
        parseJSON
          = withObject "AutoscalerList"
              (\ o ->
                 AutoscalerList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#autoscalerList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON AutoscalerList where
        toJSON AutoscalerList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _autNextPageToken,
                  Just ("kind" .= _autKind),
                  ("items" .=) <$> _autItems,
                  ("selfLink" .=) <$> _autSelfLink,
                  ("warning" .=) <$> _autWarning,
                  ("id" .=) <$> _autId])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'networkEndpointGroupAggregatedListWarning' smart constructor.
data NetworkEndpointGroupAggregatedListWarning =
  NetworkEndpointGroupAggregatedListWarning'
    { _negalwData :: !(Maybe [NetworkEndpointGroupAggregatedListWarningDataItem])
    , _negalwCode :: !(Maybe NetworkEndpointGroupAggregatedListWarningCode)
    , _negalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkEndpointGroupAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'negalwData'
--
-- * 'negalwCode'
--
-- * 'negalwMessage'
networkEndpointGroupAggregatedListWarning
    :: NetworkEndpointGroupAggregatedListWarning
networkEndpointGroupAggregatedListWarning =
  NetworkEndpointGroupAggregatedListWarning'
    {_negalwData = Nothing, _negalwCode = Nothing, _negalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
negalwData :: Lens' NetworkEndpointGroupAggregatedListWarning [NetworkEndpointGroupAggregatedListWarningDataItem]
negalwData
  = lens _negalwData (\ s a -> s{_negalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
negalwCode :: Lens' NetworkEndpointGroupAggregatedListWarning (Maybe NetworkEndpointGroupAggregatedListWarningCode)
negalwCode
  = lens _negalwCode (\ s a -> s{_negalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
negalwMessage :: Lens' NetworkEndpointGroupAggregatedListWarning (Maybe Text)
negalwMessage
  = lens _negalwMessage
      (\ s a -> s{_negalwMessage = a})

instance FromJSON
           NetworkEndpointGroupAggregatedListWarning
         where
        parseJSON
          = withObject
              "NetworkEndpointGroupAggregatedListWarning"
              (\ o ->
                 NetworkEndpointGroupAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON
           NetworkEndpointGroupAggregatedListWarning
         where
        toJSON NetworkEndpointGroupAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _negalwData,
                  ("code" .=) <$> _negalwCode,
                  ("message" .=) <$> _negalwMessage])

--
-- /See:/ 'interconnectListWarningDataItem' smart constructor.
data InterconnectListWarningDataItem =
  InterconnectListWarningDataItem'
    { _iValue :: !(Maybe Text)
    , _iKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iValue'
--
-- * 'iKey'
interconnectListWarningDataItem
    :: InterconnectListWarningDataItem
interconnectListWarningDataItem =
  InterconnectListWarningDataItem' {_iValue = Nothing, _iKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
iValue :: Lens' InterconnectListWarningDataItem (Maybe Text)
iValue = lens _iValue (\ s a -> s{_iValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
iKey :: Lens' InterconnectListWarningDataItem (Maybe Text)
iKey = lens _iKey (\ s a -> s{_iKey = a})

instance FromJSON InterconnectListWarningDataItem
         where
        parseJSON
          = withObject "InterconnectListWarningDataItem"
              (\ o ->
                 InterconnectListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON InterconnectListWarningDataItem where
        toJSON InterconnectListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _iValue, ("key" .=) <$> _iKey])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'subnetworkAggregatedListWarning' smart constructor.
data SubnetworkAggregatedListWarning =
  SubnetworkAggregatedListWarning'
    { _salwData :: !(Maybe [SubnetworkAggregatedListWarningDataItem])
    , _salwCode :: !(Maybe SubnetworkAggregatedListWarningCode)
    , _salwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SubnetworkAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'salwData'
--
-- * 'salwCode'
--
-- * 'salwMessage'
subnetworkAggregatedListWarning
    :: SubnetworkAggregatedListWarning
subnetworkAggregatedListWarning =
  SubnetworkAggregatedListWarning'
    {_salwData = Nothing, _salwCode = Nothing, _salwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
salwData :: Lens' SubnetworkAggregatedListWarning [SubnetworkAggregatedListWarningDataItem]
salwData
  = lens _salwData (\ s a -> s{_salwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
salwCode :: Lens' SubnetworkAggregatedListWarning (Maybe SubnetworkAggregatedListWarningCode)
salwCode = lens _salwCode (\ s a -> s{_salwCode = a})

-- | [Output Only] A human-readable description of the warning code.
salwMessage :: Lens' SubnetworkAggregatedListWarning (Maybe Text)
salwMessage
  = lens _salwMessage (\ s a -> s{_salwMessage = a})

instance FromJSON SubnetworkAggregatedListWarning
         where
        parseJSON
          = withObject "SubnetworkAggregatedListWarning"
              (\ o ->
                 SubnetworkAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON SubnetworkAggregatedListWarning where
        toJSON SubnetworkAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _salwData,
                  ("code" .=) <$> _salwCode,
                  ("message" .=) <$> _salwMessage])

--
-- /See:/ 'fileContentBuffer' smart constructor.
data FileContentBuffer =
  FileContentBuffer'
    { _fcbFileType :: !(Maybe FileContentBufferFileType)
    , _fcbContent :: !(Maybe Bytes)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'FileContentBuffer' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'fcbFileType'
--
-- * 'fcbContent'
fileContentBuffer
    :: FileContentBuffer
fileContentBuffer =
  FileContentBuffer' {_fcbFileType = Nothing, _fcbContent = Nothing}


-- | The file type of source file.
fcbFileType :: Lens' FileContentBuffer (Maybe FileContentBufferFileType)
fcbFileType
  = lens _fcbFileType (\ s a -> s{_fcbFileType = a})

-- | The raw content in the secure keys file.
fcbContent :: Lens' FileContentBuffer (Maybe ByteString)
fcbContent
  = lens _fcbContent (\ s a -> s{_fcbContent = a}) .
      mapping _Bytes

instance FromJSON FileContentBuffer where
        parseJSON
          = withObject "FileContentBuffer"
              (\ o ->
                 FileContentBuffer' <$>
                   (o .:? "fileType") <*> (o .:? "content"))

instance ToJSON FileContentBuffer where
        toJSON FileContentBuffer'{..}
          = object
              (catMaybes
                 [("fileType" .=) <$> _fcbFileType,
                  ("content" .=) <$> _fcbContent])

-- | Represents an Interconnect Attachment (VLAN) Location resource. You can
-- use this resource to find location details about an Interconnect
-- attachment (VLAN). For more information about interconnect attachments,
-- read Creating VLAN Attachments.
--
-- /See:/ 'interconnectLocation' smart constructor.
data InterconnectLocation =
  InterconnectLocation'
    { _intFacilityProviderFacilityId :: !(Maybe Text)
    , _intStatus :: !(Maybe InterconnectLocationStatus)
    , _intRegionInfos :: !(Maybe [InterconnectLocationRegionInfo])
    , _intKind :: !Text
    , _intAddress :: !(Maybe Text)
    , _intFacilityProvider :: !(Maybe Text)
    , _intSelfLink :: !(Maybe Text)
    , _intPeeringdbFacilityId :: !(Maybe Text)
    , _intName :: !(Maybe Text)
    , _intCity :: !(Maybe Text)
    , _intAvailabilityZone :: !(Maybe Text)
    , _intCreationTimestamp :: !(Maybe Text)
    , _intId :: !(Maybe (Textual Word64))
    , _intContinent :: !(Maybe InterconnectLocationContinent)
    , _intDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectLocation' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'intFacilityProviderFacilityId'
--
-- * 'intStatus'
--
-- * 'intRegionInfos'
--
-- * 'intKind'
--
-- * 'intAddress'
--
-- * 'intFacilityProvider'
--
-- * 'intSelfLink'
--
-- * 'intPeeringdbFacilityId'
--
-- * 'intName'
--
-- * 'intCity'
--
-- * 'intAvailabilityZone'
--
-- * 'intCreationTimestamp'
--
-- * 'intId'
--
-- * 'intContinent'
--
-- * 'intDescription'
interconnectLocation
    :: InterconnectLocation
interconnectLocation =
  InterconnectLocation'
    { _intFacilityProviderFacilityId = Nothing
    , _intStatus = Nothing
    , _intRegionInfos = Nothing
    , _intKind = "compute#interconnectLocation"
    , _intAddress = Nothing
    , _intFacilityProvider = Nothing
    , _intSelfLink = Nothing
    , _intPeeringdbFacilityId = Nothing
    , _intName = Nothing
    , _intCity = Nothing
    , _intAvailabilityZone = Nothing
    , _intCreationTimestamp = Nothing
    , _intId = Nothing
    , _intContinent = Nothing
    , _intDescription = Nothing
    }


-- | [Output Only] A provider-assigned Identifier for this facility (e.g.,
-- Ashburn-DC1).
intFacilityProviderFacilityId :: Lens' InterconnectLocation (Maybe Text)
intFacilityProviderFacilityId
  = lens _intFacilityProviderFacilityId
      (\ s a -> s{_intFacilityProviderFacilityId = a})

-- | [Output Only] The status of this InterconnectLocation, which can take
-- one of the following values: - CLOSED: The InterconnectLocation is
-- closed and is unavailable for provisioning new Interconnects. -
-- AVAILABLE: The InterconnectLocation is available for provisioning new
-- Interconnects.
intStatus :: Lens' InterconnectLocation (Maybe InterconnectLocationStatus)
intStatus
  = lens _intStatus (\ s a -> s{_intStatus = a})

-- | [Output Only] A list of InterconnectLocation.RegionInfo objects, that
-- describe parameters pertaining to the relation between this
-- InterconnectLocation and various Google Cloud regions.
intRegionInfos :: Lens' InterconnectLocation [InterconnectLocationRegionInfo]
intRegionInfos
  = lens _intRegionInfos
      (\ s a -> s{_intRegionInfos = a})
      . _Default
      . _Coerce

-- | [Output Only] Type of the resource. Always compute#interconnectLocation
-- for interconnect locations.
intKind :: Lens' InterconnectLocation Text
intKind = lens _intKind (\ s a -> s{_intKind = a})

-- | [Output Only] The postal address of the Point of Presence, each line in
-- the address is separated by a newline character.
intAddress :: Lens' InterconnectLocation (Maybe Text)
intAddress
  = lens _intAddress (\ s a -> s{_intAddress = a})

-- | [Output Only] The name of the provider for this facility (e.g.,
-- EQUINIX).
intFacilityProvider :: Lens' InterconnectLocation (Maybe Text)
intFacilityProvider
  = lens _intFacilityProvider
      (\ s a -> s{_intFacilityProvider = a})

-- | [Output Only] Server-defined URL for the resource.
intSelfLink :: Lens' InterconnectLocation (Maybe Text)
intSelfLink
  = lens _intSelfLink (\ s a -> s{_intSelfLink = a})

-- | [Output Only] The peeringdb identifier for this facility (corresponding
-- with a netfac type in peeringdb).
intPeeringdbFacilityId :: Lens' InterconnectLocation (Maybe Text)
intPeeringdbFacilityId
  = lens _intPeeringdbFacilityId
      (\ s a -> s{_intPeeringdbFacilityId = a})

-- | [Output Only] Name of the resource.
intName :: Lens' InterconnectLocation (Maybe Text)
intName = lens _intName (\ s a -> s{_intName = a})

-- | [Output Only] Metropolitan area designator that indicates which city an
-- interconnect is located. For example: \"Chicago, IL\", \"Amsterdam,
-- Netherlands\".
intCity :: Lens' InterconnectLocation (Maybe Text)
intCity = lens _intCity (\ s a -> s{_intCity = a})

-- | [Output Only] Availability zone for this InterconnectLocation. Within a
-- metropolitan area (metro), maintenance will not be simultaneously
-- scheduled in more than one availability zone. Example: \"zone1\" or
-- \"zone2\".
intAvailabilityZone :: Lens' InterconnectLocation (Maybe Text)
intAvailabilityZone
  = lens _intAvailabilityZone
      (\ s a -> s{_intAvailabilityZone = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
intCreationTimestamp :: Lens' InterconnectLocation (Maybe Text)
intCreationTimestamp
  = lens _intCreationTimestamp
      (\ s a -> s{_intCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
intId :: Lens' InterconnectLocation (Maybe Word64)
intId
  = lens _intId (\ s a -> s{_intId = a}) .
      mapping _Coerce

-- | [Output Only] Continent for this location, which can take one of the
-- following values: - AFRICA - ASIA_PAC - EUROPE - NORTH_AMERICA -
-- SOUTH_AMERICA
intContinent :: Lens' InterconnectLocation (Maybe InterconnectLocationContinent)
intContinent
  = lens _intContinent (\ s a -> s{_intContinent = a})

-- | [Output Only] An optional description of the resource.
intDescription :: Lens' InterconnectLocation (Maybe Text)
intDescription
  = lens _intDescription
      (\ s a -> s{_intDescription = a})

instance FromJSON InterconnectLocation where
        parseJSON
          = withObject "InterconnectLocation"
              (\ o ->
                 InterconnectLocation' <$>
                   (o .:? "facilityProviderFacilityId") <*>
                     (o .:? "status")
                     <*> (o .:? "regionInfos" .!= mempty)
                     <*> (o .:? "kind" .!= "compute#interconnectLocation")
                     <*> (o .:? "address")
                     <*> (o .:? "facilityProvider")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "peeringdbFacilityId")
                     <*> (o .:? "name")
                     <*> (o .:? "city")
                     <*> (o .:? "availabilityZone")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "continent")
                     <*> (o .:? "description"))

instance ToJSON InterconnectLocation where
        toJSON InterconnectLocation'{..}
          = object
              (catMaybes
                 [("facilityProviderFacilityId" .=) <$>
                    _intFacilityProviderFacilityId,
                  ("status" .=) <$> _intStatus,
                  ("regionInfos" .=) <$> _intRegionInfos,
                  Just ("kind" .= _intKind),
                  ("address" .=) <$> _intAddress,
                  ("facilityProvider" .=) <$> _intFacilityProvider,
                  ("selfLink" .=) <$> _intSelfLink,
                  ("peeringdbFacilityId" .=) <$>
                    _intPeeringdbFacilityId,
                  ("name" .=) <$> _intName, ("city" .=) <$> _intCity,
                  ("availabilityZone" .=) <$> _intAvailabilityZone,
                  ("creationTimestamp" .=) <$> _intCreationTimestamp,
                  ("id" .=) <$> _intId,
                  ("continent" .=) <$> _intContinent,
                  ("description" .=) <$> _intDescription])

--
-- /See:/ 'targetSSLProxiesSetProxyHeaderRequest' smart constructor.
newtype TargetSSLProxiesSetProxyHeaderRequest =
  TargetSSLProxiesSetProxyHeaderRequest'
    { _tspsphrProxyHeader :: Maybe TargetSSLProxiesSetProxyHeaderRequestProxyHeader
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetSSLProxiesSetProxyHeaderRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tspsphrProxyHeader'
targetSSLProxiesSetProxyHeaderRequest
    :: TargetSSLProxiesSetProxyHeaderRequest
targetSSLProxiesSetProxyHeaderRequest =
  TargetSSLProxiesSetProxyHeaderRequest' {_tspsphrProxyHeader = Nothing}


-- | The new type of proxy header to append before sending data to the
-- backend. NONE or PROXY_V1 are allowed.
tspsphrProxyHeader :: Lens' TargetSSLProxiesSetProxyHeaderRequest (Maybe TargetSSLProxiesSetProxyHeaderRequestProxyHeader)
tspsphrProxyHeader
  = lens _tspsphrProxyHeader
      (\ s a -> s{_tspsphrProxyHeader = a})

instance FromJSON
           TargetSSLProxiesSetProxyHeaderRequest
         where
        parseJSON
          = withObject "TargetSSLProxiesSetProxyHeaderRequest"
              (\ o ->
                 TargetSSLProxiesSetProxyHeaderRequest' <$>
                   (o .:? "proxyHeader"))

instance ToJSON TargetSSLProxiesSetProxyHeaderRequest
         where
        toJSON TargetSSLProxiesSetProxyHeaderRequest'{..}
          = object
              (catMaybes
                 [("proxyHeader" .=) <$> _tspsphrProxyHeader])

--
-- /See:/ 'vpnTunnelAggregatedList' smart constructor.
data VPNTunnelAggregatedList =
  VPNTunnelAggregatedList'
    { _vtalUnreachables :: !(Maybe [Text])
    , _vtalNextPageToken :: !(Maybe Text)
    , _vtalKind :: !Text
    , _vtalItems :: !(Maybe VPNTunnelAggregatedListItems)
    , _vtalSelfLink :: !(Maybe Text)
    , _vtalWarning :: !(Maybe VPNTunnelAggregatedListWarning)
    , _vtalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNTunnelAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vtalUnreachables'
--
-- * 'vtalNextPageToken'
--
-- * 'vtalKind'
--
-- * 'vtalItems'
--
-- * 'vtalSelfLink'
--
-- * 'vtalWarning'
--
-- * 'vtalId'
vpnTunnelAggregatedList
    :: VPNTunnelAggregatedList
vpnTunnelAggregatedList =
  VPNTunnelAggregatedList'
    { _vtalUnreachables = Nothing
    , _vtalNextPageToken = Nothing
    , _vtalKind = "compute#vpnTunnelAggregatedList"
    , _vtalItems = Nothing
    , _vtalSelfLink = Nothing
    , _vtalWarning = Nothing
    , _vtalId = Nothing
    }


-- | [Output Only] Unreachable resources.
vtalUnreachables :: Lens' VPNTunnelAggregatedList [Text]
vtalUnreachables
  = lens _vtalUnreachables
      (\ s a -> s{_vtalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
vtalNextPageToken :: Lens' VPNTunnelAggregatedList (Maybe Text)
vtalNextPageToken
  = lens _vtalNextPageToken
      (\ s a -> s{_vtalNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#vpnTunnel for VPN
-- tunnels.
vtalKind :: Lens' VPNTunnelAggregatedList Text
vtalKind = lens _vtalKind (\ s a -> s{_vtalKind = a})

-- | A list of VpnTunnelsScopedList resources.
vtalItems :: Lens' VPNTunnelAggregatedList (Maybe VPNTunnelAggregatedListItems)
vtalItems
  = lens _vtalItems (\ s a -> s{_vtalItems = a})

-- | [Output Only] Server-defined URL for this resource.
vtalSelfLink :: Lens' VPNTunnelAggregatedList (Maybe Text)
vtalSelfLink
  = lens _vtalSelfLink (\ s a -> s{_vtalSelfLink = a})

-- | [Output Only] Informational warning message.
vtalWarning :: Lens' VPNTunnelAggregatedList (Maybe VPNTunnelAggregatedListWarning)
vtalWarning
  = lens _vtalWarning (\ s a -> s{_vtalWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
vtalId :: Lens' VPNTunnelAggregatedList (Maybe Text)
vtalId = lens _vtalId (\ s a -> s{_vtalId = a})

instance FromJSON VPNTunnelAggregatedList where
        parseJSON
          = withObject "VPNTunnelAggregatedList"
              (\ o ->
                 VPNTunnelAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!= "compute#vpnTunnelAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON VPNTunnelAggregatedList where
        toJSON VPNTunnelAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _vtalUnreachables,
                  ("nextPageToken" .=) <$> _vtalNextPageToken,
                  Just ("kind" .= _vtalKind),
                  ("items" .=) <$> _vtalItems,
                  ("selfLink" .=) <$> _vtalSelfLink,
                  ("warning" .=) <$> _vtalWarning,
                  ("id" .=) <$> _vtalId])

--
-- /See:/ 'sslPoliciesListWarningDataItem' smart constructor.
data SSLPoliciesListWarningDataItem =
  SSLPoliciesListWarningDataItem'
    { _splwdiValue :: !(Maybe Text)
    , _splwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SSLPoliciesListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'splwdiValue'
--
-- * 'splwdiKey'
sslPoliciesListWarningDataItem
    :: SSLPoliciesListWarningDataItem
sslPoliciesListWarningDataItem =
  SSLPoliciesListWarningDataItem' {_splwdiValue = Nothing, _splwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
splwdiValue :: Lens' SSLPoliciesListWarningDataItem (Maybe Text)
splwdiValue
  = lens _splwdiValue (\ s a -> s{_splwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
splwdiKey :: Lens' SSLPoliciesListWarningDataItem (Maybe Text)
splwdiKey
  = lens _splwdiKey (\ s a -> s{_splwdiKey = a})

instance FromJSON SSLPoliciesListWarningDataItem
         where
        parseJSON
          = withObject "SSLPoliciesListWarningDataItem"
              (\ o ->
                 SSLPoliciesListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON SSLPoliciesListWarningDataItem where
        toJSON SSLPoliciesListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _splwdiValue,
                  ("key" .=) <$> _splwdiKey])

-- | Describes a single physical circuit between the Customer and Google.
-- CircuitInfo objects are created by Google, so all fields are output
-- only.
--
-- /See:/ 'interconnectCircuitInfo' smart constructor.
data InterconnectCircuitInfo =
  InterconnectCircuitInfo'
    { _iciGoogleCircuitId :: !(Maybe Text)
    , _iciCustomerDemarcId :: !(Maybe Text)
    , _iciGoogleDemarcId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectCircuitInfo' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iciGoogleCircuitId'
--
-- * 'iciCustomerDemarcId'
--
-- * 'iciGoogleDemarcId'
interconnectCircuitInfo
    :: InterconnectCircuitInfo
interconnectCircuitInfo =
  InterconnectCircuitInfo'
    { _iciGoogleCircuitId = Nothing
    , _iciCustomerDemarcId = Nothing
    , _iciGoogleDemarcId = Nothing
    }


-- | Google-assigned unique ID for this circuit. Assigned at circuit turn-up.
iciGoogleCircuitId :: Lens' InterconnectCircuitInfo (Maybe Text)
iciGoogleCircuitId
  = lens _iciGoogleCircuitId
      (\ s a -> s{_iciGoogleCircuitId = a})

-- | Customer-side demarc ID for this circuit.
iciCustomerDemarcId :: Lens' InterconnectCircuitInfo (Maybe Text)
iciCustomerDemarcId
  = lens _iciCustomerDemarcId
      (\ s a -> s{_iciCustomerDemarcId = a})

-- | Google-side demarc ID for this circuit. Assigned at circuit turn-up and
-- provided by Google to the customer in the LOA.
iciGoogleDemarcId :: Lens' InterconnectCircuitInfo (Maybe Text)
iciGoogleDemarcId
  = lens _iciGoogleDemarcId
      (\ s a -> s{_iciGoogleDemarcId = a})

instance FromJSON InterconnectCircuitInfo where
        parseJSON
          = withObject "InterconnectCircuitInfo"
              (\ o ->
                 InterconnectCircuitInfo' <$>
                   (o .:? "googleCircuitId") <*>
                     (o .:? "customerDemarcId")
                     <*> (o .:? "googleDemarcId"))

instance ToJSON InterconnectCircuitInfo where
        toJSON InterconnectCircuitInfo'{..}
          = object
              (catMaybes
                 [("googleCircuitId" .=) <$> _iciGoogleCircuitId,
                  ("customerDemarcId" .=) <$> _iciCustomerDemarcId,
                  ("googleDemarcId" .=) <$> _iciGoogleDemarcId])

-- | An instance-attached disk resource.
--
-- /See:/ 'attachedDisk' smart constructor.
data AttachedDisk =
  AttachedDisk'
    { _adDiskSizeGb :: !(Maybe (Textual Int64))
    , _adDiskEncryptionKey :: !(Maybe CustomerEncryptionKey)
    , _adKind :: !Text
    , _adMode :: !(Maybe AttachedDiskMode)
    , _adGuestOSFeatures :: !(Maybe [GuestOSFeature])
    , _adShieldedInstanceInitialState :: !(Maybe InitialStateConfig)
    , _adBoot :: !(Maybe Bool)
    , _adAutoDelete :: !(Maybe Bool)
    , _adInitializeParams :: !(Maybe AttachedDiskInitializeParams)
    , _adDeviceName :: !(Maybe Text)
    , _adInterface :: !(Maybe AttachedDiskInterface)
    , _adSource :: !(Maybe Text)
    , _adLicenses :: !(Maybe [Text])
    , _adType :: !(Maybe AttachedDiskType)
    , _adIndex :: !(Maybe (Textual Int32))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AttachedDisk' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'adDiskSizeGb'
--
-- * 'adDiskEncryptionKey'
--
-- * 'adKind'
--
-- * 'adMode'
--
-- * 'adGuestOSFeatures'
--
-- * 'adShieldedInstanceInitialState'
--
-- * 'adBoot'
--
-- * 'adAutoDelete'
--
-- * 'adInitializeParams'
--
-- * 'adDeviceName'
--
-- * 'adInterface'
--
-- * 'adSource'
--
-- * 'adLicenses'
--
-- * 'adType'
--
-- * 'adIndex'
attachedDisk
    :: AttachedDisk
attachedDisk =
  AttachedDisk'
    { _adDiskSizeGb = Nothing
    , _adDiskEncryptionKey = Nothing
    , _adKind = "compute#attachedDisk"
    , _adMode = Nothing
    , _adGuestOSFeatures = Nothing
    , _adShieldedInstanceInitialState = Nothing
    , _adBoot = Nothing
    , _adAutoDelete = Nothing
    , _adInitializeParams = Nothing
    , _adDeviceName = Nothing
    , _adInterface = Nothing
    , _adSource = Nothing
    , _adLicenses = Nothing
    , _adType = Nothing
    , _adIndex = Nothing
    }


-- | The size of the disk in GB.
adDiskSizeGb :: Lens' AttachedDisk (Maybe Int64)
adDiskSizeGb
  = lens _adDiskSizeGb (\ s a -> s{_adDiskSizeGb = a})
      . mapping _Coerce

-- | Encrypts or decrypts a disk using a customer-supplied encryption key. If
-- you are creating a new disk, this field encrypts the new disk using an
-- encryption key that you provide. If you are attaching an existing disk
-- that is already encrypted, this field decrypts the disk using the
-- customer-supplied encryption key. If you encrypt a disk using a
-- customer-supplied key, you must provide the same key again when you
-- attempt to use this resource at a later time. For example, you must
-- provide the key when you create a snapshot or an image from the disk or
-- when you attach the disk to a virtual machine instance. If you do not
-- provide an encryption key, then the disk will be encrypted using an
-- automatically generated key and you do not need to provide a key to use
-- the disk later. Instance templates do not store customer-supplied
-- encryption keys, so you cannot use your own keys to encrypt disks in a
-- managed instance group.
adDiskEncryptionKey :: Lens' AttachedDisk (Maybe CustomerEncryptionKey)
adDiskEncryptionKey
  = lens _adDiskEncryptionKey
      (\ s a -> s{_adDiskEncryptionKey = a})

-- | [Output Only] Type of the resource. Always compute#attachedDisk for
-- attached disks.
adKind :: Lens' AttachedDisk Text
adKind = lens _adKind (\ s a -> s{_adKind = a})

-- | The mode in which to attach this disk, either READ_WRITE or READ_ONLY.
-- If not specified, the default is to attach the disk in READ_WRITE mode.
adMode :: Lens' AttachedDisk (Maybe AttachedDiskMode)
adMode = lens _adMode (\ s a -> s{_adMode = a})

-- | A list of features to enable on the guest operating system. Applicable
-- only for bootable images. Read Enabling guest operating system features
-- to see a list of available options.
adGuestOSFeatures :: Lens' AttachedDisk [GuestOSFeature]
adGuestOSFeatures
  = lens _adGuestOSFeatures
      (\ s a -> s{_adGuestOSFeatures = a})
      . _Default
      . _Coerce

-- | [Output Only] shielded vm initial state stored on disk
adShieldedInstanceInitialState :: Lens' AttachedDisk (Maybe InitialStateConfig)
adShieldedInstanceInitialState
  = lens _adShieldedInstanceInitialState
      (\ s a -> s{_adShieldedInstanceInitialState = a})

-- | Indicates that this is a boot disk. The virtual machine will use the
-- first partition of the disk for its root filesystem.
adBoot :: Lens' AttachedDisk (Maybe Bool)
adBoot = lens _adBoot (\ s a -> s{_adBoot = a})

-- | Specifies whether the disk will be auto-deleted when the instance is
-- deleted (but not when the disk is detached from the instance).
adAutoDelete :: Lens' AttachedDisk (Maybe Bool)
adAutoDelete
  = lens _adAutoDelete (\ s a -> s{_adAutoDelete = a})

-- | [Input Only] Specifies the parameters for a new disk that will be
-- created alongside the new instance. Use initialization parameters to
-- create boot disks or local SSDs attached to the new instance. This
-- property is mutually exclusive with the source property; you can only
-- define one or the other, but not both.
adInitializeParams :: Lens' AttachedDisk (Maybe AttachedDiskInitializeParams)
adInitializeParams
  = lens _adInitializeParams
      (\ s a -> s{_adInitializeParams = a})

-- | Specifies a unique device name of your choice that is reflected into the
-- \/dev\/disk\/by-id\/google-* tree of a Linux operating system running
-- within the instance. This name can be used to reference the device for
-- mounting, resizing, and so on, from within the instance. If not
-- specified, the server chooses a default device name to apply to this
-- disk, in the form persistent-disk-x, where x is a number assigned by
-- Google Compute Engine. This field is only applicable for persistent
-- disks.
adDeviceName :: Lens' AttachedDisk (Maybe Text)
adDeviceName
  = lens _adDeviceName (\ s a -> s{_adDeviceName = a})

-- | Specifies the disk interface to use for attaching this disk, which is
-- either SCSI or NVME. The default is SCSI. Persistent disks must always
-- use SCSI and the request will fail if you attempt to attach a persistent
-- disk in any other format than SCSI. Local SSDs can use either NVME or
-- SCSI. For performance characteristics of SCSI over NVMe, see Local SSD
-- performance.
adInterface :: Lens' AttachedDisk (Maybe AttachedDiskInterface)
adInterface
  = lens _adInterface (\ s a -> s{_adInterface = a})

-- | Specifies a valid partial or full URL to an existing Persistent Disk
-- resource. When creating a new instance, one of
-- initializeParams.sourceImage or initializeParams.sourceSnapshot or
-- disks.source is required except for local SSD. If desired, you can also
-- attach existing non-root persistent disks using this property. This
-- field is only applicable for persistent disks. Note that for
-- InstanceTemplate, specify the disk name, not the URL for the disk.
adSource :: Lens' AttachedDisk (Maybe Text)
adSource = lens _adSource (\ s a -> s{_adSource = a})

-- | [Output Only] Any valid publicly visible licenses.
adLicenses :: Lens' AttachedDisk [Text]
adLicenses
  = lens _adLicenses (\ s a -> s{_adLicenses = a}) .
      _Default
      . _Coerce

-- | Specifies the type of the disk, either SCRATCH or PERSISTENT. If not
-- specified, the default is PERSISTENT.
adType :: Lens' AttachedDisk (Maybe AttachedDiskType)
adType = lens _adType (\ s a -> s{_adType = a})

-- | [Output Only] A zero-based index to this disk, where 0 is reserved for
-- the boot disk. If you have many disks attached to an instance, each disk
-- would have a unique index number.
adIndex :: Lens' AttachedDisk (Maybe Int32)
adIndex
  = lens _adIndex (\ s a -> s{_adIndex = a}) .
      mapping _Coerce

instance FromJSON AttachedDisk where
        parseJSON
          = withObject "AttachedDisk"
              (\ o ->
                 AttachedDisk' <$>
                   (o .:? "diskSizeGb") <*> (o .:? "diskEncryptionKey")
                     <*> (o .:? "kind" .!= "compute#attachedDisk")
                     <*> (o .:? "mode")
                     <*> (o .:? "guestOsFeatures" .!= mempty)
                     <*> (o .:? "shieldedInstanceInitialState")
                     <*> (o .:? "boot")
                     <*> (o .:? "autoDelete")
                     <*> (o .:? "initializeParams")
                     <*> (o .:? "deviceName")
                     <*> (o .:? "interface")
                     <*> (o .:? "source")
                     <*> (o .:? "licenses" .!= mempty)
                     <*> (o .:? "type")
                     <*> (o .:? "index"))

instance ToJSON AttachedDisk where
        toJSON AttachedDisk'{..}
          = object
              (catMaybes
                 [("diskSizeGb" .=) <$> _adDiskSizeGb,
                  ("diskEncryptionKey" .=) <$> _adDiskEncryptionKey,
                  Just ("kind" .= _adKind), ("mode" .=) <$> _adMode,
                  ("guestOsFeatures" .=) <$> _adGuestOSFeatures,
                  ("shieldedInstanceInitialState" .=) <$>
                    _adShieldedInstanceInitialState,
                  ("boot" .=) <$> _adBoot,
                  ("autoDelete" .=) <$> _adAutoDelete,
                  ("initializeParams" .=) <$> _adInitializeParams,
                  ("deviceName" .=) <$> _adDeviceName,
                  ("interface" .=) <$> _adInterface,
                  ("source" .=) <$> _adSource,
                  ("licenses" .=) <$> _adLicenses,
                  ("type" .=) <$> _adType, ("index" .=) <$> _adIndex])

-- | Specifies the delay introduced by Loadbalancer before forwarding the
-- request to the backend service as part of fault injection.
--
-- /See:/ 'hTTPFaultDelay' smart constructor.
data HTTPFaultDelay =
  HTTPFaultDelay'
    { _httpfdPercentage :: !(Maybe (Textual Double))
    , _httpfdFixedDelay :: !(Maybe Duration)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HTTPFaultDelay' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'httpfdPercentage'
--
-- * 'httpfdFixedDelay'
hTTPFaultDelay
    :: HTTPFaultDelay
hTTPFaultDelay =
  HTTPFaultDelay' {_httpfdPercentage = Nothing, _httpfdFixedDelay = Nothing}


-- | The percentage of traffic (connections\/operations\/requests) on which
-- delay will be introduced as part of fault injection. The value must be
-- between 0.0 and 100.0 inclusive.
httpfdPercentage :: Lens' HTTPFaultDelay (Maybe Double)
httpfdPercentage
  = lens _httpfdPercentage
      (\ s a -> s{_httpfdPercentage = a})
      . mapping _Coerce

-- | Specifies the value of the fixed delay interval.
httpfdFixedDelay :: Lens' HTTPFaultDelay (Maybe Duration)
httpfdFixedDelay
  = lens _httpfdFixedDelay
      (\ s a -> s{_httpfdFixedDelay = a})

instance FromJSON HTTPFaultDelay where
        parseJSON
          = withObject "HTTPFaultDelay"
              (\ o ->
                 HTTPFaultDelay' <$>
                   (o .:? "percentage") <*> (o .:? "fixedDelay"))

instance ToJSON HTTPFaultDelay where
        toJSON HTTPFaultDelay'{..}
          = object
              (catMaybes
                 [("percentage" .=) <$> _httpfdPercentage,
                  ("fixedDelay" .=) <$> _httpfdFixedDelay])

--
-- /See:/ 'hTTPHealthCheckListWarningDataItem' smart constructor.
data HTTPHealthCheckListWarningDataItem =
  HTTPHealthCheckListWarningDataItem'
    { _httphclwdiValue :: !(Maybe Text)
    , _httphclwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HTTPHealthCheckListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'httphclwdiValue'
--
-- * 'httphclwdiKey'
hTTPHealthCheckListWarningDataItem
    :: HTTPHealthCheckListWarningDataItem
hTTPHealthCheckListWarningDataItem =
  HTTPHealthCheckListWarningDataItem'
    {_httphclwdiValue = Nothing, _httphclwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
httphclwdiValue :: Lens' HTTPHealthCheckListWarningDataItem (Maybe Text)
httphclwdiValue
  = lens _httphclwdiValue
      (\ s a -> s{_httphclwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
httphclwdiKey :: Lens' HTTPHealthCheckListWarningDataItem (Maybe Text)
httphclwdiKey
  = lens _httphclwdiKey
      (\ s a -> s{_httphclwdiKey = a})

instance FromJSON HTTPHealthCheckListWarningDataItem
         where
        parseJSON
          = withObject "HTTPHealthCheckListWarningDataItem"
              (\ o ->
                 HTTPHealthCheckListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON HTTPHealthCheckListWarningDataItem
         where
        toJSON HTTPHealthCheckListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _httphclwdiValue,
                  ("key" .=) <$> _httphclwdiKey])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'exchangedPeeringRoutesListWarning' smart constructor.
data ExchangedPeeringRoutesListWarning =
  ExchangedPeeringRoutesListWarning'
    { _eprlwData :: !(Maybe [ExchangedPeeringRoutesListWarningDataItem])
    , _eprlwCode :: !(Maybe ExchangedPeeringRoutesListWarningCode)
    , _eprlwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ExchangedPeeringRoutesListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'eprlwData'
--
-- * 'eprlwCode'
--
-- * 'eprlwMessage'
exchangedPeeringRoutesListWarning
    :: ExchangedPeeringRoutesListWarning
exchangedPeeringRoutesListWarning =
  ExchangedPeeringRoutesListWarning'
    {_eprlwData = Nothing, _eprlwCode = Nothing, _eprlwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
eprlwData :: Lens' ExchangedPeeringRoutesListWarning [ExchangedPeeringRoutesListWarningDataItem]
eprlwData
  = lens _eprlwData (\ s a -> s{_eprlwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
eprlwCode :: Lens' ExchangedPeeringRoutesListWarning (Maybe ExchangedPeeringRoutesListWarningCode)
eprlwCode
  = lens _eprlwCode (\ s a -> s{_eprlwCode = a})

-- | [Output Only] A human-readable description of the warning code.
eprlwMessage :: Lens' ExchangedPeeringRoutesListWarning (Maybe Text)
eprlwMessage
  = lens _eprlwMessage (\ s a -> s{_eprlwMessage = a})

instance FromJSON ExchangedPeeringRoutesListWarning
         where
        parseJSON
          = withObject "ExchangedPeeringRoutesListWarning"
              (\ o ->
                 ExchangedPeeringRoutesListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON ExchangedPeeringRoutesListWarning
         where
        toJSON ExchangedPeeringRoutesListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _eprlwData,
                  ("code" .=) <$> _eprlwCode,
                  ("message" .=) <$> _eprlwMessage])

-- | Policy for retention of scheduled snapshots.
--
-- /See:/ 'resourcePolicySnapshotSchedulePolicyRetentionPolicy' smart constructor.
data ResourcePolicySnapshotSchedulePolicyRetentionPolicy =
  ResourcePolicySnapshotSchedulePolicyRetentionPolicy'
    { _rpssprpMaxRetentionDays :: !(Maybe (Textual Int32))
    , _rpssprpOnSourceDiskDelete :: !(Maybe ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePolicySnapshotSchedulePolicyRetentionPolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rpssprpMaxRetentionDays'
--
-- * 'rpssprpOnSourceDiskDelete'
resourcePolicySnapshotSchedulePolicyRetentionPolicy
    :: ResourcePolicySnapshotSchedulePolicyRetentionPolicy
resourcePolicySnapshotSchedulePolicyRetentionPolicy =
  ResourcePolicySnapshotSchedulePolicyRetentionPolicy'
    {_rpssprpMaxRetentionDays = Nothing, _rpssprpOnSourceDiskDelete = Nothing}


-- | Maximum age of the snapshot that is allowed to be kept.
rpssprpMaxRetentionDays :: Lens' ResourcePolicySnapshotSchedulePolicyRetentionPolicy (Maybe Int32)
rpssprpMaxRetentionDays
  = lens _rpssprpMaxRetentionDays
      (\ s a -> s{_rpssprpMaxRetentionDays = a})
      . mapping _Coerce

-- | Specifies the behavior to apply to scheduled snapshots when the source
-- disk is deleted.
rpssprpOnSourceDiskDelete :: Lens' ResourcePolicySnapshotSchedulePolicyRetentionPolicy (Maybe ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete)
rpssprpOnSourceDiskDelete
  = lens _rpssprpOnSourceDiskDelete
      (\ s a -> s{_rpssprpOnSourceDiskDelete = a})

instance FromJSON
           ResourcePolicySnapshotSchedulePolicyRetentionPolicy
         where
        parseJSON
          = withObject
              "ResourcePolicySnapshotSchedulePolicyRetentionPolicy"
              (\ o ->
                 ResourcePolicySnapshotSchedulePolicyRetentionPolicy'
                   <$>
                   (o .:? "maxRetentionDays") <*>
                     (o .:? "onSourceDiskDelete"))

instance ToJSON
           ResourcePolicySnapshotSchedulePolicyRetentionPolicy
         where
        toJSON
          ResourcePolicySnapshotSchedulePolicyRetentionPolicy'{..}
          = object
              (catMaybes
                 [("maxRetentionDays" .=) <$>
                    _rpssprpMaxRetentionDays,
                  ("onSourceDiskDelete" .=) <$>
                    _rpssprpOnSourceDiskDelete])

-- | Contains a list of disk types.
--
-- /See:/ 'diskTypeList' smart constructor.
data DiskTypeList =
  DiskTypeList'
    { _dtlNextPageToken :: !(Maybe Text)
    , _dtlKind :: !Text
    , _dtlItems :: !(Maybe [DiskType])
    , _dtlSelfLink :: !(Maybe Text)
    , _dtlWarning :: !(Maybe DiskTypeListWarning)
    , _dtlId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DiskTypeList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dtlNextPageToken'
--
-- * 'dtlKind'
--
-- * 'dtlItems'
--
-- * 'dtlSelfLink'
--
-- * 'dtlWarning'
--
-- * 'dtlId'
diskTypeList
    :: DiskTypeList
diskTypeList =
  DiskTypeList'
    { _dtlNextPageToken = Nothing
    , _dtlKind = "compute#diskTypeList"
    , _dtlItems = Nothing
    , _dtlSelfLink = Nothing
    , _dtlWarning = Nothing
    , _dtlId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
dtlNextPageToken :: Lens' DiskTypeList (Maybe Text)
dtlNextPageToken
  = lens _dtlNextPageToken
      (\ s a -> s{_dtlNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#diskTypeList for disk
-- types.
dtlKind :: Lens' DiskTypeList Text
dtlKind = lens _dtlKind (\ s a -> s{_dtlKind = a})

-- | A list of DiskType resources.
dtlItems :: Lens' DiskTypeList [DiskType]
dtlItems
  = lens _dtlItems (\ s a -> s{_dtlItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
dtlSelfLink :: Lens' DiskTypeList (Maybe Text)
dtlSelfLink
  = lens _dtlSelfLink (\ s a -> s{_dtlSelfLink = a})

-- | [Output Only] Informational warning message.
dtlWarning :: Lens' DiskTypeList (Maybe DiskTypeListWarning)
dtlWarning
  = lens _dtlWarning (\ s a -> s{_dtlWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
dtlId :: Lens' DiskTypeList (Maybe Text)
dtlId = lens _dtlId (\ s a -> s{_dtlId = a})

instance FromJSON DiskTypeList where
        parseJSON
          = withObject "DiskTypeList"
              (\ o ->
                 DiskTypeList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#diskTypeList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON DiskTypeList where
        toJSON DiskTypeList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _dtlNextPageToken,
                  Just ("kind" .= _dtlKind),
                  ("items" .=) <$> _dtlItems,
                  ("selfLink" .=) <$> _dtlSelfLink,
                  ("warning" .=) <$> _dtlWarning,
                  ("id" .=) <$> _dtlId])

--
-- /See:/ 'regionInstanceGroupsSetNamedPortsRequest' smart constructor.
data RegionInstanceGroupsSetNamedPortsRequest =
  RegionInstanceGroupsSetNamedPortsRequest'
    { _rigsnprFingerprint :: !(Maybe Bytes)
    , _rigsnprNamedPorts :: !(Maybe [NamedPort])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupsSetNamedPortsRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rigsnprFingerprint'
--
-- * 'rigsnprNamedPorts'
regionInstanceGroupsSetNamedPortsRequest
    :: RegionInstanceGroupsSetNamedPortsRequest
regionInstanceGroupsSetNamedPortsRequest =
  RegionInstanceGroupsSetNamedPortsRequest'
    {_rigsnprFingerprint = Nothing, _rigsnprNamedPorts = Nothing}


-- | The fingerprint of the named ports information for this instance group.
-- Use this optional property to prevent conflicts when multiple users
-- change the named ports settings concurrently. Obtain the fingerprint
-- with the instanceGroups.get method. Then, include the fingerprint in
-- your request to ensure that you do not overwrite changes that were
-- applied from another concurrent request.
rigsnprFingerprint :: Lens' RegionInstanceGroupsSetNamedPortsRequest (Maybe ByteString)
rigsnprFingerprint
  = lens _rigsnprFingerprint
      (\ s a -> s{_rigsnprFingerprint = a})
      . mapping _Bytes

-- | The list of named ports to set for this instance group.
rigsnprNamedPorts :: Lens' RegionInstanceGroupsSetNamedPortsRequest [NamedPort]
rigsnprNamedPorts
  = lens _rigsnprNamedPorts
      (\ s a -> s{_rigsnprNamedPorts = a})
      . _Default
      . _Coerce

instance FromJSON
           RegionInstanceGroupsSetNamedPortsRequest
         where
        parseJSON
          = withObject
              "RegionInstanceGroupsSetNamedPortsRequest"
              (\ o ->
                 RegionInstanceGroupsSetNamedPortsRequest' <$>
                   (o .:? "fingerprint") <*>
                     (o .:? "namedPorts" .!= mempty))

instance ToJSON
           RegionInstanceGroupsSetNamedPortsRequest
         where
        toJSON RegionInstanceGroupsSetNamedPortsRequest'{..}
          = object
              (catMaybes
                 [("fingerprint" .=) <$> _rigsnprFingerprint,
                  ("namedPorts" .=) <$> _rigsnprNamedPorts])

--
-- /See:/ 'reservationsScopedList' smart constructor.
data ReservationsScopedList =
  ReservationsScopedList'
    { _rslsWarning :: !(Maybe ReservationsScopedListWarning)
    , _rslsReservations :: !(Maybe [Reservation])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ReservationsScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rslsWarning'
--
-- * 'rslsReservations'
reservationsScopedList
    :: ReservationsScopedList
reservationsScopedList =
  ReservationsScopedList' {_rslsWarning = Nothing, _rslsReservations = Nothing}


-- | Informational warning which replaces the list of reservations when the
-- list is empty.
rslsWarning :: Lens' ReservationsScopedList (Maybe ReservationsScopedListWarning)
rslsWarning
  = lens _rslsWarning (\ s a -> s{_rslsWarning = a})

-- | A list of reservations contained in this scope.
rslsReservations :: Lens' ReservationsScopedList [Reservation]
rslsReservations
  = lens _rslsReservations
      (\ s a -> s{_rslsReservations = a})
      . _Default
      . _Coerce

instance FromJSON ReservationsScopedList where
        parseJSON
          = withObject "ReservationsScopedList"
              (\ o ->
                 ReservationsScopedList' <$>
                   (o .:? "warning") <*>
                     (o .:? "reservations" .!= mempty))

instance ToJSON ReservationsScopedList where
        toJSON ReservationsScopedList'{..}
          = object
              (catMaybes
                 [("warning" .=) <$> _rslsWarning,
                  ("reservations" .=) <$> _rslsReservations])

--
-- /See:/ 'testPermissionsRequest' smart constructor.
newtype TestPermissionsRequest =
  TestPermissionsRequest'
    { _tPermissions :: Maybe [Text]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TestPermissionsRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tPermissions'
testPermissionsRequest
    :: TestPermissionsRequest
testPermissionsRequest = TestPermissionsRequest' {_tPermissions = Nothing}


-- | The set of permissions to check for the \'resource\'. Permissions with
-- wildcards (such as \'*\' or \'storage.*\') are not allowed.
tPermissions :: Lens' TestPermissionsRequest [Text]
tPermissions
  = lens _tPermissions (\ s a -> s{_tPermissions = a})
      . _Default
      . _Coerce

instance FromJSON TestPermissionsRequest where
        parseJSON
          = withObject "TestPermissionsRequest"
              (\ o ->
                 TestPermissionsRequest' <$>
                   (o .:? "permissions" .!= mempty))

instance ToJSON TestPermissionsRequest where
        toJSON TestPermissionsRequest'{..}
          = object
              (catMaybes [("permissions" .=) <$> _tPermissions])

--
-- /See:/ 'targetTCPProxyListWarningDataItem' smart constructor.
data TargetTCPProxyListWarningDataItem =
  TargetTCPProxyListWarningDataItem'
    { _ttplwdiValue :: !(Maybe Text)
    , _ttplwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetTCPProxyListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ttplwdiValue'
--
-- * 'ttplwdiKey'
targetTCPProxyListWarningDataItem
    :: TargetTCPProxyListWarningDataItem
targetTCPProxyListWarningDataItem =
  TargetTCPProxyListWarningDataItem'
    {_ttplwdiValue = Nothing, _ttplwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
ttplwdiValue :: Lens' TargetTCPProxyListWarningDataItem (Maybe Text)
ttplwdiValue
  = lens _ttplwdiValue (\ s a -> s{_ttplwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
ttplwdiKey :: Lens' TargetTCPProxyListWarningDataItem (Maybe Text)
ttplwdiKey
  = lens _ttplwdiKey (\ s a -> s{_ttplwdiKey = a})

instance FromJSON TargetTCPProxyListWarningDataItem
         where
        parseJSON
          = withObject "TargetTCPProxyListWarningDataItem"
              (\ o ->
                 TargetTCPProxyListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON TargetTCPProxyListWarningDataItem
         where
        toJSON TargetTCPProxyListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _ttplwdiValue,
                  ("key" .=) <$> _ttplwdiKey])

-- | A guest attributes entry.
--
-- /See:/ 'guestAttributes' smart constructor.
data GuestAttributes =
  GuestAttributes'
    { _gaKind :: !Text
    , _gaVariableKey :: !(Maybe Text)
    , _gaSelfLink :: !(Maybe Text)
    , _gaQueryPath :: !(Maybe Text)
    , _gaVariableValue :: !(Maybe Text)
    , _gaQueryValue :: !(Maybe GuestAttributesValue)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'GuestAttributes' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'gaKind'
--
-- * 'gaVariableKey'
--
-- * 'gaSelfLink'
--
-- * 'gaQueryPath'
--
-- * 'gaVariableValue'
--
-- * 'gaQueryValue'
guestAttributes
    :: GuestAttributes
guestAttributes =
  GuestAttributes'
    { _gaKind = "compute#guestAttributes"
    , _gaVariableKey = Nothing
    , _gaSelfLink = Nothing
    , _gaQueryPath = Nothing
    , _gaVariableValue = Nothing
    , _gaQueryValue = Nothing
    }


-- | [Output Only] Type of the resource. Always compute#guestAttributes for
-- guest attributes entry.
gaKind :: Lens' GuestAttributes Text
gaKind = lens _gaKind (\ s a -> s{_gaKind = a})

-- | The key to search for.
gaVariableKey :: Lens' GuestAttributes (Maybe Text)
gaVariableKey
  = lens _gaVariableKey
      (\ s a -> s{_gaVariableKey = a})

-- | [Output Only] Server-defined URL for this resource.
gaSelfLink :: Lens' GuestAttributes (Maybe Text)
gaSelfLink
  = lens _gaSelfLink (\ s a -> s{_gaSelfLink = a})

-- | The path to be queried. This can be the default namespace (\'\/\') or a
-- nested namespace (\'\/\\\/\') or a specified key (\'\/\\\/\\\')
gaQueryPath :: Lens' GuestAttributes (Maybe Text)
gaQueryPath
  = lens _gaQueryPath (\ s a -> s{_gaQueryPath = a})

-- | [Output Only] The value found for the requested key.
gaVariableValue :: Lens' GuestAttributes (Maybe Text)
gaVariableValue
  = lens _gaVariableValue
      (\ s a -> s{_gaVariableValue = a})

-- | [Output Only] The value of the requested queried path.
gaQueryValue :: Lens' GuestAttributes (Maybe GuestAttributesValue)
gaQueryValue
  = lens _gaQueryValue (\ s a -> s{_gaQueryValue = a})

instance FromJSON GuestAttributes where
        parseJSON
          = withObject "GuestAttributes"
              (\ o ->
                 GuestAttributes' <$>
                   (o .:? "kind" .!= "compute#guestAttributes") <*>
                     (o .:? "variableKey")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "queryPath")
                     <*> (o .:? "variableValue")
                     <*> (o .:? "queryValue"))

instance ToJSON GuestAttributes where
        toJSON GuestAttributes'{..}
          = object
              (catMaybes
                 [Just ("kind" .= _gaKind),
                  ("variableKey" .=) <$> _gaVariableKey,
                  ("selfLink" .=) <$> _gaSelfLink,
                  ("queryPath" .=) <$> _gaQueryPath,
                  ("variableValue" .=) <$> _gaVariableValue,
                  ("queryValue" .=) <$> _gaQueryValue])

--
-- /See:/ 'projectsGetXpnResources' smart constructor.
data ProjectsGetXpnResources =
  ProjectsGetXpnResources'
    { _pgxrNextPageToken :: !(Maybe Text)
    , _pgxrKind :: !Text
    , _pgxrResources :: !(Maybe [XpnResourceId])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ProjectsGetXpnResources' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pgxrNextPageToken'
--
-- * 'pgxrKind'
--
-- * 'pgxrResources'
projectsGetXpnResources
    :: ProjectsGetXpnResources
projectsGetXpnResources =
  ProjectsGetXpnResources'
    { _pgxrNextPageToken = Nothing
    , _pgxrKind = "compute#projectsGetXpnResources"
    , _pgxrResources = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
pgxrNextPageToken :: Lens' ProjectsGetXpnResources (Maybe Text)
pgxrNextPageToken
  = lens _pgxrNextPageToken
      (\ s a -> s{_pgxrNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#projectsGetXpnResources
-- for lists of service resources (a.k.a service projects)
pgxrKind :: Lens' ProjectsGetXpnResources Text
pgxrKind = lens _pgxrKind (\ s a -> s{_pgxrKind = a})

-- | Service resources (a.k.a service projects) attached to this project as
-- their shared VPC host.
pgxrResources :: Lens' ProjectsGetXpnResources [XpnResourceId]
pgxrResources
  = lens _pgxrResources
      (\ s a -> s{_pgxrResources = a})
      . _Default
      . _Coerce

instance FromJSON ProjectsGetXpnResources where
        parseJSON
          = withObject "ProjectsGetXpnResources"
              (\ o ->
                 ProjectsGetXpnResources' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#projectsGetXpnResources")
                     <*> (o .:? "resources" .!= mempty))

instance ToJSON ProjectsGetXpnResources where
        toJSON ProjectsGetXpnResources'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _pgxrNextPageToken,
                  Just ("kind" .= _pgxrKind),
                  ("resources" .=) <$> _pgxrResources])

--
-- /See:/ 'networkEndpointWithHealthStatus' smart constructor.
data NetworkEndpointWithHealthStatus =
  NetworkEndpointWithHealthStatus'
    { _newhsHealths :: !(Maybe [HealthStatusForNetworkEndpoint])
    , _newhsNetworkEndpoint :: !(Maybe NetworkEndpoint)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkEndpointWithHealthStatus' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'newhsHealths'
--
-- * 'newhsNetworkEndpoint'
networkEndpointWithHealthStatus
    :: NetworkEndpointWithHealthStatus
networkEndpointWithHealthStatus =
  NetworkEndpointWithHealthStatus'
    {_newhsHealths = Nothing, _newhsNetworkEndpoint = Nothing}


-- | [Output only] The health status of network endpoint;
newhsHealths :: Lens' NetworkEndpointWithHealthStatus [HealthStatusForNetworkEndpoint]
newhsHealths
  = lens _newhsHealths (\ s a -> s{_newhsHealths = a})
      . _Default
      . _Coerce

-- | [Output only] The network endpoint;
newhsNetworkEndpoint :: Lens' NetworkEndpointWithHealthStatus (Maybe NetworkEndpoint)
newhsNetworkEndpoint
  = lens _newhsNetworkEndpoint
      (\ s a -> s{_newhsNetworkEndpoint = a})

instance FromJSON NetworkEndpointWithHealthStatus
         where
        parseJSON
          = withObject "NetworkEndpointWithHealthStatus"
              (\ o ->
                 NetworkEndpointWithHealthStatus' <$>
                   (o .:? "healths" .!= mempty) <*>
                     (o .:? "networkEndpoint"))

instance ToJSON NetworkEndpointWithHealthStatus where
        toJSON NetworkEndpointWithHealthStatus'{..}
          = object
              (catMaybes
                 [("healths" .=) <$> _newhsHealths,
                  ("networkEndpoint" .=) <$> _newhsNetworkEndpoint])

-- | Contains a list of machine types.
--
-- /See:/ 'machineTypeList' smart constructor.
data MachineTypeList =
  MachineTypeList'
    { _mtlNextPageToken :: !(Maybe Text)
    , _mtlKind :: !Text
    , _mtlItems :: !(Maybe [MachineType])
    , _mtlSelfLink :: !(Maybe Text)
    , _mtlWarning :: !(Maybe MachineTypeListWarning)
    , _mtlId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'MachineTypeList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'mtlNextPageToken'
--
-- * 'mtlKind'
--
-- * 'mtlItems'
--
-- * 'mtlSelfLink'
--
-- * 'mtlWarning'
--
-- * 'mtlId'
machineTypeList
    :: MachineTypeList
machineTypeList =
  MachineTypeList'
    { _mtlNextPageToken = Nothing
    , _mtlKind = "compute#machineTypeList"
    , _mtlItems = Nothing
    , _mtlSelfLink = Nothing
    , _mtlWarning = Nothing
    , _mtlId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
mtlNextPageToken :: Lens' MachineTypeList (Maybe Text)
mtlNextPageToken
  = lens _mtlNextPageToken
      (\ s a -> s{_mtlNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#machineTypeList for lists
-- of machine types.
mtlKind :: Lens' MachineTypeList Text
mtlKind = lens _mtlKind (\ s a -> s{_mtlKind = a})

-- | A list of MachineType resources.
mtlItems :: Lens' MachineTypeList [MachineType]
mtlItems
  = lens _mtlItems (\ s a -> s{_mtlItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
mtlSelfLink :: Lens' MachineTypeList (Maybe Text)
mtlSelfLink
  = lens _mtlSelfLink (\ s a -> s{_mtlSelfLink = a})

-- | [Output Only] Informational warning message.
mtlWarning :: Lens' MachineTypeList (Maybe MachineTypeListWarning)
mtlWarning
  = lens _mtlWarning (\ s a -> s{_mtlWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
mtlId :: Lens' MachineTypeList (Maybe Text)
mtlId = lens _mtlId (\ s a -> s{_mtlId = a})

instance FromJSON MachineTypeList where
        parseJSON
          = withObject "MachineTypeList"
              (\ o ->
                 MachineTypeList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#machineTypeList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON MachineTypeList where
        toJSON MachineTypeList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _mtlNextPageToken,
                  Just ("kind" .= _mtlKind),
                  ("items" .=) <$> _mtlItems,
                  ("selfLink" .=) <$> _mtlSelfLink,
                  ("warning" .=) <$> _mtlWarning,
                  ("id" .=) <$> _mtlId])

-- | A list of TargetHttpProxy resources.
--
-- /See:/ 'targetHTTPProxyList' smart constructor.
data TargetHTTPProxyList =
  TargetHTTPProxyList'
    { _thttpplNextPageToken :: !(Maybe Text)
    , _thttpplKind :: !Text
    , _thttpplItems :: !(Maybe [TargetHTTPProxy])
    , _thttpplSelfLink :: !(Maybe Text)
    , _thttpplWarning :: !(Maybe TargetHTTPProxyListWarning)
    , _thttpplId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetHTTPProxyList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'thttpplNextPageToken'
--
-- * 'thttpplKind'
--
-- * 'thttpplItems'
--
-- * 'thttpplSelfLink'
--
-- * 'thttpplWarning'
--
-- * 'thttpplId'
targetHTTPProxyList
    :: TargetHTTPProxyList
targetHTTPProxyList =
  TargetHTTPProxyList'
    { _thttpplNextPageToken = Nothing
    , _thttpplKind = "compute#targetHttpProxyList"
    , _thttpplItems = Nothing
    , _thttpplSelfLink = Nothing
    , _thttpplWarning = Nothing
    , _thttpplId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
thttpplNextPageToken :: Lens' TargetHTTPProxyList (Maybe Text)
thttpplNextPageToken
  = lens _thttpplNextPageToken
      (\ s a -> s{_thttpplNextPageToken = a})

-- | Type of resource. Always compute#targetHttpProxyList for lists of target
-- HTTP proxies.
thttpplKind :: Lens' TargetHTTPProxyList Text
thttpplKind
  = lens _thttpplKind (\ s a -> s{_thttpplKind = a})

-- | A list of TargetHttpProxy resources.
thttpplItems :: Lens' TargetHTTPProxyList [TargetHTTPProxy]
thttpplItems
  = lens _thttpplItems (\ s a -> s{_thttpplItems = a})
      . _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
thttpplSelfLink :: Lens' TargetHTTPProxyList (Maybe Text)
thttpplSelfLink
  = lens _thttpplSelfLink
      (\ s a -> s{_thttpplSelfLink = a})

-- | [Output Only] Informational warning message.
thttpplWarning :: Lens' TargetHTTPProxyList (Maybe TargetHTTPProxyListWarning)
thttpplWarning
  = lens _thttpplWarning
      (\ s a -> s{_thttpplWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
thttpplId :: Lens' TargetHTTPProxyList (Maybe Text)
thttpplId
  = lens _thttpplId (\ s a -> s{_thttpplId = a})

instance FromJSON TargetHTTPProxyList where
        parseJSON
          = withObject "TargetHTTPProxyList"
              (\ o ->
                 TargetHTTPProxyList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#targetHttpProxyList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON TargetHTTPProxyList where
        toJSON TargetHTTPProxyList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _thttpplNextPageToken,
                  Just ("kind" .= _thttpplKind),
                  ("items" .=) <$> _thttpplItems,
                  ("selfLink" .=) <$> _thttpplSelfLink,
                  ("warning" .=) <$> _thttpplWarning,
                  ("id" .=) <$> _thttpplId])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'nodeGroupsListNodesWarning' smart constructor.
data NodeGroupsListNodesWarning =
  NodeGroupsListNodesWarning'
    { _nglnwData :: !(Maybe [NodeGroupsListNodesWarningDataItem])
    , _nglnwCode :: !(Maybe NodeGroupsListNodesWarningCode)
    , _nglnwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeGroupsListNodesWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nglnwData'
--
-- * 'nglnwCode'
--
-- * 'nglnwMessage'
nodeGroupsListNodesWarning
    :: NodeGroupsListNodesWarning
nodeGroupsListNodesWarning =
  NodeGroupsListNodesWarning'
    {_nglnwData = Nothing, _nglnwCode = Nothing, _nglnwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
nglnwData :: Lens' NodeGroupsListNodesWarning [NodeGroupsListNodesWarningDataItem]
nglnwData
  = lens _nglnwData (\ s a -> s{_nglnwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
nglnwCode :: Lens' NodeGroupsListNodesWarning (Maybe NodeGroupsListNodesWarningCode)
nglnwCode
  = lens _nglnwCode (\ s a -> s{_nglnwCode = a})

-- | [Output Only] A human-readable description of the warning code.
nglnwMessage :: Lens' NodeGroupsListNodesWarning (Maybe Text)
nglnwMessage
  = lens _nglnwMessage (\ s a -> s{_nglnwMessage = a})

instance FromJSON NodeGroupsListNodesWarning where
        parseJSON
          = withObject "NodeGroupsListNodesWarning"
              (\ o ->
                 NodeGroupsListNodesWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON NodeGroupsListNodesWarning where
        toJSON NodeGroupsListNodesWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _nglnwData,
                  ("code" .=) <$> _nglnwCode,
                  ("message" .=) <$> _nglnwMessage])

--
-- /See:/ 'nodeTemplateAggregatedList' smart constructor.
data NodeTemplateAggregatedList =
  NodeTemplateAggregatedList'
    { _nodUnreachables :: !(Maybe [Text])
    , _nodNextPageToken :: !(Maybe Text)
    , _nodKind :: !Text
    , _nodItems :: !(Maybe NodeTemplateAggregatedListItems)
    , _nodSelfLink :: !(Maybe Text)
    , _nodWarning :: !(Maybe NodeTemplateAggregatedListWarning)
    , _nodId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeTemplateAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nodUnreachables'
--
-- * 'nodNextPageToken'
--
-- * 'nodKind'
--
-- * 'nodItems'
--
-- * 'nodSelfLink'
--
-- * 'nodWarning'
--
-- * 'nodId'
nodeTemplateAggregatedList
    :: NodeTemplateAggregatedList
nodeTemplateAggregatedList =
  NodeTemplateAggregatedList'
    { _nodUnreachables = Nothing
    , _nodNextPageToken = Nothing
    , _nodKind = "compute#nodeTemplateAggregatedList"
    , _nodItems = Nothing
    , _nodSelfLink = Nothing
    , _nodWarning = Nothing
    , _nodId = Nothing
    }


-- | [Output Only] Unreachable resources.
nodUnreachables :: Lens' NodeTemplateAggregatedList [Text]
nodUnreachables
  = lens _nodUnreachables
      (\ s a -> s{_nodUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
nodNextPageToken :: Lens' NodeTemplateAggregatedList (Maybe Text)
nodNextPageToken
  = lens _nodNextPageToken
      (\ s a -> s{_nodNextPageToken = a})

-- | [Output Only] Type of resource.Always compute#nodeTemplateAggregatedList
-- for aggregated lists of node templates.
nodKind :: Lens' NodeTemplateAggregatedList Text
nodKind = lens _nodKind (\ s a -> s{_nodKind = a})

-- | A list of NodeTemplatesScopedList resources.
nodItems :: Lens' NodeTemplateAggregatedList (Maybe NodeTemplateAggregatedListItems)
nodItems = lens _nodItems (\ s a -> s{_nodItems = a})

-- | [Output Only] Server-defined URL for this resource.
nodSelfLink :: Lens' NodeTemplateAggregatedList (Maybe Text)
nodSelfLink
  = lens _nodSelfLink (\ s a -> s{_nodSelfLink = a})

-- | [Output Only] Informational warning message.
nodWarning :: Lens' NodeTemplateAggregatedList (Maybe NodeTemplateAggregatedListWarning)
nodWarning
  = lens _nodWarning (\ s a -> s{_nodWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
nodId :: Lens' NodeTemplateAggregatedList (Maybe Text)
nodId = lens _nodId (\ s a -> s{_nodId = a})

instance FromJSON NodeTemplateAggregatedList where
        parseJSON
          = withObject "NodeTemplateAggregatedList"
              (\ o ->
                 NodeTemplateAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!=
                        "compute#nodeTemplateAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON NodeTemplateAggregatedList where
        toJSON NodeTemplateAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _nodUnreachables,
                  ("nextPageToken" .=) <$> _nodNextPageToken,
                  Just ("kind" .= _nodKind),
                  ("items" .=) <$> _nodItems,
                  ("selfLink" .=) <$> _nodSelfLink,
                  ("warning" .=) <$> _nodWarning,
                  ("id" .=) <$> _nodId])

-- | Response to the list request, and contains a list of
-- externalVpnGateways.
--
-- /See:/ 'externalVPNGatewayList' smart constructor.
data ExternalVPNGatewayList =
  ExternalVPNGatewayList'
    { _evglEtag :: !(Maybe Text)
    , _evglNextPageToken :: !(Maybe Text)
    , _evglKind :: !Text
    , _evglItems :: !(Maybe [ExternalVPNGateway])
    , _evglSelfLink :: !(Maybe Text)
    , _evglWarning :: !(Maybe ExternalVPNGatewayListWarning)
    , _evglId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ExternalVPNGatewayList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'evglEtag'
--
-- * 'evglNextPageToken'
--
-- * 'evglKind'
--
-- * 'evglItems'
--
-- * 'evglSelfLink'
--
-- * 'evglWarning'
--
-- * 'evglId'
externalVPNGatewayList
    :: ExternalVPNGatewayList
externalVPNGatewayList =
  ExternalVPNGatewayList'
    { _evglEtag = Nothing
    , _evglNextPageToken = Nothing
    , _evglKind = "compute#externalVpnGatewayList"
    , _evglItems = Nothing
    , _evglSelfLink = Nothing
    , _evglWarning = Nothing
    , _evglId = Nothing
    }


evglEtag :: Lens' ExternalVPNGatewayList (Maybe Text)
evglEtag = lens _evglEtag (\ s a -> s{_evglEtag = a})

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
evglNextPageToken :: Lens' ExternalVPNGatewayList (Maybe Text)
evglNextPageToken
  = lens _evglNextPageToken
      (\ s a -> s{_evglNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#externalVpnGatewayList
-- for lists of externalVpnGateways.
evglKind :: Lens' ExternalVPNGatewayList Text
evglKind = lens _evglKind (\ s a -> s{_evglKind = a})

-- | A list of ExternalVpnGateway resources.
evglItems :: Lens' ExternalVPNGatewayList [ExternalVPNGateway]
evglItems
  = lens _evglItems (\ s a -> s{_evglItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
evglSelfLink :: Lens' ExternalVPNGatewayList (Maybe Text)
evglSelfLink
  = lens _evglSelfLink (\ s a -> s{_evglSelfLink = a})

-- | [Output Only] Informational warning message.
evglWarning :: Lens' ExternalVPNGatewayList (Maybe ExternalVPNGatewayListWarning)
evglWarning
  = lens _evglWarning (\ s a -> s{_evglWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
evglId :: Lens' ExternalVPNGatewayList (Maybe Text)
evglId = lens _evglId (\ s a -> s{_evglId = a})

instance FromJSON ExternalVPNGatewayList where
        parseJSON
          = withObject "ExternalVPNGatewayList"
              (\ o ->
                 ExternalVPNGatewayList' <$>
                   (o .:? "etag") <*> (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#externalVpnGatewayList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON ExternalVPNGatewayList where
        toJSON ExternalVPNGatewayList'{..}
          = object
              (catMaybes
                 [("etag" .=) <$> _evglEtag,
                  ("nextPageToken" .=) <$> _evglNextPageToken,
                  Just ("kind" .= _evglKind),
                  ("items" .=) <$> _evglItems,
                  ("selfLink" .=) <$> _evglSelfLink,
                  ("warning" .=) <$> _evglWarning,
                  ("id" .=) <$> _evglId])

--
-- /See:/ 'vpnGatewayAggregatedList' smart constructor.
data VPNGatewayAggregatedList =
  VPNGatewayAggregatedList'
    { _vgalUnreachables :: !(Maybe [Text])
    , _vgalNextPageToken :: !(Maybe Text)
    , _vgalKind :: !Text
    , _vgalItems :: !(Maybe VPNGatewayAggregatedListItems)
    , _vgalSelfLink :: !(Maybe Text)
    , _vgalWarning :: !(Maybe VPNGatewayAggregatedListWarning)
    , _vgalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNGatewayAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vgalUnreachables'
--
-- * 'vgalNextPageToken'
--
-- * 'vgalKind'
--
-- * 'vgalItems'
--
-- * 'vgalSelfLink'
--
-- * 'vgalWarning'
--
-- * 'vgalId'
vpnGatewayAggregatedList
    :: VPNGatewayAggregatedList
vpnGatewayAggregatedList =
  VPNGatewayAggregatedList'
    { _vgalUnreachables = Nothing
    , _vgalNextPageToken = Nothing
    , _vgalKind = "compute#vpnGatewayAggregatedList"
    , _vgalItems = Nothing
    , _vgalSelfLink = Nothing
    , _vgalWarning = Nothing
    , _vgalId = Nothing
    }


-- | [Output Only] Unreachable resources.
vgalUnreachables :: Lens' VPNGatewayAggregatedList [Text]
vgalUnreachables
  = lens _vgalUnreachables
      (\ s a -> s{_vgalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
vgalNextPageToken :: Lens' VPNGatewayAggregatedList (Maybe Text)
vgalNextPageToken
  = lens _vgalNextPageToken
      (\ s a -> s{_vgalNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#vpnGateway for VPN
-- gateways.
vgalKind :: Lens' VPNGatewayAggregatedList Text
vgalKind = lens _vgalKind (\ s a -> s{_vgalKind = a})

-- | A list of VpnGateway resources.
vgalItems :: Lens' VPNGatewayAggregatedList (Maybe VPNGatewayAggregatedListItems)
vgalItems
  = lens _vgalItems (\ s a -> s{_vgalItems = a})

-- | [Output Only] Server-defined URL for this resource.
vgalSelfLink :: Lens' VPNGatewayAggregatedList (Maybe Text)
vgalSelfLink
  = lens _vgalSelfLink (\ s a -> s{_vgalSelfLink = a})

-- | [Output Only] Informational warning message.
vgalWarning :: Lens' VPNGatewayAggregatedList (Maybe VPNGatewayAggregatedListWarning)
vgalWarning
  = lens _vgalWarning (\ s a -> s{_vgalWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
vgalId :: Lens' VPNGatewayAggregatedList (Maybe Text)
vgalId = lens _vgalId (\ s a -> s{_vgalId = a})

instance FromJSON VPNGatewayAggregatedList where
        parseJSON
          = withObject "VPNGatewayAggregatedList"
              (\ o ->
                 VPNGatewayAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!= "compute#vpnGatewayAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON VPNGatewayAggregatedList where
        toJSON VPNGatewayAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _vgalUnreachables,
                  ("nextPageToken" .=) <$> _vgalNextPageToken,
                  Just ("kind" .= _vgalKind),
                  ("items" .=) <$> _vgalItems,
                  ("selfLink" .=) <$> _vgalSelfLink,
                  ("warning" .=) <$> _vgalWarning,
                  ("id" .=) <$> _vgalId])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'interconnectLocationListWarning' smart constructor.
data InterconnectLocationListWarning =
  InterconnectLocationListWarning'
    { _illwData :: !(Maybe [InterconnectLocationListWarningDataItem])
    , _illwCode :: !(Maybe InterconnectLocationListWarningCode)
    , _illwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectLocationListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'illwData'
--
-- * 'illwCode'
--
-- * 'illwMessage'
interconnectLocationListWarning
    :: InterconnectLocationListWarning
interconnectLocationListWarning =
  InterconnectLocationListWarning'
    {_illwData = Nothing, _illwCode = Nothing, _illwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
illwData :: Lens' InterconnectLocationListWarning [InterconnectLocationListWarningDataItem]
illwData
  = lens _illwData (\ s a -> s{_illwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
illwCode :: Lens' InterconnectLocationListWarning (Maybe InterconnectLocationListWarningCode)
illwCode = lens _illwCode (\ s a -> s{_illwCode = a})

-- | [Output Only] A human-readable description of the warning code.
illwMessage :: Lens' InterconnectLocationListWarning (Maybe Text)
illwMessage
  = lens _illwMessage (\ s a -> s{_illwMessage = a})

instance FromJSON InterconnectLocationListWarning
         where
        parseJSON
          = withObject "InterconnectLocationListWarning"
              (\ o ->
                 InterconnectLocationListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON InterconnectLocationListWarning where
        toJSON InterconnectLocationListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _illwData,
                  ("code" .=) <$> _illwCode,
                  ("message" .=) <$> _illwMessage])

--
-- /See:/ 'instancesGetEffectiveFirewallsResponse' smart constructor.
data InstancesGetEffectiveFirewallsResponse =
  InstancesGetEffectiveFirewallsResponse'
    { _igefrFirewallPolicys :: !(Maybe [InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy])
    , _igefrFirewalls :: !(Maybe [Firewall])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstancesGetEffectiveFirewallsResponse' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igefrFirewallPolicys'
--
-- * 'igefrFirewalls'
instancesGetEffectiveFirewallsResponse
    :: InstancesGetEffectiveFirewallsResponse
instancesGetEffectiveFirewallsResponse =
  InstancesGetEffectiveFirewallsResponse'
    {_igefrFirewallPolicys = Nothing, _igefrFirewalls = Nothing}


-- | Effective firewalls from firewall policies.
igefrFirewallPolicys :: Lens' InstancesGetEffectiveFirewallsResponse [InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy]
igefrFirewallPolicys
  = lens _igefrFirewallPolicys
      (\ s a -> s{_igefrFirewallPolicys = a})
      . _Default
      . _Coerce

-- | Effective firewalls on the instance.
igefrFirewalls :: Lens' InstancesGetEffectiveFirewallsResponse [Firewall]
igefrFirewalls
  = lens _igefrFirewalls
      (\ s a -> s{_igefrFirewalls = a})
      . _Default
      . _Coerce

instance FromJSON
           InstancesGetEffectiveFirewallsResponse
         where
        parseJSON
          = withObject "InstancesGetEffectiveFirewallsResponse"
              (\ o ->
                 InstancesGetEffectiveFirewallsResponse' <$>
                   (o .:? "firewallPolicys" .!= mempty) <*>
                     (o .:? "firewalls" .!= mempty))

instance ToJSON
           InstancesGetEffectiveFirewallsResponse
         where
        toJSON InstancesGetEffectiveFirewallsResponse'{..}
          = object
              (catMaybes
                 [("firewallPolicys" .=) <$> _igefrFirewallPolicys,
                  ("firewalls" .=) <$> _igefrFirewalls])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'instanceGroupsListInstancesWarning' smart constructor.
data InstanceGroupsListInstancesWarning =
  InstanceGroupsListInstancesWarning'
    { _igliwData :: !(Maybe [InstanceGroupsListInstancesWarningDataItem])
    , _igliwCode :: !(Maybe InstanceGroupsListInstancesWarningCode)
    , _igliwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupsListInstancesWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igliwData'
--
-- * 'igliwCode'
--
-- * 'igliwMessage'
instanceGroupsListInstancesWarning
    :: InstanceGroupsListInstancesWarning
instanceGroupsListInstancesWarning =
  InstanceGroupsListInstancesWarning'
    {_igliwData = Nothing, _igliwCode = Nothing, _igliwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
igliwData :: Lens' InstanceGroupsListInstancesWarning [InstanceGroupsListInstancesWarningDataItem]
igliwData
  = lens _igliwData (\ s a -> s{_igliwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
igliwCode :: Lens' InstanceGroupsListInstancesWarning (Maybe InstanceGroupsListInstancesWarningCode)
igliwCode
  = lens _igliwCode (\ s a -> s{_igliwCode = a})

-- | [Output Only] A human-readable description of the warning code.
igliwMessage :: Lens' InstanceGroupsListInstancesWarning (Maybe Text)
igliwMessage
  = lens _igliwMessage (\ s a -> s{_igliwMessage = a})

instance FromJSON InstanceGroupsListInstancesWarning
         where
        parseJSON
          = withObject "InstanceGroupsListInstancesWarning"
              (\ o ->
                 InstanceGroupsListInstancesWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON InstanceGroupsListInstancesWarning
         where
        toJSON InstanceGroupsListInstancesWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _igliwData,
                  ("code" .=) <$> _igliwCode,
                  ("message" .=) <$> _igliwMessage])

-- | Contains a list of managed instance groups.
--
-- /See:/ 'regionInstanceGroupManagerList' smart constructor.
data RegionInstanceGroupManagerList =
  RegionInstanceGroupManagerList'
    { _rigmlNextPageToken :: !(Maybe Text)
    , _rigmlKind :: !Text
    , _rigmlItems :: !(Maybe [InstanceGroupManager])
    , _rigmlSelfLink :: !(Maybe Text)
    , _rigmlWarning :: !(Maybe RegionInstanceGroupManagerListWarning)
    , _rigmlId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupManagerList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rigmlNextPageToken'
--
-- * 'rigmlKind'
--
-- * 'rigmlItems'
--
-- * 'rigmlSelfLink'
--
-- * 'rigmlWarning'
--
-- * 'rigmlId'
regionInstanceGroupManagerList
    :: RegionInstanceGroupManagerList
regionInstanceGroupManagerList =
  RegionInstanceGroupManagerList'
    { _rigmlNextPageToken = Nothing
    , _rigmlKind = "compute#regionInstanceGroupManagerList"
    , _rigmlItems = Nothing
    , _rigmlSelfLink = Nothing
    , _rigmlWarning = Nothing
    , _rigmlId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
rigmlNextPageToken :: Lens' RegionInstanceGroupManagerList (Maybe Text)
rigmlNextPageToken
  = lens _rigmlNextPageToken
      (\ s a -> s{_rigmlNextPageToken = a})

-- | [Output Only] The resource type, which is always
-- compute#instanceGroupManagerList for a list of managed instance groups
-- that exist in th regional scope.
rigmlKind :: Lens' RegionInstanceGroupManagerList Text
rigmlKind
  = lens _rigmlKind (\ s a -> s{_rigmlKind = a})

-- | A list of InstanceGroupManager resources.
rigmlItems :: Lens' RegionInstanceGroupManagerList [InstanceGroupManager]
rigmlItems
  = lens _rigmlItems (\ s a -> s{_rigmlItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
rigmlSelfLink :: Lens' RegionInstanceGroupManagerList (Maybe Text)
rigmlSelfLink
  = lens _rigmlSelfLink
      (\ s a -> s{_rigmlSelfLink = a})

-- | [Output Only] Informational warning message.
rigmlWarning :: Lens' RegionInstanceGroupManagerList (Maybe RegionInstanceGroupManagerListWarning)
rigmlWarning
  = lens _rigmlWarning (\ s a -> s{_rigmlWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
rigmlId :: Lens' RegionInstanceGroupManagerList (Maybe Text)
rigmlId = lens _rigmlId (\ s a -> s{_rigmlId = a})

instance FromJSON RegionInstanceGroupManagerList
         where
        parseJSON
          = withObject "RegionInstanceGroupManagerList"
              (\ o ->
                 RegionInstanceGroupManagerList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!=
                        "compute#regionInstanceGroupManagerList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON RegionInstanceGroupManagerList where
        toJSON RegionInstanceGroupManagerList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _rigmlNextPageToken,
                  Just ("kind" .= _rigmlKind),
                  ("items" .=) <$> _rigmlItems,
                  ("selfLink" .=) <$> _rigmlSelfLink,
                  ("warning" .=) <$> _rigmlWarning,
                  ("id" .=) <$> _rigmlId])

--
-- /See:/ 'diskTypesScopedList' smart constructor.
data DiskTypesScopedList =
  DiskTypesScopedList'
    { _dtslDiskTypes :: !(Maybe [DiskType])
    , _dtslWarning :: !(Maybe DiskTypesScopedListWarning)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DiskTypesScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dtslDiskTypes'
--
-- * 'dtslWarning'
diskTypesScopedList
    :: DiskTypesScopedList
diskTypesScopedList =
  DiskTypesScopedList' {_dtslDiskTypes = Nothing, _dtslWarning = Nothing}


-- | [Output Only] A list of disk types contained in this scope.
dtslDiskTypes :: Lens' DiskTypesScopedList [DiskType]
dtslDiskTypes
  = lens _dtslDiskTypes
      (\ s a -> s{_dtslDiskTypes = a})
      . _Default
      . _Coerce

-- | [Output Only] Informational warning which replaces the list of disk
-- types when the list is empty.
dtslWarning :: Lens' DiskTypesScopedList (Maybe DiskTypesScopedListWarning)
dtslWarning
  = lens _dtslWarning (\ s a -> s{_dtslWarning = a})

instance FromJSON DiskTypesScopedList where
        parseJSON
          = withObject "DiskTypesScopedList"
              (\ o ->
                 DiskTypesScopedList' <$>
                   (o .:? "diskTypes" .!= mempty) <*> (o .:? "warning"))

instance ToJSON DiskTypesScopedList where
        toJSON DiskTypesScopedList'{..}
          = object
              (catMaybes
                 [("diskTypes" .=) <$> _dtslDiskTypes,
                  ("warning" .=) <$> _dtslWarning])

--
-- /See:/ 'preservedStatePreservedDisk' smart constructor.
data PreservedStatePreservedDisk =
  PreservedStatePreservedDisk'
    { _pspdMode :: !(Maybe PreservedStatePreservedDiskMode)
    , _pspdAutoDelete :: !(Maybe PreservedStatePreservedDiskAutoDelete)
    , _pspdSource :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PreservedStatePreservedDisk' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pspdMode'
--
-- * 'pspdAutoDelete'
--
-- * 'pspdSource'
preservedStatePreservedDisk
    :: PreservedStatePreservedDisk
preservedStatePreservedDisk =
  PreservedStatePreservedDisk'
    {_pspdMode = Nothing, _pspdAutoDelete = Nothing, _pspdSource = Nothing}


-- | The mode in which to attach this disk, either READ_WRITE or READ_ONLY.
-- If not specified, the default is to attach the disk in READ_WRITE mode.
pspdMode :: Lens' PreservedStatePreservedDisk (Maybe PreservedStatePreservedDiskMode)
pspdMode = lens _pspdMode (\ s a -> s{_pspdMode = a})

-- | These stateful disks will never be deleted during autohealing, update,
-- instance recreate operations. This flag is used to configure if the disk
-- should be deleted after it is no longer used by the group, e.g. when the
-- given instance or the whole MIG is deleted. Note: disks attached in
-- READ_ONLY mode cannot be auto-deleted.
pspdAutoDelete :: Lens' PreservedStatePreservedDisk (Maybe PreservedStatePreservedDiskAutoDelete)
pspdAutoDelete
  = lens _pspdAutoDelete
      (\ s a -> s{_pspdAutoDelete = a})

-- | The URL of the disk resource that is stateful and should be attached to
-- the VM instance.
pspdSource :: Lens' PreservedStatePreservedDisk (Maybe Text)
pspdSource
  = lens _pspdSource (\ s a -> s{_pspdSource = a})

instance FromJSON PreservedStatePreservedDisk where
        parseJSON
          = withObject "PreservedStatePreservedDisk"
              (\ o ->
                 PreservedStatePreservedDisk' <$>
                   (o .:? "mode") <*> (o .:? "autoDelete") <*>
                     (o .:? "source"))

instance ToJSON PreservedStatePreservedDisk where
        toJSON PreservedStatePreservedDisk'{..}
          = object
              (catMaybes
                 [("mode" .=) <$> _pspdMode,
                  ("autoDelete" .=) <$> _pspdAutoDelete,
                  ("source" .=) <$> _pspdSource])

-- | Write a Cloud Audit log
--
-- /See:/ 'logConfigCloudAuditOptions' smart constructor.
data LogConfigCloudAuditOptions =
  LogConfigCloudAuditOptions'
    { _lccaoAuthorizationLoggingOptions :: !(Maybe AuthorizationLoggingOptions)
    , _lccaoLogName :: !(Maybe LogConfigCloudAuditOptionsLogName)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'LogConfigCloudAuditOptions' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'lccaoAuthorizationLoggingOptions'
--
-- * 'lccaoLogName'
logConfigCloudAuditOptions
    :: LogConfigCloudAuditOptions
logConfigCloudAuditOptions =
  LogConfigCloudAuditOptions'
    {_lccaoAuthorizationLoggingOptions = Nothing, _lccaoLogName = Nothing}


-- | Information used by the Cloud Audit Logging pipeline.
lccaoAuthorizationLoggingOptions :: Lens' LogConfigCloudAuditOptions (Maybe AuthorizationLoggingOptions)
lccaoAuthorizationLoggingOptions
  = lens _lccaoAuthorizationLoggingOptions
      (\ s a -> s{_lccaoAuthorizationLoggingOptions = a})

-- | The log_name to populate in the Cloud Audit Record.
lccaoLogName :: Lens' LogConfigCloudAuditOptions (Maybe LogConfigCloudAuditOptionsLogName)
lccaoLogName
  = lens _lccaoLogName (\ s a -> s{_lccaoLogName = a})

instance FromJSON LogConfigCloudAuditOptions where
        parseJSON
          = withObject "LogConfigCloudAuditOptions"
              (\ o ->
                 LogConfigCloudAuditOptions' <$>
                   (o .:? "authorizationLoggingOptions") <*>
                     (o .:? "logName"))

instance ToJSON LogConfigCloudAuditOptions where
        toJSON LogConfigCloudAuditOptions'{..}
          = object
              (catMaybes
                 [("authorizationLoggingOptions" .=) <$>
                    _lccaoAuthorizationLoggingOptions,
                  ("logName" .=) <$> _lccaoLogName])

--
-- /See:/ 'resourcePolicyAggregatedListWarningDataItem' smart constructor.
data ResourcePolicyAggregatedListWarningDataItem =
  ResourcePolicyAggregatedListWarningDataItem'
    { _rpalwdiValue :: !(Maybe Text)
    , _rpalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePolicyAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rpalwdiValue'
--
-- * 'rpalwdiKey'
resourcePolicyAggregatedListWarningDataItem
    :: ResourcePolicyAggregatedListWarningDataItem
resourcePolicyAggregatedListWarningDataItem =
  ResourcePolicyAggregatedListWarningDataItem'
    {_rpalwdiValue = Nothing, _rpalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
rpalwdiValue :: Lens' ResourcePolicyAggregatedListWarningDataItem (Maybe Text)
rpalwdiValue
  = lens _rpalwdiValue (\ s a -> s{_rpalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
rpalwdiKey :: Lens' ResourcePolicyAggregatedListWarningDataItem (Maybe Text)
rpalwdiKey
  = lens _rpalwdiKey (\ s a -> s{_rpalwdiKey = a})

instance FromJSON
           ResourcePolicyAggregatedListWarningDataItem
         where
        parseJSON
          = withObject
              "ResourcePolicyAggregatedListWarningDataItem"
              (\ o ->
                 ResourcePolicyAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           ResourcePolicyAggregatedListWarningDataItem
         where
        toJSON
          ResourcePolicyAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _rpalwdiValue,
                  ("key" .=) <$> _rpalwdiKey])

--
-- /See:/ 'projectsSetDefaultNetworkTierRequest' smart constructor.
newtype ProjectsSetDefaultNetworkTierRequest =
  ProjectsSetDefaultNetworkTierRequest'
    { _psdntrNetworkTier :: Maybe ProjectsSetDefaultNetworkTierRequestNetworkTier
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ProjectsSetDefaultNetworkTierRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'psdntrNetworkTier'
projectsSetDefaultNetworkTierRequest
    :: ProjectsSetDefaultNetworkTierRequest
projectsSetDefaultNetworkTierRequest =
  ProjectsSetDefaultNetworkTierRequest' {_psdntrNetworkTier = Nothing}


-- | Default network tier to be set.
psdntrNetworkTier :: Lens' ProjectsSetDefaultNetworkTierRequest (Maybe ProjectsSetDefaultNetworkTierRequestNetworkTier)
psdntrNetworkTier
  = lens _psdntrNetworkTier
      (\ s a -> s{_psdntrNetworkTier = a})

instance FromJSON
           ProjectsSetDefaultNetworkTierRequest
         where
        parseJSON
          = withObject "ProjectsSetDefaultNetworkTierRequest"
              (\ o ->
                 ProjectsSetDefaultNetworkTierRequest' <$>
                   (o .:? "networkTier"))

instance ToJSON ProjectsSetDefaultNetworkTierRequest
         where
        toJSON ProjectsSetDefaultNetworkTierRequest'{..}
          = object
              (catMaybes
                 [("networkTier" .=) <$> _psdntrNetworkTier])

--
-- /See:/ 'imageListWarningDataItem' smart constructor.
data ImageListWarningDataItem =
  ImageListWarningDataItem'
    { _imaValue :: !(Maybe Text)
    , _imaKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ImageListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'imaValue'
--
-- * 'imaKey'
imageListWarningDataItem
    :: ImageListWarningDataItem
imageListWarningDataItem =
  ImageListWarningDataItem' {_imaValue = Nothing, _imaKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
imaValue :: Lens' ImageListWarningDataItem (Maybe Text)
imaValue = lens _imaValue (\ s a -> s{_imaValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
imaKey :: Lens' ImageListWarningDataItem (Maybe Text)
imaKey = lens _imaKey (\ s a -> s{_imaKey = a})

instance FromJSON ImageListWarningDataItem where
        parseJSON
          = withObject "ImageListWarningDataItem"
              (\ o ->
                 ImageListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON ImageListWarningDataItem where
        toJSON ImageListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _imaValue, ("key" .=) <$> _imaKey])

--
-- /See:/ 'securityPolicyAdvancedOptionsConfig' smart constructor.
data SecurityPolicyAdvancedOptionsConfig =
  SecurityPolicyAdvancedOptionsConfig'
    { _spaocLogLevel :: !(Maybe SecurityPolicyAdvancedOptionsConfigLogLevel)
    , _spaocJSONParsing :: !(Maybe SecurityPolicyAdvancedOptionsConfigJSONParsing)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SecurityPolicyAdvancedOptionsConfig' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'spaocLogLevel'
--
-- * 'spaocJSONParsing'
securityPolicyAdvancedOptionsConfig
    :: SecurityPolicyAdvancedOptionsConfig
securityPolicyAdvancedOptionsConfig =
  SecurityPolicyAdvancedOptionsConfig'
    {_spaocLogLevel = Nothing, _spaocJSONParsing = Nothing}


spaocLogLevel :: Lens' SecurityPolicyAdvancedOptionsConfig (Maybe SecurityPolicyAdvancedOptionsConfigLogLevel)
spaocLogLevel
  = lens _spaocLogLevel
      (\ s a -> s{_spaocLogLevel = a})

spaocJSONParsing :: Lens' SecurityPolicyAdvancedOptionsConfig (Maybe SecurityPolicyAdvancedOptionsConfigJSONParsing)
spaocJSONParsing
  = lens _spaocJSONParsing
      (\ s a -> s{_spaocJSONParsing = a})

instance FromJSON SecurityPolicyAdvancedOptionsConfig
         where
        parseJSON
          = withObject "SecurityPolicyAdvancedOptionsConfig"
              (\ o ->
                 SecurityPolicyAdvancedOptionsConfig' <$>
                   (o .:? "logLevel") <*> (o .:? "jsonParsing"))

instance ToJSON SecurityPolicyAdvancedOptionsConfig
         where
        toJSON SecurityPolicyAdvancedOptionsConfig'{..}
          = object
              (catMaybes
                 [("logLevel" .=) <$> _spaocLogLevel,
                  ("jsonParsing" .=) <$> _spaocJSONParsing])

--
-- /See:/ 'acceleratorTypeListWarningDataItem' smart constructor.
data AcceleratorTypeListWarningDataItem =
  AcceleratorTypeListWarningDataItem'
    { _atlwdiValue :: !(Maybe Text)
    , _atlwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AcceleratorTypeListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'atlwdiValue'
--
-- * 'atlwdiKey'
acceleratorTypeListWarningDataItem
    :: AcceleratorTypeListWarningDataItem
acceleratorTypeListWarningDataItem =
  AcceleratorTypeListWarningDataItem'
    {_atlwdiValue = Nothing, _atlwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
atlwdiValue :: Lens' AcceleratorTypeListWarningDataItem (Maybe Text)
atlwdiValue
  = lens _atlwdiValue (\ s a -> s{_atlwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
atlwdiKey :: Lens' AcceleratorTypeListWarningDataItem (Maybe Text)
atlwdiKey
  = lens _atlwdiKey (\ s a -> s{_atlwdiKey = a})

instance FromJSON AcceleratorTypeListWarningDataItem
         where
        parseJSON
          = withObject "AcceleratorTypeListWarningDataItem"
              (\ o ->
                 AcceleratorTypeListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON AcceleratorTypeListWarningDataItem
         where
        toJSON AcceleratorTypeListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _atlwdiValue,
                  ("key" .=) <$> _atlwdiKey])

-- | Description of a planned outage on this Interconnect.
--
-- /See:/ 'interconnectOutageNotification' smart constructor.
data InterconnectOutageNotification =
  InterconnectOutageNotification'
    { _ionState :: !(Maybe InterconnectOutageNotificationState)
    , _ionAffectedCircuits :: !(Maybe [Text])
    , _ionStartTime :: !(Maybe (Textual Int64))
    , _ionIssueType :: !(Maybe InterconnectOutageNotificationIssueType)
    , _ionName :: !(Maybe Text)
    , _ionEndTime :: !(Maybe (Textual Int64))
    , _ionSource :: !(Maybe InterconnectOutageNotificationSource)
    , _ionDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectOutageNotification' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ionState'
--
-- * 'ionAffectedCircuits'
--
-- * 'ionStartTime'
--
-- * 'ionIssueType'
--
-- * 'ionName'
--
-- * 'ionEndTime'
--
-- * 'ionSource'
--
-- * 'ionDescription'
interconnectOutageNotification
    :: InterconnectOutageNotification
interconnectOutageNotification =
  InterconnectOutageNotification'
    { _ionState = Nothing
    , _ionAffectedCircuits = Nothing
    , _ionStartTime = Nothing
    , _ionIssueType = Nothing
    , _ionName = Nothing
    , _ionEndTime = Nothing
    , _ionSource = Nothing
    , _ionDescription = Nothing
    }


-- | State of this notification, which can take one of the following values:
-- - ACTIVE: This outage notification is active. The event could be in the
-- past, present, or future. See start_time and end_time for scheduling. -
-- CANCELLED: The outage associated with this notification was cancelled
-- before the outage was due to start. - COMPLETED: The outage associated
-- with this notification is complete. Note that the versions of this enum
-- prefixed with \"NS_\" have been deprecated in favor of the unprefixed
-- values.
ionState :: Lens' InterconnectOutageNotification (Maybe InterconnectOutageNotificationState)
ionState = lens _ionState (\ s a -> s{_ionState = a})

-- | If issue_type is IT_PARTIAL_OUTAGE, a list of the Google-side circuit
-- IDs that will be affected.
ionAffectedCircuits :: Lens' InterconnectOutageNotification [Text]
ionAffectedCircuits
  = lens _ionAffectedCircuits
      (\ s a -> s{_ionAffectedCircuits = a})
      . _Default
      . _Coerce

-- | Scheduled start time for the outage (milliseconds since Unix epoch).
ionStartTime :: Lens' InterconnectOutageNotification (Maybe Int64)
ionStartTime
  = lens _ionStartTime (\ s a -> s{_ionStartTime = a})
      . mapping _Coerce

-- | Form this outage is expected to take, which can take one of the
-- following values: - OUTAGE: The Interconnect may be completely out of
-- service for some or all of the specified window. - PARTIAL_OUTAGE: Some
-- circuits comprising the Interconnect as a whole should remain up, but
-- with reduced bandwidth. Note that the versions of this enum prefixed
-- with \"IT_\" have been deprecated in favor of the unprefixed values.
ionIssueType :: Lens' InterconnectOutageNotification (Maybe InterconnectOutageNotificationIssueType)
ionIssueType
  = lens _ionIssueType (\ s a -> s{_ionIssueType = a})

-- | Unique identifier for this outage notification.
ionName :: Lens' InterconnectOutageNotification (Maybe Text)
ionName = lens _ionName (\ s a -> s{_ionName = a})

-- | Scheduled end time for the outage (milliseconds since Unix epoch).
ionEndTime :: Lens' InterconnectOutageNotification (Maybe Int64)
ionEndTime
  = lens _ionEndTime (\ s a -> s{_ionEndTime = a}) .
      mapping _Coerce

-- | The party that generated this notification, which can take the following
-- value: - GOOGLE: this notification as generated by Google. Note that the
-- value of NSRC_GOOGLE has been deprecated in favor of GOOGLE.
ionSource :: Lens' InterconnectOutageNotification (Maybe InterconnectOutageNotificationSource)
ionSource
  = lens _ionSource (\ s a -> s{_ionSource = a})

-- | A description about the purpose of the outage.
ionDescription :: Lens' InterconnectOutageNotification (Maybe Text)
ionDescription
  = lens _ionDescription
      (\ s a -> s{_ionDescription = a})

instance FromJSON InterconnectOutageNotification
         where
        parseJSON
          = withObject "InterconnectOutageNotification"
              (\ o ->
                 InterconnectOutageNotification' <$>
                   (o .:? "state") <*>
                     (o .:? "affectedCircuits" .!= mempty)
                     <*> (o .:? "startTime")
                     <*> (o .:? "issueType")
                     <*> (o .:? "name")
                     <*> (o .:? "endTime")
                     <*> (o .:? "source")
                     <*> (o .:? "description"))

instance ToJSON InterconnectOutageNotification where
        toJSON InterconnectOutageNotification'{..}
          = object
              (catMaybes
                 [("state" .=) <$> _ionState,
                  ("affectedCircuits" .=) <$> _ionAffectedCircuits,
                  ("startTime" .=) <$> _ionStartTime,
                  ("issueType" .=) <$> _ionIssueType,
                  ("name" .=) <$> _ionName,
                  ("endTime" .=) <$> _ionEndTime,
                  ("source" .=) <$> _ionSource,
                  ("description" .=) <$> _ionDescription])

-- | Contains a list of node templates.
--
-- /See:/ 'nodeTemplateList' smart constructor.
data NodeTemplateList =
  NodeTemplateList'
    { _ntlNextPageToken :: !(Maybe Text)
    , _ntlKind :: !Text
    , _ntlItems :: !(Maybe [NodeTemplate])
    , _ntlSelfLink :: !(Maybe Text)
    , _ntlWarning :: !(Maybe NodeTemplateListWarning)
    , _ntlId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeTemplateList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ntlNextPageToken'
--
-- * 'ntlKind'
--
-- * 'ntlItems'
--
-- * 'ntlSelfLink'
--
-- * 'ntlWarning'
--
-- * 'ntlId'
nodeTemplateList
    :: NodeTemplateList
nodeTemplateList =
  NodeTemplateList'
    { _ntlNextPageToken = Nothing
    , _ntlKind = "compute#nodeTemplateList"
    , _ntlItems = Nothing
    , _ntlSelfLink = Nothing
    , _ntlWarning = Nothing
    , _ntlId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
ntlNextPageToken :: Lens' NodeTemplateList (Maybe Text)
ntlNextPageToken
  = lens _ntlNextPageToken
      (\ s a -> s{_ntlNextPageToken = a})

-- | [Output Only] Type of resource.Always compute#nodeTemplateList for lists
-- of node templates.
ntlKind :: Lens' NodeTemplateList Text
ntlKind = lens _ntlKind (\ s a -> s{_ntlKind = a})

-- | A list of NodeTemplate resources.
ntlItems :: Lens' NodeTemplateList [NodeTemplate]
ntlItems
  = lens _ntlItems (\ s a -> s{_ntlItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
ntlSelfLink :: Lens' NodeTemplateList (Maybe Text)
ntlSelfLink
  = lens _ntlSelfLink (\ s a -> s{_ntlSelfLink = a})

-- | [Output Only] Informational warning message.
ntlWarning :: Lens' NodeTemplateList (Maybe NodeTemplateListWarning)
ntlWarning
  = lens _ntlWarning (\ s a -> s{_ntlWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
ntlId :: Lens' NodeTemplateList (Maybe Text)
ntlId = lens _ntlId (\ s a -> s{_ntlId = a})

instance FromJSON NodeTemplateList where
        parseJSON
          = withObject "NodeTemplateList"
              (\ o ->
                 NodeTemplateList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#nodeTemplateList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON NodeTemplateList where
        toJSON NodeTemplateList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _ntlNextPageToken,
                  Just ("kind" .= _ntlKind),
                  ("items" .=) <$> _ntlItems,
                  ("selfLink" .=) <$> _ntlSelfLink,
                  ("warning" .=) <$> _ntlWarning,
                  ("id" .=) <$> _ntlId])

--
-- /See:/ 'diskTypeAggregatedList' smart constructor.
data DiskTypeAggregatedList =
  DiskTypeAggregatedList'
    { _dtalUnreachables :: !(Maybe [Text])
    , _dtalNextPageToken :: !(Maybe Text)
    , _dtalKind :: !Text
    , _dtalItems :: !(Maybe DiskTypeAggregatedListItems)
    , _dtalSelfLink :: !(Maybe Text)
    , _dtalWarning :: !(Maybe DiskTypeAggregatedListWarning)
    , _dtalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DiskTypeAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dtalUnreachables'
--
-- * 'dtalNextPageToken'
--
-- * 'dtalKind'
--
-- * 'dtalItems'
--
-- * 'dtalSelfLink'
--
-- * 'dtalWarning'
--
-- * 'dtalId'
diskTypeAggregatedList
    :: DiskTypeAggregatedList
diskTypeAggregatedList =
  DiskTypeAggregatedList'
    { _dtalUnreachables = Nothing
    , _dtalNextPageToken = Nothing
    , _dtalKind = "compute#diskTypeAggregatedList"
    , _dtalItems = Nothing
    , _dtalSelfLink = Nothing
    , _dtalWarning = Nothing
    , _dtalId = Nothing
    }


-- | [Output Only] Unreachable resources.
dtalUnreachables :: Lens' DiskTypeAggregatedList [Text]
dtalUnreachables
  = lens _dtalUnreachables
      (\ s a -> s{_dtalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
dtalNextPageToken :: Lens' DiskTypeAggregatedList (Maybe Text)
dtalNextPageToken
  = lens _dtalNextPageToken
      (\ s a -> s{_dtalNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#diskTypeAggregatedList.
dtalKind :: Lens' DiskTypeAggregatedList Text
dtalKind = lens _dtalKind (\ s a -> s{_dtalKind = a})

-- | A list of DiskTypesScopedList resources.
dtalItems :: Lens' DiskTypeAggregatedList (Maybe DiskTypeAggregatedListItems)
dtalItems
  = lens _dtalItems (\ s a -> s{_dtalItems = a})

-- | [Output Only] Server-defined URL for this resource.
dtalSelfLink :: Lens' DiskTypeAggregatedList (Maybe Text)
dtalSelfLink
  = lens _dtalSelfLink (\ s a -> s{_dtalSelfLink = a})

-- | [Output Only] Informational warning message.
dtalWarning :: Lens' DiskTypeAggregatedList (Maybe DiskTypeAggregatedListWarning)
dtalWarning
  = lens _dtalWarning (\ s a -> s{_dtalWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
dtalId :: Lens' DiskTypeAggregatedList (Maybe Text)
dtalId = lens _dtalId (\ s a -> s{_dtalId = a})

instance FromJSON DiskTypeAggregatedList where
        parseJSON
          = withObject "DiskTypeAggregatedList"
              (\ o ->
                 DiskTypeAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!= "compute#diskTypeAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON DiskTypeAggregatedList where
        toJSON DiskTypeAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _dtalUnreachables,
                  ("nextPageToken" .=) <$> _dtalNextPageToken,
                  Just ("kind" .= _dtalKind),
                  ("items" .=) <$> _dtalItems,
                  ("selfLink" .=) <$> _dtalSelfLink,
                  ("warning" .=) <$> _dtalWarning,
                  ("id" .=) <$> _dtalId])

--
-- /See:/ 'hTTPHealthCheck' smart constructor.
data HTTPHealthCheck =
  HTTPHealthCheck'
    { _hResponse :: !(Maybe Text)
    , _hPortSpecification :: !(Maybe HTTPHealthCheckPortSpecification)
    , _hRequestPath :: !(Maybe Text)
    , _hHost :: !(Maybe Text)
    , _hProxyHeader :: !(Maybe HTTPHealthCheckProxyHeader)
    , _hPortName :: !(Maybe Text)
    , _hPort :: !(Maybe (Textual Int32))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HTTPHealthCheck' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hResponse'
--
-- * 'hPortSpecification'
--
-- * 'hRequestPath'
--
-- * 'hHost'
--
-- * 'hProxyHeader'
--
-- * 'hPortName'
--
-- * 'hPort'
hTTPHealthCheck
    :: HTTPHealthCheck
hTTPHealthCheck =
  HTTPHealthCheck'
    { _hResponse = Nothing
    , _hPortSpecification = Nothing
    , _hRequestPath = Nothing
    , _hHost = Nothing
    , _hProxyHeader = Nothing
    , _hPortName = Nothing
    , _hPort = Nothing
    }


-- | The string to match anywhere in the first 1024 bytes of the response
-- body. If left empty (the default value), the status code determines
-- health. The response data can only be ASCII.
hResponse :: Lens' HTTPHealthCheck (Maybe Text)
hResponse
  = lens _hResponse (\ s a -> s{_hResponse = a})

-- | Specifies how port is selected for health checking, can be one of
-- following values: USE_FIXED_PORT: The port number in port is used for
-- health checking. USE_NAMED_PORT: The portName is used for health
-- checking. USE_SERVING_PORT: For NetworkEndpointGroup, the port specified
-- for each network endpoint is used for health checking. For other
-- backends, the port or named port specified in the Backend Service is
-- used for health checking. If not specified, HTTP health check follows
-- behavior specified in port and portName fields.
hPortSpecification :: Lens' HTTPHealthCheck (Maybe HTTPHealthCheckPortSpecification)
hPortSpecification
  = lens _hPortSpecification
      (\ s a -> s{_hPortSpecification = a})

-- | The request path of the HTTP health check request. The default value is
-- \/.
hRequestPath :: Lens' HTTPHealthCheck (Maybe Text)
hRequestPath
  = lens _hRequestPath (\ s a -> s{_hRequestPath = a})

-- | The value of the host header in the HTTP health check request. If left
-- empty (default value), the IP on behalf of which this health check is
-- performed will be used.
hHost :: Lens' HTTPHealthCheck (Maybe Text)
hHost = lens _hHost (\ s a -> s{_hHost = a})

-- | Specifies the type of proxy header to append before sending data to the
-- backend, either NONE or PROXY_V1. The default is NONE.
hProxyHeader :: Lens' HTTPHealthCheck (Maybe HTTPHealthCheckProxyHeader)
hProxyHeader
  = lens _hProxyHeader (\ s a -> s{_hProxyHeader = a})

-- | Port name as defined in InstanceGroup#NamedPort#name. If both port and
-- port_name are defined, port takes precedence.
hPortName :: Lens' HTTPHealthCheck (Maybe Text)
hPortName
  = lens _hPortName (\ s a -> s{_hPortName = a})

-- | The TCP port number for the health check request. The default value is
-- 80. Valid values are 1 through 65535.
hPort :: Lens' HTTPHealthCheck (Maybe Int32)
hPort
  = lens _hPort (\ s a -> s{_hPort = a}) .
      mapping _Coerce

instance FromJSON HTTPHealthCheck where
        parseJSON
          = withObject "HTTPHealthCheck"
              (\ o ->
                 HTTPHealthCheck' <$>
                   (o .:? "response") <*> (o .:? "portSpecification")
                     <*> (o .:? "requestPath")
                     <*> (o .:? "host")
                     <*> (o .:? "proxyHeader")
                     <*> (o .:? "portName")
                     <*> (o .:? "port"))

instance ToJSON HTTPHealthCheck where
        toJSON HTTPHealthCheck'{..}
          = object
              (catMaybes
                 [("response" .=) <$> _hResponse,
                  ("portSpecification" .=) <$> _hPortSpecification,
                  ("requestPath" .=) <$> _hRequestPath,
                  ("host" .=) <$> _hHost,
                  ("proxyHeader" .=) <$> _hProxyHeader,
                  ("portName" .=) <$> _hPortName,
                  ("port" .=) <$> _hPort])

--
-- /See:/ 'urlMapListWarningDataItem' smart constructor.
data URLMapListWarningDataItem =
  URLMapListWarningDataItem'
    { _umlwdiValue :: !(Maybe Text)
    , _umlwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'URLMapListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'umlwdiValue'
--
-- * 'umlwdiKey'
urlMapListWarningDataItem
    :: URLMapListWarningDataItem
urlMapListWarningDataItem =
  URLMapListWarningDataItem' {_umlwdiValue = Nothing, _umlwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
umlwdiValue :: Lens' URLMapListWarningDataItem (Maybe Text)
umlwdiValue
  = lens _umlwdiValue (\ s a -> s{_umlwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
umlwdiKey :: Lens' URLMapListWarningDataItem (Maybe Text)
umlwdiKey
  = lens _umlwdiKey (\ s a -> s{_umlwdiKey = a})

instance FromJSON URLMapListWarningDataItem where
        parseJSON
          = withObject "URLMapListWarningDataItem"
              (\ o ->
                 URLMapListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON URLMapListWarningDataItem where
        toJSON URLMapListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _umlwdiValue,
                  ("key" .=) <$> _umlwdiKey])

-- | Informational warning which replaces the list of backend services when
-- the list is empty.
--
-- /See:/ 'urlMapsScopedListWarning' smart constructor.
data URLMapsScopedListWarning =
  URLMapsScopedListWarning'
    { _umslwData :: !(Maybe [URLMapsScopedListWarningDataItem])
    , _umslwCode :: !(Maybe URLMapsScopedListWarningCode)
    , _umslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'URLMapsScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'umslwData'
--
-- * 'umslwCode'
--
-- * 'umslwMessage'
urlMapsScopedListWarning
    :: URLMapsScopedListWarning
urlMapsScopedListWarning =
  URLMapsScopedListWarning'
    {_umslwData = Nothing, _umslwCode = Nothing, _umslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
umslwData :: Lens' URLMapsScopedListWarning [URLMapsScopedListWarningDataItem]
umslwData
  = lens _umslwData (\ s a -> s{_umslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
umslwCode :: Lens' URLMapsScopedListWarning (Maybe URLMapsScopedListWarningCode)
umslwCode
  = lens _umslwCode (\ s a -> s{_umslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
umslwMessage :: Lens' URLMapsScopedListWarning (Maybe Text)
umslwMessage
  = lens _umslwMessage (\ s a -> s{_umslwMessage = a})

instance FromJSON URLMapsScopedListWarning where
        parseJSON
          = withObject "URLMapsScopedListWarning"
              (\ o ->
                 URLMapsScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON URLMapsScopedListWarning where
        toJSON URLMapsScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _umslwData,
                  ("code" .=) <$> _umslwCode,
                  ("message" .=) <$> _umslwMessage])

-- | Defines the IP ranges that want to use NAT for a subnetwork.
--
-- /See:/ 'routerNATSubnetworkToNAT' smart constructor.
data RouterNATSubnetworkToNAT =
  RouterNATSubnetworkToNAT'
    { _rnatstnatSourceIPRangesToNAT :: !(Maybe [RouterNATSubnetworkToNATSourceIPRangesToNATItem])
    , _rnatstnatName :: !(Maybe Text)
    , _rnatstnatSecondaryIPRangeNames :: !(Maybe [Text])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RouterNATSubnetworkToNAT' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rnatstnatSourceIPRangesToNAT'
--
-- * 'rnatstnatName'
--
-- * 'rnatstnatSecondaryIPRangeNames'
routerNATSubnetworkToNAT
    :: RouterNATSubnetworkToNAT
routerNATSubnetworkToNAT =
  RouterNATSubnetworkToNAT'
    { _rnatstnatSourceIPRangesToNAT = Nothing
    , _rnatstnatName = Nothing
    , _rnatstnatSecondaryIPRangeNames = Nothing
    }


-- | Specify the options for NAT ranges in the Subnetwork. All options of a
-- single value are valid except NAT_IP_RANGE_OPTION_UNSPECIFIED. The only
-- valid option with multiple values is: [\"PRIMARY_IP_RANGE\",
-- \"LIST_OF_SECONDARY_IP_RANGES\"] Default: [ALL_IP_RANGES]
rnatstnatSourceIPRangesToNAT :: Lens' RouterNATSubnetworkToNAT [RouterNATSubnetworkToNATSourceIPRangesToNATItem]
rnatstnatSourceIPRangesToNAT
  = lens _rnatstnatSourceIPRangesToNAT
      (\ s a -> s{_rnatstnatSourceIPRangesToNAT = a})
      . _Default
      . _Coerce

-- | URL for the subnetwork resource that will use NAT.
rnatstnatName :: Lens' RouterNATSubnetworkToNAT (Maybe Text)
rnatstnatName
  = lens _rnatstnatName
      (\ s a -> s{_rnatstnatName = a})

-- | A list of the secondary ranges of the Subnetwork that are allowed to use
-- NAT. This can be populated only if \"LIST_OF_SECONDARY_IP_RANGES\" is
-- one of the values in source_ip_ranges_to_nat.
rnatstnatSecondaryIPRangeNames :: Lens' RouterNATSubnetworkToNAT [Text]
rnatstnatSecondaryIPRangeNames
  = lens _rnatstnatSecondaryIPRangeNames
      (\ s a -> s{_rnatstnatSecondaryIPRangeNames = a})
      . _Default
      . _Coerce

instance FromJSON RouterNATSubnetworkToNAT where
        parseJSON
          = withObject "RouterNATSubnetworkToNAT"
              (\ o ->
                 RouterNATSubnetworkToNAT' <$>
                   (o .:? "sourceIpRangesToNat" .!= mempty) <*>
                     (o .:? "name")
                     <*> (o .:? "secondaryIpRangeNames" .!= mempty))

instance ToJSON RouterNATSubnetworkToNAT where
        toJSON RouterNATSubnetworkToNAT'{..}
          = object
              (catMaybes
                 [("sourceIpRangesToNat" .=) <$>
                    _rnatstnatSourceIPRangesToNAT,
                  ("name" .=) <$> _rnatstnatName,
                  ("secondaryIpRangeNames" .=) <$>
                    _rnatstnatSecondaryIPRangeNames])

--
-- /See:/ 'backendServiceGroupHealth' smart constructor.
data BackendServiceGroupHealth =
  BackendServiceGroupHealth'
    { _bsghAnnotations :: !(Maybe BackendServiceGroupHealthAnnotations)
    , _bsghKind :: !Text
    , _bsghHealthStatus :: !(Maybe [HealthStatus])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendServiceGroupHealth' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bsghAnnotations'
--
-- * 'bsghKind'
--
-- * 'bsghHealthStatus'
backendServiceGroupHealth
    :: BackendServiceGroupHealth
backendServiceGroupHealth =
  BackendServiceGroupHealth'
    { _bsghAnnotations = Nothing
    , _bsghKind = "compute#backendServiceGroupHealth"
    , _bsghHealthStatus = Nothing
    }


-- | Metadata defined as annotations on the network endpoint group.
bsghAnnotations :: Lens' BackendServiceGroupHealth (Maybe BackendServiceGroupHealthAnnotations)
bsghAnnotations
  = lens _bsghAnnotations
      (\ s a -> s{_bsghAnnotations = a})

-- | [Output Only] Type of resource. Always compute#backendServiceGroupHealth
-- for the health of backend services.
bsghKind :: Lens' BackendServiceGroupHealth Text
bsghKind = lens _bsghKind (\ s a -> s{_bsghKind = a})

-- | Health state of the backend instances or endpoints in requested instance
-- or network endpoint group, determined based on configured health checks.
bsghHealthStatus :: Lens' BackendServiceGroupHealth [HealthStatus]
bsghHealthStatus
  = lens _bsghHealthStatus
      (\ s a -> s{_bsghHealthStatus = a})
      . _Default
      . _Coerce

instance FromJSON BackendServiceGroupHealth where
        parseJSON
          = withObject "BackendServiceGroupHealth"
              (\ o ->
                 BackendServiceGroupHealth' <$>
                   (o .:? "annotations") <*>
                     (o .:? "kind" .!=
                        "compute#backendServiceGroupHealth")
                     <*> (o .:? "healthStatus" .!= mempty))

instance ToJSON BackendServiceGroupHealth where
        toJSON BackendServiceGroupHealth'{..}
          = object
              (catMaybes
                 [("annotations" .=) <$> _bsghAnnotations,
                  Just ("kind" .= _bsghKind),
                  ("healthStatus" .=) <$> _bsghHealthStatus])

--
-- /See:/ 'wafExpressionSetExpression' smart constructor.
newtype WafExpressionSetExpression =
  WafExpressionSetExpression'
    { _weseId :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'WafExpressionSetExpression' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'weseId'
wafExpressionSetExpression
    :: WafExpressionSetExpression
wafExpressionSetExpression = WafExpressionSetExpression' {_weseId = Nothing}


-- | Expression ID should uniquely identify the origin of the expression.
-- E.g. owasp-crs-v020901-id973337 identifies Owasp core rule set version
-- 2.9.1 rule id 973337. The ID could be used to determine the individual
-- attack definition that has been detected. It could also be used to
-- exclude it from the policy in case of false positive.
weseId :: Lens' WafExpressionSetExpression (Maybe Text)
weseId = lens _weseId (\ s a -> s{_weseId = a})

instance FromJSON WafExpressionSetExpression where
        parseJSON
          = withObject "WafExpressionSetExpression"
              (\ o -> WafExpressionSetExpression' <$> (o .:? "id"))

instance ToJSON WafExpressionSetExpression where
        toJSON WafExpressionSetExpression'{..}
          = object (catMaybes [("id" .=) <$> _weseId])

-- | A VPN connection contains all VPN tunnels connected from this VpnGateway
-- to the same peer gateway. The peer gateway could either be a external
-- VPN gateway or GCP VPN gateway.
--
-- /See:/ 'vpnGatewayStatusVPNConnection' smart constructor.
data VPNGatewayStatusVPNConnection =
  VPNGatewayStatusVPNConnection'
    { _vgsvcState :: !(Maybe VPNGatewayStatusHighAvailabilityRequirementState)
    , _vgsvcPeerExternalGateway :: !(Maybe Text)
    , _vgsvcTunnels :: !(Maybe [VPNGatewayStatusTunnel])
    , _vgsvcPeerGcpGateway :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNGatewayStatusVPNConnection' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vgsvcState'
--
-- * 'vgsvcPeerExternalGateway'
--
-- * 'vgsvcTunnels'
--
-- * 'vgsvcPeerGcpGateway'
vpnGatewayStatusVPNConnection
    :: VPNGatewayStatusVPNConnection
vpnGatewayStatusVPNConnection =
  VPNGatewayStatusVPNConnection'
    { _vgsvcState = Nothing
    , _vgsvcPeerExternalGateway = Nothing
    , _vgsvcTunnels = Nothing
    , _vgsvcPeerGcpGateway = Nothing
    }


-- | HighAvailabilityRequirementState for the VPN connection.
vgsvcState :: Lens' VPNGatewayStatusVPNConnection (Maybe VPNGatewayStatusHighAvailabilityRequirementState)
vgsvcState
  = lens _vgsvcState (\ s a -> s{_vgsvcState = a})

-- | URL reference to the peer external VPN gateways to which the VPN tunnels
-- in this VPN connection are connected. This field is mutually exclusive
-- with peer_gcp_gateway.
vgsvcPeerExternalGateway :: Lens' VPNGatewayStatusVPNConnection (Maybe Text)
vgsvcPeerExternalGateway
  = lens _vgsvcPeerExternalGateway
      (\ s a -> s{_vgsvcPeerExternalGateway = a})

-- | List of VPN tunnels that are in this VPN connection.
vgsvcTunnels :: Lens' VPNGatewayStatusVPNConnection [VPNGatewayStatusTunnel]
vgsvcTunnels
  = lens _vgsvcTunnels (\ s a -> s{_vgsvcTunnels = a})
      . _Default
      . _Coerce

-- | URL reference to the peer side VPN gateways to which the VPN tunnels in
-- this VPN connection are connected. This field is mutually exclusive with
-- peer_gcp_gateway.
vgsvcPeerGcpGateway :: Lens' VPNGatewayStatusVPNConnection (Maybe Text)
vgsvcPeerGcpGateway
  = lens _vgsvcPeerGcpGateway
      (\ s a -> s{_vgsvcPeerGcpGateway = a})

instance FromJSON VPNGatewayStatusVPNConnection where
        parseJSON
          = withObject "VPNGatewayStatusVPNConnection"
              (\ o ->
                 VPNGatewayStatusVPNConnection' <$>
                   (o .:? "state") <*> (o .:? "peerExternalGateway") <*>
                     (o .:? "tunnels" .!= mempty)
                     <*> (o .:? "peerGcpGateway"))

instance ToJSON VPNGatewayStatusVPNConnection where
        toJSON VPNGatewayStatusVPNConnection'{..}
          = object
              (catMaybes
                 [("state" .=) <$> _vgsvcState,
                  ("peerExternalGateway" .=) <$>
                    _vgsvcPeerExternalGateway,
                  ("tunnels" .=) <$> _vgsvcTunnels,
                  ("peerGcpGateway" .=) <$> _vgsvcPeerGcpGateway])

--
-- /See:/ 'autoscalersScopedList' smart constructor.
data AutoscalersScopedList =
  AutoscalersScopedList'
    { _aAutoscalers :: !(Maybe [Autoscaler])
    , _aWarning :: !(Maybe AutoscalersScopedListWarning)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AutoscalersScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'aAutoscalers'
--
-- * 'aWarning'
autoscalersScopedList
    :: AutoscalersScopedList
autoscalersScopedList =
  AutoscalersScopedList' {_aAutoscalers = Nothing, _aWarning = Nothing}


-- | [Output Only] A list of autoscalers contained in this scope.
aAutoscalers :: Lens' AutoscalersScopedList [Autoscaler]
aAutoscalers
  = lens _aAutoscalers (\ s a -> s{_aAutoscalers = a})
      . _Default
      . _Coerce

-- | [Output Only] Informational warning which replaces the list of
-- autoscalers when the list is empty.
aWarning :: Lens' AutoscalersScopedList (Maybe AutoscalersScopedListWarning)
aWarning = lens _aWarning (\ s a -> s{_aWarning = a})

instance FromJSON AutoscalersScopedList where
        parseJSON
          = withObject "AutoscalersScopedList"
              (\ o ->
                 AutoscalersScopedList' <$>
                   (o .:? "autoscalers" .!= mempty) <*>
                     (o .:? "warning"))

instance ToJSON AutoscalersScopedList where
        toJSON AutoscalersScopedList'{..}
          = object
              (catMaybes
                 [("autoscalers" .=) <$> _aAutoscalers,
                  ("warning" .=) <$> _aWarning])

--
-- /See:/ 'securityPoliciesWafConfig' smart constructor.
newtype SecurityPoliciesWafConfig =
  SecurityPoliciesWafConfig'
    { _spwcWafRules :: Maybe PreConfiguredWafSet
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SecurityPoliciesWafConfig' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'spwcWafRules'
securityPoliciesWafConfig
    :: SecurityPoliciesWafConfig
securityPoliciesWafConfig = SecurityPoliciesWafConfig' {_spwcWafRules = Nothing}


spwcWafRules :: Lens' SecurityPoliciesWafConfig (Maybe PreConfiguredWafSet)
spwcWafRules
  = lens _spwcWafRules (\ s a -> s{_spwcWafRules = a})

instance FromJSON SecurityPoliciesWafConfig where
        parseJSON
          = withObject "SecurityPoliciesWafConfig"
              (\ o ->
                 SecurityPoliciesWafConfig' <$> (o .:? "wafRules"))

instance ToJSON SecurityPoliciesWafConfig where
        toJSON SecurityPoliciesWafConfig'{..}
          = object
              (catMaybes [("wafRules" .=) <$> _spwcWafRules])

-- | Write a Data Access (Gin) log
--
-- /See:/ 'logConfigDataAccessOptions' smart constructor.
newtype LogConfigDataAccessOptions =
  LogConfigDataAccessOptions'
    { _lcdaoLogMode :: Maybe LogConfigDataAccessOptionsLogMode
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'LogConfigDataAccessOptions' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'lcdaoLogMode'
logConfigDataAccessOptions
    :: LogConfigDataAccessOptions
logConfigDataAccessOptions =
  LogConfigDataAccessOptions' {_lcdaoLogMode = Nothing}


-- |
lcdaoLogMode :: Lens' LogConfigDataAccessOptions (Maybe LogConfigDataAccessOptionsLogMode)
lcdaoLogMode
  = lens _lcdaoLogMode (\ s a -> s{_lcdaoLogMode = a})

instance FromJSON LogConfigDataAccessOptions where
        parseJSON
          = withObject "LogConfigDataAccessOptions"
              (\ o ->
                 LogConfigDataAccessOptions' <$> (o .:? "logMode"))

instance ToJSON LogConfigDataAccessOptions where
        toJSON LogConfigDataAccessOptions'{..}
          = object
              (catMaybes [("logMode" .=) <$> _lcdaoLogMode])

--
-- /See:/ 'autoscalerAggregatedList' smart constructor.
data AutoscalerAggregatedList =
  AutoscalerAggregatedList'
    { _aalUnreachables :: !(Maybe [Text])
    , _aalNextPageToken :: !(Maybe Text)
    , _aalKind :: !Text
    , _aalItems :: !(Maybe AutoscalerAggregatedListItems)
    , _aalSelfLink :: !(Maybe Text)
    , _aalWarning :: !(Maybe AutoscalerAggregatedListWarning)
    , _aalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AutoscalerAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'aalUnreachables'
--
-- * 'aalNextPageToken'
--
-- * 'aalKind'
--
-- * 'aalItems'
--
-- * 'aalSelfLink'
--
-- * 'aalWarning'
--
-- * 'aalId'
autoscalerAggregatedList
    :: AutoscalerAggregatedList
autoscalerAggregatedList =
  AutoscalerAggregatedList'
    { _aalUnreachables = Nothing
    , _aalNextPageToken = Nothing
    , _aalKind = "compute#autoscalerAggregatedList"
    , _aalItems = Nothing
    , _aalSelfLink = Nothing
    , _aalWarning = Nothing
    , _aalId = Nothing
    }


-- | [Output Only] Unreachable resources.
aalUnreachables :: Lens' AutoscalerAggregatedList [Text]
aalUnreachables
  = lens _aalUnreachables
      (\ s a -> s{_aalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
aalNextPageToken :: Lens' AutoscalerAggregatedList (Maybe Text)
aalNextPageToken
  = lens _aalNextPageToken
      (\ s a -> s{_aalNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#autoscalerAggregatedList
-- for aggregated lists of autoscalers.
aalKind :: Lens' AutoscalerAggregatedList Text
aalKind = lens _aalKind (\ s a -> s{_aalKind = a})

-- | A list of AutoscalersScopedList resources.
aalItems :: Lens' AutoscalerAggregatedList (Maybe AutoscalerAggregatedListItems)
aalItems = lens _aalItems (\ s a -> s{_aalItems = a})

-- | [Output Only] Server-defined URL for this resource.
aalSelfLink :: Lens' AutoscalerAggregatedList (Maybe Text)
aalSelfLink
  = lens _aalSelfLink (\ s a -> s{_aalSelfLink = a})

-- | [Output Only] Informational warning message.
aalWarning :: Lens' AutoscalerAggregatedList (Maybe AutoscalerAggregatedListWarning)
aalWarning
  = lens _aalWarning (\ s a -> s{_aalWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
aalId :: Lens' AutoscalerAggregatedList (Maybe Text)
aalId = lens _aalId (\ s a -> s{_aalId = a})

instance FromJSON AutoscalerAggregatedList where
        parseJSON
          = withObject "AutoscalerAggregatedList"
              (\ o ->
                 AutoscalerAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!= "compute#autoscalerAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON AutoscalerAggregatedList where
        toJSON AutoscalerAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _aalUnreachables,
                  ("nextPageToken" .=) <$> _aalNextPageToken,
                  Just ("kind" .= _aalKind),
                  ("items" .=) <$> _aalItems,
                  ("selfLink" .=) <$> _aalSelfLink,
                  ("warning" .=) <$> _aalWarning,
                  ("id" .=) <$> _aalId])

-- | A list of Router resources.
--
-- /See:/ 'routerAggregatedListItems' smart constructor.
newtype RouterAggregatedListItems =
  RouterAggregatedListItems'
    { _rAddtional :: HashMap Text RoutersScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RouterAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rAddtional'
routerAggregatedListItems
    :: HashMap Text RoutersScopedList -- ^ 'rAddtional'
    -> RouterAggregatedListItems
routerAggregatedListItems pRAddtional_ =
  RouterAggregatedListItems' {_rAddtional = _Coerce # pRAddtional_}


-- | Name of the scope containing this set of routers.
rAddtional :: Lens' RouterAggregatedListItems (HashMap Text RoutersScopedList)
rAddtional
  = lens _rAddtional (\ s a -> s{_rAddtional = a}) .
      _Coerce

instance FromJSON RouterAggregatedListItems where
        parseJSON
          = withObject "RouterAggregatedListItems"
              (\ o ->
                 RouterAggregatedListItems' <$> (parseJSONObject o))

instance ToJSON RouterAggregatedListItems where
        toJSON = toJSON . _rAddtional

-- | [Output Only] An informational warning that appears when the accelerator
-- types list is empty.
--
-- /See:/ 'acceleratorTypesScopedListWarning' smart constructor.
data AcceleratorTypesScopedListWarning =
  AcceleratorTypesScopedListWarning'
    { _atslwData :: !(Maybe [AcceleratorTypesScopedListWarningDataItem])
    , _atslwCode :: !(Maybe AcceleratorTypesScopedListWarningCode)
    , _atslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AcceleratorTypesScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'atslwData'
--
-- * 'atslwCode'
--
-- * 'atslwMessage'
acceleratorTypesScopedListWarning
    :: AcceleratorTypesScopedListWarning
acceleratorTypesScopedListWarning =
  AcceleratorTypesScopedListWarning'
    {_atslwData = Nothing, _atslwCode = Nothing, _atslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
atslwData :: Lens' AcceleratorTypesScopedListWarning [AcceleratorTypesScopedListWarningDataItem]
atslwData
  = lens _atslwData (\ s a -> s{_atslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
atslwCode :: Lens' AcceleratorTypesScopedListWarning (Maybe AcceleratorTypesScopedListWarningCode)
atslwCode
  = lens _atslwCode (\ s a -> s{_atslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
atslwMessage :: Lens' AcceleratorTypesScopedListWarning (Maybe Text)
atslwMessage
  = lens _atslwMessage (\ s a -> s{_atslwMessage = a})

instance FromJSON AcceleratorTypesScopedListWarning
         where
        parseJSON
          = withObject "AcceleratorTypesScopedListWarning"
              (\ o ->
                 AcceleratorTypesScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON AcceleratorTypesScopedListWarning
         where
        toJSON AcceleratorTypesScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _atslwData,
                  ("code" .=) <$> _atslwCode,
                  ("message" .=) <$> _atslwMessage])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'publicDelegatedPrefixListWarning' smart constructor.
data PublicDelegatedPrefixListWarning =
  PublicDelegatedPrefixListWarning'
    { _pdplwData :: !(Maybe [PublicDelegatedPrefixListWarningDataItem])
    , _pdplwCode :: !(Maybe PublicDelegatedPrefixListWarningCode)
    , _pdplwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PublicDelegatedPrefixListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pdplwData'
--
-- * 'pdplwCode'
--
-- * 'pdplwMessage'
publicDelegatedPrefixListWarning
    :: PublicDelegatedPrefixListWarning
publicDelegatedPrefixListWarning =
  PublicDelegatedPrefixListWarning'
    {_pdplwData = Nothing, _pdplwCode = Nothing, _pdplwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
pdplwData :: Lens' PublicDelegatedPrefixListWarning [PublicDelegatedPrefixListWarningDataItem]
pdplwData
  = lens _pdplwData (\ s a -> s{_pdplwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
pdplwCode :: Lens' PublicDelegatedPrefixListWarning (Maybe PublicDelegatedPrefixListWarningCode)
pdplwCode
  = lens _pdplwCode (\ s a -> s{_pdplwCode = a})

-- | [Output Only] A human-readable description of the warning code.
pdplwMessage :: Lens' PublicDelegatedPrefixListWarning (Maybe Text)
pdplwMessage
  = lens _pdplwMessage (\ s a -> s{_pdplwMessage = a})

instance FromJSON PublicDelegatedPrefixListWarning
         where
        parseJSON
          = withObject "PublicDelegatedPrefixListWarning"
              (\ o ->
                 PublicDelegatedPrefixListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON PublicDelegatedPrefixListWarning
         where
        toJSON PublicDelegatedPrefixListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _pdplwData,
                  ("code" .=) <$> _pdplwCode,
                  ("message" .=) <$> _pdplwMessage])

-- | Represents a Target TCP Proxy resource. A target TCP proxy is a
-- component of a TCP Proxy load balancer. Global forwarding rules
-- reference target TCP proxy, and the target proxy then references an
-- external backend service. For more information, read TCP Proxy Load
-- Balancing overview. (== resource_for {$api_version}.targetTcpProxies ==)
--
-- /See:/ 'targetTCPProxy' smart constructor.
data TargetTCPProxy =
  TargetTCPProxy'
    { _ttpService :: !(Maybe Text)
    , _ttpProxyBind :: !(Maybe Bool)
    , _ttpKind :: !Text
    , _ttpSelfLink :: !(Maybe Text)
    , _ttpName :: !(Maybe Text)
    , _ttpCreationTimestamp :: !(Maybe Text)
    , _ttpId :: !(Maybe (Textual Word64))
    , _ttpProxyHeader :: !(Maybe TargetTCPProxyProxyHeader)
    , _ttpDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetTCPProxy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ttpService'
--
-- * 'ttpProxyBind'
--
-- * 'ttpKind'
--
-- * 'ttpSelfLink'
--
-- * 'ttpName'
--
-- * 'ttpCreationTimestamp'
--
-- * 'ttpId'
--
-- * 'ttpProxyHeader'
--
-- * 'ttpDescription'
targetTCPProxy
    :: TargetTCPProxy
targetTCPProxy =
  TargetTCPProxy'
    { _ttpService = Nothing
    , _ttpProxyBind = Nothing
    , _ttpKind = "compute#targetTcpProxy"
    , _ttpSelfLink = Nothing
    , _ttpName = Nothing
    , _ttpCreationTimestamp = Nothing
    , _ttpId = Nothing
    , _ttpProxyHeader = Nothing
    , _ttpDescription = Nothing
    }


-- | URL to the BackendService resource.
ttpService :: Lens' TargetTCPProxy (Maybe Text)
ttpService
  = lens _ttpService (\ s a -> s{_ttpService = a})

-- | This field only applies when the forwarding rule that references this
-- target proxy has a loadBalancingScheme set to INTERNAL_SELF_MANAGED.
-- When this field is set to true, Envoy proxies set up inbound traffic
-- interception and bind to the IP address and port specified in the
-- forwarding rule. This is generally useful when using Traffic Director to
-- configure Envoy as a gateway or middle proxy (in other words, not a
-- sidecar proxy). The Envoy proxy listens for inbound requests and handles
-- requests when it receives them. The default is false.
ttpProxyBind :: Lens' TargetTCPProxy (Maybe Bool)
ttpProxyBind
  = lens _ttpProxyBind (\ s a -> s{_ttpProxyBind = a})

-- | [Output Only] Type of the resource. Always compute#targetTcpProxy for
-- target TCP proxies.
ttpKind :: Lens' TargetTCPProxy Text
ttpKind = lens _ttpKind (\ s a -> s{_ttpKind = a})

-- | [Output Only] Server-defined URL for the resource.
ttpSelfLink :: Lens' TargetTCPProxy (Maybe Text)
ttpSelfLink
  = lens _ttpSelfLink (\ s a -> s{_ttpSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
ttpName :: Lens' TargetTCPProxy (Maybe Text)
ttpName = lens _ttpName (\ s a -> s{_ttpName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
ttpCreationTimestamp :: Lens' TargetTCPProxy (Maybe Text)
ttpCreationTimestamp
  = lens _ttpCreationTimestamp
      (\ s a -> s{_ttpCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
ttpId :: Lens' TargetTCPProxy (Maybe Word64)
ttpId
  = lens _ttpId (\ s a -> s{_ttpId = a}) .
      mapping _Coerce

-- | Specifies the type of proxy header to append before sending data to the
-- backend, either NONE or PROXY_V1. The default is NONE.
ttpProxyHeader :: Lens' TargetTCPProxy (Maybe TargetTCPProxyProxyHeader)
ttpProxyHeader
  = lens _ttpProxyHeader
      (\ s a -> s{_ttpProxyHeader = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource.
ttpDescription :: Lens' TargetTCPProxy (Maybe Text)
ttpDescription
  = lens _ttpDescription
      (\ s a -> s{_ttpDescription = a})

instance FromJSON TargetTCPProxy where
        parseJSON
          = withObject "TargetTCPProxy"
              (\ o ->
                 TargetTCPProxy' <$>
                   (o .:? "service") <*> (o .:? "proxyBind") <*>
                     (o .:? "kind" .!= "compute#targetTcpProxy")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "proxyHeader")
                     <*> (o .:? "description"))

instance ToJSON TargetTCPProxy where
        toJSON TargetTCPProxy'{..}
          = object
              (catMaybes
                 [("service" .=) <$> _ttpService,
                  ("proxyBind" .=) <$> _ttpProxyBind,
                  Just ("kind" .= _ttpKind),
                  ("selfLink" .=) <$> _ttpSelfLink,
                  ("name" .=) <$> _ttpName,
                  ("creationTimestamp" .=) <$> _ttpCreationTimestamp,
                  ("id" .=) <$> _ttpId,
                  ("proxyHeader" .=) <$> _ttpProxyHeader,
                  ("description" .=) <$> _ttpDescription])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'backendBucketListWarning' smart constructor.
data BackendBucketListWarning =
  BackendBucketListWarning'
    { _bblwData :: !(Maybe [BackendBucketListWarningDataItem])
    , _bblwCode :: !(Maybe BackendBucketListWarningCode)
    , _bblwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendBucketListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bblwData'
--
-- * 'bblwCode'
--
-- * 'bblwMessage'
backendBucketListWarning
    :: BackendBucketListWarning
backendBucketListWarning =
  BackendBucketListWarning'
    {_bblwData = Nothing, _bblwCode = Nothing, _bblwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
bblwData :: Lens' BackendBucketListWarning [BackendBucketListWarningDataItem]
bblwData
  = lens _bblwData (\ s a -> s{_bblwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
bblwCode :: Lens' BackendBucketListWarning (Maybe BackendBucketListWarningCode)
bblwCode = lens _bblwCode (\ s a -> s{_bblwCode = a})

-- | [Output Only] A human-readable description of the warning code.
bblwMessage :: Lens' BackendBucketListWarning (Maybe Text)
bblwMessage
  = lens _bblwMessage (\ s a -> s{_bblwMessage = a})

instance FromJSON BackendBucketListWarning where
        parseJSON
          = withObject "BackendBucketListWarning"
              (\ o ->
                 BackendBucketListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON BackendBucketListWarning where
        toJSON BackendBucketListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _bblwData,
                  ("code" .=) <$> _bblwCode,
                  ("message" .=) <$> _bblwMessage])

-- | Configuration for a Cloud Run network endpoint group (NEG). The service
-- must be provided explicitly or in the URL mask. The tag is optional, may
-- be provided explicitly or in the URL mask. Note: Cloud Run service must
-- be in the same project and located in the same region as the Serverless
-- NEG.
--
-- /See:/ 'networkEndpointGroupCloudRun' smart constructor.
data NetworkEndpointGroupCloudRun =
  NetworkEndpointGroupCloudRun'
    { _negcrTag :: !(Maybe Text)
    , _negcrService :: !(Maybe Text)
    , _negcrURLMask :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkEndpointGroupCloudRun' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'negcrTag'
--
-- * 'negcrService'
--
-- * 'negcrURLMask'
networkEndpointGroupCloudRun
    :: NetworkEndpointGroupCloudRun
networkEndpointGroupCloudRun =
  NetworkEndpointGroupCloudRun'
    {_negcrTag = Nothing, _negcrService = Nothing, _negcrURLMask = Nothing}


-- | Optional Cloud Run tag represents the \"named-revision\" to provide
-- additional fine-grained traffic routing information. The tag must be
-- 1-63 characters long, and comply with RFC1035. Example value:
-- \"revision-0010\".
negcrTag :: Lens' NetworkEndpointGroupCloudRun (Maybe Text)
negcrTag = lens _negcrTag (\ s a -> s{_negcrTag = a})

-- | Cloud Run service is the main resource of Cloud Run. The service must be
-- 1-63 characters long, and comply with RFC1035. Example value:
-- \"run-service\".
negcrService :: Lens' NetworkEndpointGroupCloudRun (Maybe Text)
negcrService
  = lens _negcrService (\ s a -> s{_negcrService = a})

-- | A template to parse service and tag fields from a request URL. URL mask
-- allows for routing to multiple Run services without having to create
-- multiple network endpoint groups and backend services. For example,
-- request URLs \"foo1.domain.com\/bar1\" and \"foo1.domain.com\/bar2\" can
-- be backed by the same Serverless Network Endpoint Group (NEG) with URL
-- mask \".domain.com\/\". The URL mask will parse them to {
-- service=\"bar1\", tag=\"foo1\" } and { service=\"bar2\", tag=\"foo2\" }
-- respectively.
negcrURLMask :: Lens' NetworkEndpointGroupCloudRun (Maybe Text)
negcrURLMask
  = lens _negcrURLMask (\ s a -> s{_negcrURLMask = a})

instance FromJSON NetworkEndpointGroupCloudRun where
        parseJSON
          = withObject "NetworkEndpointGroupCloudRun"
              (\ o ->
                 NetworkEndpointGroupCloudRun' <$>
                   (o .:? "tag") <*> (o .:? "service") <*>
                     (o .:? "urlMask"))

instance ToJSON NetworkEndpointGroupCloudRun where
        toJSON NetworkEndpointGroupCloudRun'{..}
          = object
              (catMaybes
                 [("tag" .=) <$> _negcrTag,
                  ("service" .=) <$> _negcrService,
                  ("urlMask" .=) <$> _negcrURLMask])

-- | Labels to apply to this image. These can be later modified by the
-- setLabels method.
--
-- /See:/ 'imageLabels' smart constructor.
newtype ImageLabels =
  ImageLabels'
    { _iAddtional :: HashMap Text Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ImageLabels' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iAddtional'
imageLabels
    :: HashMap Text Text -- ^ 'iAddtional'
    -> ImageLabels
imageLabels pIAddtional_ = ImageLabels' {_iAddtional = _Coerce # pIAddtional_}


iAddtional :: Lens' ImageLabels (HashMap Text Text)
iAddtional
  = lens _iAddtional (\ s a -> s{_iAddtional = a}) .
      _Coerce

instance FromJSON ImageLabels where
        parseJSON
          = withObject "ImageLabels"
              (\ o -> ImageLabels' <$> (parseJSONObject o))

instance ToJSON ImageLabels where
        toJSON = toJSON . _iAddtional

--
-- /See:/ 'publicDelegatedPrefixAggregatedListWarningDataItem' smart constructor.
data PublicDelegatedPrefixAggregatedListWarningDataItem =
  PublicDelegatedPrefixAggregatedListWarningDataItem'
    { _pdpalwdiValue :: !(Maybe Text)
    , _pdpalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PublicDelegatedPrefixAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pdpalwdiValue'
--
-- * 'pdpalwdiKey'
publicDelegatedPrefixAggregatedListWarningDataItem
    :: PublicDelegatedPrefixAggregatedListWarningDataItem
publicDelegatedPrefixAggregatedListWarningDataItem =
  PublicDelegatedPrefixAggregatedListWarningDataItem'
    {_pdpalwdiValue = Nothing, _pdpalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
pdpalwdiValue :: Lens' PublicDelegatedPrefixAggregatedListWarningDataItem (Maybe Text)
pdpalwdiValue
  = lens _pdpalwdiValue
      (\ s a -> s{_pdpalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
pdpalwdiKey :: Lens' PublicDelegatedPrefixAggregatedListWarningDataItem (Maybe Text)
pdpalwdiKey
  = lens _pdpalwdiKey (\ s a -> s{_pdpalwdiKey = a})

instance FromJSON
           PublicDelegatedPrefixAggregatedListWarningDataItem
         where
        parseJSON
          = withObject
              "PublicDelegatedPrefixAggregatedListWarningDataItem"
              (\ o ->
                 PublicDelegatedPrefixAggregatedListWarningDataItem'
                   <$> (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           PublicDelegatedPrefixAggregatedListWarningDataItem
         where
        toJSON
          PublicDelegatedPrefixAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _pdpalwdiValue,
                  ("key" .=) <$> _pdpalwdiKey])

--
-- /See:/ 'distributionPolicy' smart constructor.
data DistributionPolicy =
  DistributionPolicy'
    { _dpZones :: !(Maybe [DistributionPolicyZoneConfiguration])
    , _dpTargetShape :: !(Maybe DistributionPolicyTargetShape)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DistributionPolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dpZones'
--
-- * 'dpTargetShape'
distributionPolicy
    :: DistributionPolicy
distributionPolicy =
  DistributionPolicy' {_dpZones = Nothing, _dpTargetShape = Nothing}


-- | Zones where the regional managed instance group will create and manage
-- its instances.
dpZones :: Lens' DistributionPolicy [DistributionPolicyZoneConfiguration]
dpZones
  = lens _dpZones (\ s a -> s{_dpZones = a}) . _Default
      . _Coerce

-- | The distribution shape to which the group converges either proactively
-- or on resize events (depending on the value set in
-- updatePolicy.instanceRedistributionType).
dpTargetShape :: Lens' DistributionPolicy (Maybe DistributionPolicyTargetShape)
dpTargetShape
  = lens _dpTargetShape
      (\ s a -> s{_dpTargetShape = a})

instance FromJSON DistributionPolicy where
        parseJSON
          = withObject "DistributionPolicy"
              (\ o ->
                 DistributionPolicy' <$>
                   (o .:? "zones" .!= mempty) <*> (o .:? "targetShape"))

instance ToJSON DistributionPolicy where
        toJSON DistributionPolicy'{..}
          = object
              (catMaybes
                 [("zones" .=) <$> _dpZones,
                  ("targetShape" .=) <$> _dpTargetShape])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'regionInstanceGroupManagersListInstanceConfigsRespWarning' smart constructor.
data RegionInstanceGroupManagersListInstanceConfigsRespWarning =
  RegionInstanceGroupManagersListInstanceConfigsRespWarning'
    { _rigmlicrwData :: !(Maybe [RegionInstanceGroupManagersListInstanceConfigsRespWarningDataItem])
    , _rigmlicrwCode :: !(Maybe RegionInstanceGroupManagersListInstanceConfigsRespWarningCode)
    , _rigmlicrwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupManagersListInstanceConfigsRespWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rigmlicrwData'
--
-- * 'rigmlicrwCode'
--
-- * 'rigmlicrwMessage'
regionInstanceGroupManagersListInstanceConfigsRespWarning
    :: RegionInstanceGroupManagersListInstanceConfigsRespWarning
regionInstanceGroupManagersListInstanceConfigsRespWarning =
  RegionInstanceGroupManagersListInstanceConfigsRespWarning'
    { _rigmlicrwData = Nothing
    , _rigmlicrwCode = Nothing
    , _rigmlicrwMessage = Nothing
    }


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
rigmlicrwData :: Lens' RegionInstanceGroupManagersListInstanceConfigsRespWarning [RegionInstanceGroupManagersListInstanceConfigsRespWarningDataItem]
rigmlicrwData
  = lens _rigmlicrwData
      (\ s a -> s{_rigmlicrwData = a})
      . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
rigmlicrwCode :: Lens' RegionInstanceGroupManagersListInstanceConfigsRespWarning (Maybe RegionInstanceGroupManagersListInstanceConfigsRespWarningCode)
rigmlicrwCode
  = lens _rigmlicrwCode
      (\ s a -> s{_rigmlicrwCode = a})

-- | [Output Only] A human-readable description of the warning code.
rigmlicrwMessage :: Lens' RegionInstanceGroupManagersListInstanceConfigsRespWarning (Maybe Text)
rigmlicrwMessage
  = lens _rigmlicrwMessage
      (\ s a -> s{_rigmlicrwMessage = a})

instance FromJSON
           RegionInstanceGroupManagersListInstanceConfigsRespWarning
         where
        parseJSON
          = withObject
              "RegionInstanceGroupManagersListInstanceConfigsRespWarning"
              (\ o ->
                 RegionInstanceGroupManagersListInstanceConfigsRespWarning'
                   <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON
           RegionInstanceGroupManagersListInstanceConfigsRespWarning
         where
        toJSON
          RegionInstanceGroupManagersListInstanceConfigsRespWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _rigmlicrwData,
                  ("code" .=) <$> _rigmlicrwCode,
                  ("message" .=) <$> _rigmlicrwMessage])

--
-- /See:/ 'nodeGroupListWarningDataItem' smart constructor.
data NodeGroupListWarningDataItem =
  NodeGroupListWarningDataItem'
    { _nglwdiValue :: !(Maybe Text)
    , _nglwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeGroupListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nglwdiValue'
--
-- * 'nglwdiKey'
nodeGroupListWarningDataItem
    :: NodeGroupListWarningDataItem
nodeGroupListWarningDataItem =
  NodeGroupListWarningDataItem' {_nglwdiValue = Nothing, _nglwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
nglwdiValue :: Lens' NodeGroupListWarningDataItem (Maybe Text)
nglwdiValue
  = lens _nglwdiValue (\ s a -> s{_nglwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
nglwdiKey :: Lens' NodeGroupListWarningDataItem (Maybe Text)
nglwdiKey
  = lens _nglwdiKey (\ s a -> s{_nglwdiKey = a})

instance FromJSON NodeGroupListWarningDataItem where
        parseJSON
          = withObject "NodeGroupListWarningDataItem"
              (\ o ->
                 NodeGroupListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON NodeGroupListWarningDataItem where
        toJSON NodeGroupListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _nglwdiValue,
                  ("key" .=) <$> _nglwdiKey])

-- | Commitment for a particular license resource.
--
-- /See:/ 'licenseResourceCommitment' smart constructor.
data LicenseResourceCommitment =
  LicenseResourceCommitment'
    { _lrcCoresPerLicense :: !(Maybe Text)
    , _lrcAmount :: !(Maybe (Textual Int64))
    , _lrcLicense :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'LicenseResourceCommitment' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'lrcCoresPerLicense'
--
-- * 'lrcAmount'
--
-- * 'lrcLicense'
licenseResourceCommitment
    :: LicenseResourceCommitment
licenseResourceCommitment =
  LicenseResourceCommitment'
    {_lrcCoresPerLicense = Nothing, _lrcAmount = Nothing, _lrcLicense = Nothing}


-- | Specifies the core range of the instance for which this license applies.
lrcCoresPerLicense :: Lens' LicenseResourceCommitment (Maybe Text)
lrcCoresPerLicense
  = lens _lrcCoresPerLicense
      (\ s a -> s{_lrcCoresPerLicense = a})

-- | The number of licenses purchased.
lrcAmount :: Lens' LicenseResourceCommitment (Maybe Int64)
lrcAmount
  = lens _lrcAmount (\ s a -> s{_lrcAmount = a}) .
      mapping _Coerce

-- | Any applicable license URI.
lrcLicense :: Lens' LicenseResourceCommitment (Maybe Text)
lrcLicense
  = lens _lrcLicense (\ s a -> s{_lrcLicense = a})

instance FromJSON LicenseResourceCommitment where
        parseJSON
          = withObject "LicenseResourceCommitment"
              (\ o ->
                 LicenseResourceCommitment' <$>
                   (o .:? "coresPerLicense") <*> (o .:? "amount") <*>
                     (o .:? "license"))

instance ToJSON LicenseResourceCommitment where
        toJSON LicenseResourceCommitment'{..}
          = object
              (catMaybes
                 [("coresPerLicense" .=) <$> _lrcCoresPerLicense,
                  ("amount" .=) <$> _lrcAmount,
                  ("license" .=) <$> _lrcLicense])

--
-- /See:/ 'packetMirroringMirroredResourceInfoInstanceInfo' smart constructor.
data PacketMirroringMirroredResourceInfoInstanceInfo =
  PacketMirroringMirroredResourceInfoInstanceInfo'
    { _pmmriiiURL :: !(Maybe Text)
    , _pmmriiiCanonicalURL :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PacketMirroringMirroredResourceInfoInstanceInfo' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pmmriiiURL'
--
-- * 'pmmriiiCanonicalURL'
packetMirroringMirroredResourceInfoInstanceInfo
    :: PacketMirroringMirroredResourceInfoInstanceInfo
packetMirroringMirroredResourceInfoInstanceInfo =
  PacketMirroringMirroredResourceInfoInstanceInfo'
    {_pmmriiiURL = Nothing, _pmmriiiCanonicalURL = Nothing}


-- | Resource URL to the virtual machine instance which is being mirrored.
pmmriiiURL :: Lens' PacketMirroringMirroredResourceInfoInstanceInfo (Maybe Text)
pmmriiiURL
  = lens _pmmriiiURL (\ s a -> s{_pmmriiiURL = a})

-- | [Output Only] Unique identifier for the instance; defined by the server.
pmmriiiCanonicalURL :: Lens' PacketMirroringMirroredResourceInfoInstanceInfo (Maybe Text)
pmmriiiCanonicalURL
  = lens _pmmriiiCanonicalURL
      (\ s a -> s{_pmmriiiCanonicalURL = a})

instance FromJSON
           PacketMirroringMirroredResourceInfoInstanceInfo
         where
        parseJSON
          = withObject
              "PacketMirroringMirroredResourceInfoInstanceInfo"
              (\ o ->
                 PacketMirroringMirroredResourceInfoInstanceInfo' <$>
                   (o .:? "url") <*> (o .:? "canonicalUrl"))

instance ToJSON
           PacketMirroringMirroredResourceInfoInstanceInfo
         where
        toJSON
          PacketMirroringMirroredResourceInfoInstanceInfo'{..}
          = object
              (catMaybes
                 [("url" .=) <$> _pmmriiiURL,
                  ("canonicalUrl" .=) <$> _pmmriiiCanonicalURL])

-- | Cloud Autoscaler policy.
--
-- /See:/ 'autoscalingPolicy' smart constructor.
data AutoscalingPolicy =
  AutoscalingPolicy'
    { _apScaleInControl :: !(Maybe AutoscalingPolicyScaleInControl)
    , _apMode :: !(Maybe AutoscalingPolicyMode)
    , _apScalingSchedules :: !(Maybe AutoscalingPolicyScalingSchedules)
    , _apCustomMetricUtilizations :: !(Maybe [AutoscalingPolicyCustomMetricUtilization])
    , _apMaxNumReplicas :: !(Maybe (Textual Int32))
    , _apCPUUtilization :: !(Maybe AutoscalingPolicyCPUUtilization)
    , _apLoadBalancingUtilization :: !(Maybe AutoscalingPolicyLoadBalancingUtilization)
    , _apMinNumReplicas :: !(Maybe (Textual Int32))
    , _apCoolDownPeriodSec :: !(Maybe (Textual Int32))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AutoscalingPolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'apScaleInControl'
--
-- * 'apMode'
--
-- * 'apScalingSchedules'
--
-- * 'apCustomMetricUtilizations'
--
-- * 'apMaxNumReplicas'
--
-- * 'apCPUUtilization'
--
-- * 'apLoadBalancingUtilization'
--
-- * 'apMinNumReplicas'
--
-- * 'apCoolDownPeriodSec'
autoscalingPolicy
    :: AutoscalingPolicy
autoscalingPolicy =
  AutoscalingPolicy'
    { _apScaleInControl = Nothing
    , _apMode = Nothing
    , _apScalingSchedules = Nothing
    , _apCustomMetricUtilizations = Nothing
    , _apMaxNumReplicas = Nothing
    , _apCPUUtilization = Nothing
    , _apLoadBalancingUtilization = Nothing
    , _apMinNumReplicas = Nothing
    , _apCoolDownPeriodSec = Nothing
    }


apScaleInControl :: Lens' AutoscalingPolicy (Maybe AutoscalingPolicyScaleInControl)
apScaleInControl
  = lens _apScaleInControl
      (\ s a -> s{_apScaleInControl = a})

-- | Defines operating mode for this policy.
apMode :: Lens' AutoscalingPolicy (Maybe AutoscalingPolicyMode)
apMode = lens _apMode (\ s a -> s{_apMode = a})

-- | Scaling schedules defined for an autoscaler. Multiple schedules can be
-- set on an autoscaler, and they can overlap. During overlapping periods
-- the greatest min_required_replicas of all scaling schedules is applied.
-- Up to 128 scaling schedules are allowed.
apScalingSchedules :: Lens' AutoscalingPolicy (Maybe AutoscalingPolicyScalingSchedules)
apScalingSchedules
  = lens _apScalingSchedules
      (\ s a -> s{_apScalingSchedules = a})

-- | Configuration parameters of autoscaling based on a custom metric.
apCustomMetricUtilizations :: Lens' AutoscalingPolicy [AutoscalingPolicyCustomMetricUtilization]
apCustomMetricUtilizations
  = lens _apCustomMetricUtilizations
      (\ s a -> s{_apCustomMetricUtilizations = a})
      . _Default
      . _Coerce

-- | The maximum number of instances that the autoscaler can scale out to.
-- This is required when creating or updating an autoscaler. The maximum
-- number of replicas must not be lower than minimal number of replicas.
apMaxNumReplicas :: Lens' AutoscalingPolicy (Maybe Int32)
apMaxNumReplicas
  = lens _apMaxNumReplicas
      (\ s a -> s{_apMaxNumReplicas = a})
      . mapping _Coerce

-- | Defines the CPU utilization policy that allows the autoscaler to scale
-- based on the average CPU utilization of a managed instance group.
apCPUUtilization :: Lens' AutoscalingPolicy (Maybe AutoscalingPolicyCPUUtilization)
apCPUUtilization
  = lens _apCPUUtilization
      (\ s a -> s{_apCPUUtilization = a})

-- | Configuration parameters of autoscaling based on load balancer.
apLoadBalancingUtilization :: Lens' AutoscalingPolicy (Maybe AutoscalingPolicyLoadBalancingUtilization)
apLoadBalancingUtilization
  = lens _apLoadBalancingUtilization
      (\ s a -> s{_apLoadBalancingUtilization = a})

-- | The minimum number of replicas that the autoscaler can scale in to. This
-- cannot be less than 0. If not provided, autoscaler chooses a default
-- value depending on maximum number of instances allowed.
apMinNumReplicas :: Lens' AutoscalingPolicy (Maybe Int32)
apMinNumReplicas
  = lens _apMinNumReplicas
      (\ s a -> s{_apMinNumReplicas = a})
      . mapping _Coerce

-- | The number of seconds that the autoscaler waits before it starts
-- collecting information from a new instance. This prevents the autoscaler
-- from collecting information when the instance is initializing, during
-- which the collected usage would not be reliable. The default time
-- autoscaler waits is 60 seconds. Virtual machine initialization times
-- might vary because of numerous factors. We recommend that you test how
-- long an instance may take to initialize. To do this, create an instance
-- and time the startup process.
apCoolDownPeriodSec :: Lens' AutoscalingPolicy (Maybe Int32)
apCoolDownPeriodSec
  = lens _apCoolDownPeriodSec
      (\ s a -> s{_apCoolDownPeriodSec = a})
      . mapping _Coerce

instance FromJSON AutoscalingPolicy where
        parseJSON
          = withObject "AutoscalingPolicy"
              (\ o ->
                 AutoscalingPolicy' <$>
                   (o .:? "scaleInControl") <*> (o .:? "mode") <*>
                     (o .:? "scalingSchedules")
                     <*> (o .:? "customMetricUtilizations" .!= mempty)
                     <*> (o .:? "maxNumReplicas")
                     <*> (o .:? "cpuUtilization")
                     <*> (o .:? "loadBalancingUtilization")
                     <*> (o .:? "minNumReplicas")
                     <*> (o .:? "coolDownPeriodSec"))

instance ToJSON AutoscalingPolicy where
        toJSON AutoscalingPolicy'{..}
          = object
              (catMaybes
                 [("scaleInControl" .=) <$> _apScaleInControl,
                  ("mode" .=) <$> _apMode,
                  ("scalingSchedules" .=) <$> _apScalingSchedules,
                  ("customMetricUtilizations" .=) <$>
                    _apCustomMetricUtilizations,
                  ("maxNumReplicas" .=) <$> _apMaxNumReplicas,
                  ("cpuUtilization" .=) <$> _apCPUUtilization,
                  ("loadBalancingUtilization" .=) <$>
                    _apLoadBalancingUtilization,
                  ("minNumReplicas" .=) <$> _apMinNumReplicas,
                  ("coolDownPeriodSec" .=) <$> _apCoolDownPeriodSec])

--
-- /See:/ 'packetMirroringForwardingRuleInfo' smart constructor.
data PacketMirroringForwardingRuleInfo =
  PacketMirroringForwardingRuleInfo'
    { _pmfriURL :: !(Maybe Text)
    , _pmfriCanonicalURL :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PacketMirroringForwardingRuleInfo' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pmfriURL'
--
-- * 'pmfriCanonicalURL'
packetMirroringForwardingRuleInfo
    :: PacketMirroringForwardingRuleInfo
packetMirroringForwardingRuleInfo =
  PacketMirroringForwardingRuleInfo'
    {_pmfriURL = Nothing, _pmfriCanonicalURL = Nothing}


-- | Resource URL to the forwarding rule representing the ILB configured as
-- destination of the mirrored traffic.
pmfriURL :: Lens' PacketMirroringForwardingRuleInfo (Maybe Text)
pmfriURL = lens _pmfriURL (\ s a -> s{_pmfriURL = a})

-- | [Output Only] Unique identifier for the forwarding rule; defined by the
-- server.
pmfriCanonicalURL :: Lens' PacketMirroringForwardingRuleInfo (Maybe Text)
pmfriCanonicalURL
  = lens _pmfriCanonicalURL
      (\ s a -> s{_pmfriCanonicalURL = a})

instance FromJSON PacketMirroringForwardingRuleInfo
         where
        parseJSON
          = withObject "PacketMirroringForwardingRuleInfo"
              (\ o ->
                 PacketMirroringForwardingRuleInfo' <$>
                   (o .:? "url") <*> (o .:? "canonicalUrl"))

instance ToJSON PacketMirroringForwardingRuleInfo
         where
        toJSON PacketMirroringForwardingRuleInfo'{..}
          = object
              (catMaybes
                 [("url" .=) <$> _pmfriURL,
                  ("canonicalUrl" .=) <$> _pmfriCanonicalURL])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'nodeGroupAggregatedListWarning' smart constructor.
data NodeGroupAggregatedListWarning =
  NodeGroupAggregatedListWarning'
    { _ngalwData :: !(Maybe [NodeGroupAggregatedListWarningDataItem])
    , _ngalwCode :: !(Maybe NodeGroupAggregatedListWarningCode)
    , _ngalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeGroupAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ngalwData'
--
-- * 'ngalwCode'
--
-- * 'ngalwMessage'
nodeGroupAggregatedListWarning
    :: NodeGroupAggregatedListWarning
nodeGroupAggregatedListWarning =
  NodeGroupAggregatedListWarning'
    {_ngalwData = Nothing, _ngalwCode = Nothing, _ngalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
ngalwData :: Lens' NodeGroupAggregatedListWarning [NodeGroupAggregatedListWarningDataItem]
ngalwData
  = lens _ngalwData (\ s a -> s{_ngalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
ngalwCode :: Lens' NodeGroupAggregatedListWarning (Maybe NodeGroupAggregatedListWarningCode)
ngalwCode
  = lens _ngalwCode (\ s a -> s{_ngalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
ngalwMessage :: Lens' NodeGroupAggregatedListWarning (Maybe Text)
ngalwMessage
  = lens _ngalwMessage (\ s a -> s{_ngalwMessage = a})

instance FromJSON NodeGroupAggregatedListWarning
         where
        parseJSON
          = withObject "NodeGroupAggregatedListWarning"
              (\ o ->
                 NodeGroupAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON NodeGroupAggregatedListWarning where
        toJSON NodeGroupAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _ngalwData,
                  ("code" .=) <$> _ngalwCode,
                  ("message" .=) <$> _ngalwMessage])

-- | Contains a list of region resources.
--
-- /See:/ 'regionList' smart constructor.
data RegionList =
  RegionList'
    { _regNextPageToken :: !(Maybe Text)
    , _regKind :: !Text
    , _regItems :: !(Maybe [Region])
    , _regSelfLink :: !(Maybe Text)
    , _regWarning :: !(Maybe RegionListWarning)
    , _regId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'regNextPageToken'
--
-- * 'regKind'
--
-- * 'regItems'
--
-- * 'regSelfLink'
--
-- * 'regWarning'
--
-- * 'regId'
regionList
    :: RegionList
regionList =
  RegionList'
    { _regNextPageToken = Nothing
    , _regKind = "compute#regionList"
    , _regItems = Nothing
    , _regSelfLink = Nothing
    , _regWarning = Nothing
    , _regId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
regNextPageToken :: Lens' RegionList (Maybe Text)
regNextPageToken
  = lens _regNextPageToken
      (\ s a -> s{_regNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#regionList for lists of
-- regions.
regKind :: Lens' RegionList Text
regKind = lens _regKind (\ s a -> s{_regKind = a})

-- | A list of Region resources.
regItems :: Lens' RegionList [Region]
regItems
  = lens _regItems (\ s a -> s{_regItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
regSelfLink :: Lens' RegionList (Maybe Text)
regSelfLink
  = lens _regSelfLink (\ s a -> s{_regSelfLink = a})

-- | [Output Only] Informational warning message.
regWarning :: Lens' RegionList (Maybe RegionListWarning)
regWarning
  = lens _regWarning (\ s a -> s{_regWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
regId :: Lens' RegionList (Maybe Text)
regId = lens _regId (\ s a -> s{_regId = a})

instance FromJSON RegionList where
        parseJSON
          = withObject "RegionList"
              (\ o ->
                 RegionList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#regionList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON RegionList where
        toJSON RegionList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _regNextPageToken,
                  Just ("kind" .= _regKind),
                  ("items" .=) <$> _regItems,
                  ("selfLink" .=) <$> _regSelfLink,
                  ("warning" .=) <$> _regWarning,
                  ("id" .=) <$> _regId])

-- | Configuration that allows for slower scale in so that even if Autoscaler
-- recommends an abrupt scale in of a MIG, it will be throttled as
-- specified by the parameters below.
--
-- /See:/ 'autoscalingPolicyScaleInControl' smart constructor.
data AutoscalingPolicyScaleInControl =
  AutoscalingPolicyScaleInControl'
    { _apsicTimeWindowSec :: !(Maybe (Textual Int32))
    , _apsicMaxScaledInReplicas :: !(Maybe FixedOrPercent)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AutoscalingPolicyScaleInControl' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'apsicTimeWindowSec'
--
-- * 'apsicMaxScaledInReplicas'
autoscalingPolicyScaleInControl
    :: AutoscalingPolicyScaleInControl
autoscalingPolicyScaleInControl =
  AutoscalingPolicyScaleInControl'
    {_apsicTimeWindowSec = Nothing, _apsicMaxScaledInReplicas = Nothing}


-- | How far back autoscaling looks when computing recommendations to include
-- directives regarding slower scale in, as described above.
apsicTimeWindowSec :: Lens' AutoscalingPolicyScaleInControl (Maybe Int32)
apsicTimeWindowSec
  = lens _apsicTimeWindowSec
      (\ s a -> s{_apsicTimeWindowSec = a})
      . mapping _Coerce

-- | Maximum allowed number (or %) of VMs that can be deducted from the peak
-- recommendation during the window autoscaler looks at when computing
-- recommendations. Possibly all these VMs can be deleted at once so user
-- service needs to be prepared to lose that many VMs in one step.
apsicMaxScaledInReplicas :: Lens' AutoscalingPolicyScaleInControl (Maybe FixedOrPercent)
apsicMaxScaledInReplicas
  = lens _apsicMaxScaledInReplicas
      (\ s a -> s{_apsicMaxScaledInReplicas = a})

instance FromJSON AutoscalingPolicyScaleInControl
         where
        parseJSON
          = withObject "AutoscalingPolicyScaleInControl"
              (\ o ->
                 AutoscalingPolicyScaleInControl' <$>
                   (o .:? "timeWindowSec") <*>
                     (o .:? "maxScaledInReplicas"))

instance ToJSON AutoscalingPolicyScaleInControl where
        toJSON AutoscalingPolicyScaleInControl'{..}
          = object
              (catMaybes
                 [("timeWindowSec" .=) <$> _apsicTimeWindowSec,
                  ("maxScaledInReplicas" .=) <$>
                    _apsicMaxScaledInReplicas])

-- | Contains a list of VpnGateway resources.
--
-- /See:/ 'vpnGatewayList' smart constructor.
data VPNGatewayList =
  VPNGatewayList'
    { _vglNextPageToken :: !(Maybe Text)
    , _vglKind :: !Text
    , _vglItems :: !(Maybe [VPNGateway])
    , _vglSelfLink :: !(Maybe Text)
    , _vglWarning :: !(Maybe VPNGatewayListWarning)
    , _vglId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNGatewayList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vglNextPageToken'
--
-- * 'vglKind'
--
-- * 'vglItems'
--
-- * 'vglSelfLink'
--
-- * 'vglWarning'
--
-- * 'vglId'
vpnGatewayList
    :: VPNGatewayList
vpnGatewayList =
  VPNGatewayList'
    { _vglNextPageToken = Nothing
    , _vglKind = "compute#vpnGatewayList"
    , _vglItems = Nothing
    , _vglSelfLink = Nothing
    , _vglWarning = Nothing
    , _vglId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
vglNextPageToken :: Lens' VPNGatewayList (Maybe Text)
vglNextPageToken
  = lens _vglNextPageToken
      (\ s a -> s{_vglNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#vpnGateway for VPN
-- gateways.
vglKind :: Lens' VPNGatewayList Text
vglKind = lens _vglKind (\ s a -> s{_vglKind = a})

-- | A list of VpnGateway resources.
vglItems :: Lens' VPNGatewayList [VPNGateway]
vglItems
  = lens _vglItems (\ s a -> s{_vglItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
vglSelfLink :: Lens' VPNGatewayList (Maybe Text)
vglSelfLink
  = lens _vglSelfLink (\ s a -> s{_vglSelfLink = a})

-- | [Output Only] Informational warning message.
vglWarning :: Lens' VPNGatewayList (Maybe VPNGatewayListWarning)
vglWarning
  = lens _vglWarning (\ s a -> s{_vglWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
vglId :: Lens' VPNGatewayList (Maybe Text)
vglId = lens _vglId (\ s a -> s{_vglId = a})

instance FromJSON VPNGatewayList where
        parseJSON
          = withObject "VPNGatewayList"
              (\ o ->
                 VPNGatewayList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#vpnGatewayList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON VPNGatewayList where
        toJSON VPNGatewayList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _vglNextPageToken,
                  Just ("kind" .= _vglKind),
                  ("items" .=) <$> _vglItems,
                  ("selfLink" .=) <$> _vglSelfLink,
                  ("warning" .=) <$> _vglWarning,
                  ("id" .=) <$> _vglId])

-- | Node Affinity: the configuration of desired nodes onto which this
-- Instance could be scheduled.
--
-- /See:/ 'schedulingNodeAffinity' smart constructor.
data SchedulingNodeAffinity =
  SchedulingNodeAffinity'
    { _snaOperator :: !(Maybe SchedulingNodeAffinityOperator)
    , _snaValues :: !(Maybe [Text])
    , _snaKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SchedulingNodeAffinity' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'snaOperator'
--
-- * 'snaValues'
--
-- * 'snaKey'
schedulingNodeAffinity
    :: SchedulingNodeAffinity
schedulingNodeAffinity =
  SchedulingNodeAffinity'
    {_snaOperator = Nothing, _snaValues = Nothing, _snaKey = Nothing}


-- | Defines the operation of node selection. Valid operators are IN for
-- affinity and NOT_IN for anti-affinity.
snaOperator :: Lens' SchedulingNodeAffinity (Maybe SchedulingNodeAffinityOperator)
snaOperator
  = lens _snaOperator (\ s a -> s{_snaOperator = a})

-- | Corresponds to the label values of Node resource.
snaValues :: Lens' SchedulingNodeAffinity [Text]
snaValues
  = lens _snaValues (\ s a -> s{_snaValues = a}) .
      _Default
      . _Coerce

-- | Corresponds to the label key of Node resource.
snaKey :: Lens' SchedulingNodeAffinity (Maybe Text)
snaKey = lens _snaKey (\ s a -> s{_snaKey = a})

instance FromJSON SchedulingNodeAffinity where
        parseJSON
          = withObject "SchedulingNodeAffinity"
              (\ o ->
                 SchedulingNodeAffinity' <$>
                   (o .:? "operator") <*> (o .:? "values" .!= mempty)
                     <*> (o .:? "key"))

instance ToJSON SchedulingNodeAffinity where
        toJSON SchedulingNodeAffinity'{..}
          = object
              (catMaybes
                 [("operator" .=) <$> _snaOperator,
                  ("values" .=) <$> _snaValues,
                  ("key" .=) <$> _snaKey])

-- | Contains a list of VpnTunnel resources.
--
-- /See:/ 'vpnTunnelList' smart constructor.
data VPNTunnelList =
  VPNTunnelList'
    { _vtlNextPageToken :: !(Maybe Text)
    , _vtlKind :: !Text
    , _vtlItems :: !(Maybe [VPNTunnel])
    , _vtlSelfLink :: !(Maybe Text)
    , _vtlWarning :: !(Maybe VPNTunnelListWarning)
    , _vtlId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNTunnelList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vtlNextPageToken'
--
-- * 'vtlKind'
--
-- * 'vtlItems'
--
-- * 'vtlSelfLink'
--
-- * 'vtlWarning'
--
-- * 'vtlId'
vpnTunnelList
    :: VPNTunnelList
vpnTunnelList =
  VPNTunnelList'
    { _vtlNextPageToken = Nothing
    , _vtlKind = "compute#vpnTunnelList"
    , _vtlItems = Nothing
    , _vtlSelfLink = Nothing
    , _vtlWarning = Nothing
    , _vtlId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
vtlNextPageToken :: Lens' VPNTunnelList (Maybe Text)
vtlNextPageToken
  = lens _vtlNextPageToken
      (\ s a -> s{_vtlNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#vpnTunnel for VPN
-- tunnels.
vtlKind :: Lens' VPNTunnelList Text
vtlKind = lens _vtlKind (\ s a -> s{_vtlKind = a})

-- | A list of VpnTunnel resources.
vtlItems :: Lens' VPNTunnelList [VPNTunnel]
vtlItems
  = lens _vtlItems (\ s a -> s{_vtlItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
vtlSelfLink :: Lens' VPNTunnelList (Maybe Text)
vtlSelfLink
  = lens _vtlSelfLink (\ s a -> s{_vtlSelfLink = a})

-- | [Output Only] Informational warning message.
vtlWarning :: Lens' VPNTunnelList (Maybe VPNTunnelListWarning)
vtlWarning
  = lens _vtlWarning (\ s a -> s{_vtlWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
vtlId :: Lens' VPNTunnelList (Maybe Text)
vtlId = lens _vtlId (\ s a -> s{_vtlId = a})

instance FromJSON VPNTunnelList where
        parseJSON
          = withObject "VPNTunnelList"
              (\ o ->
                 VPNTunnelList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#vpnTunnelList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON VPNTunnelList where
        toJSON VPNTunnelList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _vtlNextPageToken,
                  Just ("kind" .= _vtlKind),
                  ("items" .=) <$> _vtlItems,
                  ("selfLink" .=) <$> _vtlSelfLink,
                  ("warning" .=) <$> _vtlWarning,
                  ("id" .=) <$> _vtlId])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'acceleratorTypeAggregatedListWarning' smart constructor.
data AcceleratorTypeAggregatedListWarning =
  AcceleratorTypeAggregatedListWarning'
    { _atalwData :: !(Maybe [AcceleratorTypeAggregatedListWarningDataItem])
    , _atalwCode :: !(Maybe AcceleratorTypeAggregatedListWarningCode)
    , _atalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AcceleratorTypeAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'atalwData'
--
-- * 'atalwCode'
--
-- * 'atalwMessage'
acceleratorTypeAggregatedListWarning
    :: AcceleratorTypeAggregatedListWarning
acceleratorTypeAggregatedListWarning =
  AcceleratorTypeAggregatedListWarning'
    {_atalwData = Nothing, _atalwCode = Nothing, _atalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
atalwData :: Lens' AcceleratorTypeAggregatedListWarning [AcceleratorTypeAggregatedListWarningDataItem]
atalwData
  = lens _atalwData (\ s a -> s{_atalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
atalwCode :: Lens' AcceleratorTypeAggregatedListWarning (Maybe AcceleratorTypeAggregatedListWarningCode)
atalwCode
  = lens _atalwCode (\ s a -> s{_atalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
atalwMessage :: Lens' AcceleratorTypeAggregatedListWarning (Maybe Text)
atalwMessage
  = lens _atalwMessage (\ s a -> s{_atalwMessage = a})

instance FromJSON
           AcceleratorTypeAggregatedListWarning
         where
        parseJSON
          = withObject "AcceleratorTypeAggregatedListWarning"
              (\ o ->
                 AcceleratorTypeAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON AcceleratorTypeAggregatedListWarning
         where
        toJSON AcceleratorTypeAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _atalwData,
                  ("code" .=) <$> _atalwCode,
                  ("message" .=) <$> _atalwMessage])

--
-- /See:/ 'regionInstanceGroupsListInstancesWarningDataItem' smart constructor.
data RegionInstanceGroupsListInstancesWarningDataItem =
  RegionInstanceGroupsListInstancesWarningDataItem'
    { _rigliwdiValue :: !(Maybe Text)
    , _rigliwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupsListInstancesWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rigliwdiValue'
--
-- * 'rigliwdiKey'
regionInstanceGroupsListInstancesWarningDataItem
    :: RegionInstanceGroupsListInstancesWarningDataItem
regionInstanceGroupsListInstancesWarningDataItem =
  RegionInstanceGroupsListInstancesWarningDataItem'
    {_rigliwdiValue = Nothing, _rigliwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
rigliwdiValue :: Lens' RegionInstanceGroupsListInstancesWarningDataItem (Maybe Text)
rigliwdiValue
  = lens _rigliwdiValue
      (\ s a -> s{_rigliwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
rigliwdiKey :: Lens' RegionInstanceGroupsListInstancesWarningDataItem (Maybe Text)
rigliwdiKey
  = lens _rigliwdiKey (\ s a -> s{_rigliwdiKey = a})

instance FromJSON
           RegionInstanceGroupsListInstancesWarningDataItem
         where
        parseJSON
          = withObject
              "RegionInstanceGroupsListInstancesWarningDataItem"
              (\ o ->
                 RegionInstanceGroupsListInstancesWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           RegionInstanceGroupsListInstancesWarningDataItem
         where
        toJSON
          RegionInstanceGroupsListInstancesWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _rigliwdiValue,
                  ("key" .=) <$> _rigliwdiKey])

-- | Represents an Interconnect resource. An Interconnect resource is a
-- dedicated connection between the GCP network and your on-premises
-- network. For more information, read the Dedicated Interconnect Overview.
-- (== resource_for {$api_version}.interconnects ==)
--
-- /See:/ 'interconnect' smart constructor.
data Interconnect =
  Interconnect'
    { _iiState :: !(Maybe InterconnectState)
    , _iiInterconnectType :: !(Maybe InterconnectInterconnectType)
    , _iiLocation :: !(Maybe Text)
    , _iiPeerIPAddress :: !(Maybe Text)
    , _iiKind :: !Text
    , _iiExpectedOutages :: !(Maybe [InterconnectOutageNotification])
    , _iiProvisionedLinkCount :: !(Maybe (Textual Int32))
    , _iiCustomerName :: !(Maybe Text)
    , _iiRequestedLinkCount :: !(Maybe (Textual Int32))
    , _iiOperationalStatus :: !(Maybe InterconnectOperationalStatus)
    , _iiSelfLink :: !(Maybe Text)
    , _iiName :: !(Maybe Text)
    , _iiGoogleReferenceId :: !(Maybe Text)
    , _iiCreationTimestamp :: !(Maybe Text)
    , _iiAdminEnabled :: !(Maybe Bool)
    , _iiId :: !(Maybe (Textual Word64))
    , _iiInterconnectAttachments :: !(Maybe [Text])
    , _iiLinkType :: !(Maybe InterconnectLinkType)
    , _iiGoogleIPAddress :: !(Maybe Text)
    , _iiDescription :: !(Maybe Text)
    , _iiNocContactEmail :: !(Maybe Text)
    , _iiCircuitInfos :: !(Maybe [InterconnectCircuitInfo])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Interconnect' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iiState'
--
-- * 'iiInterconnectType'
--
-- * 'iiLocation'
--
-- * 'iiPeerIPAddress'
--
-- * 'iiKind'
--
-- * 'iiExpectedOutages'
--
-- * 'iiProvisionedLinkCount'
--
-- * 'iiCustomerName'
--
-- * 'iiRequestedLinkCount'
--
-- * 'iiOperationalStatus'
--
-- * 'iiSelfLink'
--
-- * 'iiName'
--
-- * 'iiGoogleReferenceId'
--
-- * 'iiCreationTimestamp'
--
-- * 'iiAdminEnabled'
--
-- * 'iiId'
--
-- * 'iiInterconnectAttachments'
--
-- * 'iiLinkType'
--
-- * 'iiGoogleIPAddress'
--
-- * 'iiDescription'
--
-- * 'iiNocContactEmail'
--
-- * 'iiCircuitInfos'
interconnect
    :: Interconnect
interconnect =
  Interconnect'
    { _iiState = Nothing
    , _iiInterconnectType = Nothing
    , _iiLocation = Nothing
    , _iiPeerIPAddress = Nothing
    , _iiKind = "compute#interconnect"
    , _iiExpectedOutages = Nothing
    , _iiProvisionedLinkCount = Nothing
    , _iiCustomerName = Nothing
    , _iiRequestedLinkCount = Nothing
    , _iiOperationalStatus = Nothing
    , _iiSelfLink = Nothing
    , _iiName = Nothing
    , _iiGoogleReferenceId = Nothing
    , _iiCreationTimestamp = Nothing
    , _iiAdminEnabled = Nothing
    , _iiId = Nothing
    , _iiInterconnectAttachments = Nothing
    , _iiLinkType = Nothing
    , _iiGoogleIPAddress = Nothing
    , _iiDescription = Nothing
    , _iiNocContactEmail = Nothing
    , _iiCircuitInfos = Nothing
    }


-- | [Output Only] The current state of Interconnect functionality, which can
-- take one of the following values: - ACTIVE: The Interconnect is valid,
-- turned up and ready to use. Attachments may be provisioned on this
-- Interconnect. - UNPROVISIONED: The Interconnect has not completed
-- turnup. No attachments may be provisioned on this Interconnect. -
-- UNDER_MAINTENANCE: The Interconnect is undergoing internal maintenance.
-- No attachments may be provisioned or updated on this Interconnect.
iiState :: Lens' Interconnect (Maybe InterconnectState)
iiState = lens _iiState (\ s a -> s{_iiState = a})

-- | Type of interconnect, which can take one of the following values: -
-- PARTNER: A partner-managed interconnection shared between customers
-- though a partner. - DEDICATED: A dedicated physical interconnection with
-- the customer. Note that a value IT_PRIVATE has been deprecated in favor
-- of DEDICATED.
iiInterconnectType :: Lens' Interconnect (Maybe InterconnectInterconnectType)
iiInterconnectType
  = lens _iiInterconnectType
      (\ s a -> s{_iiInterconnectType = a})

-- | URL of the InterconnectLocation object that represents where this
-- connection is to be provisioned.
iiLocation :: Lens' Interconnect (Maybe Text)
iiLocation
  = lens _iiLocation (\ s a -> s{_iiLocation = a})

-- | [Output Only] IP address configured on the customer side of the
-- Interconnect link. The customer should configure this IP address during
-- turnup when prompted by Google NOC. This can be used only for ping
-- tests.
iiPeerIPAddress :: Lens' Interconnect (Maybe Text)
iiPeerIPAddress
  = lens _iiPeerIPAddress
      (\ s a -> s{_iiPeerIPAddress = a})

-- | [Output Only] Type of the resource. Always compute#interconnect for
-- interconnects.
iiKind :: Lens' Interconnect Text
iiKind = lens _iiKind (\ s a -> s{_iiKind = a})

-- | [Output Only] A list of outages expected for this Interconnect.
iiExpectedOutages :: Lens' Interconnect [InterconnectOutageNotification]
iiExpectedOutages
  = lens _iiExpectedOutages
      (\ s a -> s{_iiExpectedOutages = a})
      . _Default
      . _Coerce

-- | [Output Only] Number of links actually provisioned in this interconnect.
iiProvisionedLinkCount :: Lens' Interconnect (Maybe Int32)
iiProvisionedLinkCount
  = lens _iiProvisionedLinkCount
      (\ s a -> s{_iiProvisionedLinkCount = a})
      . mapping _Coerce

-- | Customer name, to put in the Letter of Authorization as the party
-- authorized to request a crossconnect.
iiCustomerName :: Lens' Interconnect (Maybe Text)
iiCustomerName
  = lens _iiCustomerName
      (\ s a -> s{_iiCustomerName = a})

-- | Target number of physical links in the link bundle, as requested by the
-- customer.
iiRequestedLinkCount :: Lens' Interconnect (Maybe Int32)
iiRequestedLinkCount
  = lens _iiRequestedLinkCount
      (\ s a -> s{_iiRequestedLinkCount = a})
      . mapping _Coerce

-- | [Output Only] The current status of this Interconnect\'s functionality,
-- which can take one of the following values: - OS_ACTIVE: A valid
-- Interconnect, which is turned up and is ready to use. Attachments may be
-- provisioned on this Interconnect. - OS_UNPROVISIONED: An Interconnect
-- that has not completed turnup. No attachments may be provisioned on this
-- Interconnect. - OS_UNDER_MAINTENANCE: An Interconnect that is undergoing
-- internal maintenance. No attachments may be provisioned or updated on
-- this Interconnect.
iiOperationalStatus :: Lens' Interconnect (Maybe InterconnectOperationalStatus)
iiOperationalStatus
  = lens _iiOperationalStatus
      (\ s a -> s{_iiOperationalStatus = a})

-- | [Output Only] Server-defined URL for the resource.
iiSelfLink :: Lens' Interconnect (Maybe Text)
iiSelfLink
  = lens _iiSelfLink (\ s a -> s{_iiSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
iiName :: Lens' Interconnect (Maybe Text)
iiName = lens _iiName (\ s a -> s{_iiName = a})

-- | [Output Only] Google reference ID to be used when raising support
-- tickets with Google or otherwise to debug backend connectivity issues.
iiGoogleReferenceId :: Lens' Interconnect (Maybe Text)
iiGoogleReferenceId
  = lens _iiGoogleReferenceId
      (\ s a -> s{_iiGoogleReferenceId = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
iiCreationTimestamp :: Lens' Interconnect (Maybe Text)
iiCreationTimestamp
  = lens _iiCreationTimestamp
      (\ s a -> s{_iiCreationTimestamp = a})

-- | Administrative status of the interconnect. When this is set to true, the
-- Interconnect is functional and can carry traffic. When set to false, no
-- packets can be carried over the interconnect and no BGP routes are
-- exchanged over it. By default, the status is set to true.
iiAdminEnabled :: Lens' Interconnect (Maybe Bool)
iiAdminEnabled
  = lens _iiAdminEnabled
      (\ s a -> s{_iiAdminEnabled = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
iiId :: Lens' Interconnect (Maybe Word64)
iiId
  = lens _iiId (\ s a -> s{_iiId = a}) .
      mapping _Coerce

-- | [Output Only] A list of the URLs of all InterconnectAttachments
-- configured to use this Interconnect.
iiInterconnectAttachments :: Lens' Interconnect [Text]
iiInterconnectAttachments
  = lens _iiInterconnectAttachments
      (\ s a -> s{_iiInterconnectAttachments = a})
      . _Default
      . _Coerce

-- | Type of link requested, which can take one of the following values: -
-- LINK_TYPE_ETHERNET_10G_LR: A 10G Ethernet with LR optics -
-- LINK_TYPE_ETHERNET_100G_LR: A 100G Ethernet with LR optics. Note that
-- this field indicates the speed of each of the links in the bundle, not
-- the speed of the entire bundle.
iiLinkType :: Lens' Interconnect (Maybe InterconnectLinkType)
iiLinkType
  = lens _iiLinkType (\ s a -> s{_iiLinkType = a})

-- | [Output Only] IP address configured on the Google side of the
-- Interconnect link. This can be used only for ping tests.
iiGoogleIPAddress :: Lens' Interconnect (Maybe Text)
iiGoogleIPAddress
  = lens _iiGoogleIPAddress
      (\ s a -> s{_iiGoogleIPAddress = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource.
iiDescription :: Lens' Interconnect (Maybe Text)
iiDescription
  = lens _iiDescription
      (\ s a -> s{_iiDescription = a})

-- | Email address to contact the customer NOC for operations and maintenance
-- notifications regarding this Interconnect. If specified, this will be
-- used for notifications in addition to all other forms described, such as
-- Stackdriver logs alerting and Cloud Notifications.
iiNocContactEmail :: Lens' Interconnect (Maybe Text)
iiNocContactEmail
  = lens _iiNocContactEmail
      (\ s a -> s{_iiNocContactEmail = a})

-- | [Output Only] A list of CircuitInfo objects, that describe the
-- individual circuits in this LAG.
iiCircuitInfos :: Lens' Interconnect [InterconnectCircuitInfo]
iiCircuitInfos
  = lens _iiCircuitInfos
      (\ s a -> s{_iiCircuitInfos = a})
      . _Default
      . _Coerce

instance FromJSON Interconnect where
        parseJSON
          = withObject "Interconnect"
              (\ o ->
                 Interconnect' <$>
                   (o .:? "state") <*> (o .:? "interconnectType") <*>
                     (o .:? "location")
                     <*> (o .:? "peerIpAddress")
                     <*> (o .:? "kind" .!= "compute#interconnect")
                     <*> (o .:? "expectedOutages" .!= mempty)
                     <*> (o .:? "provisionedLinkCount")
                     <*> (o .:? "customerName")
                     <*> (o .:? "requestedLinkCount")
                     <*> (o .:? "operationalStatus")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "googleReferenceId")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "adminEnabled")
                     <*> (o .:? "id")
                     <*> (o .:? "interconnectAttachments" .!= mempty)
                     <*> (o .:? "linkType")
                     <*> (o .:? "googleIpAddress")
                     <*> (o .:? "description")
                     <*> (o .:? "nocContactEmail")
                     <*> (o .:? "circuitInfos" .!= mempty))

instance ToJSON Interconnect where
        toJSON Interconnect'{..}
          = object
              (catMaybes
                 [("state" .=) <$> _iiState,
                  ("interconnectType" .=) <$> _iiInterconnectType,
                  ("location" .=) <$> _iiLocation,
                  ("peerIpAddress" .=) <$> _iiPeerIPAddress,
                  Just ("kind" .= _iiKind),
                  ("expectedOutages" .=) <$> _iiExpectedOutages,
                  ("provisionedLinkCount" .=) <$>
                    _iiProvisionedLinkCount,
                  ("customerName" .=) <$> _iiCustomerName,
                  ("requestedLinkCount" .=) <$> _iiRequestedLinkCount,
                  ("operationalStatus" .=) <$> _iiOperationalStatus,
                  ("selfLink" .=) <$> _iiSelfLink,
                  ("name" .=) <$> _iiName,
                  ("googleReferenceId" .=) <$> _iiGoogleReferenceId,
                  ("creationTimestamp" .=) <$> _iiCreationTimestamp,
                  ("adminEnabled" .=) <$> _iiAdminEnabled,
                  ("id" .=) <$> _iiId,
                  ("interconnectAttachments" .=) <$>
                    _iiInterconnectAttachments,
                  ("linkType" .=) <$> _iiLinkType,
                  ("googleIpAddress" .=) <$> _iiGoogleIPAddress,
                  ("description" .=) <$> _iiDescription,
                  ("nocContactEmail" .=) <$> _iiNocContactEmail,
                  ("circuitInfos" .=) <$> _iiCircuitInfos])

--
-- /See:/ 'machineTypeScratchDisksItem' smart constructor.
newtype MachineTypeScratchDisksItem =
  MachineTypeScratchDisksItem'
    { _mtsdiDiskGb :: Maybe (Textual Int32)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'MachineTypeScratchDisksItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'mtsdiDiskGb'
machineTypeScratchDisksItem
    :: MachineTypeScratchDisksItem
machineTypeScratchDisksItem =
  MachineTypeScratchDisksItem' {_mtsdiDiskGb = Nothing}


-- | Size of the scratch disk, defined in GB.
mtsdiDiskGb :: Lens' MachineTypeScratchDisksItem (Maybe Int32)
mtsdiDiskGb
  = lens _mtsdiDiskGb (\ s a -> s{_mtsdiDiskGb = a}) .
      mapping _Coerce

instance FromJSON MachineTypeScratchDisksItem where
        parseJSON
          = withObject "MachineTypeScratchDisksItem"
              (\ o ->
                 MachineTypeScratchDisksItem' <$> (o .:? "diskGb"))

instance ToJSON MachineTypeScratchDisksItem where
        toJSON MachineTypeScratchDisksItem'{..}
          = object (catMaybes [("diskGb" .=) <$> _mtsdiDiskGb])

--
-- /See:/ 'disksAddResourcePoliciesRequest' smart constructor.
newtype DisksAddResourcePoliciesRequest =
  DisksAddResourcePoliciesRequest'
    { _darprResourcePolicies :: Maybe [Text]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DisksAddResourcePoliciesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'darprResourcePolicies'
disksAddResourcePoliciesRequest
    :: DisksAddResourcePoliciesRequest
disksAddResourcePoliciesRequest =
  DisksAddResourcePoliciesRequest' {_darprResourcePolicies = Nothing}


-- | Resource policies to be added to this disk. Currently you can only
-- specify one policy here.
darprResourcePolicies :: Lens' DisksAddResourcePoliciesRequest [Text]
darprResourcePolicies
  = lens _darprResourcePolicies
      (\ s a -> s{_darprResourcePolicies = a})
      . _Default
      . _Coerce

instance FromJSON DisksAddResourcePoliciesRequest
         where
        parseJSON
          = withObject "DisksAddResourcePoliciesRequest"
              (\ o ->
                 DisksAddResourcePoliciesRequest' <$>
                   (o .:? "resourcePolicies" .!= mempty))

instance ToJSON DisksAddResourcePoliciesRequest where
        toJSON DisksAddResourcePoliciesRequest'{..}
          = object
              (catMaybes
                 [("resourcePolicies" .=) <$> _darprResourcePolicies])

--
-- /See:/ 'networkEndpointGroupsScopedListWarningDataItem' smart constructor.
data NetworkEndpointGroupsScopedListWarningDataItem =
  NetworkEndpointGroupsScopedListWarningDataItem'
    { _negslwdiValue :: !(Maybe Text)
    , _negslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkEndpointGroupsScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'negslwdiValue'
--
-- * 'negslwdiKey'
networkEndpointGroupsScopedListWarningDataItem
    :: NetworkEndpointGroupsScopedListWarningDataItem
networkEndpointGroupsScopedListWarningDataItem =
  NetworkEndpointGroupsScopedListWarningDataItem'
    {_negslwdiValue = Nothing, _negslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
negslwdiValue :: Lens' NetworkEndpointGroupsScopedListWarningDataItem (Maybe Text)
negslwdiValue
  = lens _negslwdiValue
      (\ s a -> s{_negslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
negslwdiKey :: Lens' NetworkEndpointGroupsScopedListWarningDataItem (Maybe Text)
negslwdiKey
  = lens _negslwdiKey (\ s a -> s{_negslwdiKey = a})

instance FromJSON
           NetworkEndpointGroupsScopedListWarningDataItem
         where
        parseJSON
          = withObject
              "NetworkEndpointGroupsScopedListWarningDataItem"
              (\ o ->
                 NetworkEndpointGroupsScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           NetworkEndpointGroupsScopedListWarningDataItem
         where
        toJSON
          NetworkEndpointGroupsScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _negslwdiValue,
                  ("key" .=) <$> _negslwdiKey])

--
-- /See:/ 'subnetworksScopedListWarningDataItem' smart constructor.
data SubnetworksScopedListWarningDataItem =
  SubnetworksScopedListWarningDataItem'
    { _sslwdiValue :: !(Maybe Text)
    , _sslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SubnetworksScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sslwdiValue'
--
-- * 'sslwdiKey'
subnetworksScopedListWarningDataItem
    :: SubnetworksScopedListWarningDataItem
subnetworksScopedListWarningDataItem =
  SubnetworksScopedListWarningDataItem'
    {_sslwdiValue = Nothing, _sslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
sslwdiValue :: Lens' SubnetworksScopedListWarningDataItem (Maybe Text)
sslwdiValue
  = lens _sslwdiValue (\ s a -> s{_sslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
sslwdiKey :: Lens' SubnetworksScopedListWarningDataItem (Maybe Text)
sslwdiKey
  = lens _sslwdiKey (\ s a -> s{_sslwdiKey = a})

instance FromJSON
           SubnetworksScopedListWarningDataItem
         where
        parseJSON
          = withObject "SubnetworksScopedListWarningDataItem"
              (\ o ->
                 SubnetworksScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON SubnetworksScopedListWarningDataItem
         where
        toJSON SubnetworksScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _sslwdiValue,
                  ("key" .=) <$> _sslwdiKey])

--
-- /See:/ 'machineTypesScopedList' smart constructor.
data MachineTypesScopedList =
  MachineTypesScopedList'
    { _mtslMachineTypes :: !(Maybe [MachineType])
    , _mtslWarning :: !(Maybe MachineTypesScopedListWarning)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'MachineTypesScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'mtslMachineTypes'
--
-- * 'mtslWarning'
machineTypesScopedList
    :: MachineTypesScopedList
machineTypesScopedList =
  MachineTypesScopedList' {_mtslMachineTypes = Nothing, _mtslWarning = Nothing}


-- | [Output Only] A list of machine types contained in this scope.
mtslMachineTypes :: Lens' MachineTypesScopedList [MachineType]
mtslMachineTypes
  = lens _mtslMachineTypes
      (\ s a -> s{_mtslMachineTypes = a})
      . _Default
      . _Coerce

-- | [Output Only] An informational warning that appears when the machine
-- types list is empty.
mtslWarning :: Lens' MachineTypesScopedList (Maybe MachineTypesScopedListWarning)
mtslWarning
  = lens _mtslWarning (\ s a -> s{_mtslWarning = a})

instance FromJSON MachineTypesScopedList where
        parseJSON
          = withObject "MachineTypesScopedList"
              (\ o ->
                 MachineTypesScopedList' <$>
                   (o .:? "machineTypes" .!= mempty) <*>
                     (o .:? "warning"))

instance ToJSON MachineTypesScopedList where
        toJSON MachineTypesScopedList'{..}
          = object
              (catMaybes
                 [("machineTypes" .=) <$> _mtslMachineTypes,
                  ("warning" .=) <$> _mtslWarning])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'resourcePolicyListWarning' smart constructor.
data ResourcePolicyListWarning =
  ResourcePolicyListWarning'
    { _rplwData :: !(Maybe [ResourcePolicyListWarningDataItem])
    , _rplwCode :: !(Maybe ResourcePolicyListWarningCode)
    , _rplwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePolicyListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rplwData'
--
-- * 'rplwCode'
--
-- * 'rplwMessage'
resourcePolicyListWarning
    :: ResourcePolicyListWarning
resourcePolicyListWarning =
  ResourcePolicyListWarning'
    {_rplwData = Nothing, _rplwCode = Nothing, _rplwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
rplwData :: Lens' ResourcePolicyListWarning [ResourcePolicyListWarningDataItem]
rplwData
  = lens _rplwData (\ s a -> s{_rplwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
rplwCode :: Lens' ResourcePolicyListWarning (Maybe ResourcePolicyListWarningCode)
rplwCode = lens _rplwCode (\ s a -> s{_rplwCode = a})

-- | [Output Only] A human-readable description of the warning code.
rplwMessage :: Lens' ResourcePolicyListWarning (Maybe Text)
rplwMessage
  = lens _rplwMessage (\ s a -> s{_rplwMessage = a})

instance FromJSON ResourcePolicyListWarning where
        parseJSON
          = withObject "ResourcePolicyListWarning"
              (\ o ->
                 ResourcePolicyListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON ResourcePolicyListWarning where
        toJSON ResourcePolicyListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _rplwData,
                  ("code" .=) <$> _rplwCode,
                  ("message" .=) <$> _rplwMessage])

--
-- /See:/ 'instanceGroupManagerStatusVersionTarget' smart constructor.
newtype InstanceGroupManagerStatusVersionTarget =
  InstanceGroupManagerStatusVersionTarget'
    { _igmsvtIsReached :: Maybe Bool
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagerStatusVersionTarget' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmsvtIsReached'
instanceGroupManagerStatusVersionTarget
    :: InstanceGroupManagerStatusVersionTarget
instanceGroupManagerStatusVersionTarget =
  InstanceGroupManagerStatusVersionTarget' {_igmsvtIsReached = Nothing}


-- | [Output Only] A bit indicating whether version target has been reached
-- in this managed instance group, i.e. all instances are in their target
-- version. Instances\' target version are specified by version field on
-- Instance Group Manager.
igmsvtIsReached :: Lens' InstanceGroupManagerStatusVersionTarget (Maybe Bool)
igmsvtIsReached
  = lens _igmsvtIsReached
      (\ s a -> s{_igmsvtIsReached = a})

instance FromJSON
           InstanceGroupManagerStatusVersionTarget
         where
        parseJSON
          = withObject
              "InstanceGroupManagerStatusVersionTarget"
              (\ o ->
                 InstanceGroupManagerStatusVersionTarget' <$>
                   (o .:? "isReached"))

instance ToJSON
           InstanceGroupManagerStatusVersionTarget
         where
        toJSON InstanceGroupManagerStatusVersionTarget'{..}
          = object
              (catMaybes [("isReached" .=) <$> _igmsvtIsReached])

-- | Represents a collection of network endpoints. A network endpoint group
-- (NEG) defines how a set of endpoints should be reached, whether they are
-- reachable, and where they are located. For more information about using
-- NEGs, see Setting up external HTTP(S) Load Balancing with internet NEGs,
-- Setting up zonal NEGs, or Setting up external HTTP(S) Load Balancing
-- with serverless NEGs. (== resource_for
-- {$api_version}.networkEndpointGroups ==) (== resource_for
-- {$api_version}.globalNetworkEndpointGroups ==) (== resource_for
-- {$api_version}.regionNetworkEndpointGroups ==)
--
-- /See:/ 'networkEndpointGroup' smart constructor.
data NetworkEndpointGroup =
  NetworkEndpointGroup'
    { _negAnnotations :: !(Maybe NetworkEndpointGroupAnnotations)
    , _negSize :: !(Maybe (Textual Int32))
    , _negKind :: !Text
    , _negCloudRun :: !(Maybe NetworkEndpointGroupCloudRun)
    , _negNetwork :: !(Maybe Text)
    , _negZone :: !(Maybe Text)
    , _negSelfLink :: !(Maybe Text)
    , _negName :: !(Maybe Text)
    , _negAppEngine :: !(Maybe NetworkEndpointGroupAppEngine)
    , _negCreationTimestamp :: !(Maybe Text)
    , _negDefaultPort :: !(Maybe (Textual Int32))
    , _negSubnetwork :: !(Maybe Text)
    , _negNetworkEndpointType :: !(Maybe NetworkEndpointGroupNetworkEndpointType)
    , _negId :: !(Maybe (Textual Word64))
    , _negRegion :: !(Maybe Text)
    , _negCloudFunction :: !(Maybe NetworkEndpointGroupCloudFunction)
    , _negDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkEndpointGroup' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'negAnnotations'
--
-- * 'negSize'
--
-- * 'negKind'
--
-- * 'negCloudRun'
--
-- * 'negNetwork'
--
-- * 'negZone'
--
-- * 'negSelfLink'
--
-- * 'negName'
--
-- * 'negAppEngine'
--
-- * 'negCreationTimestamp'
--
-- * 'negDefaultPort'
--
-- * 'negSubnetwork'
--
-- * 'negNetworkEndpointType'
--
-- * 'negId'
--
-- * 'negRegion'
--
-- * 'negCloudFunction'
--
-- * 'negDescription'
networkEndpointGroup
    :: NetworkEndpointGroup
networkEndpointGroup =
  NetworkEndpointGroup'
    { _negAnnotations = Nothing
    , _negSize = Nothing
    , _negKind = "compute#networkEndpointGroup"
    , _negCloudRun = Nothing
    , _negNetwork = Nothing
    , _negZone = Nothing
    , _negSelfLink = Nothing
    , _negName = Nothing
    , _negAppEngine = Nothing
    , _negCreationTimestamp = Nothing
    , _negDefaultPort = Nothing
    , _negSubnetwork = Nothing
    , _negNetworkEndpointType = Nothing
    , _negId = Nothing
    , _negRegion = Nothing
    , _negCloudFunction = Nothing
    , _negDescription = Nothing
    }


-- | Metadata defined as annotations on the network endpoint group.
negAnnotations :: Lens' NetworkEndpointGroup (Maybe NetworkEndpointGroupAnnotations)
negAnnotations
  = lens _negAnnotations
      (\ s a -> s{_negAnnotations = a})

-- | [Output only] Number of network endpoints in the network endpoint group.
negSize :: Lens' NetworkEndpointGroup (Maybe Int32)
negSize
  = lens _negSize (\ s a -> s{_negSize = a}) .
      mapping _Coerce

-- | [Output Only] Type of the resource. Always compute#networkEndpointGroup
-- for network endpoint group.
negKind :: Lens' NetworkEndpointGroup Text
negKind = lens _negKind (\ s a -> s{_negKind = a})

-- | Only valid when networkEndpointType is \"SERVERLESS\". Only one of
-- cloudRun, appEngine or cloudFunction may be set.
negCloudRun :: Lens' NetworkEndpointGroup (Maybe NetworkEndpointGroupCloudRun)
negCloudRun
  = lens _negCloudRun (\ s a -> s{_negCloudRun = a})

-- | The URL of the network to which all network endpoints in the NEG belong.
-- Uses \"default\" project network if unspecified.
negNetwork :: Lens' NetworkEndpointGroup (Maybe Text)
negNetwork
  = lens _negNetwork (\ s a -> s{_negNetwork = a})

-- | [Output Only] The URL of the zone where the network endpoint group is
-- located.
negZone :: Lens' NetworkEndpointGroup (Maybe Text)
negZone = lens _negZone (\ s a -> s{_negZone = a})

-- | [Output Only] Server-defined URL for the resource.
negSelfLink :: Lens' NetworkEndpointGroup (Maybe Text)
negSelfLink
  = lens _negSelfLink (\ s a -> s{_negSelfLink = a})

-- | Name of the resource; provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
negName :: Lens' NetworkEndpointGroup (Maybe Text)
negName = lens _negName (\ s a -> s{_negName = a})

-- | Only valid when networkEndpointType is \"SERVERLESS\". Only one of
-- cloudRun, appEngine or cloudFunction may be set.
negAppEngine :: Lens' NetworkEndpointGroup (Maybe NetworkEndpointGroupAppEngine)
negAppEngine
  = lens _negAppEngine (\ s a -> s{_negAppEngine = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
negCreationTimestamp :: Lens' NetworkEndpointGroup (Maybe Text)
negCreationTimestamp
  = lens _negCreationTimestamp
      (\ s a -> s{_negCreationTimestamp = a})

-- | The default port used if the port number is not specified in the network
-- endpoint.
negDefaultPort :: Lens' NetworkEndpointGroup (Maybe Int32)
negDefaultPort
  = lens _negDefaultPort
      (\ s a -> s{_negDefaultPort = a})
      . mapping _Coerce

-- | Optional URL of the subnetwork to which all network endpoints in the NEG
-- belong.
negSubnetwork :: Lens' NetworkEndpointGroup (Maybe Text)
negSubnetwork
  = lens _negSubnetwork
      (\ s a -> s{_negSubnetwork = a})

-- | Type of network endpoints in this network endpoint group. Can be one of
-- GCE_VM_IP_PORT, NON_GCP_PRIVATE_IP_PORT, INTERNET_FQDN_PORT,
-- INTERNET_IP_PORT, or SERVERLESS.
negNetworkEndpointType :: Lens' NetworkEndpointGroup (Maybe NetworkEndpointGroupNetworkEndpointType)
negNetworkEndpointType
  = lens _negNetworkEndpointType
      (\ s a -> s{_negNetworkEndpointType = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
negId :: Lens' NetworkEndpointGroup (Maybe Word64)
negId
  = lens _negId (\ s a -> s{_negId = a}) .
      mapping _Coerce

-- | [Output Only] The URL of the region where the network endpoint group is
-- located.
negRegion :: Lens' NetworkEndpointGroup (Maybe Text)
negRegion
  = lens _negRegion (\ s a -> s{_negRegion = a})

-- | Only valid when networkEndpointType is \"SERVERLESS\". Only one of
-- cloudRun, appEngine or cloudFunction may be set.
negCloudFunction :: Lens' NetworkEndpointGroup (Maybe NetworkEndpointGroupCloudFunction)
negCloudFunction
  = lens _negCloudFunction
      (\ s a -> s{_negCloudFunction = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource.
negDescription :: Lens' NetworkEndpointGroup (Maybe Text)
negDescription
  = lens _negDescription
      (\ s a -> s{_negDescription = a})

instance FromJSON NetworkEndpointGroup where
        parseJSON
          = withObject "NetworkEndpointGroup"
              (\ o ->
                 NetworkEndpointGroup' <$>
                   (o .:? "annotations") <*> (o .:? "size") <*>
                     (o .:? "kind" .!= "compute#networkEndpointGroup")
                     <*> (o .:? "cloudRun")
                     <*> (o .:? "network")
                     <*> (o .:? "zone")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "appEngine")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "defaultPort")
                     <*> (o .:? "subnetwork")
                     <*> (o .:? "networkEndpointType")
                     <*> (o .:? "id")
                     <*> (o .:? "region")
                     <*> (o .:? "cloudFunction")
                     <*> (o .:? "description"))

instance ToJSON NetworkEndpointGroup where
        toJSON NetworkEndpointGroup'{..}
          = object
              (catMaybes
                 [("annotations" .=) <$> _negAnnotations,
                  ("size" .=) <$> _negSize, Just ("kind" .= _negKind),
                  ("cloudRun" .=) <$> _negCloudRun,
                  ("network" .=) <$> _negNetwork,
                  ("zone" .=) <$> _negZone,
                  ("selfLink" .=) <$> _negSelfLink,
                  ("name" .=) <$> _negName,
                  ("appEngine" .=) <$> _negAppEngine,
                  ("creationTimestamp" .=) <$> _negCreationTimestamp,
                  ("defaultPort" .=) <$> _negDefaultPort,
                  ("subnetwork" .=) <$> _negSubnetwork,
                  ("networkEndpointType" .=) <$>
                    _negNetworkEndpointType,
                  ("id" .=) <$> _negId, ("region" .=) <$> _negRegion,
                  ("cloudFunction" .=) <$> _negCloudFunction,
                  ("description" .=) <$> _negDescription])

--
-- /See:/ 'targetHTTPProxyAggregatedList' smart constructor.
data TargetHTTPProxyAggregatedList =
  TargetHTTPProxyAggregatedList'
    { _thttppalUnreachables :: !(Maybe [Text])
    , _thttppalNextPageToken :: !(Maybe Text)
    , _thttppalKind :: !Text
    , _thttppalItems :: !(Maybe TargetHTTPProxyAggregatedListItems)
    , _thttppalSelfLink :: !(Maybe Text)
    , _thttppalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetHTTPProxyAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'thttppalUnreachables'
--
-- * 'thttppalNextPageToken'
--
-- * 'thttppalKind'
--
-- * 'thttppalItems'
--
-- * 'thttppalSelfLink'
--
-- * 'thttppalId'
targetHTTPProxyAggregatedList
    :: TargetHTTPProxyAggregatedList
targetHTTPProxyAggregatedList =
  TargetHTTPProxyAggregatedList'
    { _thttppalUnreachables = Nothing
    , _thttppalNextPageToken = Nothing
    , _thttppalKind = "compute#targetHttpProxyAggregatedList"
    , _thttppalItems = Nothing
    , _thttppalSelfLink = Nothing
    , _thttppalId = Nothing
    }


-- | [Output Only] Unreachable resources.
thttppalUnreachables :: Lens' TargetHTTPProxyAggregatedList [Text]
thttppalUnreachables
  = lens _thttppalUnreachables
      (\ s a -> s{_thttppalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
thttppalNextPageToken :: Lens' TargetHTTPProxyAggregatedList (Maybe Text)
thttppalNextPageToken
  = lens _thttppalNextPageToken
      (\ s a -> s{_thttppalNextPageToken = a})

-- | [Output Only] Type of resource. Always
-- compute#targetHttpProxyAggregatedList for lists of Target HTTP Proxies.
thttppalKind :: Lens' TargetHTTPProxyAggregatedList Text
thttppalKind
  = lens _thttppalKind (\ s a -> s{_thttppalKind = a})

-- | A list of TargetHttpProxiesScopedList resources.
thttppalItems :: Lens' TargetHTTPProxyAggregatedList (Maybe TargetHTTPProxyAggregatedListItems)
thttppalItems
  = lens _thttppalItems
      (\ s a -> s{_thttppalItems = a})

-- | [Output Only] Server-defined URL for this resource.
thttppalSelfLink :: Lens' TargetHTTPProxyAggregatedList (Maybe Text)
thttppalSelfLink
  = lens _thttppalSelfLink
      (\ s a -> s{_thttppalSelfLink = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
thttppalId :: Lens' TargetHTTPProxyAggregatedList (Maybe Text)
thttppalId
  = lens _thttppalId (\ s a -> s{_thttppalId = a})

instance FromJSON TargetHTTPProxyAggregatedList where
        parseJSON
          = withObject "TargetHTTPProxyAggregatedList"
              (\ o ->
                 TargetHTTPProxyAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!=
                        "compute#targetHttpProxyAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "id"))

instance ToJSON TargetHTTPProxyAggregatedList where
        toJSON TargetHTTPProxyAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _thttppalUnreachables,
                  ("nextPageToken" .=) <$> _thttppalNextPageToken,
                  Just ("kind" .= _thttppalKind),
                  ("items" .=) <$> _thttppalItems,
                  ("selfLink" .=) <$> _thttppalSelfLink,
                  ("id" .=) <$> _thttppalId])

-- | Represents a Subnetwork resource. A subnetwork (also known as a subnet)
-- is a logical partition of a Virtual Private Cloud network with one
-- primary IP range and zero or more secondary IP ranges. For more
-- information, read Virtual Private Cloud (VPC) Network. (== resource_for
-- {$api_version}.subnetworks ==)
--
-- /See:/ 'subnetwork' smart constructor.
data Subnetwork =
  Subnetwork'
    { _subExternalIPv6Prefix :: !(Maybe Text)
    , _subState :: !(Maybe SubnetworkState)
    , _subKind :: !Text
    , _subFingerprint :: !(Maybe Bytes)
    , _subNetwork :: !(Maybe Text)
    , _subStackType :: !(Maybe SubnetworkStackType)
    , _subGatewayAddress :: !(Maybe Text)
    , _subPurpose :: !(Maybe SubnetworkPurpose)
    , _subRole :: !(Maybe SubnetworkRole)
    , _subSelfLink :: !(Maybe Text)
    , _subEnableFlowLogs :: !(Maybe Bool)
    , _subName :: !(Maybe Text)
    , _subSecondaryIPRanges :: !(Maybe [SubnetworkSecondaryRange])
    , _subCreationTimestamp :: !(Maybe Text)
    , _subIPCIdRRange :: !(Maybe Text)
    , _subIPv6CIdRRange :: !(Maybe Text)
    , _subIPv6AccessType :: !(Maybe SubnetworkIPv6AccessType)
    , _subId :: !(Maybe (Textual Word64))
    , _subRegion :: !(Maybe Text)
    , _subLogConfig :: !(Maybe SubnetworkLogConfig)
    , _subDescription :: !(Maybe Text)
    , _subPrivateIPGoogleAccess :: !(Maybe Bool)
    , _subPrivateIPv6GoogleAccess :: !(Maybe SubnetworkPrivateIPv6GoogleAccess)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Subnetwork' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'subExternalIPv6Prefix'
--
-- * 'subState'
--
-- * 'subKind'
--
-- * 'subFingerprint'
--
-- * 'subNetwork'
--
-- * 'subStackType'
--
-- * 'subGatewayAddress'
--
-- * 'subPurpose'
--
-- * 'subRole'
--
-- * 'subSelfLink'
--
-- * 'subEnableFlowLogs'
--
-- * 'subName'
--
-- * 'subSecondaryIPRanges'
--
-- * 'subCreationTimestamp'
--
-- * 'subIPCIdRRange'
--
-- * 'subIPv6CIdRRange'
--
-- * 'subIPv6AccessType'
--
-- * 'subId'
--
-- * 'subRegion'
--
-- * 'subLogConfig'
--
-- * 'subDescription'
--
-- * 'subPrivateIPGoogleAccess'
--
-- * 'subPrivateIPv6GoogleAccess'
subnetwork
    :: Subnetwork
subnetwork =
  Subnetwork'
    { _subExternalIPv6Prefix = Nothing
    , _subState = Nothing
    , _subKind = "compute#subnetwork"
    , _subFingerprint = Nothing
    , _subNetwork = Nothing
    , _subStackType = Nothing
    , _subGatewayAddress = Nothing
    , _subPurpose = Nothing
    , _subRole = Nothing
    , _subSelfLink = Nothing
    , _subEnableFlowLogs = Nothing
    , _subName = Nothing
    , _subSecondaryIPRanges = Nothing
    , _subCreationTimestamp = Nothing
    , _subIPCIdRRange = Nothing
    , _subIPv6CIdRRange = Nothing
    , _subIPv6AccessType = Nothing
    , _subId = Nothing
    , _subRegion = Nothing
    , _subLogConfig = Nothing
    , _subDescription = Nothing
    , _subPrivateIPGoogleAccess = Nothing
    , _subPrivateIPv6GoogleAccess = Nothing
    }


-- | [Output Only] The range of external IPv6 addresses that are owned by
-- this subnetwork.
subExternalIPv6Prefix :: Lens' Subnetwork (Maybe Text)
subExternalIPv6Prefix
  = lens _subExternalIPv6Prefix
      (\ s a -> s{_subExternalIPv6Prefix = a})

-- | [Output Only] The state of the subnetwork, which can be one of the
-- following values: READY: Subnetwork is created and ready to use
-- DRAINING: only applicable to subnetworks that have the purpose set to
-- INTERNAL_HTTPS_LOAD_BALANCER and indicates that connections to the load
-- balancer are being drained. A subnetwork that is draining cannot be used
-- or modified until it reaches a status of READY
subState :: Lens' Subnetwork (Maybe SubnetworkState)
subState = lens _subState (\ s a -> s{_subState = a})

-- | [Output Only] Type of the resource. Always compute#subnetwork for
-- Subnetwork resources.
subKind :: Lens' Subnetwork Text
subKind = lens _subKind (\ s a -> s{_subKind = a})

-- | Fingerprint of this resource. A hash of the contents stored in this
-- object. This field is used in optimistic locking. This field will be
-- ignored when inserting a Subnetwork. An up-to-date fingerprint must be
-- provided in order to update the Subnetwork, otherwise the request will
-- fail with error 412 conditionNotMet. To see the latest fingerprint, make
-- a get() request to retrieve a Subnetwork.
subFingerprint :: Lens' Subnetwork (Maybe ByteString)
subFingerprint
  = lens _subFingerprint
      (\ s a -> s{_subFingerprint = a})
      . mapping _Bytes

-- | The URL of the network to which this subnetwork belongs, provided by the
-- client when initially creating the subnetwork. Only networks that are in
-- the distributed mode can have subnetworks. This field can be set only at
-- resource creation time.
subNetwork :: Lens' Subnetwork (Maybe Text)
subNetwork
  = lens _subNetwork (\ s a -> s{_subNetwork = a})

-- | The stack type for this subnet to identify whether the IPv6 feature is
-- enabled or not. If not specified IPV4_ONLY will be used. This field can
-- be both set at resource creation time and updated using patch.
subStackType :: Lens' Subnetwork (Maybe SubnetworkStackType)
subStackType
  = lens _subStackType (\ s a -> s{_subStackType = a})

-- | [Output Only] The gateway address for default routes to reach
-- destination addresses outside this subnetwork.
subGatewayAddress :: Lens' Subnetwork (Maybe Text)
subGatewayAddress
  = lens _subGatewayAddress
      (\ s a -> s{_subGatewayAddress = a})

-- | The purpose of the resource. This field can be either PRIVATE_RFC_1918
-- or INTERNAL_HTTPS_LOAD_BALANCER. A subnetwork with purpose set to
-- INTERNAL_HTTPS_LOAD_BALANCER is a user-created subnetwork that is
-- reserved for Internal HTTP(S) Load Balancing. If unspecified, the
-- purpose defaults to PRIVATE_RFC_1918. The enableFlowLogs field isn\'t
-- supported with the purpose field set to INTERNAL_HTTPS_LOAD_BALANCER.
subPurpose :: Lens' Subnetwork (Maybe SubnetworkPurpose)
subPurpose
  = lens _subPurpose (\ s a -> s{_subPurpose = a})

-- | The role of subnetwork. Currently, this field is only used when purpose
-- = INTERNAL_HTTPS_LOAD_BALANCER. The value can be set to ACTIVE or
-- BACKUP. An ACTIVE subnetwork is one that is currently being used for
-- Internal HTTP(S) Load Balancing. A BACKUP subnetwork is one that is
-- ready to be promoted to ACTIVE or is currently draining. This field can
-- be updated with a patch request.
subRole :: Lens' Subnetwork (Maybe SubnetworkRole)
subRole = lens _subRole (\ s a -> s{_subRole = a})

-- | [Output Only] Server-defined URL for the resource.
subSelfLink :: Lens' Subnetwork (Maybe Text)
subSelfLink
  = lens _subSelfLink (\ s a -> s{_subSelfLink = a})

-- | Whether to enable flow logging for this subnetwork. If this field is not
-- explicitly set, it will not appear in get listings. If not set the
-- default behavior is to disable flow logging. This field isn\'t supported
-- with the purpose field set to INTERNAL_HTTPS_LOAD_BALANCER.
subEnableFlowLogs :: Lens' Subnetwork (Maybe Bool)
subEnableFlowLogs
  = lens _subEnableFlowLogs
      (\ s a -> s{_subEnableFlowLogs = a})

-- | The name of the resource, provided by the client when initially creating
-- the resource. The name must be 1-63 characters long, and comply with
-- RFC1035. Specifically, the name must be 1-63 characters long and match
-- the regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the
-- first character must be a lowercase letter, and all following characters
-- must be a dash, lowercase letter, or digit, except the last character,
-- which cannot be a dash.
subName :: Lens' Subnetwork (Maybe Text)
subName = lens _subName (\ s a -> s{_subName = a})

-- | An array of configurations for secondary IP ranges for VM instances
-- contained in this subnetwork. The primary IP of such VM must belong to
-- the primary ipCidrRange of the subnetwork. The alias IPs may belong to
-- either primary or secondary ranges. This field can be updated with a
-- patch request.
subSecondaryIPRanges :: Lens' Subnetwork [SubnetworkSecondaryRange]
subSecondaryIPRanges
  = lens _subSecondaryIPRanges
      (\ s a -> s{_subSecondaryIPRanges = a})
      . _Default
      . _Coerce

-- | [Output Only] Creation timestamp in RFC3339 text format.
subCreationTimestamp :: Lens' Subnetwork (Maybe Text)
subCreationTimestamp
  = lens _subCreationTimestamp
      (\ s a -> s{_subCreationTimestamp = a})

-- | The range of internal addresses that are owned by this subnetwork.
-- Provide this property when you create the subnetwork. For example,
-- 10.0.0.0\/8 or 100.64.0.0\/10. Ranges must be unique and non-overlapping
-- within a network. Only IPv4 is supported. This field is set at resource
-- creation time. The range can be any range listed in the Valid ranges
-- list. The range can be expanded after creation using expandIpCidrRange.
subIPCIdRRange :: Lens' Subnetwork (Maybe Text)
subIPCIdRRange
  = lens _subIPCIdRRange
      (\ s a -> s{_subIPCIdRRange = a})

-- | [Output Only] The range of internal IPv6 addresses that are owned by
-- this subnetwork.
subIPv6CIdRRange :: Lens' Subnetwork (Maybe Text)
subIPv6CIdRRange
  = lens _subIPv6CIdRRange
      (\ s a -> s{_subIPv6CIdRRange = a})

-- | The access type of IPv6 address this subnet holds. It\'s immutable and
-- can only be specified during creation or the first time the subnet is
-- updated into IPV4_IPV6 dual stack. If the ipv6_type is EXTERNAL then
-- this subnet cannot enable direct path.
subIPv6AccessType :: Lens' Subnetwork (Maybe SubnetworkIPv6AccessType)
subIPv6AccessType
  = lens _subIPv6AccessType
      (\ s a -> s{_subIPv6AccessType = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
subId :: Lens' Subnetwork (Maybe Word64)
subId
  = lens _subId (\ s a -> s{_subId = a}) .
      mapping _Coerce

-- | URL of the region where the Subnetwork resides. This field can be set
-- only at resource creation time.
subRegion :: Lens' Subnetwork (Maybe Text)
subRegion
  = lens _subRegion (\ s a -> s{_subRegion = a})

-- | This field denotes the VPC flow logging options for this subnetwork. If
-- logging is enabled, logs are exported to Cloud Logging.
subLogConfig :: Lens' Subnetwork (Maybe SubnetworkLogConfig)
subLogConfig
  = lens _subLogConfig (\ s a -> s{_subLogConfig = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource. This field can be set only at resource creation
-- time.
subDescription :: Lens' Subnetwork (Maybe Text)
subDescription
  = lens _subDescription
      (\ s a -> s{_subDescription = a})

-- | Whether the VMs in this subnet can access Google services without
-- assigned external IP addresses. This field can be both set at resource
-- creation time and updated using setPrivateIpGoogleAccess.
subPrivateIPGoogleAccess :: Lens' Subnetwork (Maybe Bool)
subPrivateIPGoogleAccess
  = lens _subPrivateIPGoogleAccess
      (\ s a -> s{_subPrivateIPGoogleAccess = a})

-- | The private IPv6 google access type for the VMs in this subnet. This is
-- an expanded field of enablePrivateV6Access. If both fields are set,
-- privateIpv6GoogleAccess will take priority. This field can be both set
-- at resource creation time and updated using patch.
subPrivateIPv6GoogleAccess :: Lens' Subnetwork (Maybe SubnetworkPrivateIPv6GoogleAccess)
subPrivateIPv6GoogleAccess
  = lens _subPrivateIPv6GoogleAccess
      (\ s a -> s{_subPrivateIPv6GoogleAccess = a})

instance FromJSON Subnetwork where
        parseJSON
          = withObject "Subnetwork"
              (\ o ->
                 Subnetwork' <$>
                   (o .:? "externalIpv6Prefix") <*> (o .:? "state") <*>
                     (o .:? "kind" .!= "compute#subnetwork")
                     <*> (o .:? "fingerprint")
                     <*> (o .:? "network")
                     <*> (o .:? "stackType")
                     <*> (o .:? "gatewayAddress")
                     <*> (o .:? "purpose")
                     <*> (o .:? "role")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "enableFlowLogs")
                     <*> (o .:? "name")
                     <*> (o .:? "secondaryIpRanges" .!= mempty)
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "ipCidrRange")
                     <*> (o .:? "ipv6CidrRange")
                     <*> (o .:? "ipv6AccessType")
                     <*> (o .:? "id")
                     <*> (o .:? "region")
                     <*> (o .:? "logConfig")
                     <*> (o .:? "description")
                     <*> (o .:? "privateIpGoogleAccess")
                     <*> (o .:? "privateIpv6GoogleAccess"))

instance ToJSON Subnetwork where
        toJSON Subnetwork'{..}
          = object
              (catMaybes
                 [("externalIpv6Prefix" .=) <$>
                    _subExternalIPv6Prefix,
                  ("state" .=) <$> _subState,
                  Just ("kind" .= _subKind),
                  ("fingerprint" .=) <$> _subFingerprint,
                  ("network" .=) <$> _subNetwork,
                  ("stackType" .=) <$> _subStackType,
                  ("gatewayAddress" .=) <$> _subGatewayAddress,
                  ("purpose" .=) <$> _subPurpose,
                  ("role" .=) <$> _subRole,
                  ("selfLink" .=) <$> _subSelfLink,
                  ("enableFlowLogs" .=) <$> _subEnableFlowLogs,
                  ("name" .=) <$> _subName,
                  ("secondaryIpRanges" .=) <$> _subSecondaryIPRanges,
                  ("creationTimestamp" .=) <$> _subCreationTimestamp,
                  ("ipCidrRange" .=) <$> _subIPCIdRRange,
                  ("ipv6CidrRange" .=) <$> _subIPv6CIdRRange,
                  ("ipv6AccessType" .=) <$> _subIPv6AccessType,
                  ("id" .=) <$> _subId, ("region" .=) <$> _subRegion,
                  ("logConfig" .=) <$> _subLogConfig,
                  ("description" .=) <$> _subDescription,
                  ("privateIpGoogleAccess" .=) <$>
                    _subPrivateIPGoogleAccess,
                  ("privateIpv6GoogleAccess" .=) <$>
                    _subPrivateIPv6GoogleAccess])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'healthCheckListWarning' smart constructor.
data HealthCheckListWarning =
  HealthCheckListWarning'
    { _hclwData :: !(Maybe [HealthCheckListWarningDataItem])
    , _hclwCode :: !(Maybe HealthCheckListWarningCode)
    , _hclwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HealthCheckListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hclwData'
--
-- * 'hclwCode'
--
-- * 'hclwMessage'
healthCheckListWarning
    :: HealthCheckListWarning
healthCheckListWarning =
  HealthCheckListWarning'
    {_hclwData = Nothing, _hclwCode = Nothing, _hclwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
hclwData :: Lens' HealthCheckListWarning [HealthCheckListWarningDataItem]
hclwData
  = lens _hclwData (\ s a -> s{_hclwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
hclwCode :: Lens' HealthCheckListWarning (Maybe HealthCheckListWarningCode)
hclwCode = lens _hclwCode (\ s a -> s{_hclwCode = a})

-- | [Output Only] A human-readable description of the warning code.
hclwMessage :: Lens' HealthCheckListWarning (Maybe Text)
hclwMessage
  = lens _hclwMessage (\ s a -> s{_hclwMessage = a})

instance FromJSON HealthCheckListWarning where
        parseJSON
          = withObject "HealthCheckListWarning"
              (\ o ->
                 HealthCheckListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON HealthCheckListWarning where
        toJSON HealthCheckListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _hclwData,
                  ("code" .=) <$> _hclwCode,
                  ("message" .=) <$> _hclwMessage])

--
-- /See:/ 'machineTypeAggregatedList' smart constructor.
data MachineTypeAggregatedList =
  MachineTypeAggregatedList'
    { _mtalUnreachables :: !(Maybe [Text])
    , _mtalNextPageToken :: !(Maybe Text)
    , _mtalKind :: !Text
    , _mtalItems :: !(Maybe MachineTypeAggregatedListItems)
    , _mtalSelfLink :: !(Maybe Text)
    , _mtalWarning :: !(Maybe MachineTypeAggregatedListWarning)
    , _mtalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'MachineTypeAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'mtalUnreachables'
--
-- * 'mtalNextPageToken'
--
-- * 'mtalKind'
--
-- * 'mtalItems'
--
-- * 'mtalSelfLink'
--
-- * 'mtalWarning'
--
-- * 'mtalId'
machineTypeAggregatedList
    :: MachineTypeAggregatedList
machineTypeAggregatedList =
  MachineTypeAggregatedList'
    { _mtalUnreachables = Nothing
    , _mtalNextPageToken = Nothing
    , _mtalKind = "compute#machineTypeAggregatedList"
    , _mtalItems = Nothing
    , _mtalSelfLink = Nothing
    , _mtalWarning = Nothing
    , _mtalId = Nothing
    }


-- | [Output Only] Unreachable resources.
mtalUnreachables :: Lens' MachineTypeAggregatedList [Text]
mtalUnreachables
  = lens _mtalUnreachables
      (\ s a -> s{_mtalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
mtalNextPageToken :: Lens' MachineTypeAggregatedList (Maybe Text)
mtalNextPageToken
  = lens _mtalNextPageToken
      (\ s a -> s{_mtalNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#machineTypeAggregatedList
-- for aggregated lists of machine types.
mtalKind :: Lens' MachineTypeAggregatedList Text
mtalKind = lens _mtalKind (\ s a -> s{_mtalKind = a})

-- | A list of MachineTypesScopedList resources.
mtalItems :: Lens' MachineTypeAggregatedList (Maybe MachineTypeAggregatedListItems)
mtalItems
  = lens _mtalItems (\ s a -> s{_mtalItems = a})

-- | [Output Only] Server-defined URL for this resource.
mtalSelfLink :: Lens' MachineTypeAggregatedList (Maybe Text)
mtalSelfLink
  = lens _mtalSelfLink (\ s a -> s{_mtalSelfLink = a})

-- | [Output Only] Informational warning message.
mtalWarning :: Lens' MachineTypeAggregatedList (Maybe MachineTypeAggregatedListWarning)
mtalWarning
  = lens _mtalWarning (\ s a -> s{_mtalWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
mtalId :: Lens' MachineTypeAggregatedList (Maybe Text)
mtalId = lens _mtalId (\ s a -> s{_mtalId = a})

instance FromJSON MachineTypeAggregatedList where
        parseJSON
          = withObject "MachineTypeAggregatedList"
              (\ o ->
                 MachineTypeAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!=
                        "compute#machineTypeAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON MachineTypeAggregatedList where
        toJSON MachineTypeAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _mtalUnreachables,
                  ("nextPageToken" .=) <$> _mtalNextPageToken,
                  Just ("kind" .= _mtalKind),
                  ("items" .=) <$> _mtalItems,
                  ("selfLink" .=) <$> _mtalSelfLink,
                  ("warning" .=) <$> _mtalWarning,
                  ("id" .=) <$> _mtalId])

--
-- /See:/ 'networkEndpointGroupsListNetworkEndpointsWarningDataItem' smart constructor.
data NetworkEndpointGroupsListNetworkEndpointsWarningDataItem =
  NetworkEndpointGroupsListNetworkEndpointsWarningDataItem'
    { _neglnewdiValue :: !(Maybe Text)
    , _neglnewdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkEndpointGroupsListNetworkEndpointsWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'neglnewdiValue'
--
-- * 'neglnewdiKey'
networkEndpointGroupsListNetworkEndpointsWarningDataItem
    :: NetworkEndpointGroupsListNetworkEndpointsWarningDataItem
networkEndpointGroupsListNetworkEndpointsWarningDataItem =
  NetworkEndpointGroupsListNetworkEndpointsWarningDataItem'
    {_neglnewdiValue = Nothing, _neglnewdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
neglnewdiValue :: Lens' NetworkEndpointGroupsListNetworkEndpointsWarningDataItem (Maybe Text)
neglnewdiValue
  = lens _neglnewdiValue
      (\ s a -> s{_neglnewdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
neglnewdiKey :: Lens' NetworkEndpointGroupsListNetworkEndpointsWarningDataItem (Maybe Text)
neglnewdiKey
  = lens _neglnewdiKey (\ s a -> s{_neglnewdiKey = a})

instance FromJSON
           NetworkEndpointGroupsListNetworkEndpointsWarningDataItem
         where
        parseJSON
          = withObject
              "NetworkEndpointGroupsListNetworkEndpointsWarningDataItem"
              (\ o ->
                 NetworkEndpointGroupsListNetworkEndpointsWarningDataItem'
                   <$> (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           NetworkEndpointGroupsListNetworkEndpointsWarningDataItem
         where
        toJSON
          NetworkEndpointGroupsListNetworkEndpointsWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _neglnewdiValue,
                  ("key" .=) <$> _neglnewdiKey])

--
-- /See:/ 'resourcePolicyWeeklyCycleDayOfWeek' smart constructor.
data ResourcePolicyWeeklyCycleDayOfWeek =
  ResourcePolicyWeeklyCycleDayOfWeek'
    { _rpwcdowStartTime :: !(Maybe Text)
    , _rpwcdowDay :: !(Maybe ResourcePolicyWeeklyCycleDayOfWeekDay)
    , _rpwcdowDuration :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePolicyWeeklyCycleDayOfWeek' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rpwcdowStartTime'
--
-- * 'rpwcdowDay'
--
-- * 'rpwcdowDuration'
resourcePolicyWeeklyCycleDayOfWeek
    :: ResourcePolicyWeeklyCycleDayOfWeek
resourcePolicyWeeklyCycleDayOfWeek =
  ResourcePolicyWeeklyCycleDayOfWeek'
    { _rpwcdowStartTime = Nothing
    , _rpwcdowDay = Nothing
    , _rpwcdowDuration = Nothing
    }


-- | Time within the window to start the operations. It must be in format
-- \"HH:MM\", where HH : [00-23] and MM : [00-00] GMT.
rpwcdowStartTime :: Lens' ResourcePolicyWeeklyCycleDayOfWeek (Maybe Text)
rpwcdowStartTime
  = lens _rpwcdowStartTime
      (\ s a -> s{_rpwcdowStartTime = a})

-- | Defines a schedule that runs on specific days of the week. Specify one
-- or more days. The following options are available: MONDAY, TUESDAY,
-- WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
rpwcdowDay :: Lens' ResourcePolicyWeeklyCycleDayOfWeek (Maybe ResourcePolicyWeeklyCycleDayOfWeekDay)
rpwcdowDay
  = lens _rpwcdowDay (\ s a -> s{_rpwcdowDay = a})

-- | [Output only] Duration of the time window, automatically chosen to be
-- smallest possible in the given scenario.
rpwcdowDuration :: Lens' ResourcePolicyWeeklyCycleDayOfWeek (Maybe Text)
rpwcdowDuration
  = lens _rpwcdowDuration
      (\ s a -> s{_rpwcdowDuration = a})

instance FromJSON ResourcePolicyWeeklyCycleDayOfWeek
         where
        parseJSON
          = withObject "ResourcePolicyWeeklyCycleDayOfWeek"
              (\ o ->
                 ResourcePolicyWeeklyCycleDayOfWeek' <$>
                   (o .:? "startTime") <*> (o .:? "day") <*>
                     (o .:? "duration"))

instance ToJSON ResourcePolicyWeeklyCycleDayOfWeek
         where
        toJSON ResourcePolicyWeeklyCycleDayOfWeek'{..}
          = object
              (catMaybes
                 [("startTime" .=) <$> _rpwcdowStartTime,
                  ("day" .=) <$> _rpwcdowDay,
                  ("duration" .=) <$> _rpwcdowDuration])

-- | [Output Only] An informational warning that appears when the nodeGroup
-- list is empty.
--
-- /See:/ 'nodeGroupsScopedListWarning' smart constructor.
data NodeGroupsScopedListWarning =
  NodeGroupsScopedListWarning'
    { _ngslwData :: !(Maybe [NodeGroupsScopedListWarningDataItem])
    , _ngslwCode :: !(Maybe NodeGroupsScopedListWarningCode)
    , _ngslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeGroupsScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ngslwData'
--
-- * 'ngslwCode'
--
-- * 'ngslwMessage'
nodeGroupsScopedListWarning
    :: NodeGroupsScopedListWarning
nodeGroupsScopedListWarning =
  NodeGroupsScopedListWarning'
    {_ngslwData = Nothing, _ngslwCode = Nothing, _ngslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
ngslwData :: Lens' NodeGroupsScopedListWarning [NodeGroupsScopedListWarningDataItem]
ngslwData
  = lens _ngslwData (\ s a -> s{_ngslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
ngslwCode :: Lens' NodeGroupsScopedListWarning (Maybe NodeGroupsScopedListWarningCode)
ngslwCode
  = lens _ngslwCode (\ s a -> s{_ngslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
ngslwMessage :: Lens' NodeGroupsScopedListWarning (Maybe Text)
ngslwMessage
  = lens _ngslwMessage (\ s a -> s{_ngslwMessage = a})

instance FromJSON NodeGroupsScopedListWarning where
        parseJSON
          = withObject "NodeGroupsScopedListWarning"
              (\ o ->
                 NodeGroupsScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON NodeGroupsScopedListWarning where
        toJSON NodeGroupsScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _ngslwData,
                  ("code" .=) <$> _ngslwCode,
                  ("message" .=) <$> _ngslwMessage])

-- | Contains a list of node types.
--
-- /See:/ 'nodeTypeList' smart constructor.
data NodeTypeList =
  NodeTypeList'
    { _ntltNextPageToken :: !(Maybe Text)
    , _ntltKind :: !Text
    , _ntltItems :: !(Maybe [NodeType])
    , _ntltSelfLink :: !(Maybe Text)
    , _ntltWarning :: !(Maybe NodeTypeListWarning)
    , _ntltId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeTypeList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ntltNextPageToken'
--
-- * 'ntltKind'
--
-- * 'ntltItems'
--
-- * 'ntltSelfLink'
--
-- * 'ntltWarning'
--
-- * 'ntltId'
nodeTypeList
    :: NodeTypeList
nodeTypeList =
  NodeTypeList'
    { _ntltNextPageToken = Nothing
    , _ntltKind = "compute#nodeTypeList"
    , _ntltItems = Nothing
    , _ntltSelfLink = Nothing
    , _ntltWarning = Nothing
    , _ntltId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
ntltNextPageToken :: Lens' NodeTypeList (Maybe Text)
ntltNextPageToken
  = lens _ntltNextPageToken
      (\ s a -> s{_ntltNextPageToken = a})

-- | [Output Only] Type of resource.Always compute#nodeTypeList for lists of
-- node types.
ntltKind :: Lens' NodeTypeList Text
ntltKind = lens _ntltKind (\ s a -> s{_ntltKind = a})

-- | A list of NodeType resources.
ntltItems :: Lens' NodeTypeList [NodeType]
ntltItems
  = lens _ntltItems (\ s a -> s{_ntltItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
ntltSelfLink :: Lens' NodeTypeList (Maybe Text)
ntltSelfLink
  = lens _ntltSelfLink (\ s a -> s{_ntltSelfLink = a})

-- | [Output Only] Informational warning message.
ntltWarning :: Lens' NodeTypeList (Maybe NodeTypeListWarning)
ntltWarning
  = lens _ntltWarning (\ s a -> s{_ntltWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
ntltId :: Lens' NodeTypeList (Maybe Text)
ntltId = lens _ntltId (\ s a -> s{_ntltId = a})

instance FromJSON NodeTypeList where
        parseJSON
          = withObject "NodeTypeList"
              (\ o ->
                 NodeTypeList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#nodeTypeList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON NodeTypeList where
        toJSON NodeTypeList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _ntltNextPageToken,
                  Just ("kind" .= _ntltKind),
                  ("items" .=) <$> _ntltItems,
                  ("selfLink" .=) <$> _ntltSelfLink,
                  ("warning" .=) <$> _ntltWarning,
                  ("id" .=) <$> _ntltId])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'publicAdvertisedPrefixListWarning' smart constructor.
data PublicAdvertisedPrefixListWarning =
  PublicAdvertisedPrefixListWarning'
    { _paplwData :: !(Maybe [PublicAdvertisedPrefixListWarningDataItem])
    , _paplwCode :: !(Maybe PublicAdvertisedPrefixListWarningCode)
    , _paplwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PublicAdvertisedPrefixListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'paplwData'
--
-- * 'paplwCode'
--
-- * 'paplwMessage'
publicAdvertisedPrefixListWarning
    :: PublicAdvertisedPrefixListWarning
publicAdvertisedPrefixListWarning =
  PublicAdvertisedPrefixListWarning'
    {_paplwData = Nothing, _paplwCode = Nothing, _paplwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
paplwData :: Lens' PublicAdvertisedPrefixListWarning [PublicAdvertisedPrefixListWarningDataItem]
paplwData
  = lens _paplwData (\ s a -> s{_paplwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
paplwCode :: Lens' PublicAdvertisedPrefixListWarning (Maybe PublicAdvertisedPrefixListWarningCode)
paplwCode
  = lens _paplwCode (\ s a -> s{_paplwCode = a})

-- | [Output Only] A human-readable description of the warning code.
paplwMessage :: Lens' PublicAdvertisedPrefixListWarning (Maybe Text)
paplwMessage
  = lens _paplwMessage (\ s a -> s{_paplwMessage = a})

instance FromJSON PublicAdvertisedPrefixListWarning
         where
        parseJSON
          = withObject "PublicAdvertisedPrefixListWarning"
              (\ o ->
                 PublicAdvertisedPrefixListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON PublicAdvertisedPrefixListWarning
         where
        toJSON PublicAdvertisedPrefixListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _paplwData,
                  ("code" .=) <$> _paplwCode,
                  ("message" .=) <$> _paplwMessage])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'externalVPNGatewayListWarning' smart constructor.
data ExternalVPNGatewayListWarning =
  ExternalVPNGatewayListWarning'
    { _evglwData :: !(Maybe [ExternalVPNGatewayListWarningDataItem])
    , _evglwCode :: !(Maybe ExternalVPNGatewayListWarningCode)
    , _evglwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ExternalVPNGatewayListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'evglwData'
--
-- * 'evglwCode'
--
-- * 'evglwMessage'
externalVPNGatewayListWarning
    :: ExternalVPNGatewayListWarning
externalVPNGatewayListWarning =
  ExternalVPNGatewayListWarning'
    {_evglwData = Nothing, _evglwCode = Nothing, _evglwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
evglwData :: Lens' ExternalVPNGatewayListWarning [ExternalVPNGatewayListWarningDataItem]
evglwData
  = lens _evglwData (\ s a -> s{_evglwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
evglwCode :: Lens' ExternalVPNGatewayListWarning (Maybe ExternalVPNGatewayListWarningCode)
evglwCode
  = lens _evglwCode (\ s a -> s{_evglwCode = a})

-- | [Output Only] A human-readable description of the warning code.
evglwMessage :: Lens' ExternalVPNGatewayListWarning (Maybe Text)
evglwMessage
  = lens _evglwMessage (\ s a -> s{_evglwMessage = a})

instance FromJSON ExternalVPNGatewayListWarning where
        parseJSON
          = withObject "ExternalVPNGatewayListWarning"
              (\ o ->
                 ExternalVPNGatewayListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON ExternalVPNGatewayListWarning where
        toJSON ExternalVPNGatewayListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _evglwData,
                  ("code" .=) <$> _evglwCode,
                  ("message" .=) <$> _evglwMessage])

-- | Represents a Disk Type resource. Google Compute Engine has two Disk Type
-- resources: *
-- [Regional](\/compute\/docs\/reference\/rest\/{$api_version}\/regionDiskTypes)
-- * [Zonal](\/compute\/docs\/reference\/rest\/{$api_version}\/diskTypes)
-- You can choose from a variety of disk types based on your needs. For
-- more information, read Storage options. The diskTypes resource
-- represents disk types for a zonal persistent disk. For more information,
-- read Zonal persistent disks. The regionDiskTypes resource represents
-- disk types for a regional persistent disk. For more information, read
-- Regional persistent disks. (== resource_for {$api_version}.diskTypes ==)
-- (== resource_for {$api_version}.regionDiskTypes ==)
--
-- /See:/ 'diskType' smart constructor.
data DiskType =
  DiskType'
    { _dtKind :: !Text
    , _dtZone :: !(Maybe Text)
    , _dtSelfLink :: !(Maybe Text)
    , _dtName :: !(Maybe Text)
    , _dtCreationTimestamp :: !(Maybe Text)
    , _dtId :: !(Maybe (Textual Word64))
    , _dtRegion :: !(Maybe Text)
    , _dtValidDiskSize :: !(Maybe Text)
    , _dtDescription :: !(Maybe Text)
    , _dtDefaultDiskSizeGb :: !(Maybe (Textual Int64))
    , _dtDeprecated :: !(Maybe DeprecationStatus)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DiskType' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dtKind'
--
-- * 'dtZone'
--
-- * 'dtSelfLink'
--
-- * 'dtName'
--
-- * 'dtCreationTimestamp'
--
-- * 'dtId'
--
-- * 'dtRegion'
--
-- * 'dtValidDiskSize'
--
-- * 'dtDescription'
--
-- * 'dtDefaultDiskSizeGb'
--
-- * 'dtDeprecated'
diskType
    :: DiskType
diskType =
  DiskType'
    { _dtKind = "compute#diskType"
    , _dtZone = Nothing
    , _dtSelfLink = Nothing
    , _dtName = Nothing
    , _dtCreationTimestamp = Nothing
    , _dtId = Nothing
    , _dtRegion = Nothing
    , _dtValidDiskSize = Nothing
    , _dtDescription = Nothing
    , _dtDefaultDiskSizeGb = Nothing
    , _dtDeprecated = Nothing
    }


-- | [Output Only] Type of the resource. Always compute#diskType for disk
-- types.
dtKind :: Lens' DiskType Text
dtKind = lens _dtKind (\ s a -> s{_dtKind = a})

-- | [Output Only] URL of the zone where the disk type resides. You must
-- specify this field as part of the HTTP request URL. It is not settable
-- as a field in the request body.
dtZone :: Lens' DiskType (Maybe Text)
dtZone = lens _dtZone (\ s a -> s{_dtZone = a})

-- | [Output Only] Server-defined URL for the resource.
dtSelfLink :: Lens' DiskType (Maybe Text)
dtSelfLink
  = lens _dtSelfLink (\ s a -> s{_dtSelfLink = a})

-- | [Output Only] Name of the resource.
dtName :: Lens' DiskType (Maybe Text)
dtName = lens _dtName (\ s a -> s{_dtName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
dtCreationTimestamp :: Lens' DiskType (Maybe Text)
dtCreationTimestamp
  = lens _dtCreationTimestamp
      (\ s a -> s{_dtCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
dtId :: Lens' DiskType (Maybe Word64)
dtId
  = lens _dtId (\ s a -> s{_dtId = a}) .
      mapping _Coerce

-- | [Output Only] URL of the region where the disk type resides. Only
-- applicable for regional resources. You must specify this field as part
-- of the HTTP request URL. It is not settable as a field in the request
-- body.
dtRegion :: Lens' DiskType (Maybe Text)
dtRegion = lens _dtRegion (\ s a -> s{_dtRegion = a})

-- | [Output Only] An optional textual description of the valid disk size,
-- such as \"10GB-10TB\".
dtValidDiskSize :: Lens' DiskType (Maybe Text)
dtValidDiskSize
  = lens _dtValidDiskSize
      (\ s a -> s{_dtValidDiskSize = a})

-- | [Output Only] An optional description of this resource.
dtDescription :: Lens' DiskType (Maybe Text)
dtDescription
  = lens _dtDescription
      (\ s a -> s{_dtDescription = a})

-- | [Output Only] Server-defined default disk size in GB.
dtDefaultDiskSizeGb :: Lens' DiskType (Maybe Int64)
dtDefaultDiskSizeGb
  = lens _dtDefaultDiskSizeGb
      (\ s a -> s{_dtDefaultDiskSizeGb = a})
      . mapping _Coerce

-- | [Output Only] The deprecation status associated with this disk type.
dtDeprecated :: Lens' DiskType (Maybe DeprecationStatus)
dtDeprecated
  = lens _dtDeprecated (\ s a -> s{_dtDeprecated = a})

instance FromJSON DiskType where
        parseJSON
          = withObject "DiskType"
              (\ o ->
                 DiskType' <$>
                   (o .:? "kind" .!= "compute#diskType") <*>
                     (o .:? "zone")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "region")
                     <*> (o .:? "validDiskSize")
                     <*> (o .:? "description")
                     <*> (o .:? "defaultDiskSizeGb")
                     <*> (o .:? "deprecated"))

instance ToJSON DiskType where
        toJSON DiskType'{..}
          = object
              (catMaybes
                 [Just ("kind" .= _dtKind), ("zone" .=) <$> _dtZone,
                  ("selfLink" .=) <$> _dtSelfLink,
                  ("name" .=) <$> _dtName,
                  ("creationTimestamp" .=) <$> _dtCreationTimestamp,
                  ("id" .=) <$> _dtId, ("region" .=) <$> _dtRegion,
                  ("validDiskSize" .=) <$> _dtValidDiskSize,
                  ("description" .=) <$> _dtDescription,
                  ("defaultDiskSizeGb" .=) <$> _dtDefaultDiskSizeGb,
                  ("deprecated" .=) <$> _dtDeprecated])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'nodeTemplateAggregatedListWarning' smart constructor.
data NodeTemplateAggregatedListWarning =
  NodeTemplateAggregatedListWarning'
    { _ntalwData :: !(Maybe [NodeTemplateAggregatedListWarningDataItem])
    , _ntalwCode :: !(Maybe NodeTemplateAggregatedListWarningCode)
    , _ntalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeTemplateAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ntalwData'
--
-- * 'ntalwCode'
--
-- * 'ntalwMessage'
nodeTemplateAggregatedListWarning
    :: NodeTemplateAggregatedListWarning
nodeTemplateAggregatedListWarning =
  NodeTemplateAggregatedListWarning'
    {_ntalwData = Nothing, _ntalwCode = Nothing, _ntalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
ntalwData :: Lens' NodeTemplateAggregatedListWarning [NodeTemplateAggregatedListWarningDataItem]
ntalwData
  = lens _ntalwData (\ s a -> s{_ntalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
ntalwCode :: Lens' NodeTemplateAggregatedListWarning (Maybe NodeTemplateAggregatedListWarningCode)
ntalwCode
  = lens _ntalwCode (\ s a -> s{_ntalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
ntalwMessage :: Lens' NodeTemplateAggregatedListWarning (Maybe Text)
ntalwMessage
  = lens _ntalwMessage (\ s a -> s{_ntalwMessage = a})

instance FromJSON NodeTemplateAggregatedListWarning
         where
        parseJSON
          = withObject "NodeTemplateAggregatedListWarning"
              (\ o ->
                 NodeTemplateAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON NodeTemplateAggregatedListWarning
         where
        toJSON NodeTemplateAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _ntalwData,
                  ("code" .=) <$> _ntalwCode,
                  ("message" .=) <$> _ntalwMessage])

--
-- /See:/ 'autoscalerAggregatedListWarningDataItem' smart constructor.
data AutoscalerAggregatedListWarningDataItem =
  AutoscalerAggregatedListWarningDataItem'
    { _aalwdiValue :: !(Maybe Text)
    , _aalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AutoscalerAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'aalwdiValue'
--
-- * 'aalwdiKey'
autoscalerAggregatedListWarningDataItem
    :: AutoscalerAggregatedListWarningDataItem
autoscalerAggregatedListWarningDataItem =
  AutoscalerAggregatedListWarningDataItem'
    {_aalwdiValue = Nothing, _aalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
aalwdiValue :: Lens' AutoscalerAggregatedListWarningDataItem (Maybe Text)
aalwdiValue
  = lens _aalwdiValue (\ s a -> s{_aalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
aalwdiKey :: Lens' AutoscalerAggregatedListWarningDataItem (Maybe Text)
aalwdiKey
  = lens _aalwdiKey (\ s a -> s{_aalwdiKey = a})

instance FromJSON
           AutoscalerAggregatedListWarningDataItem
         where
        parseJSON
          = withObject
              "AutoscalerAggregatedListWarningDataItem"
              (\ o ->
                 AutoscalerAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           AutoscalerAggregatedListWarningDataItem
         where
        toJSON AutoscalerAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _aalwdiValue,
                  ("key" .=) <$> _aalwdiKey])

-- | The labels to set for this resource.
--
-- /See:/ 'zoneSetLabelsRequestLabels' smart constructor.
newtype ZoneSetLabelsRequestLabels =
  ZoneSetLabelsRequestLabels'
    { _zslrlAddtional :: HashMap Text Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ZoneSetLabelsRequestLabels' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'zslrlAddtional'
zoneSetLabelsRequestLabels
    :: HashMap Text Text -- ^ 'zslrlAddtional'
    -> ZoneSetLabelsRequestLabels
zoneSetLabelsRequestLabels pZslrlAddtional_ =
  ZoneSetLabelsRequestLabels' {_zslrlAddtional = _Coerce # pZslrlAddtional_}


zslrlAddtional :: Lens' ZoneSetLabelsRequestLabels (HashMap Text Text)
zslrlAddtional
  = lens _zslrlAddtional
      (\ s a -> s{_zslrlAddtional = a})
      . _Coerce

instance FromJSON ZoneSetLabelsRequestLabels where
        parseJSON
          = withObject "ZoneSetLabelsRequestLabels"
              (\ o ->
                 ZoneSetLabelsRequestLabels' <$> (parseJSONObject o))

instance ToJSON ZoneSetLabelsRequestLabels where
        toJSON = toJSON . _zslrlAddtional

--
-- /See:/ 'nodeTypeListWarningDataItem' smart constructor.
data NodeTypeListWarningDataItem =
  NodeTypeListWarningDataItem'
    { _ntlwdiValue :: !(Maybe Text)
    , _ntlwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeTypeListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ntlwdiValue'
--
-- * 'ntlwdiKey'
nodeTypeListWarningDataItem
    :: NodeTypeListWarningDataItem
nodeTypeListWarningDataItem =
  NodeTypeListWarningDataItem' {_ntlwdiValue = Nothing, _ntlwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
ntlwdiValue :: Lens' NodeTypeListWarningDataItem (Maybe Text)
ntlwdiValue
  = lens _ntlwdiValue (\ s a -> s{_ntlwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
ntlwdiKey :: Lens' NodeTypeListWarningDataItem (Maybe Text)
ntlwdiKey
  = lens _ntlwdiKey (\ s a -> s{_ntlwdiKey = a})

instance FromJSON NodeTypeListWarningDataItem where
        parseJSON
          = withObject "NodeTypeListWarningDataItem"
              (\ o ->
                 NodeTypeListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON NodeTypeListWarningDataItem where
        toJSON NodeTypeListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _ntlwdiValue,
                  ("key" .=) <$> _ntlwdiKey])

-- | Message representing the validation result for a UrlMap.
--
-- /See:/ 'urlMapValidationResult' smart constructor.
data URLMapValidationResult =
  URLMapValidationResult'
    { _umvrLoadErrors :: !(Maybe [Text])
    , _umvrLoadSucceeded :: !(Maybe Bool)
    , _umvrTestPassed :: !(Maybe Bool)
    , _umvrTestFailures :: !(Maybe [TestFailure])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'URLMapValidationResult' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'umvrLoadErrors'
--
-- * 'umvrLoadSucceeded'
--
-- * 'umvrTestPassed'
--
-- * 'umvrTestFailures'
urlMapValidationResult
    :: URLMapValidationResult
urlMapValidationResult =
  URLMapValidationResult'
    { _umvrLoadErrors = Nothing
    , _umvrLoadSucceeded = Nothing
    , _umvrTestPassed = Nothing
    , _umvrTestFailures = Nothing
    }


umvrLoadErrors :: Lens' URLMapValidationResult [Text]
umvrLoadErrors
  = lens _umvrLoadErrors
      (\ s a -> s{_umvrLoadErrors = a})
      . _Default
      . _Coerce

-- | Whether the given UrlMap can be successfully loaded. If false,
-- \'loadErrors\' indicates the reasons.
umvrLoadSucceeded :: Lens' URLMapValidationResult (Maybe Bool)
umvrLoadSucceeded
  = lens _umvrLoadSucceeded
      (\ s a -> s{_umvrLoadSucceeded = a})

-- | If successfully loaded, this field indicates whether the test passed. If
-- false, \'testFailures\'s indicate the reason of failure.
umvrTestPassed :: Lens' URLMapValidationResult (Maybe Bool)
umvrTestPassed
  = lens _umvrTestPassed
      (\ s a -> s{_umvrTestPassed = a})

umvrTestFailures :: Lens' URLMapValidationResult [TestFailure]
umvrTestFailures
  = lens _umvrTestFailures
      (\ s a -> s{_umvrTestFailures = a})
      . _Default
      . _Coerce

instance FromJSON URLMapValidationResult where
        parseJSON
          = withObject "URLMapValidationResult"
              (\ o ->
                 URLMapValidationResult' <$>
                   (o .:? "loadErrors" .!= mempty) <*>
                     (o .:? "loadSucceeded")
                     <*> (o .:? "testPassed")
                     <*> (o .:? "testFailures" .!= mempty))

instance ToJSON URLMapValidationResult where
        toJSON URLMapValidationResult'{..}
          = object
              (catMaybes
                 [("loadErrors" .=) <$> _umvrLoadErrors,
                  ("loadSucceeded" .=) <$> _umvrLoadSucceeded,
                  ("testPassed" .=) <$> _umvrTestPassed,
                  ("testFailures" .=) <$> _umvrTestFailures])

-- | Informational warning which replaces the list of reservations when the
-- list is empty.
--
-- /See:/ 'reservationsScopedListWarning' smart constructor.
data ReservationsScopedListWarning =
  ReservationsScopedListWarning'
    { _resData :: !(Maybe [ReservationsScopedListWarningDataItem])
    , _resCode :: !(Maybe ReservationsScopedListWarningCode)
    , _resMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ReservationsScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'resData'
--
-- * 'resCode'
--
-- * 'resMessage'
reservationsScopedListWarning
    :: ReservationsScopedListWarning
reservationsScopedListWarning =
  ReservationsScopedListWarning'
    {_resData = Nothing, _resCode = Nothing, _resMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
resData :: Lens' ReservationsScopedListWarning [ReservationsScopedListWarningDataItem]
resData
  = lens _resData (\ s a -> s{_resData = a}) . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
resCode :: Lens' ReservationsScopedListWarning (Maybe ReservationsScopedListWarningCode)
resCode = lens _resCode (\ s a -> s{_resCode = a})

-- | [Output Only] A human-readable description of the warning code.
resMessage :: Lens' ReservationsScopedListWarning (Maybe Text)
resMessage
  = lens _resMessage (\ s a -> s{_resMessage = a})

instance FromJSON ReservationsScopedListWarning where
        parseJSON
          = withObject "ReservationsScopedListWarning"
              (\ o ->
                 ReservationsScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON ReservationsScopedListWarning where
        toJSON ReservationsScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _resData, ("code" .=) <$> _resCode,
                  ("message" .=) <$> _resMessage])

-- | A metadata key\/value entry.
--
-- /See:/ 'metadata' smart constructor.
data Metadata =
  Metadata'
    { _mKind :: !Text
    , _mFingerprint :: !(Maybe Bytes)
    , _mItems :: !(Maybe [MetadataItemsItem])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Metadata' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'mKind'
--
-- * 'mFingerprint'
--
-- * 'mItems'
metadata
    :: Metadata
metadata =
  Metadata'
    {_mKind = "compute#metadata", _mFingerprint = Nothing, _mItems = Nothing}


-- | [Output Only] Type of the resource. Always compute#metadata for
-- metadata.
mKind :: Lens' Metadata Text
mKind = lens _mKind (\ s a -> s{_mKind = a})

-- | Specifies a fingerprint for this request, which is essentially a hash of
-- the metadata\'s contents and used for optimistic locking. The
-- fingerprint is initially generated by Compute Engine and changes after
-- every request to modify or update metadata. You must always provide an
-- up-to-date fingerprint hash in order to update or change metadata,
-- otherwise the request will fail with error 412 conditionNotMet. To see
-- the latest fingerprint, make a get() request to retrieve the resource.
mFingerprint :: Lens' Metadata (Maybe ByteString)
mFingerprint
  = lens _mFingerprint (\ s a -> s{_mFingerprint = a})
      . mapping _Bytes

-- | Array of key\/value pairs. The total size of all keys and values must be
-- less than 512 KB.
mItems :: Lens' Metadata [MetadataItemsItem]
mItems
  = lens _mItems (\ s a -> s{_mItems = a}) . _Default .
      _Coerce

instance FromJSON Metadata where
        parseJSON
          = withObject "Metadata"
              (\ o ->
                 Metadata' <$>
                   (o .:? "kind" .!= "compute#metadata") <*>
                     (o .:? "fingerprint")
                     <*> (o .:? "items" .!= mempty))

instance ToJSON Metadata where
        toJSON Metadata'{..}
          = object
              (catMaybes
                 [Just ("kind" .= _mKind),
                  ("fingerprint" .=) <$> _mFingerprint,
                  ("items" .=) <$> _mItems])

--
-- /See:/ 'routeWarningsItem' smart constructor.
data RouteWarningsItem =
  RouteWarningsItem'
    { _rwiData :: !(Maybe [RouteWarningsItemDataItem])
    , _rwiCode :: !(Maybe RouteWarningsItemCode)
    , _rwiMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RouteWarningsItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rwiData'
--
-- * 'rwiCode'
--
-- * 'rwiMessage'
routeWarningsItem
    :: RouteWarningsItem
routeWarningsItem =
  RouteWarningsItem'
    {_rwiData = Nothing, _rwiCode = Nothing, _rwiMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
rwiData :: Lens' RouteWarningsItem [RouteWarningsItemDataItem]
rwiData
  = lens _rwiData (\ s a -> s{_rwiData = a}) . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
rwiCode :: Lens' RouteWarningsItem (Maybe RouteWarningsItemCode)
rwiCode = lens _rwiCode (\ s a -> s{_rwiCode = a})

-- | [Output Only] A human-readable description of the warning code.
rwiMessage :: Lens' RouteWarningsItem (Maybe Text)
rwiMessage
  = lens _rwiMessage (\ s a -> s{_rwiMessage = a})

instance FromJSON RouteWarningsItem where
        parseJSON
          = withObject "RouteWarningsItem"
              (\ o ->
                 RouteWarningsItem' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON RouteWarningsItem where
        toJSON RouteWarningsItem'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _rwiData, ("code" .=) <$> _rwiCode,
                  ("message" .=) <$> _rwiMessage])

--
-- /See:/ 'nodeGroupsListNodes' smart constructor.
data NodeGroupsListNodes =
  NodeGroupsListNodes'
    { _nglnNextPageToken :: !(Maybe Text)
    , _nglnKind :: !Text
    , _nglnItems :: !(Maybe [NodeGroupNode])
    , _nglnSelfLink :: !(Maybe Text)
    , _nglnWarning :: !(Maybe NodeGroupsListNodesWarning)
    , _nglnId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeGroupsListNodes' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nglnNextPageToken'
--
-- * 'nglnKind'
--
-- * 'nglnItems'
--
-- * 'nglnSelfLink'
--
-- * 'nglnWarning'
--
-- * 'nglnId'
nodeGroupsListNodes
    :: NodeGroupsListNodes
nodeGroupsListNodes =
  NodeGroupsListNodes'
    { _nglnNextPageToken = Nothing
    , _nglnKind = "compute#nodeGroupsListNodes"
    , _nglnItems = Nothing
    , _nglnSelfLink = Nothing
    , _nglnWarning = Nothing
    , _nglnId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
nglnNextPageToken :: Lens' NodeGroupsListNodes (Maybe Text)
nglnNextPageToken
  = lens _nglnNextPageToken
      (\ s a -> s{_nglnNextPageToken = a})

-- | [Output Only] The resource type, which is always
-- compute.nodeGroupsListNodes for the list of nodes in the specified node
-- group.
nglnKind :: Lens' NodeGroupsListNodes Text
nglnKind = lens _nglnKind (\ s a -> s{_nglnKind = a})

-- | A list of Node resources.
nglnItems :: Lens' NodeGroupsListNodes [NodeGroupNode]
nglnItems
  = lens _nglnItems (\ s a -> s{_nglnItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
nglnSelfLink :: Lens' NodeGroupsListNodes (Maybe Text)
nglnSelfLink
  = lens _nglnSelfLink (\ s a -> s{_nglnSelfLink = a})

-- | [Output Only] Informational warning message.
nglnWarning :: Lens' NodeGroupsListNodes (Maybe NodeGroupsListNodesWarning)
nglnWarning
  = lens _nglnWarning (\ s a -> s{_nglnWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
nglnId :: Lens' NodeGroupsListNodes (Maybe Text)
nglnId = lens _nglnId (\ s a -> s{_nglnId = a})

instance FromJSON NodeGroupsListNodes where
        parseJSON
          = withObject "NodeGroupsListNodes"
              (\ o ->
                 NodeGroupsListNodes' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#nodeGroupsListNodes")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON NodeGroupsListNodes where
        toJSON NodeGroupsListNodes'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _nglnNextPageToken,
                  Just ("kind" .= _nglnKind),
                  ("items" .=) <$> _nglnItems,
                  ("selfLink" .=) <$> _nglnSelfLink,
                  ("warning" .=) <$> _nglnWarning,
                  ("id" .=) <$> _nglnId])

-- | Applicable only to Failover for Internal TCP\/UDP Load Balancing and
-- Network Load Balancing. On failover or failback, this field indicates
-- whether connection draining will be honored. GCP has a fixed connection
-- draining timeout of 10 minutes. A setting of true terminates existing
-- TCP connections to the active pool during failover and failback,
-- immediately draining traffic. A setting of false allows existing TCP
-- connections to persist, even on VMs no longer in the active pool, for up
-- to the duration of the connection draining timeout (10 minutes).
--
-- /See:/ 'backendServiceFailoverPolicy' smart constructor.
data BackendServiceFailoverPolicy =
  BackendServiceFailoverPolicy'
    { _bsfpDisableConnectionDrainOnFailover :: !(Maybe Bool)
    , _bsfpDropTrafficIfUnhealthy :: !(Maybe Bool)
    , _bsfpFailoverRatio :: !(Maybe (Textual Double))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendServiceFailoverPolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bsfpDisableConnectionDrainOnFailover'
--
-- * 'bsfpDropTrafficIfUnhealthy'
--
-- * 'bsfpFailoverRatio'
backendServiceFailoverPolicy
    :: BackendServiceFailoverPolicy
backendServiceFailoverPolicy =
  BackendServiceFailoverPolicy'
    { _bsfpDisableConnectionDrainOnFailover = Nothing
    , _bsfpDropTrafficIfUnhealthy = Nothing
    , _bsfpFailoverRatio = Nothing
    }


-- | This can be set to true only if the protocol is TCP. The default is
-- false.
bsfpDisableConnectionDrainOnFailover :: Lens' BackendServiceFailoverPolicy (Maybe Bool)
bsfpDisableConnectionDrainOnFailover
  = lens _bsfpDisableConnectionDrainOnFailover
      (\ s a ->
         s{_bsfpDisableConnectionDrainOnFailover = a})

-- | Applicable only to Failover for Internal TCP\/UDP Load Balancing and
-- Network Load Balancing, If set to true, connections to the load balancer
-- are dropped when all primary and all backup backend VMs are unhealthy.If
-- set to false, connections are distributed among all primary VMs when all
-- primary and all backup backend VMs are unhealthy. The default is false.
bsfpDropTrafficIfUnhealthy :: Lens' BackendServiceFailoverPolicy (Maybe Bool)
bsfpDropTrafficIfUnhealthy
  = lens _bsfpDropTrafficIfUnhealthy
      (\ s a -> s{_bsfpDropTrafficIfUnhealthy = a})

-- | Applicable only to Failover for Internal TCP\/UDP Load Balancing and
-- Network Load Balancing. The value of the field must be in the range [0,
-- 1]. If the value is 0, the load balancer performs a failover when the
-- number of healthy primary VMs equals zero. For all other values, the
-- load balancer performs a failover when the total number of healthy
-- primary VMs is less than this ratio.
bsfpFailoverRatio :: Lens' BackendServiceFailoverPolicy (Maybe Double)
bsfpFailoverRatio
  = lens _bsfpFailoverRatio
      (\ s a -> s{_bsfpFailoverRatio = a})
      . mapping _Coerce

instance FromJSON BackendServiceFailoverPolicy where
        parseJSON
          = withObject "BackendServiceFailoverPolicy"
              (\ o ->
                 BackendServiceFailoverPolicy' <$>
                   (o .:? "disableConnectionDrainOnFailover") <*>
                     (o .:? "dropTrafficIfUnhealthy")
                     <*> (o .:? "failoverRatio"))

instance ToJSON BackendServiceFailoverPolicy where
        toJSON BackendServiceFailoverPolicy'{..}
          = object
              (catMaybes
                 [("disableConnectionDrainOnFailover" .=) <$>
                    _bsfpDisableConnectionDrainOnFailover,
                  ("dropTrafficIfUnhealthy" .=) <$>
                    _bsfpDropTrafficIfUnhealthy,
                  ("failoverRatio" .=) <$> _bsfpFailoverRatio])

-- | Response to the list request, and contains a list of interconnect
-- locations.
--
-- /See:/ 'interconnectLocationList' smart constructor.
data InterconnectLocationList =
  InterconnectLocationList'
    { _illNextPageToken :: !(Maybe Text)
    , _illKind :: !Text
    , _illItems :: !(Maybe [InterconnectLocation])
    , _illSelfLink :: !(Maybe Text)
    , _illWarning :: !(Maybe InterconnectLocationListWarning)
    , _illId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectLocationList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'illNextPageToken'
--
-- * 'illKind'
--
-- * 'illItems'
--
-- * 'illSelfLink'
--
-- * 'illWarning'
--
-- * 'illId'
interconnectLocationList
    :: InterconnectLocationList
interconnectLocationList =
  InterconnectLocationList'
    { _illNextPageToken = Nothing
    , _illKind = "compute#interconnectLocationList"
    , _illItems = Nothing
    , _illSelfLink = Nothing
    , _illWarning = Nothing
    , _illId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
illNextPageToken :: Lens' InterconnectLocationList (Maybe Text)
illNextPageToken
  = lens _illNextPageToken
      (\ s a -> s{_illNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#interconnectLocationList
-- for lists of interconnect locations.
illKind :: Lens' InterconnectLocationList Text
illKind = lens _illKind (\ s a -> s{_illKind = a})

-- | A list of InterconnectLocation resources.
illItems :: Lens' InterconnectLocationList [InterconnectLocation]
illItems
  = lens _illItems (\ s a -> s{_illItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
illSelfLink :: Lens' InterconnectLocationList (Maybe Text)
illSelfLink
  = lens _illSelfLink (\ s a -> s{_illSelfLink = a})

-- | [Output Only] Informational warning message.
illWarning :: Lens' InterconnectLocationList (Maybe InterconnectLocationListWarning)
illWarning
  = lens _illWarning (\ s a -> s{_illWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
illId :: Lens' InterconnectLocationList (Maybe Text)
illId = lens _illId (\ s a -> s{_illId = a})

instance FromJSON InterconnectLocationList where
        parseJSON
          = withObject "InterconnectLocationList"
              (\ o ->
                 InterconnectLocationList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#interconnectLocationList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON InterconnectLocationList where
        toJSON InterconnectLocationList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _illNextPageToken,
                  Just ("kind" .= _illKind),
                  ("items" .=) <$> _illItems,
                  ("selfLink" .=) <$> _illSelfLink,
                  ("warning" .=) <$> _illWarning,
                  ("id" .=) <$> _illId])

--
-- /See:/ 'sslPoliciesListAvailableFeaturesResponse' smart constructor.
newtype SSLPoliciesListAvailableFeaturesResponse =
  SSLPoliciesListAvailableFeaturesResponse'
    { _splafrFeatures :: Maybe [Text]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SSLPoliciesListAvailableFeaturesResponse' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'splafrFeatures'
sslPoliciesListAvailableFeaturesResponse
    :: SSLPoliciesListAvailableFeaturesResponse
sslPoliciesListAvailableFeaturesResponse =
  SSLPoliciesListAvailableFeaturesResponse' {_splafrFeatures = Nothing}


splafrFeatures :: Lens' SSLPoliciesListAvailableFeaturesResponse [Text]
splafrFeatures
  = lens _splafrFeatures
      (\ s a -> s{_splafrFeatures = a})
      . _Default
      . _Coerce

instance FromJSON
           SSLPoliciesListAvailableFeaturesResponse
         where
        parseJSON
          = withObject
              "SSLPoliciesListAvailableFeaturesResponse"
              (\ o ->
                 SSLPoliciesListAvailableFeaturesResponse' <$>
                   (o .:? "features" .!= mempty))

instance ToJSON
           SSLPoliciesListAvailableFeaturesResponse
         where
        toJSON SSLPoliciesListAvailableFeaturesResponse'{..}
          = object
              (catMaybes [("features" .=) <$> _splafrFeatures])

-- | Labels to apply to instances that are created from these properties.
--
-- /See:/ 'instancePropertiesLabels' smart constructor.
newtype InstancePropertiesLabels =
  InstancePropertiesLabels'
    { _iplAddtional :: HashMap Text Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstancePropertiesLabels' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iplAddtional'
instancePropertiesLabels
    :: HashMap Text Text -- ^ 'iplAddtional'
    -> InstancePropertiesLabels
instancePropertiesLabels pIplAddtional_ =
  InstancePropertiesLabels' {_iplAddtional = _Coerce # pIplAddtional_}


iplAddtional :: Lens' InstancePropertiesLabels (HashMap Text Text)
iplAddtional
  = lens _iplAddtional (\ s a -> s{_iplAddtional = a})
      . _Coerce

instance FromJSON InstancePropertiesLabels where
        parseJSON
          = withObject "InstancePropertiesLabels"
              (\ o ->
                 InstancePropertiesLabels' <$> (parseJSONObject o))

instance ToJSON InstancePropertiesLabels where
        toJSON = toJSON . _iplAddtional

--
-- /See:/ 'machineTypesScopedListWarningDataItem' smart constructor.
data MachineTypesScopedListWarningDataItem =
  MachineTypesScopedListWarningDataItem'
    { _mtslwdiValue :: !(Maybe Text)
    , _mtslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'MachineTypesScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'mtslwdiValue'
--
-- * 'mtslwdiKey'
machineTypesScopedListWarningDataItem
    :: MachineTypesScopedListWarningDataItem
machineTypesScopedListWarningDataItem =
  MachineTypesScopedListWarningDataItem'
    {_mtslwdiValue = Nothing, _mtslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
mtslwdiValue :: Lens' MachineTypesScopedListWarningDataItem (Maybe Text)
mtslwdiValue
  = lens _mtslwdiValue (\ s a -> s{_mtslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
mtslwdiKey :: Lens' MachineTypesScopedListWarningDataItem (Maybe Text)
mtslwdiKey
  = lens _mtslwdiKey (\ s a -> s{_mtslwdiKey = a})

instance FromJSON
           MachineTypesScopedListWarningDataItem
         where
        parseJSON
          = withObject "MachineTypesScopedListWarningDataItem"
              (\ o ->
                 MachineTypesScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON MachineTypesScopedListWarningDataItem
         where
        toJSON MachineTypesScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _mtslwdiValue,
                  ("key" .=) <$> _mtslwdiKey])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'diskTypeListWarning' smart constructor.
data DiskTypeListWarning =
  DiskTypeListWarning'
    { _dtlwData :: !(Maybe [DiskTypeListWarningDataItem])
    , _dtlwCode :: !(Maybe DiskTypeListWarningCode)
    , _dtlwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DiskTypeListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dtlwData'
--
-- * 'dtlwCode'
--
-- * 'dtlwMessage'
diskTypeListWarning
    :: DiskTypeListWarning
diskTypeListWarning =
  DiskTypeListWarning'
    {_dtlwData = Nothing, _dtlwCode = Nothing, _dtlwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
dtlwData :: Lens' DiskTypeListWarning [DiskTypeListWarningDataItem]
dtlwData
  = lens _dtlwData (\ s a -> s{_dtlwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
dtlwCode :: Lens' DiskTypeListWarning (Maybe DiskTypeListWarningCode)
dtlwCode = lens _dtlwCode (\ s a -> s{_dtlwCode = a})

-- | [Output Only] A human-readable description of the warning code.
dtlwMessage :: Lens' DiskTypeListWarning (Maybe Text)
dtlwMessage
  = lens _dtlwMessage (\ s a -> s{_dtlwMessage = a})

instance FromJSON DiskTypeListWarning where
        parseJSON
          = withObject "DiskTypeListWarning"
              (\ o ->
                 DiskTypeListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON DiskTypeListWarning where
        toJSON DiskTypeListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _dtlwData,
                  ("code" .=) <$> _dtlwCode,
                  ("message" .=) <$> _dtlwMessage])

-- | Represents an external VPN gateway. External VPN gateway is the
-- on-premises VPN gateway(s) or another cloud provider\'s VPN gateway that
-- connects to your Google Cloud VPN gateway. To create a highly available
-- VPN from Google Cloud Platform to your VPN gateway or another cloud
-- provider\'s VPN gateway, you must create a external VPN gateway resource
-- with information about the other gateway. For more information about
-- using external VPN gateways, see Creating an HA VPN gateway and tunnel
-- pair to a peer VPN. (== resource_for {$api_version}.externalVpnGateways
-- ==)
--
-- /See:/ 'externalVPNGateway' smart constructor.
data ExternalVPNGateway =
  ExternalVPNGateway'
    { _evgKind :: !Text
    , _evgInterfaces :: !(Maybe [ExternalVPNGatewayInterface])
    , _evgRedundancyType :: !(Maybe ExternalVPNGatewayRedundancyType)
    , _evgSelfLink :: !(Maybe Text)
    , _evgName :: !(Maybe Text)
    , _evgCreationTimestamp :: !(Maybe Text)
    , _evgId :: !(Maybe (Textual Word64))
    , _evgLabels :: !(Maybe ExternalVPNGatewayLabels)
    , _evgLabelFingerprint :: !(Maybe Bytes)
    , _evgDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ExternalVPNGateway' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'evgKind'
--
-- * 'evgInterfaces'
--
-- * 'evgRedundancyType'
--
-- * 'evgSelfLink'
--
-- * 'evgName'
--
-- * 'evgCreationTimestamp'
--
-- * 'evgId'
--
-- * 'evgLabels'
--
-- * 'evgLabelFingerprint'
--
-- * 'evgDescription'
externalVPNGateway
    :: ExternalVPNGateway
externalVPNGateway =
  ExternalVPNGateway'
    { _evgKind = "compute#externalVpnGateway"
    , _evgInterfaces = Nothing
    , _evgRedundancyType = Nothing
    , _evgSelfLink = Nothing
    , _evgName = Nothing
    , _evgCreationTimestamp = Nothing
    , _evgId = Nothing
    , _evgLabels = Nothing
    , _evgLabelFingerprint = Nothing
    , _evgDescription = Nothing
    }


-- | [Output Only] Type of the resource. Always compute#externalVpnGateway
-- for externalVpnGateways.
evgKind :: Lens' ExternalVPNGateway Text
evgKind = lens _evgKind (\ s a -> s{_evgKind = a})

-- | List of interfaces for this external VPN gateway. If your peer-side
-- gateway is an on-premises gateway and non-AWS cloud providers? gateway,
-- at most two interfaces can be provided for an external VPN gateway. If
-- your peer side is an AWS virtual private gateway, four interfaces should
-- be provided for an external VPN gateway.
evgInterfaces :: Lens' ExternalVPNGateway [ExternalVPNGatewayInterface]
evgInterfaces
  = lens _evgInterfaces
      (\ s a -> s{_evgInterfaces = a})
      . _Default
      . _Coerce

-- | Indicates the user-supplied redundancy type of this external VPN
-- gateway.
evgRedundancyType :: Lens' ExternalVPNGateway (Maybe ExternalVPNGatewayRedundancyType)
evgRedundancyType
  = lens _evgRedundancyType
      (\ s a -> s{_evgRedundancyType = a})

-- | [Output Only] Server-defined URL for the resource.
evgSelfLink :: Lens' ExternalVPNGateway (Maybe Text)
evgSelfLink
  = lens _evgSelfLink (\ s a -> s{_evgSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
evgName :: Lens' ExternalVPNGateway (Maybe Text)
evgName = lens _evgName (\ s a -> s{_evgName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
evgCreationTimestamp :: Lens' ExternalVPNGateway (Maybe Text)
evgCreationTimestamp
  = lens _evgCreationTimestamp
      (\ s a -> s{_evgCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
evgId :: Lens' ExternalVPNGateway (Maybe Word64)
evgId
  = lens _evgId (\ s a -> s{_evgId = a}) .
      mapping _Coerce

-- | Labels for this resource. These can only be added or modified by the
-- setLabels method. Each label key\/value pair must comply with RFC1035.
-- Label values may be empty.
evgLabels :: Lens' ExternalVPNGateway (Maybe ExternalVPNGatewayLabels)
evgLabels
  = lens _evgLabels (\ s a -> s{_evgLabels = a})

-- | A fingerprint for the labels being applied to this ExternalVpnGateway,
-- which is essentially a hash of the labels set used for optimistic
-- locking. The fingerprint is initially generated by Compute Engine and
-- changes after every request to modify or update labels. You must always
-- provide an up-to-date fingerprint hash in order to update or change
-- labels, otherwise the request will fail with error 412 conditionNotMet.
-- To see the latest fingerprint, make a get() request to retrieve an
-- ExternalVpnGateway.
evgLabelFingerprint :: Lens' ExternalVPNGateway (Maybe ByteString)
evgLabelFingerprint
  = lens _evgLabelFingerprint
      (\ s a -> s{_evgLabelFingerprint = a})
      . mapping _Bytes

-- | An optional description of this resource. Provide this property when you
-- create the resource.
evgDescription :: Lens' ExternalVPNGateway (Maybe Text)
evgDescription
  = lens _evgDescription
      (\ s a -> s{_evgDescription = a})

instance FromJSON ExternalVPNGateway where
        parseJSON
          = withObject "ExternalVPNGateway"
              (\ o ->
                 ExternalVPNGateway' <$>
                   (o .:? "kind" .!= "compute#externalVpnGateway") <*>
                     (o .:? "interfaces" .!= mempty)
                     <*> (o .:? "redundancyType")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "labels")
                     <*> (o .:? "labelFingerprint")
                     <*> (o .:? "description"))

instance ToJSON ExternalVPNGateway where
        toJSON ExternalVPNGateway'{..}
          = object
              (catMaybes
                 [Just ("kind" .= _evgKind),
                  ("interfaces" .=) <$> _evgInterfaces,
                  ("redundancyType" .=) <$> _evgRedundancyType,
                  ("selfLink" .=) <$> _evgSelfLink,
                  ("name" .=) <$> _evgName,
                  ("creationTimestamp" .=) <$> _evgCreationTimestamp,
                  ("id" .=) <$> _evgId, ("labels" .=) <$> _evgLabels,
                  ("labelFingerprint" .=) <$> _evgLabelFingerprint,
                  ("description" .=) <$> _evgDescription])

--
-- /See:/ 'nodeTemplateListWarningDataItem' smart constructor.
data NodeTemplateListWarningDataItem =
  NodeTemplateListWarningDataItem'
    { _nodValue :: !(Maybe Text)
    , _nodKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeTemplateListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nodValue'
--
-- * 'nodKey'
nodeTemplateListWarningDataItem
    :: NodeTemplateListWarningDataItem
nodeTemplateListWarningDataItem =
  NodeTemplateListWarningDataItem' {_nodValue = Nothing, _nodKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
nodValue :: Lens' NodeTemplateListWarningDataItem (Maybe Text)
nodValue = lens _nodValue (\ s a -> s{_nodValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
nodKey :: Lens' NodeTemplateListWarningDataItem (Maybe Text)
nodKey = lens _nodKey (\ s a -> s{_nodKey = a})

instance FromJSON NodeTemplateListWarningDataItem
         where
        parseJSON
          = withObject "NodeTemplateListWarningDataItem"
              (\ o ->
                 NodeTemplateListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON NodeTemplateListWarningDataItem where
        toJSON NodeTemplateListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _nodValue, ("key" .=) <$> _nodKey])

--
-- /See:/ 'vpnGatewayListWarningDataItem' smart constructor.
data VPNGatewayListWarningDataItem =
  VPNGatewayListWarningDataItem'
    { _vglwdiValue :: !(Maybe Text)
    , _vglwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNGatewayListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vglwdiValue'
--
-- * 'vglwdiKey'
vpnGatewayListWarningDataItem
    :: VPNGatewayListWarningDataItem
vpnGatewayListWarningDataItem =
  VPNGatewayListWarningDataItem' {_vglwdiValue = Nothing, _vglwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
vglwdiValue :: Lens' VPNGatewayListWarningDataItem (Maybe Text)
vglwdiValue
  = lens _vglwdiValue (\ s a -> s{_vglwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
vglwdiKey :: Lens' VPNGatewayListWarningDataItem (Maybe Text)
vglwdiKey
  = lens _vglwdiKey (\ s a -> s{_vglwdiKey = a})

instance FromJSON VPNGatewayListWarningDataItem where
        parseJSON
          = withObject "VPNGatewayListWarningDataItem"
              (\ o ->
                 VPNGatewayListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON VPNGatewayListWarningDataItem where
        toJSON VPNGatewayListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _vglwdiValue,
                  ("key" .=) <$> _vglwdiKey])

--
-- /See:/ 'regionListWarningDataItem' smart constructor.
data RegionListWarningDataItem =
  RegionListWarningDataItem'
    { _regValue :: !(Maybe Text)
    , _regKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'regValue'
--
-- * 'regKey'
regionListWarningDataItem
    :: RegionListWarningDataItem
regionListWarningDataItem =
  RegionListWarningDataItem' {_regValue = Nothing, _regKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
regValue :: Lens' RegionListWarningDataItem (Maybe Text)
regValue = lens _regValue (\ s a -> s{_regValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
regKey :: Lens' RegionListWarningDataItem (Maybe Text)
regKey = lens _regKey (\ s a -> s{_regKey = a})

instance FromJSON RegionListWarningDataItem where
        parseJSON
          = withObject "RegionListWarningDataItem"
              (\ o ->
                 RegionListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON RegionListWarningDataItem where
        toJSON RegionListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _regValue, ("key" .=) <$> _regKey])

--
-- /See:/ 'instancesSetMachineResourcesRequest' smart constructor.
newtype InstancesSetMachineResourcesRequest =
  InstancesSetMachineResourcesRequest'
    { _ismrrGuestAccelerators :: Maybe [AcceleratorConfig]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstancesSetMachineResourcesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ismrrGuestAccelerators'
instancesSetMachineResourcesRequest
    :: InstancesSetMachineResourcesRequest
instancesSetMachineResourcesRequest =
  InstancesSetMachineResourcesRequest' {_ismrrGuestAccelerators = Nothing}


-- | A list of the type and count of accelerator cards attached to the
-- instance.
ismrrGuestAccelerators :: Lens' InstancesSetMachineResourcesRequest [AcceleratorConfig]
ismrrGuestAccelerators
  = lens _ismrrGuestAccelerators
      (\ s a -> s{_ismrrGuestAccelerators = a})
      . _Default
      . _Coerce

instance FromJSON InstancesSetMachineResourcesRequest
         where
        parseJSON
          = withObject "InstancesSetMachineResourcesRequest"
              (\ o ->
                 InstancesSetMachineResourcesRequest' <$>
                   (o .:? "guestAccelerators" .!= mempty))

instance ToJSON InstancesSetMachineResourcesRequest
         where
        toJSON InstancesSetMachineResourcesRequest'{..}
          = object
              (catMaybes
                 [("guestAccelerators" .=) <$>
                    _ismrrGuestAccelerators])

--
-- /See:/ 'exchangedPeeringRoutesList' smart constructor.
data ExchangedPeeringRoutesList =
  ExchangedPeeringRoutesList'
    { _eprlNextPageToken :: !(Maybe Text)
    , _eprlKind :: !Text
    , _eprlItems :: !(Maybe [ExchangedPeeringRoute])
    , _eprlSelfLink :: !(Maybe Text)
    , _eprlWarning :: !(Maybe ExchangedPeeringRoutesListWarning)
    , _eprlId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ExchangedPeeringRoutesList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'eprlNextPageToken'
--
-- * 'eprlKind'
--
-- * 'eprlItems'
--
-- * 'eprlSelfLink'
--
-- * 'eprlWarning'
--
-- * 'eprlId'
exchangedPeeringRoutesList
    :: ExchangedPeeringRoutesList
exchangedPeeringRoutesList =
  ExchangedPeeringRoutesList'
    { _eprlNextPageToken = Nothing
    , _eprlKind = "compute#exchangedPeeringRoutesList"
    , _eprlItems = Nothing
    , _eprlSelfLink = Nothing
    , _eprlWarning = Nothing
    , _eprlId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
eprlNextPageToken :: Lens' ExchangedPeeringRoutesList (Maybe Text)
eprlNextPageToken
  = lens _eprlNextPageToken
      (\ s a -> s{_eprlNextPageToken = a})

-- | [Output Only] Type of resource. Always
-- compute#exchangedPeeringRoutesList for exchanged peering routes lists.
eprlKind :: Lens' ExchangedPeeringRoutesList Text
eprlKind = lens _eprlKind (\ s a -> s{_eprlKind = a})

-- | A list of ExchangedPeeringRoute resources.
eprlItems :: Lens' ExchangedPeeringRoutesList [ExchangedPeeringRoute]
eprlItems
  = lens _eprlItems (\ s a -> s{_eprlItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
eprlSelfLink :: Lens' ExchangedPeeringRoutesList (Maybe Text)
eprlSelfLink
  = lens _eprlSelfLink (\ s a -> s{_eprlSelfLink = a})

-- | [Output Only] Informational warning message.
eprlWarning :: Lens' ExchangedPeeringRoutesList (Maybe ExchangedPeeringRoutesListWarning)
eprlWarning
  = lens _eprlWarning (\ s a -> s{_eprlWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
eprlId :: Lens' ExchangedPeeringRoutesList (Maybe Text)
eprlId = lens _eprlId (\ s a -> s{_eprlId = a})

instance FromJSON ExchangedPeeringRoutesList where
        parseJSON
          = withObject "ExchangedPeeringRoutesList"
              (\ o ->
                 ExchangedPeeringRoutesList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!=
                        "compute#exchangedPeeringRoutesList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON ExchangedPeeringRoutesList where
        toJSON ExchangedPeeringRoutesList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _eprlNextPageToken,
                  Just ("kind" .= _eprlKind),
                  ("items" .=) <$> _eprlItems,
                  ("selfLink" .=) <$> _eprlSelfLink,
                  ("warning" .=) <$> _eprlWarning,
                  ("id" .=) <$> _eprlId])

--
-- /See:/ 'instancesSetServiceAccountRequest' smart constructor.
data InstancesSetServiceAccountRequest =
  InstancesSetServiceAccountRequest'
    { _issarEmail :: !(Maybe Text)
    , _issarScopes :: !(Maybe [Text])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstancesSetServiceAccountRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'issarEmail'
--
-- * 'issarScopes'
instancesSetServiceAccountRequest
    :: InstancesSetServiceAccountRequest
instancesSetServiceAccountRequest =
  InstancesSetServiceAccountRequest'
    {_issarEmail = Nothing, _issarScopes = Nothing}


-- | Email address of the service account.
issarEmail :: Lens' InstancesSetServiceAccountRequest (Maybe Text)
issarEmail
  = lens _issarEmail (\ s a -> s{_issarEmail = a})

-- | The list of scopes to be made available for this service account.
issarScopes :: Lens' InstancesSetServiceAccountRequest [Text]
issarScopes
  = lens _issarScopes (\ s a -> s{_issarScopes = a}) .
      _Default
      . _Coerce

instance FromJSON InstancesSetServiceAccountRequest
         where
        parseJSON
          = withObject "InstancesSetServiceAccountRequest"
              (\ o ->
                 InstancesSetServiceAccountRequest' <$>
                   (o .:? "email") <*> (o .:? "scopes" .!= mempty))

instance ToJSON InstancesSetServiceAccountRequest
         where
        toJSON InstancesSetServiceAccountRequest'{..}
          = object
              (catMaybes
                 [("email" .=) <$> _issarEmail,
                  ("scopes" .=) <$> _issarScopes])

--
-- /See:/ 'securityPolicyReference' smart constructor.
newtype SecurityPolicyReference =
  SecurityPolicyReference'
    { _sprSecurityPolicy :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SecurityPolicyReference' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sprSecurityPolicy'
securityPolicyReference
    :: SecurityPolicyReference
securityPolicyReference =
  SecurityPolicyReference' {_sprSecurityPolicy = Nothing}


sprSecurityPolicy :: Lens' SecurityPolicyReference (Maybe Text)
sprSecurityPolicy
  = lens _sprSecurityPolicy
      (\ s a -> s{_sprSecurityPolicy = a})

instance FromJSON SecurityPolicyReference where
        parseJSON
          = withObject "SecurityPolicyReference"
              (\ o ->
                 SecurityPolicyReference' <$>
                   (o .:? "securityPolicy"))

instance ToJSON SecurityPolicyReference where
        toJSON SecurityPolicyReference'{..}
          = object
              (catMaybes
                 [("securityPolicy" .=) <$> _sprSecurityPolicy])

--
-- /See:/ 'diskTypesScopedListWarningDataItem' smart constructor.
data DiskTypesScopedListWarningDataItem =
  DiskTypesScopedListWarningDataItem'
    { _dtslwdiValue :: !(Maybe Text)
    , _dtslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DiskTypesScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dtslwdiValue'
--
-- * 'dtslwdiKey'
diskTypesScopedListWarningDataItem
    :: DiskTypesScopedListWarningDataItem
diskTypesScopedListWarningDataItem =
  DiskTypesScopedListWarningDataItem'
    {_dtslwdiValue = Nothing, _dtslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
dtslwdiValue :: Lens' DiskTypesScopedListWarningDataItem (Maybe Text)
dtslwdiValue
  = lens _dtslwdiValue (\ s a -> s{_dtslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
dtslwdiKey :: Lens' DiskTypesScopedListWarningDataItem (Maybe Text)
dtslwdiKey
  = lens _dtslwdiKey (\ s a -> s{_dtslwdiKey = a})

instance FromJSON DiskTypesScopedListWarningDataItem
         where
        parseJSON
          = withObject "DiskTypesScopedListWarningDataItem"
              (\ o ->
                 DiskTypesScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON DiskTypesScopedListWarningDataItem
         where
        toJSON DiskTypesScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _dtslwdiValue,
                  ("key" .=) <$> _dtslwdiKey])

-- | This reservation type allows to pre allocate specific instance
-- configuration.
--
-- /See:/ 'allocationSpecificSKUReservation' smart constructor.
data AllocationSpecificSKUReservation =
  AllocationSpecificSKUReservation'
    { _asskurInUseCount :: !(Maybe (Textual Int64))
    , _asskurInstanceProperties :: !(Maybe AllocationSpecificSKUAllocationReservedInstanceProperties)
    , _asskurCount :: !(Maybe (Textual Int64))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AllocationSpecificSKUReservation' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'asskurInUseCount'
--
-- * 'asskurInstanceProperties'
--
-- * 'asskurCount'
allocationSpecificSKUReservation
    :: AllocationSpecificSKUReservation
allocationSpecificSKUReservation =
  AllocationSpecificSKUReservation'
    { _asskurInUseCount = Nothing
    , _asskurInstanceProperties = Nothing
    , _asskurCount = Nothing
    }


-- | [Output Only] Indicates how many instances are in use.
asskurInUseCount :: Lens' AllocationSpecificSKUReservation (Maybe Int64)
asskurInUseCount
  = lens _asskurInUseCount
      (\ s a -> s{_asskurInUseCount = a})
      . mapping _Coerce

-- | The instance properties for the reservation.
asskurInstanceProperties :: Lens' AllocationSpecificSKUReservation (Maybe AllocationSpecificSKUAllocationReservedInstanceProperties)
asskurInstanceProperties
  = lens _asskurInstanceProperties
      (\ s a -> s{_asskurInstanceProperties = a})

-- | Specifies the number of resources that are allocated.
asskurCount :: Lens' AllocationSpecificSKUReservation (Maybe Int64)
asskurCount
  = lens _asskurCount (\ s a -> s{_asskurCount = a}) .
      mapping _Coerce

instance FromJSON AllocationSpecificSKUReservation
         where
        parseJSON
          = withObject "AllocationSpecificSKUReservation"
              (\ o ->
                 AllocationSpecificSKUReservation' <$>
                   (o .:? "inUseCount") <*> (o .:? "instanceProperties")
                     <*> (o .:? "count"))

instance ToJSON AllocationSpecificSKUReservation
         where
        toJSON AllocationSpecificSKUReservation'{..}
          = object
              (catMaybes
                 [("inUseCount" .=) <$> _asskurInUseCount,
                  ("instanceProperties" .=) <$>
                    _asskurInstanceProperties,
                  ("count" .=) <$> _asskurCount])

-- | Contain information of Nat mapping for an interface of this endpoint.
--
-- /See:/ 'vMEndpointNATMAppingsInterfaceNATMAppings' smart constructor.
data VMEndpointNATMAppingsInterfaceNATMAppings =
  VMEndpointNATMAppingsInterfaceNATMAppings'
    { _vmenatmainatmaDrainNATIPPortRanges :: !(Maybe [Text])
    , _vmenatmainatmaSourceAliasIPRange :: !(Maybe Text)
    , _vmenatmainatmaNumTotalDrainNATPorts :: !(Maybe (Textual Int32))
    , _vmenatmainatmaSourceVirtualIP :: !(Maybe Text)
    , _vmenatmainatmaNATIPPortRanges :: !(Maybe [Text])
    , _vmenatmainatmaNumTotalNATPorts :: !(Maybe (Textual Int32))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VMEndpointNATMAppingsInterfaceNATMAppings' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vmenatmainatmaDrainNATIPPortRanges'
--
-- * 'vmenatmainatmaSourceAliasIPRange'
--
-- * 'vmenatmainatmaNumTotalDrainNATPorts'
--
-- * 'vmenatmainatmaSourceVirtualIP'
--
-- * 'vmenatmainatmaNATIPPortRanges'
--
-- * 'vmenatmainatmaNumTotalNATPorts'
vMEndpointNATMAppingsInterfaceNATMAppings
    :: VMEndpointNATMAppingsInterfaceNATMAppings
vMEndpointNATMAppingsInterfaceNATMAppings =
  VMEndpointNATMAppingsInterfaceNATMAppings'
    { _vmenatmainatmaDrainNATIPPortRanges = Nothing
    , _vmenatmainatmaSourceAliasIPRange = Nothing
    , _vmenatmainatmaNumTotalDrainNATPorts = Nothing
    , _vmenatmainatmaSourceVirtualIP = Nothing
    , _vmenatmainatmaNATIPPortRanges = Nothing
    , _vmenatmainatmaNumTotalNATPorts = Nothing
    }


-- | List of all drain IP:port-range mappings assigned to this interface.
-- These ranges are inclusive, that is, both the first and the last ports
-- can be used for NAT. Example: [\"2.2.2.2:12345-12355\",
-- \"1.1.1.1:2234-2234\"].
vmenatmainatmaDrainNATIPPortRanges :: Lens' VMEndpointNATMAppingsInterfaceNATMAppings [Text]
vmenatmainatmaDrainNATIPPortRanges
  = lens _vmenatmainatmaDrainNATIPPortRanges
      (\ s a -> s{_vmenatmainatmaDrainNATIPPortRanges = a})
      . _Default
      . _Coerce

-- | Alias IP range for this interface endpoint. It will be a private (RFC
-- 1918) IP range. Examples: \"10.33.4.55\/32\", or \"192.168.5.0\/24\".
vmenatmainatmaSourceAliasIPRange :: Lens' VMEndpointNATMAppingsInterfaceNATMAppings (Maybe Text)
vmenatmainatmaSourceAliasIPRange
  = lens _vmenatmainatmaSourceAliasIPRange
      (\ s a -> s{_vmenatmainatmaSourceAliasIPRange = a})

-- | Total number of drain ports across all NAT IPs allocated to this
-- interface. It equals to the aggregated port number in the field
-- drain_nat_ip_port_ranges.
vmenatmainatmaNumTotalDrainNATPorts :: Lens' VMEndpointNATMAppingsInterfaceNATMAppings (Maybe Int32)
vmenatmainatmaNumTotalDrainNATPorts
  = lens _vmenatmainatmaNumTotalDrainNATPorts
      (\ s a ->
         s{_vmenatmainatmaNumTotalDrainNATPorts = a})
      . mapping _Coerce

-- | Primary IP of the VM for this NIC.
vmenatmainatmaSourceVirtualIP :: Lens' VMEndpointNATMAppingsInterfaceNATMAppings (Maybe Text)
vmenatmainatmaSourceVirtualIP
  = lens _vmenatmainatmaSourceVirtualIP
      (\ s a -> s{_vmenatmainatmaSourceVirtualIP = a})

-- | A list of all IP:port-range mappings assigned to this interface. These
-- ranges are inclusive, that is, both the first and the last ports can be
-- used for NAT. Example: [\"2.2.2.2:12345-12355\", \"1.1.1.1:2234-2234\"].
vmenatmainatmaNATIPPortRanges :: Lens' VMEndpointNATMAppingsInterfaceNATMAppings [Text]
vmenatmainatmaNATIPPortRanges
  = lens _vmenatmainatmaNATIPPortRanges
      (\ s a -> s{_vmenatmainatmaNATIPPortRanges = a})
      . _Default
      . _Coerce

-- | Total number of ports across all NAT IPs allocated to this interface. It
-- equals to the aggregated port number in the field nat_ip_port_ranges.
vmenatmainatmaNumTotalNATPorts :: Lens' VMEndpointNATMAppingsInterfaceNATMAppings (Maybe Int32)
vmenatmainatmaNumTotalNATPorts
  = lens _vmenatmainatmaNumTotalNATPorts
      (\ s a -> s{_vmenatmainatmaNumTotalNATPorts = a})
      . mapping _Coerce

instance FromJSON
           VMEndpointNATMAppingsInterfaceNATMAppings
         where
        parseJSON
          = withObject
              "VMEndpointNATMAppingsInterfaceNATMAppings"
              (\ o ->
                 VMEndpointNATMAppingsInterfaceNATMAppings' <$>
                   (o .:? "drainNatIpPortRanges" .!= mempty) <*>
                     (o .:? "sourceAliasIpRange")
                     <*> (o .:? "numTotalDrainNatPorts")
                     <*> (o .:? "sourceVirtualIp")
                     <*> (o .:? "natIpPortRanges" .!= mempty)
                     <*> (o .:? "numTotalNatPorts"))

instance ToJSON
           VMEndpointNATMAppingsInterfaceNATMAppings
         where
        toJSON VMEndpointNATMAppingsInterfaceNATMAppings'{..}
          = object
              (catMaybes
                 [("drainNatIpPortRanges" .=) <$>
                    _vmenatmainatmaDrainNATIPPortRanges,
                  ("sourceAliasIpRange" .=) <$>
                    _vmenatmainatmaSourceAliasIPRange,
                  ("numTotalDrainNatPorts" .=) <$>
                    _vmenatmainatmaNumTotalDrainNATPorts,
                  ("sourceVirtualIp" .=) <$>
                    _vmenatmainatmaSourceVirtualIP,
                  ("natIpPortRanges" .=) <$>
                    _vmenatmainatmaNATIPPortRanges,
                  ("numTotalNatPorts" .=) <$>
                    _vmenatmainatmaNumTotalNATPorts])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'vpnTunnelAggregatedListWarning' smart constructor.
data VPNTunnelAggregatedListWarning =
  VPNTunnelAggregatedListWarning'
    { _vtalwData :: !(Maybe [VPNTunnelAggregatedListWarningDataItem])
    , _vtalwCode :: !(Maybe VPNTunnelAggregatedListWarningCode)
    , _vtalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNTunnelAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vtalwData'
--
-- * 'vtalwCode'
--
-- * 'vtalwMessage'
vpnTunnelAggregatedListWarning
    :: VPNTunnelAggregatedListWarning
vpnTunnelAggregatedListWarning =
  VPNTunnelAggregatedListWarning'
    {_vtalwData = Nothing, _vtalwCode = Nothing, _vtalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
vtalwData :: Lens' VPNTunnelAggregatedListWarning [VPNTunnelAggregatedListWarningDataItem]
vtalwData
  = lens _vtalwData (\ s a -> s{_vtalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
vtalwCode :: Lens' VPNTunnelAggregatedListWarning (Maybe VPNTunnelAggregatedListWarningCode)
vtalwCode
  = lens _vtalwCode (\ s a -> s{_vtalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
vtalwMessage :: Lens' VPNTunnelAggregatedListWarning (Maybe Text)
vtalwMessage
  = lens _vtalwMessage (\ s a -> s{_vtalwMessage = a})

instance FromJSON VPNTunnelAggregatedListWarning
         where
        parseJSON
          = withObject "VPNTunnelAggregatedListWarning"
              (\ o ->
                 VPNTunnelAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON VPNTunnelAggregatedListWarning where
        toJSON VPNTunnelAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _vtalwData,
                  ("code" .=) <$> _vtalwCode,
                  ("message" .=) <$> _vtalwMessage])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'instanceGroupManagersListPerInstanceConfigsRespWarning' smart constructor.
data InstanceGroupManagersListPerInstanceConfigsRespWarning =
  InstanceGroupManagersListPerInstanceConfigsRespWarning'
    { _igmlpicrwData :: !(Maybe [InstanceGroupManagersListPerInstanceConfigsRespWarningDataItem])
    , _igmlpicrwCode :: !(Maybe InstanceGroupManagersListPerInstanceConfigsRespWarningCode)
    , _igmlpicrwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagersListPerInstanceConfigsRespWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmlpicrwData'
--
-- * 'igmlpicrwCode'
--
-- * 'igmlpicrwMessage'
instanceGroupManagersListPerInstanceConfigsRespWarning
    :: InstanceGroupManagersListPerInstanceConfigsRespWarning
instanceGroupManagersListPerInstanceConfigsRespWarning =
  InstanceGroupManagersListPerInstanceConfigsRespWarning'
    { _igmlpicrwData = Nothing
    , _igmlpicrwCode = Nothing
    , _igmlpicrwMessage = Nothing
    }


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
igmlpicrwData :: Lens' InstanceGroupManagersListPerInstanceConfigsRespWarning [InstanceGroupManagersListPerInstanceConfigsRespWarningDataItem]
igmlpicrwData
  = lens _igmlpicrwData
      (\ s a -> s{_igmlpicrwData = a})
      . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
igmlpicrwCode :: Lens' InstanceGroupManagersListPerInstanceConfigsRespWarning (Maybe InstanceGroupManagersListPerInstanceConfigsRespWarningCode)
igmlpicrwCode
  = lens _igmlpicrwCode
      (\ s a -> s{_igmlpicrwCode = a})

-- | [Output Only] A human-readable description of the warning code.
igmlpicrwMessage :: Lens' InstanceGroupManagersListPerInstanceConfigsRespWarning (Maybe Text)
igmlpicrwMessage
  = lens _igmlpicrwMessage
      (\ s a -> s{_igmlpicrwMessage = a})

instance FromJSON
           InstanceGroupManagersListPerInstanceConfigsRespWarning
         where
        parseJSON
          = withObject
              "InstanceGroupManagersListPerInstanceConfigsRespWarning"
              (\ o ->
                 InstanceGroupManagersListPerInstanceConfigsRespWarning'
                   <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON
           InstanceGroupManagersListPerInstanceConfigsRespWarning
         where
        toJSON
          InstanceGroupManagersListPerInstanceConfigsRespWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _igmlpicrwData,
                  ("code" .=) <$> _igmlpicrwCode,
                  ("message" .=) <$> _igmlpicrwMessage])

-- | Represents a Target HTTP Proxy resource. Google Compute Engine has two
-- Target HTTP Proxy resources: *
-- [Global](\/compute\/docs\/reference\/rest\/{$api_version}\/targetHttpProxies)
-- *
-- [Regional](\/compute\/docs\/reference\/rest\/{$api_version}\/regionTargetHttpProxies)
-- A target HTTP proxy is a component of GCP HTTP load balancers. *
-- targetHttpProxies are used by external HTTP load balancers and Traffic
-- Director. * regionTargetHttpProxies are used by internal HTTP load
-- balancers. Forwarding rules reference a target HTTP proxy, and the
-- target proxy then references a URL map. For more information, read Using
-- Target Proxies and Forwarding rule concepts. (== resource_for
-- {$api_version}.targetHttpProxies ==) (== resource_for
-- {$api_version}.regionTargetHttpProxies ==)
--
-- /See:/ 'targetHTTPProxy' smart constructor.
data TargetHTTPProxy =
  TargetHTTPProxy'
    { _thttppURLMap :: !(Maybe Text)
    , _thttppProxyBind :: !(Maybe Bool)
    , _thttppKind :: !Text
    , _thttppFingerprint :: !(Maybe Bytes)
    , _thttppSelfLink :: !(Maybe Text)
    , _thttppName :: !(Maybe Text)
    , _thttppCreationTimestamp :: !(Maybe Text)
    , _thttppId :: !(Maybe (Textual Word64))
    , _thttppRegion :: !(Maybe Text)
    , _thttppDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetHTTPProxy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'thttppURLMap'
--
-- * 'thttppProxyBind'
--
-- * 'thttppKind'
--
-- * 'thttppFingerprint'
--
-- * 'thttppSelfLink'
--
-- * 'thttppName'
--
-- * 'thttppCreationTimestamp'
--
-- * 'thttppId'
--
-- * 'thttppRegion'
--
-- * 'thttppDescription'
targetHTTPProxy
    :: TargetHTTPProxy
targetHTTPProxy =
  TargetHTTPProxy'
    { _thttppURLMap = Nothing
    , _thttppProxyBind = Nothing
    , _thttppKind = "compute#targetHttpProxy"
    , _thttppFingerprint = Nothing
    , _thttppSelfLink = Nothing
    , _thttppName = Nothing
    , _thttppCreationTimestamp = Nothing
    , _thttppId = Nothing
    , _thttppRegion = Nothing
    , _thttppDescription = Nothing
    }


-- | URL to the UrlMap resource that defines the mapping from URL to the
-- BackendService.
thttppURLMap :: Lens' TargetHTTPProxy (Maybe Text)
thttppURLMap
  = lens _thttppURLMap (\ s a -> s{_thttppURLMap = a})

-- | This field only applies when the forwarding rule that references this
-- target proxy has a loadBalancingScheme set to INTERNAL_SELF_MANAGED.
-- When this field is set to true, Envoy proxies set up inbound traffic
-- interception and bind to the IP address and port specified in the
-- forwarding rule. This is generally useful when using Traffic Director to
-- configure Envoy as a gateway or middle proxy (in other words, not a
-- sidecar proxy). The Envoy proxy listens for inbound requests and handles
-- requests when it receives them. The default is false.
thttppProxyBind :: Lens' TargetHTTPProxy (Maybe Bool)
thttppProxyBind
  = lens _thttppProxyBind
      (\ s a -> s{_thttppProxyBind = a})

-- | [Output Only] Type of resource. Always compute#targetHttpProxy for
-- target HTTP proxies.
thttppKind :: Lens' TargetHTTPProxy Text
thttppKind
  = lens _thttppKind (\ s a -> s{_thttppKind = a})

-- | Fingerprint of this resource. A hash of the contents stored in this
-- object. This field is used in optimistic locking. This field will be
-- ignored when inserting a TargetHttpProxy. An up-to-date fingerprint must
-- be provided in order to patch\/update the TargetHttpProxy; otherwise,
-- the request will fail with error 412 conditionNotMet. To see the latest
-- fingerprint, make a get() request to retrieve the TargetHttpProxy.
thttppFingerprint :: Lens' TargetHTTPProxy (Maybe ByteString)
thttppFingerprint
  = lens _thttppFingerprint
      (\ s a -> s{_thttppFingerprint = a})
      . mapping _Bytes

-- | [Output Only] Server-defined URL for the resource.
thttppSelfLink :: Lens' TargetHTTPProxy (Maybe Text)
thttppSelfLink
  = lens _thttppSelfLink
      (\ s a -> s{_thttppSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
thttppName :: Lens' TargetHTTPProxy (Maybe Text)
thttppName
  = lens _thttppName (\ s a -> s{_thttppName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
thttppCreationTimestamp :: Lens' TargetHTTPProxy (Maybe Text)
thttppCreationTimestamp
  = lens _thttppCreationTimestamp
      (\ s a -> s{_thttppCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
thttppId :: Lens' TargetHTTPProxy (Maybe Word64)
thttppId
  = lens _thttppId (\ s a -> s{_thttppId = a}) .
      mapping _Coerce

-- | [Output Only] URL of the region where the regional Target HTTP Proxy
-- resides. This field is not applicable to global Target HTTP Proxies.
thttppRegion :: Lens' TargetHTTPProxy (Maybe Text)
thttppRegion
  = lens _thttppRegion (\ s a -> s{_thttppRegion = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource.
thttppDescription :: Lens' TargetHTTPProxy (Maybe Text)
thttppDescription
  = lens _thttppDescription
      (\ s a -> s{_thttppDescription = a})

instance FromJSON TargetHTTPProxy where
        parseJSON
          = withObject "TargetHTTPProxy"
              (\ o ->
                 TargetHTTPProxy' <$>
                   (o .:? "urlMap") <*> (o .:? "proxyBind") <*>
                     (o .:? "kind" .!= "compute#targetHttpProxy")
                     <*> (o .:? "fingerprint")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "region")
                     <*> (o .:? "description"))

instance ToJSON TargetHTTPProxy where
        toJSON TargetHTTPProxy'{..}
          = object
              (catMaybes
                 [("urlMap" .=) <$> _thttppURLMap,
                  ("proxyBind" .=) <$> _thttppProxyBind,
                  Just ("kind" .= _thttppKind),
                  ("fingerprint" .=) <$> _thttppFingerprint,
                  ("selfLink" .=) <$> _thttppSelfLink,
                  ("name" .=) <$> _thttppName,
                  ("creationTimestamp" .=) <$>
                    _thttppCreationTimestamp,
                  ("id" .=) <$> _thttppId,
                  ("region" .=) <$> _thttppRegion,
                  ("description" .=) <$> _thttppDescription])

-- | A set of Shielded Instance options.
--
-- /See:/ 'shieldedInstanceConfig' smart constructor.
data ShieldedInstanceConfig =
  ShieldedInstanceConfig'
    { _sicEnableVtpm :: !(Maybe Bool)
    , _sicEnableIntegrityMonitoring :: !(Maybe Bool)
    , _sicEnableSecureBoot :: !(Maybe Bool)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ShieldedInstanceConfig' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sicEnableVtpm'
--
-- * 'sicEnableIntegrityMonitoring'
--
-- * 'sicEnableSecureBoot'
shieldedInstanceConfig
    :: ShieldedInstanceConfig
shieldedInstanceConfig =
  ShieldedInstanceConfig'
    { _sicEnableVtpm = Nothing
    , _sicEnableIntegrityMonitoring = Nothing
    , _sicEnableSecureBoot = Nothing
    }


-- | Defines whether the instance has the vTPM enabled. Enabled by default.
sicEnableVtpm :: Lens' ShieldedInstanceConfig (Maybe Bool)
sicEnableVtpm
  = lens _sicEnableVtpm
      (\ s a -> s{_sicEnableVtpm = a})

-- | Defines whether the instance has integrity monitoring enabled. Enabled
-- by default.
sicEnableIntegrityMonitoring :: Lens' ShieldedInstanceConfig (Maybe Bool)
sicEnableIntegrityMonitoring
  = lens _sicEnableIntegrityMonitoring
      (\ s a -> s{_sicEnableIntegrityMonitoring = a})

-- | Defines whether the instance has Secure Boot enabled. Disabled by
-- default.
sicEnableSecureBoot :: Lens' ShieldedInstanceConfig (Maybe Bool)
sicEnableSecureBoot
  = lens _sicEnableSecureBoot
      (\ s a -> s{_sicEnableSecureBoot = a})

instance FromJSON ShieldedInstanceConfig where
        parseJSON
          = withObject "ShieldedInstanceConfig"
              (\ o ->
                 ShieldedInstanceConfig' <$>
                   (o .:? "enableVtpm") <*>
                     (o .:? "enableIntegrityMonitoring")
                     <*> (o .:? "enableSecureBoot"))

instance ToJSON ShieldedInstanceConfig where
        toJSON ShieldedInstanceConfig'{..}
          = object
              (catMaybes
                 [("enableVtpm" .=) <$> _sicEnableVtpm,
                  ("enableIntegrityMonitoring" .=) <$>
                    _sicEnableIntegrityMonitoring,
                  ("enableSecureBoot" .=) <$> _sicEnableSecureBoot])

-- | Represents a Machine Type resource. You can use specific machine types
-- for your VM instances based on performance and pricing requirements. For
-- more information, read Machine Types. (== resource_for
-- {$api_version}.machineTypes ==)
--
-- /See:/ 'machineType' smart constructor.
data MachineType =
  MachineType'
    { _mtIsSharedCPU :: !(Maybe Bool)
    , _mtKind :: !Text
    , _mtImageSpaceGb :: !(Maybe (Textual Int32))
    , _mtZone :: !(Maybe Text)
    , _mtSelfLink :: !(Maybe Text)
    , _mtAccelerators :: !(Maybe [MachineTypeAcceleratorsItem])
    , _mtName :: !(Maybe Text)
    , _mtCreationTimestamp :: !(Maybe Text)
    , _mtScratchDisks :: !(Maybe [MachineTypeScratchDisksItem])
    , _mtId :: !(Maybe (Textual Word64))
    , _mtGuestCPUs :: !(Maybe (Textual Int32))
    , _mtMaximumPersistentDisksSizeGb :: !(Maybe (Textual Int64))
    , _mtMaximumPersistentDisks :: !(Maybe (Textual Int32))
    , _mtMemoryMb :: !(Maybe (Textual Int32))
    , _mtDescription :: !(Maybe Text)
    , _mtDeprecated :: !(Maybe DeprecationStatus)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'MachineType' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'mtIsSharedCPU'
--
-- * 'mtKind'
--
-- * 'mtImageSpaceGb'
--
-- * 'mtZone'
--
-- * 'mtSelfLink'
--
-- * 'mtAccelerators'
--
-- * 'mtName'
--
-- * 'mtCreationTimestamp'
--
-- * 'mtScratchDisks'
--
-- * 'mtId'
--
-- * 'mtGuestCPUs'
--
-- * 'mtMaximumPersistentDisksSizeGb'
--
-- * 'mtMaximumPersistentDisks'
--
-- * 'mtMemoryMb'
--
-- * 'mtDescription'
--
-- * 'mtDeprecated'
machineType
    :: MachineType
machineType =
  MachineType'
    { _mtIsSharedCPU = Nothing
    , _mtKind = "compute#machineType"
    , _mtImageSpaceGb = Nothing
    , _mtZone = Nothing
    , _mtSelfLink = Nothing
    , _mtAccelerators = Nothing
    , _mtName = Nothing
    , _mtCreationTimestamp = Nothing
    , _mtScratchDisks = Nothing
    , _mtId = Nothing
    , _mtGuestCPUs = Nothing
    , _mtMaximumPersistentDisksSizeGb = Nothing
    , _mtMaximumPersistentDisks = Nothing
    , _mtMemoryMb = Nothing
    , _mtDescription = Nothing
    , _mtDeprecated = Nothing
    }


-- | [Output Only] Whether this machine type has a shared CPU. See
-- Shared-core machine types for more information.
mtIsSharedCPU :: Lens' MachineType (Maybe Bool)
mtIsSharedCPU
  = lens _mtIsSharedCPU
      (\ s a -> s{_mtIsSharedCPU = a})

-- | [Output Only] The type of the resource. Always compute#machineType for
-- machine types.
mtKind :: Lens' MachineType Text
mtKind = lens _mtKind (\ s a -> s{_mtKind = a})

-- | [Deprecated] This property is deprecated and will never be populated
-- with any relevant values.
mtImageSpaceGb :: Lens' MachineType (Maybe Int32)
mtImageSpaceGb
  = lens _mtImageSpaceGb
      (\ s a -> s{_mtImageSpaceGb = a})
      . mapping _Coerce

-- | [Output Only] The name of the zone where the machine type resides, such
-- as us-central1-a.
mtZone :: Lens' MachineType (Maybe Text)
mtZone = lens _mtZone (\ s a -> s{_mtZone = a})

-- | [Output Only] Server-defined URL for the resource.
mtSelfLink :: Lens' MachineType (Maybe Text)
mtSelfLink
  = lens _mtSelfLink (\ s a -> s{_mtSelfLink = a})

-- | [Output Only] A list of accelerator configurations assigned to this
-- machine type.
mtAccelerators :: Lens' MachineType [MachineTypeAcceleratorsItem]
mtAccelerators
  = lens _mtAccelerators
      (\ s a -> s{_mtAccelerators = a})
      . _Default
      . _Coerce

-- | [Output Only] Name of the resource.
mtName :: Lens' MachineType (Maybe Text)
mtName = lens _mtName (\ s a -> s{_mtName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
mtCreationTimestamp :: Lens' MachineType (Maybe Text)
mtCreationTimestamp
  = lens _mtCreationTimestamp
      (\ s a -> s{_mtCreationTimestamp = a})

-- | [Output Only] A list of extended scratch disks assigned to the instance.
mtScratchDisks :: Lens' MachineType [MachineTypeScratchDisksItem]
mtScratchDisks
  = lens _mtScratchDisks
      (\ s a -> s{_mtScratchDisks = a})
      . _Default
      . _Coerce

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
mtId :: Lens' MachineType (Maybe Word64)
mtId
  = lens _mtId (\ s a -> s{_mtId = a}) .
      mapping _Coerce

-- | [Output Only] The number of virtual CPUs that are available to the
-- instance.
mtGuestCPUs :: Lens' MachineType (Maybe Int32)
mtGuestCPUs
  = lens _mtGuestCPUs (\ s a -> s{_mtGuestCPUs = a}) .
      mapping _Coerce

-- | [Output Only] Maximum total persistent disks size (GB) allowed.
mtMaximumPersistentDisksSizeGb :: Lens' MachineType (Maybe Int64)
mtMaximumPersistentDisksSizeGb
  = lens _mtMaximumPersistentDisksSizeGb
      (\ s a -> s{_mtMaximumPersistentDisksSizeGb = a})
      . mapping _Coerce

-- | [Output Only] Maximum persistent disks allowed.
mtMaximumPersistentDisks :: Lens' MachineType (Maybe Int32)
mtMaximumPersistentDisks
  = lens _mtMaximumPersistentDisks
      (\ s a -> s{_mtMaximumPersistentDisks = a})
      . mapping _Coerce

-- | [Output Only] The amount of physical memory available to the instance,
-- defined in MB.
mtMemoryMb :: Lens' MachineType (Maybe Int32)
mtMemoryMb
  = lens _mtMemoryMb (\ s a -> s{_mtMemoryMb = a}) .
      mapping _Coerce

-- | [Output Only] An optional textual description of the resource.
mtDescription :: Lens' MachineType (Maybe Text)
mtDescription
  = lens _mtDescription
      (\ s a -> s{_mtDescription = a})

-- | [Output Only] The deprecation status associated with this machine type.
-- Only applicable if the machine type is unavailable.
mtDeprecated :: Lens' MachineType (Maybe DeprecationStatus)
mtDeprecated
  = lens _mtDeprecated (\ s a -> s{_mtDeprecated = a})

instance FromJSON MachineType where
        parseJSON
          = withObject "MachineType"
              (\ o ->
                 MachineType' <$>
                   (o .:? "isSharedCpu") <*>
                     (o .:? "kind" .!= "compute#machineType")
                     <*> (o .:? "imageSpaceGb")
                     <*> (o .:? "zone")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "accelerators" .!= mempty)
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "scratchDisks" .!= mempty)
                     <*> (o .:? "id")
                     <*> (o .:? "guestCpus")
                     <*> (o .:? "maximumPersistentDisksSizeGb")
                     <*> (o .:? "maximumPersistentDisks")
                     <*> (o .:? "memoryMb")
                     <*> (o .:? "description")
                     <*> (o .:? "deprecated"))

instance ToJSON MachineType where
        toJSON MachineType'{..}
          = object
              (catMaybes
                 [("isSharedCpu" .=) <$> _mtIsSharedCPU,
                  Just ("kind" .= _mtKind),
                  ("imageSpaceGb" .=) <$> _mtImageSpaceGb,
                  ("zone" .=) <$> _mtZone,
                  ("selfLink" .=) <$> _mtSelfLink,
                  ("accelerators" .=) <$> _mtAccelerators,
                  ("name" .=) <$> _mtName,
                  ("creationTimestamp" .=) <$> _mtCreationTimestamp,
                  ("scratchDisks" .=) <$> _mtScratchDisks,
                  ("id" .=) <$> _mtId,
                  ("guestCpus" .=) <$> _mtGuestCPUs,
                  ("maximumPersistentDisksSizeGb" .=) <$>
                    _mtMaximumPersistentDisksSizeGb,
                  ("maximumPersistentDisks" .=) <$>
                    _mtMaximumPersistentDisks,
                  ("memoryMb" .=) <$> _mtMemoryMb,
                  ("description" .=) <$> _mtDescription,
                  ("deprecated" .=) <$> _mtDeprecated])

-- | A specification of the type and number of accelerator cards attached to
-- the instance.
--
-- /See:/ 'acceleratorConfig' smart constructor.
data AcceleratorConfig =
  AcceleratorConfig'
    { _acAcceleratorCount :: !(Maybe (Textual Int32))
    , _acAcceleratorType :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AcceleratorConfig' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'acAcceleratorCount'
--
-- * 'acAcceleratorType'
acceleratorConfig
    :: AcceleratorConfig
acceleratorConfig =
  AcceleratorConfig'
    {_acAcceleratorCount = Nothing, _acAcceleratorType = Nothing}


-- | The number of the guest accelerator cards exposed to this instance.
acAcceleratorCount :: Lens' AcceleratorConfig (Maybe Int32)
acAcceleratorCount
  = lens _acAcceleratorCount
      (\ s a -> s{_acAcceleratorCount = a})
      . mapping _Coerce

-- | Full or partial URL of the accelerator type resource to attach to this
-- instance. For example:
-- projects\/my-project\/zones\/us-central1-c\/acceleratorTypes\/nvidia-tesla-p100
-- If you are creating an instance template, specify only the accelerator
-- name. See GPUs on Compute Engine for a full list of accelerator types.
acAcceleratorType :: Lens' AcceleratorConfig (Maybe Text)
acAcceleratorType
  = lens _acAcceleratorType
      (\ s a -> s{_acAcceleratorType = a})

instance FromJSON AcceleratorConfig where
        parseJSON
          = withObject "AcceleratorConfig"
              (\ o ->
                 AcceleratorConfig' <$>
                   (o .:? "acceleratorCount") <*>
                     (o .:? "acceleratorType"))

instance ToJSON AcceleratorConfig where
        toJSON AcceleratorConfig'{..}
          = object
              (catMaybes
                 [("acceleratorCount" .=) <$> _acAcceleratorCount,
                  ("acceleratorType" .=) <$> _acAcceleratorType])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'autoscalerListWarning' smart constructor.
data AutoscalerListWarning =
  AutoscalerListWarning'
    { _alwData :: !(Maybe [AutoscalerListWarningDataItem])
    , _alwCode :: !(Maybe AutoscalerListWarningCode)
    , _alwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AutoscalerListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'alwData'
--
-- * 'alwCode'
--
-- * 'alwMessage'
autoscalerListWarning
    :: AutoscalerListWarning
autoscalerListWarning =
  AutoscalerListWarning'
    {_alwData = Nothing, _alwCode = Nothing, _alwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
alwData :: Lens' AutoscalerListWarning [AutoscalerListWarningDataItem]
alwData
  = lens _alwData (\ s a -> s{_alwData = a}) . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
alwCode :: Lens' AutoscalerListWarning (Maybe AutoscalerListWarningCode)
alwCode = lens _alwCode (\ s a -> s{_alwCode = a})

-- | [Output Only] A human-readable description of the warning code.
alwMessage :: Lens' AutoscalerListWarning (Maybe Text)
alwMessage
  = lens _alwMessage (\ s a -> s{_alwMessage = a})

instance FromJSON AutoscalerListWarning where
        parseJSON
          = withObject "AutoscalerListWarning"
              (\ o ->
                 AutoscalerListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON AutoscalerListWarning where
        toJSON AutoscalerListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _alwData, ("code" .=) <$> _alwCode,
                  ("message" .=) <$> _alwMessage])

--
-- /See:/ 'machineTypeAggregatedListWarningDataItem' smart constructor.
data MachineTypeAggregatedListWarningDataItem =
  MachineTypeAggregatedListWarningDataItem'
    { _mtalwdiValue :: !(Maybe Text)
    , _mtalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'MachineTypeAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'mtalwdiValue'
--
-- * 'mtalwdiKey'
machineTypeAggregatedListWarningDataItem
    :: MachineTypeAggregatedListWarningDataItem
machineTypeAggregatedListWarningDataItem =
  MachineTypeAggregatedListWarningDataItem'
    {_mtalwdiValue = Nothing, _mtalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
mtalwdiValue :: Lens' MachineTypeAggregatedListWarningDataItem (Maybe Text)
mtalwdiValue
  = lens _mtalwdiValue (\ s a -> s{_mtalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
mtalwdiKey :: Lens' MachineTypeAggregatedListWarningDataItem (Maybe Text)
mtalwdiKey
  = lens _mtalwdiKey (\ s a -> s{_mtalwdiKey = a})

instance FromJSON
           MachineTypeAggregatedListWarningDataItem
         where
        parseJSON
          = withObject
              "MachineTypeAggregatedListWarningDataItem"
              (\ o ->
                 MachineTypeAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           MachineTypeAggregatedListWarningDataItem
         where
        toJSON MachineTypeAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _mtalwdiValue,
                  ("key" .=) <$> _mtalwdiKey])

-- | [Output Only] If errors are generated during processing of the
-- operation, this field will be populated.
--
-- /See:/ 'operationError' smart constructor.
newtype OperationError =
  OperationError'
    { _oeErrors :: Maybe [OperationErrorErrorsItem]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'OperationError' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'oeErrors'
operationError
    :: OperationError
operationError = OperationError' {_oeErrors = Nothing}


-- | [Output Only] The array of errors encountered while processing this
-- operation.
oeErrors :: Lens' OperationError [OperationErrorErrorsItem]
oeErrors
  = lens _oeErrors (\ s a -> s{_oeErrors = a}) .
      _Default
      . _Coerce

instance FromJSON OperationError where
        parseJSON
          = withObject "OperationError"
              (\ o ->
                 OperationError' <$> (o .:? "errors" .!= mempty))

instance ToJSON OperationError where
        toJSON OperationError'{..}
          = object (catMaybes [("errors" .=) <$> _oeErrors])

-- | Configuration for location policy among multiple possible locations
-- (e.g. preferences for zone selection among zones in a single region).
--
-- /See:/ 'locationPolicy' smart constructor.
newtype LocationPolicy =
  LocationPolicy'
    { _lpLocations :: Maybe LocationPolicyLocations
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'LocationPolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'lpLocations'
locationPolicy
    :: LocationPolicy
locationPolicy = LocationPolicy' {_lpLocations = Nothing}


-- | Location configurations mapped by location name. Currently only zone
-- names are supported and must be represented as valid internal URLs, such
-- as zones\/us-central1-a.
lpLocations :: Lens' LocationPolicy (Maybe LocationPolicyLocations)
lpLocations
  = lens _lpLocations (\ s a -> s{_lpLocations = a})

instance FromJSON LocationPolicy where
        parseJSON
          = withObject "LocationPolicy"
              (\ o -> LocationPolicy' <$> (o .:? "locations"))

instance ToJSON LocationPolicy where
        toJSON LocationPolicy'{..}
          = object
              (catMaybes [("locations" .=) <$> _lpLocations])

-- | HttpRouteRuleMatch criteria for field values that must stay within the
-- specified integer range.
--
-- /See:/ 'int64RangeMatch' smart constructor.
data Int64RangeMatch =
  Int64RangeMatch'
    { _irmRangeStart :: !(Maybe (Textual Int64))
    , _irmRangeEnd :: !(Maybe (Textual Int64))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Int64RangeMatch' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'irmRangeStart'
--
-- * 'irmRangeEnd'
int64RangeMatch
    :: Int64RangeMatch
int64RangeMatch =
  Int64RangeMatch' {_irmRangeStart = Nothing, _irmRangeEnd = Nothing}


-- | The start of the range (inclusive) in signed long integer format.
irmRangeStart :: Lens' Int64RangeMatch (Maybe Int64)
irmRangeStart
  = lens _irmRangeStart
      (\ s a -> s{_irmRangeStart = a})
      . mapping _Coerce

-- | The end of the range (exclusive) in signed long integer format.
irmRangeEnd :: Lens' Int64RangeMatch (Maybe Int64)
irmRangeEnd
  = lens _irmRangeEnd (\ s a -> s{_irmRangeEnd = a}) .
      mapping _Coerce

instance FromJSON Int64RangeMatch where
        parseJSON
          = withObject "Int64RangeMatch"
              (\ o ->
                 Int64RangeMatch' <$>
                   (o .:? "rangeStart") <*> (o .:? "rangeEnd"))

instance ToJSON Int64RangeMatch where
        toJSON Int64RangeMatch'{..}
          = object
              (catMaybes
                 [("rangeStart" .=) <$> _irmRangeStart,
                  ("rangeEnd" .=) <$> _irmRangeEnd])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'nodeTypeAggregatedListWarning' smart constructor.
data NodeTypeAggregatedListWarning =
  NodeTypeAggregatedListWarning'
    { _ntalwtData :: !(Maybe [NodeTypeAggregatedListWarningDataItem])
    , _ntalwtCode :: !(Maybe NodeTypeAggregatedListWarningCode)
    , _ntalwtMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeTypeAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ntalwtData'
--
-- * 'ntalwtCode'
--
-- * 'ntalwtMessage'
nodeTypeAggregatedListWarning
    :: NodeTypeAggregatedListWarning
nodeTypeAggregatedListWarning =
  NodeTypeAggregatedListWarning'
    {_ntalwtData = Nothing, _ntalwtCode = Nothing, _ntalwtMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
ntalwtData :: Lens' NodeTypeAggregatedListWarning [NodeTypeAggregatedListWarningDataItem]
ntalwtData
  = lens _ntalwtData (\ s a -> s{_ntalwtData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
ntalwtCode :: Lens' NodeTypeAggregatedListWarning (Maybe NodeTypeAggregatedListWarningCode)
ntalwtCode
  = lens _ntalwtCode (\ s a -> s{_ntalwtCode = a})

-- | [Output Only] A human-readable description of the warning code.
ntalwtMessage :: Lens' NodeTypeAggregatedListWarning (Maybe Text)
ntalwtMessage
  = lens _ntalwtMessage
      (\ s a -> s{_ntalwtMessage = a})

instance FromJSON NodeTypeAggregatedListWarning where
        parseJSON
          = withObject "NodeTypeAggregatedListWarning"
              (\ o ->
                 NodeTypeAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON NodeTypeAggregatedListWarning where
        toJSON NodeTypeAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _ntalwtData,
                  ("code" .=) <$> _ntalwtCode,
                  ("message" .=) <$> _ntalwtMessage])

-- | Informational warning which replaces the list of addresses when the list
-- is empty.
--
-- /See:/ 'targetInstancesScopedListWarning' smart constructor.
data TargetInstancesScopedListWarning =
  TargetInstancesScopedListWarning'
    { _tislwData :: !(Maybe [TargetInstancesScopedListWarningDataItem])
    , _tislwCode :: !(Maybe TargetInstancesScopedListWarningCode)
    , _tislwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetInstancesScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tislwData'
--
-- * 'tislwCode'
--
-- * 'tislwMessage'
targetInstancesScopedListWarning
    :: TargetInstancesScopedListWarning
targetInstancesScopedListWarning =
  TargetInstancesScopedListWarning'
    {_tislwData = Nothing, _tislwCode = Nothing, _tislwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
tislwData :: Lens' TargetInstancesScopedListWarning [TargetInstancesScopedListWarningDataItem]
tislwData
  = lens _tislwData (\ s a -> s{_tislwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
tislwCode :: Lens' TargetInstancesScopedListWarning (Maybe TargetInstancesScopedListWarningCode)
tislwCode
  = lens _tislwCode (\ s a -> s{_tislwCode = a})

-- | [Output Only] A human-readable description of the warning code.
tislwMessage :: Lens' TargetInstancesScopedListWarning (Maybe Text)
tislwMessage
  = lens _tislwMessage (\ s a -> s{_tislwMessage = a})

instance FromJSON TargetInstancesScopedListWarning
         where
        parseJSON
          = withObject "TargetInstancesScopedListWarning"
              (\ o ->
                 TargetInstancesScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON TargetInstancesScopedListWarning
         where
        toJSON TargetInstancesScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _tislwData,
                  ("code" .=) <$> _tislwCode,
                  ("message" .=) <$> _tislwMessage])

-- | Configuration and status of a managed SSL certificate.
--
-- /See:/ 'sslCertificateManagedSSLCertificate' smart constructor.
data SSLCertificateManagedSSLCertificate =
  SSLCertificateManagedSSLCertificate'
    { _scmscDomainStatus :: !(Maybe SSLCertificateManagedSSLCertificateDomainStatus)
    , _scmscStatus :: !(Maybe SSLCertificateManagedSSLCertificateStatus)
    , _scmscDomains :: !(Maybe [Text])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SSLCertificateManagedSSLCertificate' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'scmscDomainStatus'
--
-- * 'scmscStatus'
--
-- * 'scmscDomains'
sslCertificateManagedSSLCertificate
    :: SSLCertificateManagedSSLCertificate
sslCertificateManagedSSLCertificate =
  SSLCertificateManagedSSLCertificate'
    { _scmscDomainStatus = Nothing
    , _scmscStatus = Nothing
    , _scmscDomains = Nothing
    }


-- | [Output only] Detailed statuses of the domains specified for managed
-- certificate resource.
scmscDomainStatus :: Lens' SSLCertificateManagedSSLCertificate (Maybe SSLCertificateManagedSSLCertificateDomainStatus)
scmscDomainStatus
  = lens _scmscDomainStatus
      (\ s a -> s{_scmscDomainStatus = a})

-- | [Output only] Status of the managed certificate resource.
scmscStatus :: Lens' SSLCertificateManagedSSLCertificate (Maybe SSLCertificateManagedSSLCertificateStatus)
scmscStatus
  = lens _scmscStatus (\ s a -> s{_scmscStatus = a})

-- | The domains for which a managed SSL certificate will be generated. Each
-- Google-managed SSL certificate supports up to the [maximum number of
-- domains per Google-managed SSL
-- certificate](\/load-balancing\/docs\/quotas#ssl_certificates).
scmscDomains :: Lens' SSLCertificateManagedSSLCertificate [Text]
scmscDomains
  = lens _scmscDomains (\ s a -> s{_scmscDomains = a})
      . _Default
      . _Coerce

instance FromJSON SSLCertificateManagedSSLCertificate
         where
        parseJSON
          = withObject "SSLCertificateManagedSSLCertificate"
              (\ o ->
                 SSLCertificateManagedSSLCertificate' <$>
                   (o .:? "domainStatus") <*> (o .:? "status") <*>
                     (o .:? "domains" .!= mempty))

instance ToJSON SSLCertificateManagedSSLCertificate
         where
        toJSON SSLCertificateManagedSSLCertificate'{..}
          = object
              (catMaybes
                 [("domainStatus" .=) <$> _scmscDomainStatus,
                  ("status" .=) <$> _scmscStatus,
                  ("domains" .=) <$> _scmscDomains])

--
-- /See:/ 'networkEndpointGroupAggregatedList' smart constructor.
data NetworkEndpointGroupAggregatedList =
  NetworkEndpointGroupAggregatedList'
    { _negalUnreachables :: !(Maybe [Text])
    , _negalNextPageToken :: !(Maybe Text)
    , _negalKind :: !Text
    , _negalItems :: !(Maybe NetworkEndpointGroupAggregatedListItems)
    , _negalSelfLink :: !(Maybe Text)
    , _negalWarning :: !(Maybe NetworkEndpointGroupAggregatedListWarning)
    , _negalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkEndpointGroupAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'negalUnreachables'
--
-- * 'negalNextPageToken'
--
-- * 'negalKind'
--
-- * 'negalItems'
--
-- * 'negalSelfLink'
--
-- * 'negalWarning'
--
-- * 'negalId'
networkEndpointGroupAggregatedList
    :: NetworkEndpointGroupAggregatedList
networkEndpointGroupAggregatedList =
  NetworkEndpointGroupAggregatedList'
    { _negalUnreachables = Nothing
    , _negalNextPageToken = Nothing
    , _negalKind = "compute#networkEndpointGroupAggregatedList"
    , _negalItems = Nothing
    , _negalSelfLink = Nothing
    , _negalWarning = Nothing
    , _negalId = Nothing
    }


-- | [Output Only] Unreachable resources.
negalUnreachables :: Lens' NetworkEndpointGroupAggregatedList [Text]
negalUnreachables
  = lens _negalUnreachables
      (\ s a -> s{_negalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
negalNextPageToken :: Lens' NetworkEndpointGroupAggregatedList (Maybe Text)
negalNextPageToken
  = lens _negalNextPageToken
      (\ s a -> s{_negalNextPageToken = a})

-- | [Output Only] The resource type, which is always
-- compute#networkEndpointGroupAggregatedList for aggregated lists of
-- network endpoint groups.
negalKind :: Lens' NetworkEndpointGroupAggregatedList Text
negalKind
  = lens _negalKind (\ s a -> s{_negalKind = a})

-- | A list of NetworkEndpointGroupsScopedList resources.
negalItems :: Lens' NetworkEndpointGroupAggregatedList (Maybe NetworkEndpointGroupAggregatedListItems)
negalItems
  = lens _negalItems (\ s a -> s{_negalItems = a})

-- | [Output Only] Server-defined URL for this resource.
negalSelfLink :: Lens' NetworkEndpointGroupAggregatedList (Maybe Text)
negalSelfLink
  = lens _negalSelfLink
      (\ s a -> s{_negalSelfLink = a})

-- | [Output Only] Informational warning message.
negalWarning :: Lens' NetworkEndpointGroupAggregatedList (Maybe NetworkEndpointGroupAggregatedListWarning)
negalWarning
  = lens _negalWarning (\ s a -> s{_negalWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
negalId :: Lens' NetworkEndpointGroupAggregatedList (Maybe Text)
negalId = lens _negalId (\ s a -> s{_negalId = a})

instance FromJSON NetworkEndpointGroupAggregatedList
         where
        parseJSON
          = withObject "NetworkEndpointGroupAggregatedList"
              (\ o ->
                 NetworkEndpointGroupAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!=
                        "compute#networkEndpointGroupAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON NetworkEndpointGroupAggregatedList
         where
        toJSON NetworkEndpointGroupAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _negalUnreachables,
                  ("nextPageToken" .=) <$> _negalNextPageToken,
                  Just ("kind" .= _negalKind),
                  ("items" .=) <$> _negalItems,
                  ("selfLink" .=) <$> _negalSelfLink,
                  ("warning" .=) <$> _negalWarning,
                  ("id" .=) <$> _negalId])

--
-- /See:/ 'subnetworkAggregatedList' smart constructor.
data SubnetworkAggregatedList =
  SubnetworkAggregatedList'
    { _salUnreachables :: !(Maybe [Text])
    , _salNextPageToken :: !(Maybe Text)
    , _salKind :: !Text
    , _salItems :: !(Maybe SubnetworkAggregatedListItems)
    , _salSelfLink :: !(Maybe Text)
    , _salWarning :: !(Maybe SubnetworkAggregatedListWarning)
    , _salId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SubnetworkAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'salUnreachables'
--
-- * 'salNextPageToken'
--
-- * 'salKind'
--
-- * 'salItems'
--
-- * 'salSelfLink'
--
-- * 'salWarning'
--
-- * 'salId'
subnetworkAggregatedList
    :: SubnetworkAggregatedList
subnetworkAggregatedList =
  SubnetworkAggregatedList'
    { _salUnreachables = Nothing
    , _salNextPageToken = Nothing
    , _salKind = "compute#subnetworkAggregatedList"
    , _salItems = Nothing
    , _salSelfLink = Nothing
    , _salWarning = Nothing
    , _salId = Nothing
    }


-- | [Output Only] Unreachable resources.
salUnreachables :: Lens' SubnetworkAggregatedList [Text]
salUnreachables
  = lens _salUnreachables
      (\ s a -> s{_salUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
salNextPageToken :: Lens' SubnetworkAggregatedList (Maybe Text)
salNextPageToken
  = lens _salNextPageToken
      (\ s a -> s{_salNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#subnetworkAggregatedList
-- for aggregated lists of subnetworks.
salKind :: Lens' SubnetworkAggregatedList Text
salKind = lens _salKind (\ s a -> s{_salKind = a})

-- | A list of SubnetworksScopedList resources.
salItems :: Lens' SubnetworkAggregatedList (Maybe SubnetworkAggregatedListItems)
salItems = lens _salItems (\ s a -> s{_salItems = a})

-- | [Output Only] Server-defined URL for this resource.
salSelfLink :: Lens' SubnetworkAggregatedList (Maybe Text)
salSelfLink
  = lens _salSelfLink (\ s a -> s{_salSelfLink = a})

-- | [Output Only] Informational warning message.
salWarning :: Lens' SubnetworkAggregatedList (Maybe SubnetworkAggregatedListWarning)
salWarning
  = lens _salWarning (\ s a -> s{_salWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
salId :: Lens' SubnetworkAggregatedList (Maybe Text)
salId = lens _salId (\ s a -> s{_salId = a})

instance FromJSON SubnetworkAggregatedList where
        parseJSON
          = withObject "SubnetworkAggregatedList"
              (\ o ->
                 SubnetworkAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!= "compute#subnetworkAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON SubnetworkAggregatedList where
        toJSON SubnetworkAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _salUnreachables,
                  ("nextPageToken" .=) <$> _salNextPageToken,
                  Just ("kind" .= _salKind),
                  ("items" .=) <$> _salItems,
                  ("selfLink" .=) <$> _salSelfLink,
                  ("warning" .=) <$> _salWarning,
                  ("id" .=) <$> _salId])

--
-- /See:/ 'vpnTunnelListWarningDataItem' smart constructor.
data VPNTunnelListWarningDataItem =
  VPNTunnelListWarningDataItem'
    { _vtlwdiValue :: !(Maybe Text)
    , _vtlwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNTunnelListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vtlwdiValue'
--
-- * 'vtlwdiKey'
vpnTunnelListWarningDataItem
    :: VPNTunnelListWarningDataItem
vpnTunnelListWarningDataItem =
  VPNTunnelListWarningDataItem' {_vtlwdiValue = Nothing, _vtlwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
vtlwdiValue :: Lens' VPNTunnelListWarningDataItem (Maybe Text)
vtlwdiValue
  = lens _vtlwdiValue (\ s a -> s{_vtlwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
vtlwdiKey :: Lens' VPNTunnelListWarningDataItem (Maybe Text)
vtlwdiKey
  = lens _vtlwdiKey (\ s a -> s{_vtlwdiKey = a})

instance FromJSON VPNTunnelListWarningDataItem where
        parseJSON
          = withObject "VPNTunnelListWarningDataItem"
              (\ o ->
                 VPNTunnelListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON VPNTunnelListWarningDataItem where
        toJSON VPNTunnelListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _vtlwdiValue,
                  ("key" .=) <$> _vtlwdiKey])

--
-- /See:/ 'interconnectDiagnosticsLinkOpticalPower' smart constructor.
data InterconnectDiagnosticsLinkOpticalPower =
  InterconnectDiagnosticsLinkOpticalPower'
    { _idlopState :: !(Maybe InterconnectDiagnosticsLinkOpticalPowerState)
    , _idlopValue :: !(Maybe (Textual Double))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectDiagnosticsLinkOpticalPower' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'idlopState'
--
-- * 'idlopValue'
interconnectDiagnosticsLinkOpticalPower
    :: InterconnectDiagnosticsLinkOpticalPower
interconnectDiagnosticsLinkOpticalPower =
  InterconnectDiagnosticsLinkOpticalPower'
    {_idlopState = Nothing, _idlopValue = Nothing}


-- | The status of the current value when compared to the warning and alarm
-- levels for the receiving or transmitting transceiver. Possible states
-- include: - OK: The value has not crossed a warning threshold. -
-- LOW_WARNING: The value has crossed below the low warning threshold. -
-- HIGH_WARNING: The value has crossed above the high warning threshold. -
-- LOW_ALARM: The value has crossed below the low alarm threshold. -
-- HIGH_ALARM: The value has crossed above the high alarm threshold.
idlopState :: Lens' InterconnectDiagnosticsLinkOpticalPower (Maybe InterconnectDiagnosticsLinkOpticalPowerState)
idlopState
  = lens _idlopState (\ s a -> s{_idlopState = a})

-- | Value of the current receiving or transmitting optical power, read in
-- dBm. Take a known good optical value, give it a 10% margin and trigger
-- warnings relative to that value. In general, a -7dBm warning and a
-- -11dBm alarm are good optical value estimates for most links.
idlopValue :: Lens' InterconnectDiagnosticsLinkOpticalPower (Maybe Double)
idlopValue
  = lens _idlopValue (\ s a -> s{_idlopValue = a}) .
      mapping _Coerce

instance FromJSON
           InterconnectDiagnosticsLinkOpticalPower
         where
        parseJSON
          = withObject
              "InterconnectDiagnosticsLinkOpticalPower"
              (\ o ->
                 InterconnectDiagnosticsLinkOpticalPower' <$>
                   (o .:? "state") <*> (o .:? "value"))

instance ToJSON
           InterconnectDiagnosticsLinkOpticalPower
         where
        toJSON InterconnectDiagnosticsLinkOpticalPower'{..}
          = object
              (catMaybes
                 [("state" .=) <$> _idlopState,
                  ("value" .=) <$> _idlopValue])

--
-- /See:/ 'disksResizeRequest' smart constructor.
newtype DisksResizeRequest =
  DisksResizeRequest'
    { _drrSizeGb :: Maybe (Textual Int64)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DisksResizeRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'drrSizeGb'
disksResizeRequest
    :: DisksResizeRequest
disksResizeRequest = DisksResizeRequest' {_drrSizeGb = Nothing}


-- | The new size of the persistent disk, which is specified in GB.
drrSizeGb :: Lens' DisksResizeRequest (Maybe Int64)
drrSizeGb
  = lens _drrSizeGb (\ s a -> s{_drrSizeGb = a}) .
      mapping _Coerce

instance FromJSON DisksResizeRequest where
        parseJSON
          = withObject "DisksResizeRequest"
              (\ o -> DisksResizeRequest' <$> (o .:? "sizeGb"))

instance ToJSON DisksResizeRequest where
        toJSON DisksResizeRequest'{..}
          = object (catMaybes [("sizeGb" .=) <$> _drrSizeGb])

--
-- /See:/ 'healthChecksScopedList' smart constructor.
data HealthChecksScopedList =
  HealthChecksScopedList'
    { _hcslWarning :: !(Maybe HealthChecksScopedListWarning)
    , _hcslHealthChecks :: !(Maybe [HealthCheck])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HealthChecksScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hcslWarning'
--
-- * 'hcslHealthChecks'
healthChecksScopedList
    :: HealthChecksScopedList
healthChecksScopedList =
  HealthChecksScopedList' {_hcslWarning = Nothing, _hcslHealthChecks = Nothing}


-- | Informational warning which replaces the list of backend services when
-- the list is empty.
hcslWarning :: Lens' HealthChecksScopedList (Maybe HealthChecksScopedListWarning)
hcslWarning
  = lens _hcslWarning (\ s a -> s{_hcslWarning = a})

-- | A list of HealthChecks contained in this scope.
hcslHealthChecks :: Lens' HealthChecksScopedList [HealthCheck]
hcslHealthChecks
  = lens _hcslHealthChecks
      (\ s a -> s{_hcslHealthChecks = a})
      . _Default
      . _Coerce

instance FromJSON HealthChecksScopedList where
        parseJSON
          = withObject "HealthChecksScopedList"
              (\ o ->
                 HealthChecksScopedList' <$>
                   (o .:? "warning") <*>
                     (o .:? "healthChecks" .!= mempty))

instance ToJSON HealthChecksScopedList where
        toJSON HealthChecksScopedList'{..}
          = object
              (catMaybes
                 [("warning" .=) <$> _hcslWarning,
                  ("healthChecks" .=) <$> _hcslHealthChecks])

--
-- /See:/ 'autoscalersScopedListWarningDataItem' smart constructor.
data AutoscalersScopedListWarningDataItem =
  AutoscalersScopedListWarningDataItem'
    { _aValue :: !(Maybe Text)
    , _aKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AutoscalersScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'aValue'
--
-- * 'aKey'
autoscalersScopedListWarningDataItem
    :: AutoscalersScopedListWarningDataItem
autoscalersScopedListWarningDataItem =
  AutoscalersScopedListWarningDataItem' {_aValue = Nothing, _aKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
aValue :: Lens' AutoscalersScopedListWarningDataItem (Maybe Text)
aValue = lens _aValue (\ s a -> s{_aValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
aKey :: Lens' AutoscalersScopedListWarningDataItem (Maybe Text)
aKey = lens _aKey (\ s a -> s{_aKey = a})

instance FromJSON
           AutoscalersScopedListWarningDataItem
         where
        parseJSON
          = withObject "AutoscalersScopedListWarningDataItem"
              (\ o ->
                 AutoscalersScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON AutoscalersScopedListWarningDataItem
         where
        toJSON AutoscalersScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _aValue, ("key" .=) <$> _aKey])

--
-- /See:/ 'disksRemoveResourcePoliciesRequest' smart constructor.
newtype DisksRemoveResourcePoliciesRequest =
  DisksRemoveResourcePoliciesRequest'
    { _drrprResourcePolicies :: Maybe [Text]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DisksRemoveResourcePoliciesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'drrprResourcePolicies'
disksRemoveResourcePoliciesRequest
    :: DisksRemoveResourcePoliciesRequest
disksRemoveResourcePoliciesRequest =
  DisksRemoveResourcePoliciesRequest' {_drrprResourcePolicies = Nothing}


-- | Resource policies to be removed from this disk.
drrprResourcePolicies :: Lens' DisksRemoveResourcePoliciesRequest [Text]
drrprResourcePolicies
  = lens _drrprResourcePolicies
      (\ s a -> s{_drrprResourcePolicies = a})
      . _Default
      . _Coerce

instance FromJSON DisksRemoveResourcePoliciesRequest
         where
        parseJSON
          = withObject "DisksRemoveResourcePoliciesRequest"
              (\ o ->
                 DisksRemoveResourcePoliciesRequest' <$>
                   (o .:? "resourcePolicies" .!= mempty))

instance ToJSON DisksRemoveResourcePoliciesRequest
         where
        toJSON DisksRemoveResourcePoliciesRequest'{..}
          = object
              (catMaybes
                 [("resourcePolicies" .=) <$> _drrprResourcePolicies])

--
-- /See:/ 'zoneSetPolicyRequest' smart constructor.
data ZoneSetPolicyRequest =
  ZoneSetPolicyRequest'
    { _zsprEtag :: !(Maybe Bytes)
    , _zsprBindings :: !(Maybe [Binding])
    , _zsprPolicy :: !(Maybe Policy)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ZoneSetPolicyRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'zsprEtag'
--
-- * 'zsprBindings'
--
-- * 'zsprPolicy'
zoneSetPolicyRequest
    :: ZoneSetPolicyRequest
zoneSetPolicyRequest =
  ZoneSetPolicyRequest'
    {_zsprEtag = Nothing, _zsprBindings = Nothing, _zsprPolicy = Nothing}


-- | Flatten Policy to create a backward compatible wire-format. Deprecated.
-- Use \'policy\' to specify the etag.
zsprEtag :: Lens' ZoneSetPolicyRequest (Maybe ByteString)
zsprEtag
  = lens _zsprEtag (\ s a -> s{_zsprEtag = a}) .
      mapping _Bytes

-- | Flatten Policy to create a backwacd compatible wire-format. Deprecated.
-- Use \'policy\' to specify bindings.
zsprBindings :: Lens' ZoneSetPolicyRequest [Binding]
zsprBindings
  = lens _zsprBindings (\ s a -> s{_zsprBindings = a})
      . _Default
      . _Coerce

-- | REQUIRED: The complete policy to be applied to the \'resource\'. The
-- size of the policy is limited to a few 10s of KB. An empty policy is in
-- general a valid policy but certain services (like Projects) might reject
-- them.
zsprPolicy :: Lens' ZoneSetPolicyRequest (Maybe Policy)
zsprPolicy
  = lens _zsprPolicy (\ s a -> s{_zsprPolicy = a})

instance FromJSON ZoneSetPolicyRequest where
        parseJSON
          = withObject "ZoneSetPolicyRequest"
              (\ o ->
                 ZoneSetPolicyRequest' <$>
                   (o .:? "etag") <*> (o .:? "bindings" .!= mempty) <*>
                     (o .:? "policy"))

instance ToJSON ZoneSetPolicyRequest where
        toJSON ZoneSetPolicyRequest'{..}
          = object
              (catMaybes
                 [("etag" .=) <$> _zsprEtag,
                  ("bindings" .=) <$> _zsprBindings,
                  ("policy" .=) <$> _zsprPolicy])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'vpnGatewayAggregatedListWarning' smart constructor.
data VPNGatewayAggregatedListWarning =
  VPNGatewayAggregatedListWarning'
    { _vgalwData :: !(Maybe [VPNGatewayAggregatedListWarningDataItem])
    , _vgalwCode :: !(Maybe VPNGatewayAggregatedListWarningCode)
    , _vgalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNGatewayAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vgalwData'
--
-- * 'vgalwCode'
--
-- * 'vgalwMessage'
vpnGatewayAggregatedListWarning
    :: VPNGatewayAggregatedListWarning
vpnGatewayAggregatedListWarning =
  VPNGatewayAggregatedListWarning'
    {_vgalwData = Nothing, _vgalwCode = Nothing, _vgalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
vgalwData :: Lens' VPNGatewayAggregatedListWarning [VPNGatewayAggregatedListWarningDataItem]
vgalwData
  = lens _vgalwData (\ s a -> s{_vgalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
vgalwCode :: Lens' VPNGatewayAggregatedListWarning (Maybe VPNGatewayAggregatedListWarningCode)
vgalwCode
  = lens _vgalwCode (\ s a -> s{_vgalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
vgalwMessage :: Lens' VPNGatewayAggregatedListWarning (Maybe Text)
vgalwMessage
  = lens _vgalwMessage (\ s a -> s{_vgalwMessage = a})

instance FromJSON VPNGatewayAggregatedListWarning
         where
        parseJSON
          = withObject "VPNGatewayAggregatedListWarning"
              (\ o ->
                 VPNGatewayAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON VPNGatewayAggregatedListWarning where
        toJSON VPNGatewayAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _vgalwData,
                  ("code" .=) <$> _vgalwCode,
                  ("message" .=) <$> _vgalwMessage])

--
-- /See:/ 'diskTypeAggregatedListWarningDataItem' smart constructor.
data DiskTypeAggregatedListWarningDataItem =
  DiskTypeAggregatedListWarningDataItem'
    { _dtalwdiValue :: !(Maybe Text)
    , _dtalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DiskTypeAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dtalwdiValue'
--
-- * 'dtalwdiKey'
diskTypeAggregatedListWarningDataItem
    :: DiskTypeAggregatedListWarningDataItem
diskTypeAggregatedListWarningDataItem =
  DiskTypeAggregatedListWarningDataItem'
    {_dtalwdiValue = Nothing, _dtalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
dtalwdiValue :: Lens' DiskTypeAggregatedListWarningDataItem (Maybe Text)
dtalwdiValue
  = lens _dtalwdiValue (\ s a -> s{_dtalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
dtalwdiKey :: Lens' DiskTypeAggregatedListWarningDataItem (Maybe Text)
dtalwdiKey
  = lens _dtalwdiKey (\ s a -> s{_dtalwdiKey = a})

instance FromJSON
           DiskTypeAggregatedListWarningDataItem
         where
        parseJSON
          = withObject "DiskTypeAggregatedListWarningDataItem"
              (\ o ->
                 DiskTypeAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON DiskTypeAggregatedListWarningDataItem
         where
        toJSON DiskTypeAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _dtalwdiValue,
                  ("key" .=) <$> _dtalwdiKey])

-- | A Shielded Instance Identity Entry.
--
-- /See:/ 'shieldedInstanceIdentityEntry' smart constructor.
data ShieldedInstanceIdentityEntry =
  ShieldedInstanceIdentityEntry'
    { _siieEkCert :: !(Maybe Text)
    , _siieEkPub :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ShieldedInstanceIdentityEntry' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'siieEkCert'
--
-- * 'siieEkPub'
shieldedInstanceIdentityEntry
    :: ShieldedInstanceIdentityEntry
shieldedInstanceIdentityEntry =
  ShieldedInstanceIdentityEntry' {_siieEkCert = Nothing, _siieEkPub = Nothing}


-- | A PEM-encoded X.509 certificate. This field can be empty.
siieEkCert :: Lens' ShieldedInstanceIdentityEntry (Maybe Text)
siieEkCert
  = lens _siieEkCert (\ s a -> s{_siieEkCert = a})

-- | A PEM-encoded public key.
siieEkPub :: Lens' ShieldedInstanceIdentityEntry (Maybe Text)
siieEkPub
  = lens _siieEkPub (\ s a -> s{_siieEkPub = a})

instance FromJSON ShieldedInstanceIdentityEntry where
        parseJSON
          = withObject "ShieldedInstanceIdentityEntry"
              (\ o ->
                 ShieldedInstanceIdentityEntry' <$>
                   (o .:? "ekCert") <*> (o .:? "ekPub"))

instance ToJSON ShieldedInstanceIdentityEntry where
        toJSON ShieldedInstanceIdentityEntry'{..}
          = object
              (catMaybes
                 [("ekCert" .=) <$> _siieEkCert,
                  ("ekPub" .=) <$> _siieEkPub])

--
-- /See:/ 'allocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk' smart constructor.
data AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk =
  AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk'
    { _asskuaaiprdDiskSizeGb :: !(Maybe (Textual Int64))
    , _asskuaaiprdInterface :: !(Maybe AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'asskuaaiprdDiskSizeGb'
--
-- * 'asskuaaiprdInterface'
allocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk
    :: AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk
allocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk =
  AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk'
    {_asskuaaiprdDiskSizeGb = Nothing, _asskuaaiprdInterface = Nothing}


-- | Specifies the size of the disk in base-2 GB.
asskuaaiprdDiskSizeGb :: Lens' AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk (Maybe Int64)
asskuaaiprdDiskSizeGb
  = lens _asskuaaiprdDiskSizeGb
      (\ s a -> s{_asskuaaiprdDiskSizeGb = a})
      . mapping _Coerce

-- | Specifies the disk interface to use for attaching this disk, which is
-- either SCSI or NVME. The default is SCSI. For performance
-- characteristics of SCSI over NVMe, see Local SSD performance.
asskuaaiprdInterface :: Lens' AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk (Maybe AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface)
asskuaaiprdInterface
  = lens _asskuaaiprdInterface
      (\ s a -> s{_asskuaaiprdInterface = a})

instance FromJSON
           AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk
         where
        parseJSON
          = withObject
              "AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk"
              (\ o ->
                 AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk'
                   <$> (o .:? "diskSizeGb") <*> (o .:? "interface"))

instance ToJSON
           AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk
         where
        toJSON
          AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk'{..}
          = object
              (catMaybes
                 [("diskSizeGb" .=) <$> _asskuaaiprdDiskSizeGb,
                  ("interface" .=) <$> _asskuaaiprdInterface])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'regionInstanceGroupManagerListWarning' smart constructor.
data RegionInstanceGroupManagerListWarning =
  RegionInstanceGroupManagerListWarning'
    { _rigmlwData :: !(Maybe [RegionInstanceGroupManagerListWarningDataItem])
    , _rigmlwCode :: !(Maybe RegionInstanceGroupManagerListWarningCode)
    , _rigmlwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupManagerListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rigmlwData'
--
-- * 'rigmlwCode'
--
-- * 'rigmlwMessage'
regionInstanceGroupManagerListWarning
    :: RegionInstanceGroupManagerListWarning
regionInstanceGroupManagerListWarning =
  RegionInstanceGroupManagerListWarning'
    {_rigmlwData = Nothing, _rigmlwCode = Nothing, _rigmlwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
rigmlwData :: Lens' RegionInstanceGroupManagerListWarning [RegionInstanceGroupManagerListWarningDataItem]
rigmlwData
  = lens _rigmlwData (\ s a -> s{_rigmlwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
rigmlwCode :: Lens' RegionInstanceGroupManagerListWarning (Maybe RegionInstanceGroupManagerListWarningCode)
rigmlwCode
  = lens _rigmlwCode (\ s a -> s{_rigmlwCode = a})

-- | [Output Only] A human-readable description of the warning code.
rigmlwMessage :: Lens' RegionInstanceGroupManagerListWarning (Maybe Text)
rigmlwMessage
  = lens _rigmlwMessage
      (\ s a -> s{_rigmlwMessage = a})

instance FromJSON
           RegionInstanceGroupManagerListWarning
         where
        parseJSON
          = withObject "RegionInstanceGroupManagerListWarning"
              (\ o ->
                 RegionInstanceGroupManagerListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON RegionInstanceGroupManagerListWarning
         where
        toJSON RegionInstanceGroupManagerListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _rigmlwData,
                  ("code" .=) <$> _rigmlwCode,
                  ("message" .=) <$> _rigmlwMessage])

--
-- /See:/ 'regionInstanceGroupManagersSetTemplateRequest' smart constructor.
newtype RegionInstanceGroupManagersSetTemplateRequest =
  RegionInstanceGroupManagersSetTemplateRequest'
    { _rigmstrInstanceTemplate :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupManagersSetTemplateRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rigmstrInstanceTemplate'
regionInstanceGroupManagersSetTemplateRequest
    :: RegionInstanceGroupManagersSetTemplateRequest
regionInstanceGroupManagersSetTemplateRequest =
  RegionInstanceGroupManagersSetTemplateRequest'
    {_rigmstrInstanceTemplate = Nothing}


-- | URL of the InstanceTemplate resource from which all new instances will
-- be created.
rigmstrInstanceTemplate :: Lens' RegionInstanceGroupManagersSetTemplateRequest (Maybe Text)
rigmstrInstanceTemplate
  = lens _rigmstrInstanceTemplate
      (\ s a -> s{_rigmstrInstanceTemplate = a})

instance FromJSON
           RegionInstanceGroupManagersSetTemplateRequest
         where
        parseJSON
          = withObject
              "RegionInstanceGroupManagersSetTemplateRequest"
              (\ o ->
                 RegionInstanceGroupManagersSetTemplateRequest' <$>
                   (o .:? "instanceTemplate"))

instance ToJSON
           RegionInstanceGroupManagersSetTemplateRequest
         where
        toJSON
          RegionInstanceGroupManagersSetTemplateRequest'{..}
          = object
              (catMaybes
                 [("instanceTemplate" .=) <$>
                    _rigmstrInstanceTemplate])

--
-- /See:/ 'instanceGroupsListInstances' smart constructor.
data InstanceGroupsListInstances =
  InstanceGroupsListInstances'
    { _igliNextPageToken :: !(Maybe Text)
    , _igliKind :: !Text
    , _igliItems :: !(Maybe [InstanceWithNamedPorts])
    , _igliSelfLink :: !(Maybe Text)
    , _igliWarning :: !(Maybe InstanceGroupsListInstancesWarning)
    , _igliId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupsListInstances' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igliNextPageToken'
--
-- * 'igliKind'
--
-- * 'igliItems'
--
-- * 'igliSelfLink'
--
-- * 'igliWarning'
--
-- * 'igliId'
instanceGroupsListInstances
    :: InstanceGroupsListInstances
instanceGroupsListInstances =
  InstanceGroupsListInstances'
    { _igliNextPageToken = Nothing
    , _igliKind = "compute#instanceGroupsListInstances"
    , _igliItems = Nothing
    , _igliSelfLink = Nothing
    , _igliWarning = Nothing
    , _igliId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
igliNextPageToken :: Lens' InstanceGroupsListInstances (Maybe Text)
igliNextPageToken
  = lens _igliNextPageToken
      (\ s a -> s{_igliNextPageToken = a})

-- | [Output Only] The resource type, which is always
-- compute#instanceGroupsListInstances for the list of instances in the
-- specified instance group.
igliKind :: Lens' InstanceGroupsListInstances Text
igliKind = lens _igliKind (\ s a -> s{_igliKind = a})

-- | A list of InstanceWithNamedPorts resources.
igliItems :: Lens' InstanceGroupsListInstances [InstanceWithNamedPorts]
igliItems
  = lens _igliItems (\ s a -> s{_igliItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
igliSelfLink :: Lens' InstanceGroupsListInstances (Maybe Text)
igliSelfLink
  = lens _igliSelfLink (\ s a -> s{_igliSelfLink = a})

-- | [Output Only] Informational warning message.
igliWarning :: Lens' InstanceGroupsListInstances (Maybe InstanceGroupsListInstancesWarning)
igliWarning
  = lens _igliWarning (\ s a -> s{_igliWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
igliId :: Lens' InstanceGroupsListInstances (Maybe Text)
igliId = lens _igliId (\ s a -> s{_igliId = a})

instance FromJSON InstanceGroupsListInstances where
        parseJSON
          = withObject "InstanceGroupsListInstances"
              (\ o ->
                 InstanceGroupsListInstances' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!=
                        "compute#instanceGroupsListInstances")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON InstanceGroupsListInstances where
        toJSON InstanceGroupsListInstances'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _igliNextPageToken,
                  Just ("kind" .= _igliKind),
                  ("items" .=) <$> _igliItems,
                  ("selfLink" .=) <$> _igliSelfLink,
                  ("warning" .=) <$> _igliWarning,
                  ("id" .=) <$> _igliId])

-- | Represents an Autoscaler resource. Google Compute Engine has two
-- Autoscaler resources: *
-- [Zonal](\/compute\/docs\/reference\/rest\/{$api_version}\/autoscalers) *
-- [Regional](\/compute\/docs\/reference\/rest\/{$api_version}\/regionAutoscalers)
-- Use autoscalers to automatically add or delete instances from a managed
-- instance group according to your defined autoscaling policy. For more
-- information, read Autoscaling Groups of Instances. For zonal managed
-- instance groups resource, use the autoscaler resource. For regional
-- managed instance groups, use the regionAutoscalers resource. (==
-- resource_for {$api_version}.autoscalers ==) (== resource_for
-- {$api_version}.regionAutoscalers ==)
--
-- /See:/ 'autoscaler' smart constructor.
data Autoscaler =
  Autoscaler'
    { _aaStatus :: !(Maybe AutoscalerStatus)
    , _aaKind :: !Text
    , _aaZone :: !(Maybe Text)
    , _aaStatusDetails :: !(Maybe [AutoscalerStatusDetails])
    , _aaScalingScheduleStatus :: !(Maybe AutoscalerScalingScheduleStatus)
    , _aaSelfLink :: !(Maybe Text)
    , _aaName :: !(Maybe Text)
    , _aaCreationTimestamp :: !(Maybe Text)
    , _aaAutoscalingPolicy :: !(Maybe AutoscalingPolicy)
    , _aaId :: !(Maybe (Textual Word64))
    , _aaRegion :: !(Maybe Text)
    , _aaRecommendedSize :: !(Maybe (Textual Int32))
    , _aaDescription :: !(Maybe Text)
    , _aaTarget :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Autoscaler' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'aaStatus'
--
-- * 'aaKind'
--
-- * 'aaZone'
--
-- * 'aaStatusDetails'
--
-- * 'aaScalingScheduleStatus'
--
-- * 'aaSelfLink'
--
-- * 'aaName'
--
-- * 'aaCreationTimestamp'
--
-- * 'aaAutoscalingPolicy'
--
-- * 'aaId'
--
-- * 'aaRegion'
--
-- * 'aaRecommendedSize'
--
-- * 'aaDescription'
--
-- * 'aaTarget'
autoscaler
    :: Autoscaler
autoscaler =
  Autoscaler'
    { _aaStatus = Nothing
    , _aaKind = "compute#autoscaler"
    , _aaZone = Nothing
    , _aaStatusDetails = Nothing
    , _aaScalingScheduleStatus = Nothing
    , _aaSelfLink = Nothing
    , _aaName = Nothing
    , _aaCreationTimestamp = Nothing
    , _aaAutoscalingPolicy = Nothing
    , _aaId = Nothing
    , _aaRegion = Nothing
    , _aaRecommendedSize = Nothing
    , _aaDescription = Nothing
    , _aaTarget = Nothing
    }


-- | [Output Only] The status of the autoscaler configuration. Current set of
-- possible values: - PENDING: Autoscaler backend hasn\'t read new\/updated
-- configuration. - DELETING: Configuration is being deleted. - ACTIVE:
-- Configuration is acknowledged to be effective. Some warnings might be
-- present in the statusDetails field. - ERROR: Configuration has errors.
-- Actionable for users. Details are present in the statusDetails field.
-- New values might be added in the future.
aaStatus :: Lens' Autoscaler (Maybe AutoscalerStatus)
aaStatus = lens _aaStatus (\ s a -> s{_aaStatus = a})

-- | [Output Only] Type of the resource. Always compute#autoscaler for
-- autoscalers.
aaKind :: Lens' Autoscaler Text
aaKind = lens _aaKind (\ s a -> s{_aaKind = a})

-- | [Output Only] URL of the zone where the instance group resides (for
-- autoscalers living in zonal scope).
aaZone :: Lens' Autoscaler (Maybe Text)
aaZone = lens _aaZone (\ s a -> s{_aaZone = a})

-- | [Output Only] Human-readable details about the current state of the
-- autoscaler. Read the documentation for Commonly returned status messages
-- for examples of status messages you might encounter.
aaStatusDetails :: Lens' Autoscaler [AutoscalerStatusDetails]
aaStatusDetails
  = lens _aaStatusDetails
      (\ s a -> s{_aaStatusDetails = a})
      . _Default
      . _Coerce

-- | [Output Only] Status information of existing scaling schedules.
aaScalingScheduleStatus :: Lens' Autoscaler (Maybe AutoscalerScalingScheduleStatus)
aaScalingScheduleStatus
  = lens _aaScalingScheduleStatus
      (\ s a -> s{_aaScalingScheduleStatus = a})

-- | [Output Only] Server-defined URL for the resource.
aaSelfLink :: Lens' Autoscaler (Maybe Text)
aaSelfLink
  = lens _aaSelfLink (\ s a -> s{_aaSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
aaName :: Lens' Autoscaler (Maybe Text)
aaName = lens _aaName (\ s a -> s{_aaName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
aaCreationTimestamp :: Lens' Autoscaler (Maybe Text)
aaCreationTimestamp
  = lens _aaCreationTimestamp
      (\ s a -> s{_aaCreationTimestamp = a})

-- | The configuration parameters for the autoscaling algorithm. You can
-- define one or more signals for an autoscaler: cpuUtilization,
-- customMetricUtilizations, and loadBalancingUtilization. If none of these
-- are specified, the default will be to autoscale based on cpuUtilization
-- to 0.6 or 60%.
aaAutoscalingPolicy :: Lens' Autoscaler (Maybe AutoscalingPolicy)
aaAutoscalingPolicy
  = lens _aaAutoscalingPolicy
      (\ s a -> s{_aaAutoscalingPolicy = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
aaId :: Lens' Autoscaler (Maybe Word64)
aaId
  = lens _aaId (\ s a -> s{_aaId = a}) .
      mapping _Coerce

-- | [Output Only] URL of the region where the instance group resides (for
-- autoscalers living in regional scope).
aaRegion :: Lens' Autoscaler (Maybe Text)
aaRegion = lens _aaRegion (\ s a -> s{_aaRegion = a})

-- | [Output Only] Target recommended MIG size (number of instances) computed
-- by autoscaler. Autoscaler calculates the recommended MIG size even when
-- the autoscaling policy mode is different from ON. This field is empty
-- when autoscaler is not connected to an existing managed instance group
-- or autoscaler did not generate its prediction.
aaRecommendedSize :: Lens' Autoscaler (Maybe Int32)
aaRecommendedSize
  = lens _aaRecommendedSize
      (\ s a -> s{_aaRecommendedSize = a})
      . mapping _Coerce

-- | An optional description of this resource. Provide this property when you
-- create the resource.
aaDescription :: Lens' Autoscaler (Maybe Text)
aaDescription
  = lens _aaDescription
      (\ s a -> s{_aaDescription = a})

-- | URL of the managed instance group that this autoscaler will scale. This
-- field is required when creating an autoscaler.
aaTarget :: Lens' Autoscaler (Maybe Text)
aaTarget = lens _aaTarget (\ s a -> s{_aaTarget = a})

instance FromJSON Autoscaler where
        parseJSON
          = withObject "Autoscaler"
              (\ o ->
                 Autoscaler' <$>
                   (o .:? "status") <*>
                     (o .:? "kind" .!= "compute#autoscaler")
                     <*> (o .:? "zone")
                     <*> (o .:? "statusDetails" .!= mempty)
                     <*> (o .:? "scalingScheduleStatus")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "autoscalingPolicy")
                     <*> (o .:? "id")
                     <*> (o .:? "region")
                     <*> (o .:? "recommendedSize")
                     <*> (o .:? "description")
                     <*> (o .:? "target"))

instance ToJSON Autoscaler where
        toJSON Autoscaler'{..}
          = object
              (catMaybes
                 [("status" .=) <$> _aaStatus,
                  Just ("kind" .= _aaKind), ("zone" .=) <$> _aaZone,
                  ("statusDetails" .=) <$> _aaStatusDetails,
                  ("scalingScheduleStatus" .=) <$>
                    _aaScalingScheduleStatus,
                  ("selfLink" .=) <$> _aaSelfLink,
                  ("name" .=) <$> _aaName,
                  ("creationTimestamp" .=) <$> _aaCreationTimestamp,
                  ("autoscalingPolicy" .=) <$> _aaAutoscalingPolicy,
                  ("id" .=) <$> _aaId, ("region" .=) <$> _aaRegion,
                  ("recommendedSize" .=) <$> _aaRecommendedSize,
                  ("description" .=) <$> _aaDescription,
                  ("target" .=) <$> _aaTarget])

-- | This message defines settings for a consistent hash style load balancer.
--
-- /See:/ 'consistentHashLoadBalancerSettings' smart constructor.
data ConsistentHashLoadBalancerSettings =
  ConsistentHashLoadBalancerSettings'
    { _chlbsMinimumRingSize :: !(Maybe (Textual Int64))
    , _chlbsHTTPCookie :: !(Maybe ConsistentHashLoadBalancerSettingsHTTPCookie)
    , _chlbsHTTPHeaderName :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ConsistentHashLoadBalancerSettings' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'chlbsMinimumRingSize'
--
-- * 'chlbsHTTPCookie'
--
-- * 'chlbsHTTPHeaderName'
consistentHashLoadBalancerSettings
    :: ConsistentHashLoadBalancerSettings
consistentHashLoadBalancerSettings =
  ConsistentHashLoadBalancerSettings'
    { _chlbsMinimumRingSize = Nothing
    , _chlbsHTTPCookie = Nothing
    , _chlbsHTTPHeaderName = Nothing
    }


-- | The minimum number of virtual nodes to use for the hash ring. Defaults
-- to 1024. Larger ring sizes result in more granular load distributions.
-- If the number of hosts in the load balancing pool is larger than the
-- ring size, each host will be assigned a single virtual node.
chlbsMinimumRingSize :: Lens' ConsistentHashLoadBalancerSettings (Maybe Int64)
chlbsMinimumRingSize
  = lens _chlbsMinimumRingSize
      (\ s a -> s{_chlbsMinimumRingSize = a})
      . mapping _Coerce

-- | Hash is based on HTTP Cookie. This field describes a HTTP cookie that
-- will be used as the hash key for the consistent hash load balancer. If
-- the cookie is not present, it will be generated. This field is
-- applicable if the sessionAffinity is set to HTTP_COOKIE.
chlbsHTTPCookie :: Lens' ConsistentHashLoadBalancerSettings (Maybe ConsistentHashLoadBalancerSettingsHTTPCookie)
chlbsHTTPCookie
  = lens _chlbsHTTPCookie
      (\ s a -> s{_chlbsHTTPCookie = a})

-- | The hash based on the value of the specified header field. This field is
-- applicable if the sessionAffinity is set to HEADER_FIELD.
chlbsHTTPHeaderName :: Lens' ConsistentHashLoadBalancerSettings (Maybe Text)
chlbsHTTPHeaderName
  = lens _chlbsHTTPHeaderName
      (\ s a -> s{_chlbsHTTPHeaderName = a})

instance FromJSON ConsistentHashLoadBalancerSettings
         where
        parseJSON
          = withObject "ConsistentHashLoadBalancerSettings"
              (\ o ->
                 ConsistentHashLoadBalancerSettings' <$>
                   (o .:? "minimumRingSize") <*> (o .:? "httpCookie")
                     <*> (o .:? "httpHeaderName"))

instance ToJSON ConsistentHashLoadBalancerSettings
         where
        toJSON ConsistentHashLoadBalancerSettings'{..}
          = object
              (catMaybes
                 [("minimumRingSize" .=) <$> _chlbsMinimumRingSize,
                  ("httpCookie" .=) <$> _chlbsHTTPCookie,
                  ("httpHeaderName" .=) <$> _chlbsHTTPHeaderName])

-- | A VPN gateway interface.
--
-- /See:/ 'vpnGatewayVPNGatewayInterface' smart constructor.
data VPNGatewayVPNGatewayInterface =
  VPNGatewayVPNGatewayInterface'
    { _vgvgiIPAddress :: !(Maybe Text)
    , _vgvgiId :: !(Maybe (Textual Word32))
    , _vgvgiInterconnectAttachment :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNGatewayVPNGatewayInterface' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vgvgiIPAddress'
--
-- * 'vgvgiId'
--
-- * 'vgvgiInterconnectAttachment'
vpnGatewayVPNGatewayInterface
    :: VPNGatewayVPNGatewayInterface
vpnGatewayVPNGatewayInterface =
  VPNGatewayVPNGatewayInterface'
    { _vgvgiIPAddress = Nothing
    , _vgvgiId = Nothing
    , _vgvgiInterconnectAttachment = Nothing
    }


-- | [Output Only] IP address for this VPN interface associated with the VPN
-- gateway. The IP address could be either a regional external IP address
-- or a regional internal IP address. The two IP addresses for a VPN
-- gateway must be all regional external or regional internal IP addresses.
-- There cannot be a mix of regional external IP addresses and regional
-- internal IP addresses. For IPsec-encrypted Cloud Interconnect, the IP
-- addresses for both interfaces could either be regional internal IP
-- addresses or regional external IP addresses. For regular (non
-- IPsec-encrypted Cloud Interconnect) HA VPN tunnels, the IP address must
-- be a regional external IP address.
vgvgiIPAddress :: Lens' VPNGatewayVPNGatewayInterface (Maybe Text)
vgvgiIPAddress
  = lens _vgvgiIPAddress
      (\ s a -> s{_vgvgiIPAddress = a})

-- | [Output Only] Numeric identifier for this VPN interface associated with
-- the VPN gateway.
vgvgiId :: Lens' VPNGatewayVPNGatewayInterface (Maybe Word32)
vgvgiId
  = lens _vgvgiId (\ s a -> s{_vgvgiId = a}) .
      mapping _Coerce

-- | URL of the VLAN attachment (interconnectAttachment) resource for this
-- VPN gateway interface. When the value of this field is present, the VPN
-- gateway is used for IPsec-encrypted Cloud Interconnect; all egress or
-- ingress traffic for this VPN gateway interface goes through the
-- specified VLAN attachment resource. Not currently available publicly.
vgvgiInterconnectAttachment :: Lens' VPNGatewayVPNGatewayInterface (Maybe Text)
vgvgiInterconnectAttachment
  = lens _vgvgiInterconnectAttachment
      (\ s a -> s{_vgvgiInterconnectAttachment = a})

instance FromJSON VPNGatewayVPNGatewayInterface where
        parseJSON
          = withObject "VPNGatewayVPNGatewayInterface"
              (\ o ->
                 VPNGatewayVPNGatewayInterface' <$>
                   (o .:? "ipAddress") <*> (o .:? "id") <*>
                     (o .:? "interconnectAttachment"))

instance ToJSON VPNGatewayVPNGatewayInterface where
        toJSON VPNGatewayVPNGatewayInterface'{..}
          = object
              (catMaybes
                 [("ipAddress" .=) <$> _vgvgiIPAddress,
                  ("id" .=) <$> _vgvgiId,
                  ("interconnectAttachment" .=) <$>
                    _vgvgiInterconnectAttachment])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'machineTypeListWarning' smart constructor.
data MachineTypeListWarning =
  MachineTypeListWarning'
    { _mtlwData :: !(Maybe [MachineTypeListWarningDataItem])
    , _mtlwCode :: !(Maybe MachineTypeListWarningCode)
    , _mtlwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'MachineTypeListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'mtlwData'
--
-- * 'mtlwCode'
--
-- * 'mtlwMessage'
machineTypeListWarning
    :: MachineTypeListWarning
machineTypeListWarning =
  MachineTypeListWarning'
    {_mtlwData = Nothing, _mtlwCode = Nothing, _mtlwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
mtlwData :: Lens' MachineTypeListWarning [MachineTypeListWarningDataItem]
mtlwData
  = lens _mtlwData (\ s a -> s{_mtlwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
mtlwCode :: Lens' MachineTypeListWarning (Maybe MachineTypeListWarningCode)
mtlwCode = lens _mtlwCode (\ s a -> s{_mtlwCode = a})

-- | [Output Only] A human-readable description of the warning code.
mtlwMessage :: Lens' MachineTypeListWarning (Maybe Text)
mtlwMessage
  = lens _mtlwMessage (\ s a -> s{_mtlwMessage = a})

instance FromJSON MachineTypeListWarning where
        parseJSON
          = withObject "MachineTypeListWarning"
              (\ o ->
                 MachineTypeListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON MachineTypeListWarning where
        toJSON MachineTypeListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _mtlwData,
                  ("code" .=) <$> _mtlwCode,
                  ("message" .=) <$> _mtlwMessage])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'targetHTTPProxyListWarning' smart constructor.
data TargetHTTPProxyListWarning =
  TargetHTTPProxyListWarning'
    { _thttpplwData :: !(Maybe [TargetHTTPProxyListWarningDataItem])
    , _thttpplwCode :: !(Maybe TargetHTTPProxyListWarningCode)
    , _thttpplwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetHTTPProxyListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'thttpplwData'
--
-- * 'thttpplwCode'
--
-- * 'thttpplwMessage'
targetHTTPProxyListWarning
    :: TargetHTTPProxyListWarning
targetHTTPProxyListWarning =
  TargetHTTPProxyListWarning'
    { _thttpplwData = Nothing
    , _thttpplwCode = Nothing
    , _thttpplwMessage = Nothing
    }


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
thttpplwData :: Lens' TargetHTTPProxyListWarning [TargetHTTPProxyListWarningDataItem]
thttpplwData
  = lens _thttpplwData (\ s a -> s{_thttpplwData = a})
      . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
thttpplwCode :: Lens' TargetHTTPProxyListWarning (Maybe TargetHTTPProxyListWarningCode)
thttpplwCode
  = lens _thttpplwCode (\ s a -> s{_thttpplwCode = a})

-- | [Output Only] A human-readable description of the warning code.
thttpplwMessage :: Lens' TargetHTTPProxyListWarning (Maybe Text)
thttpplwMessage
  = lens _thttpplwMessage
      (\ s a -> s{_thttpplwMessage = a})

instance FromJSON TargetHTTPProxyListWarning where
        parseJSON
          = withObject "TargetHTTPProxyListWarning"
              (\ o ->
                 TargetHTTPProxyListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON TargetHTTPProxyListWarning where
        toJSON TargetHTTPProxyListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _thttpplwData,
                  ("code" .=) <$> _thttpplwCode,
                  ("message" .=) <$> _thttpplwMessage])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'diskAggregatedListWarning' smart constructor.
data DiskAggregatedListWarning =
  DiskAggregatedListWarning'
    { _dalwData :: !(Maybe [DiskAggregatedListWarningDataItem])
    , _dalwCode :: !(Maybe DiskAggregatedListWarningCode)
    , _dalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DiskAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dalwData'
--
-- * 'dalwCode'
--
-- * 'dalwMessage'
diskAggregatedListWarning
    :: DiskAggregatedListWarning
diskAggregatedListWarning =
  DiskAggregatedListWarning'
    {_dalwData = Nothing, _dalwCode = Nothing, _dalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
dalwData :: Lens' DiskAggregatedListWarning [DiskAggregatedListWarningDataItem]
dalwData
  = lens _dalwData (\ s a -> s{_dalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
dalwCode :: Lens' DiskAggregatedListWarning (Maybe DiskAggregatedListWarningCode)
dalwCode = lens _dalwCode (\ s a -> s{_dalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
dalwMessage :: Lens' DiskAggregatedListWarning (Maybe Text)
dalwMessage
  = lens _dalwMessage (\ s a -> s{_dalwMessage = a})

instance FromJSON DiskAggregatedListWarning where
        parseJSON
          = withObject "DiskAggregatedListWarning"
              (\ o ->
                 DiskAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON DiskAggregatedListWarning where
        toJSON DiskAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _dalwData,
                  ("code" .=) <$> _dalwCode,
                  ("message" .=) <$> _dalwMessage])

--
-- /See:/ 'resourcePoliciesScopedList' smart constructor.
data ResourcePoliciesScopedList =
  ResourcePoliciesScopedList'
    { _rpslResourcePolicies :: !(Maybe [ResourcePolicy])
    , _rpslWarning :: !(Maybe ResourcePoliciesScopedListWarning)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePoliciesScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rpslResourcePolicies'
--
-- * 'rpslWarning'
resourcePoliciesScopedList
    :: ResourcePoliciesScopedList
resourcePoliciesScopedList =
  ResourcePoliciesScopedList'
    {_rpslResourcePolicies = Nothing, _rpslWarning = Nothing}


-- | A list of resourcePolicies contained in this scope.
rpslResourcePolicies :: Lens' ResourcePoliciesScopedList [ResourcePolicy]
rpslResourcePolicies
  = lens _rpslResourcePolicies
      (\ s a -> s{_rpslResourcePolicies = a})
      . _Default
      . _Coerce

-- | Informational warning which replaces the list of resourcePolicies when
-- the list is empty.
rpslWarning :: Lens' ResourcePoliciesScopedList (Maybe ResourcePoliciesScopedListWarning)
rpslWarning
  = lens _rpslWarning (\ s a -> s{_rpslWarning = a})

instance FromJSON ResourcePoliciesScopedList where
        parseJSON
          = withObject "ResourcePoliciesScopedList"
              (\ o ->
                 ResourcePoliciesScopedList' <$>
                   (o .:? "resourcePolicies" .!= mempty) <*>
                     (o .:? "warning"))

instance ToJSON ResourcePoliciesScopedList where
        toJSON ResourcePoliciesScopedList'{..}
          = object
              (catMaybes
                 [("resourcePolicies" .=) <$> _rpslResourcePolicies,
                  ("warning" .=) <$> _rpslWarning])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'targetPoolAggregatedListWarning' smart constructor.
data TargetPoolAggregatedListWarning =
  TargetPoolAggregatedListWarning'
    { _tpalwData :: !(Maybe [TargetPoolAggregatedListWarningDataItem])
    , _tpalwCode :: !(Maybe TargetPoolAggregatedListWarningCode)
    , _tpalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetPoolAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tpalwData'
--
-- * 'tpalwCode'
--
-- * 'tpalwMessage'
targetPoolAggregatedListWarning
    :: TargetPoolAggregatedListWarning
targetPoolAggregatedListWarning =
  TargetPoolAggregatedListWarning'
    {_tpalwData = Nothing, _tpalwCode = Nothing, _tpalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
tpalwData :: Lens' TargetPoolAggregatedListWarning [TargetPoolAggregatedListWarningDataItem]
tpalwData
  = lens _tpalwData (\ s a -> s{_tpalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
tpalwCode :: Lens' TargetPoolAggregatedListWarning (Maybe TargetPoolAggregatedListWarningCode)
tpalwCode
  = lens _tpalwCode (\ s a -> s{_tpalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
tpalwMessage :: Lens' TargetPoolAggregatedListWarning (Maybe Text)
tpalwMessage
  = lens _tpalwMessage (\ s a -> s{_tpalwMessage = a})

instance FromJSON TargetPoolAggregatedListWarning
         where
        parseJSON
          = withObject "TargetPoolAggregatedListWarning"
              (\ o ->
                 TargetPoolAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON TargetPoolAggregatedListWarning where
        toJSON TargetPoolAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _tpalwData,
                  ("code" .=) <$> _tpalwCode,
                  ("message" .=) <$> _tpalwMessage])

-- | HttpRouteRuleMatch criteria for a request\'s query parameter.
--
-- /See:/ 'hTTPQueryParameterMatch' smart constructor.
data HTTPQueryParameterMatch =
  HTTPQueryParameterMatch'
    { _httpqpmName :: !(Maybe Text)
    , _httpqpmPresentMatch :: !(Maybe Bool)
    , _httpqpmExactMatch :: !(Maybe Text)
    , _httpqpmRegexMatch :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HTTPQueryParameterMatch' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'httpqpmName'
--
-- * 'httpqpmPresentMatch'
--
-- * 'httpqpmExactMatch'
--
-- * 'httpqpmRegexMatch'
hTTPQueryParameterMatch
    :: HTTPQueryParameterMatch
hTTPQueryParameterMatch =
  HTTPQueryParameterMatch'
    { _httpqpmName = Nothing
    , _httpqpmPresentMatch = Nothing
    , _httpqpmExactMatch = Nothing
    , _httpqpmRegexMatch = Nothing
    }


-- | The name of the query parameter to match. The query parameter must exist
-- in the request, in the absence of which the request match fails.
httpqpmName :: Lens' HTTPQueryParameterMatch (Maybe Text)
httpqpmName
  = lens _httpqpmName (\ s a -> s{_httpqpmName = a})

-- | Specifies that the queryParameterMatch matches if the request contains
-- the query parameter, irrespective of whether the parameter has a value
-- or not. Only one of presentMatch, exactMatch or regexMatch must be set.
httpqpmPresentMatch :: Lens' HTTPQueryParameterMatch (Maybe Bool)
httpqpmPresentMatch
  = lens _httpqpmPresentMatch
      (\ s a -> s{_httpqpmPresentMatch = a})

-- | The queryParameterMatch matches if the value of the parameter exactly
-- matches the contents of exactMatch. Only one of presentMatch, exactMatch
-- or regexMatch must be set.
httpqpmExactMatch :: Lens' HTTPQueryParameterMatch (Maybe Text)
httpqpmExactMatch
  = lens _httpqpmExactMatch
      (\ s a -> s{_httpqpmExactMatch = a})

-- | The queryParameterMatch matches if the value of the parameter matches
-- the regular expression specified by regexMatch. For the regular
-- expression grammar, please see github.com\/google\/re2\/wiki\/Syntax
-- Only one of presentMatch, exactMatch or regexMatch must be set. Note
-- that regexMatch only applies when the loadBalancingScheme is set to
-- INTERNAL_SELF_MANAGED.
httpqpmRegexMatch :: Lens' HTTPQueryParameterMatch (Maybe Text)
httpqpmRegexMatch
  = lens _httpqpmRegexMatch
      (\ s a -> s{_httpqpmRegexMatch = a})

instance FromJSON HTTPQueryParameterMatch where
        parseJSON
          = withObject "HTTPQueryParameterMatch"
              (\ o ->
                 HTTPQueryParameterMatch' <$>
                   (o .:? "name") <*> (o .:? "presentMatch") <*>
                     (o .:? "exactMatch")
                     <*> (o .:? "regexMatch"))

instance ToJSON HTTPQueryParameterMatch where
        toJSON HTTPQueryParameterMatch'{..}
          = object
              (catMaybes
                 [("name" .=) <$> _httpqpmName,
                  ("presentMatch" .=) <$> _httpqpmPresentMatch,
                  ("exactMatch" .=) <$> _httpqpmExactMatch,
                  ("regexMatch" .=) <$> _httpqpmRegexMatch])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'reservationListWarning' smart constructor.
data ReservationListWarning =
  ReservationListWarning'
    { _rrData :: !(Maybe [ReservationListWarningDataItem])
    , _rrCode :: !(Maybe ReservationListWarningCode)
    , _rrMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ReservationListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rrData'
--
-- * 'rrCode'
--
-- * 'rrMessage'
reservationListWarning
    :: ReservationListWarning
reservationListWarning =
  ReservationListWarning'
    {_rrData = Nothing, _rrCode = Nothing, _rrMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
rrData :: Lens' ReservationListWarning [ReservationListWarningDataItem]
rrData
  = lens _rrData (\ s a -> s{_rrData = a}) . _Default .
      _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
rrCode :: Lens' ReservationListWarning (Maybe ReservationListWarningCode)
rrCode = lens _rrCode (\ s a -> s{_rrCode = a})

-- | [Output Only] A human-readable description of the warning code.
rrMessage :: Lens' ReservationListWarning (Maybe Text)
rrMessage
  = lens _rrMessage (\ s a -> s{_rrMessage = a})

instance FromJSON ReservationListWarning where
        parseJSON
          = withObject "ReservationListWarning"
              (\ o ->
                 ReservationListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON ReservationListWarning where
        toJSON ReservationListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _rrData, ("code" .=) <$> _rrCode,
                  ("message" .=) <$> _rrMessage])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'usableSubnetworksAggregatedListWarning' smart constructor.
data UsableSubnetworksAggregatedListWarning =
  UsableSubnetworksAggregatedListWarning'
    { _usalwData :: !(Maybe [UsableSubnetworksAggregatedListWarningDataItem])
    , _usalwCode :: !(Maybe UsableSubnetworksAggregatedListWarningCode)
    , _usalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'UsableSubnetworksAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'usalwData'
--
-- * 'usalwCode'
--
-- * 'usalwMessage'
usableSubnetworksAggregatedListWarning
    :: UsableSubnetworksAggregatedListWarning
usableSubnetworksAggregatedListWarning =
  UsableSubnetworksAggregatedListWarning'
    {_usalwData = Nothing, _usalwCode = Nothing, _usalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
usalwData :: Lens' UsableSubnetworksAggregatedListWarning [UsableSubnetworksAggregatedListWarningDataItem]
usalwData
  = lens _usalwData (\ s a -> s{_usalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
usalwCode :: Lens' UsableSubnetworksAggregatedListWarning (Maybe UsableSubnetworksAggregatedListWarningCode)
usalwCode
  = lens _usalwCode (\ s a -> s{_usalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
usalwMessage :: Lens' UsableSubnetworksAggregatedListWarning (Maybe Text)
usalwMessage
  = lens _usalwMessage (\ s a -> s{_usalwMessage = a})

instance FromJSON
           UsableSubnetworksAggregatedListWarning
         where
        parseJSON
          = withObject "UsableSubnetworksAggregatedListWarning"
              (\ o ->
                 UsableSubnetworksAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON
           UsableSubnetworksAggregatedListWarning
         where
        toJSON UsableSubnetworksAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _usalwData,
                  ("code" .=) <$> _usalwCode,
                  ("message" .=) <$> _usalwMessage])

--
-- /See:/ 'reservationsResizeRequest' smart constructor.
newtype ReservationsResizeRequest =
  ReservationsResizeRequest'
    { _rrrSpecificSKUCount :: Maybe (Textual Int64)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ReservationsResizeRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rrrSpecificSKUCount'
reservationsResizeRequest
    :: ReservationsResizeRequest
reservationsResizeRequest =
  ReservationsResizeRequest' {_rrrSpecificSKUCount = Nothing}


-- | Number of allocated resources can be resized with minimum = 1 and
-- maximum = 1000.
rrrSpecificSKUCount :: Lens' ReservationsResizeRequest (Maybe Int64)
rrrSpecificSKUCount
  = lens _rrrSpecificSKUCount
      (\ s a -> s{_rrrSpecificSKUCount = a})
      . mapping _Coerce

instance FromJSON ReservationsResizeRequest where
        parseJSON
          = withObject "ReservationsResizeRequest"
              (\ o ->
                 ReservationsResizeRequest' <$>
                   (o .:? "specificSkuCount"))

instance ToJSON ReservationsResizeRequest where
        toJSON ReservationsResizeRequest'{..}
          = object
              (catMaybes
                 [("specificSkuCount" .=) <$> _rrrSpecificSKUCount])

-- | [Output Only] Informational warning which replaces the list of disks
-- when the list is empty.
--
-- /See:/ 'disksScopedListWarning' smart constructor.
data DisksScopedListWarning =
  DisksScopedListWarning'
    { _dslwData :: !(Maybe [DisksScopedListWarningDataItem])
    , _dslwCode :: !(Maybe DisksScopedListWarningCode)
    , _dslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DisksScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dslwData'
--
-- * 'dslwCode'
--
-- * 'dslwMessage'
disksScopedListWarning
    :: DisksScopedListWarning
disksScopedListWarning =
  DisksScopedListWarning'
    {_dslwData = Nothing, _dslwCode = Nothing, _dslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
dslwData :: Lens' DisksScopedListWarning [DisksScopedListWarningDataItem]
dslwData
  = lens _dslwData (\ s a -> s{_dslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
dslwCode :: Lens' DisksScopedListWarning (Maybe DisksScopedListWarningCode)
dslwCode = lens _dslwCode (\ s a -> s{_dslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
dslwMessage :: Lens' DisksScopedListWarning (Maybe Text)
dslwMessage
  = lens _dslwMessage (\ s a -> s{_dslwMessage = a})

instance FromJSON DisksScopedListWarning where
        parseJSON
          = withObject "DisksScopedListWarning"
              (\ o ->
                 DisksScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON DisksScopedListWarning where
        toJSON DisksScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _dslwData,
                  ("code" .=) <$> _dslwCode,
                  ("message" .=) <$> _dslwMessage])

--
-- /See:/ 'nodeTemplatesScopedListWarningDataItem' smart constructor.
data NodeTemplatesScopedListWarningDataItem =
  NodeTemplatesScopedListWarningDataItem'
    { _ntslwdiValue :: !(Maybe Text)
    , _ntslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeTemplatesScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ntslwdiValue'
--
-- * 'ntslwdiKey'
nodeTemplatesScopedListWarningDataItem
    :: NodeTemplatesScopedListWarningDataItem
nodeTemplatesScopedListWarningDataItem =
  NodeTemplatesScopedListWarningDataItem'
    {_ntslwdiValue = Nothing, _ntslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
ntslwdiValue :: Lens' NodeTemplatesScopedListWarningDataItem (Maybe Text)
ntslwdiValue
  = lens _ntslwdiValue (\ s a -> s{_ntslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
ntslwdiKey :: Lens' NodeTemplatesScopedListWarningDataItem (Maybe Text)
ntslwdiKey
  = lens _ntslwdiKey (\ s a -> s{_ntslwdiKey = a})

instance FromJSON
           NodeTemplatesScopedListWarningDataItem
         where
        parseJSON
          = withObject "NodeTemplatesScopedListWarningDataItem"
              (\ o ->
                 NodeTemplatesScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           NodeTemplatesScopedListWarningDataItem
         where
        toJSON NodeTemplatesScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _ntslwdiValue,
                  ("key" .=) <$> _ntslwdiKey])

-- | A list of TargetVpnGateway resources.
--
-- /See:/ 'targetVPNGatewayAggregatedListItems' smart constructor.
newtype TargetVPNGatewayAggregatedListItems =
  TargetVPNGatewayAggregatedListItems'
    { _tvgaliAddtional :: HashMap Text TargetVPNGatewaysScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetVPNGatewayAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tvgaliAddtional'
targetVPNGatewayAggregatedListItems
    :: HashMap Text TargetVPNGatewaysScopedList -- ^ 'tvgaliAddtional'
    -> TargetVPNGatewayAggregatedListItems
targetVPNGatewayAggregatedListItems pTvgaliAddtional_ =
  TargetVPNGatewayAggregatedListItems'
    {_tvgaliAddtional = _Coerce # pTvgaliAddtional_}


-- | [Output Only] Name of the scope containing this set of target VPN
-- gateways.
tvgaliAddtional :: Lens' TargetVPNGatewayAggregatedListItems (HashMap Text TargetVPNGatewaysScopedList)
tvgaliAddtional
  = lens _tvgaliAddtional
      (\ s a -> s{_tvgaliAddtional = a})
      . _Coerce

instance FromJSON TargetVPNGatewayAggregatedListItems
         where
        parseJSON
          = withObject "TargetVPNGatewayAggregatedListItems"
              (\ o ->
                 TargetVPNGatewayAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON TargetVPNGatewayAggregatedListItems
         where
        toJSON = toJSON . _tvgaliAddtional

-- | Labels to apply to this disk. These can be later modified by the
-- setLabels method.
--
-- /See:/ 'diskLabels' smart constructor.
newtype DiskLabels =
  DiskLabels'
    { _dlAddtional :: HashMap Text Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DiskLabels' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dlAddtional'
diskLabels
    :: HashMap Text Text -- ^ 'dlAddtional'
    -> DiskLabels
diskLabels pDlAddtional_ = DiskLabels' {_dlAddtional = _Coerce # pDlAddtional_}


dlAddtional :: Lens' DiskLabels (HashMap Text Text)
dlAddtional
  = lens _dlAddtional (\ s a -> s{_dlAddtional = a}) .
      _Coerce

instance FromJSON DiskLabels where
        parseJSON
          = withObject "DiskLabels"
              (\ o -> DiskLabels' <$> (parseJSONObject o))

instance ToJSON DiskLabels where
        toJSON = toJSON . _dlAddtional

--
-- /See:/ 'instanceGroupManagerListWarningDataItem' smart constructor.
data InstanceGroupManagerListWarningDataItem =
  InstanceGroupManagerListWarningDataItem'
    { _igmlwdiValue :: !(Maybe Text)
    , _igmlwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagerListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmlwdiValue'
--
-- * 'igmlwdiKey'
instanceGroupManagerListWarningDataItem
    :: InstanceGroupManagerListWarningDataItem
instanceGroupManagerListWarningDataItem =
  InstanceGroupManagerListWarningDataItem'
    {_igmlwdiValue = Nothing, _igmlwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
igmlwdiValue :: Lens' InstanceGroupManagerListWarningDataItem (Maybe Text)
igmlwdiValue
  = lens _igmlwdiValue (\ s a -> s{_igmlwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
igmlwdiKey :: Lens' InstanceGroupManagerListWarningDataItem (Maybe Text)
igmlwdiKey
  = lens _igmlwdiKey (\ s a -> s{_igmlwdiKey = a})

instance FromJSON
           InstanceGroupManagerListWarningDataItem
         where
        parseJSON
          = withObject
              "InstanceGroupManagerListWarningDataItem"
              (\ o ->
                 InstanceGroupManagerListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           InstanceGroupManagerListWarningDataItem
         where
        toJSON InstanceGroupManagerListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _igmlwdiValue,
                  ("key" .=) <$> _igmlwdiKey])

--
-- /See:/ 'reservationAggregatedListWarningDataItem' smart constructor.
data ReservationAggregatedListWarningDataItem =
  ReservationAggregatedListWarningDataItem'
    { _resValue :: !(Maybe Text)
    , _resKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ReservationAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'resValue'
--
-- * 'resKey'
reservationAggregatedListWarningDataItem
    :: ReservationAggregatedListWarningDataItem
reservationAggregatedListWarningDataItem =
  ReservationAggregatedListWarningDataItem'
    {_resValue = Nothing, _resKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
resValue :: Lens' ReservationAggregatedListWarningDataItem (Maybe Text)
resValue = lens _resValue (\ s a -> s{_resValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
resKey :: Lens' ReservationAggregatedListWarningDataItem (Maybe Text)
resKey = lens _resKey (\ s a -> s{_resKey = a})

instance FromJSON
           ReservationAggregatedListWarningDataItem
         where
        parseJSON
          = withObject
              "ReservationAggregatedListWarningDataItem"
              (\ o ->
                 ReservationAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           ReservationAggregatedListWarningDataItem
         where
        toJSON ReservationAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _resValue, ("key" .=) <$> _resKey])

-- | A list of SslCertificatesScopedList resources.
--
-- /See:/ 'sslCertificateAggregatedListItems' smart constructor.
newtype SSLCertificateAggregatedListItems =
  SSLCertificateAggregatedListItems'
    { _scaliAddtional :: HashMap Text SSLCertificatesScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SSLCertificateAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'scaliAddtional'
sslCertificateAggregatedListItems
    :: HashMap Text SSLCertificatesScopedList -- ^ 'scaliAddtional'
    -> SSLCertificateAggregatedListItems
sslCertificateAggregatedListItems pScaliAddtional_ =
  SSLCertificateAggregatedListItems'
    {_scaliAddtional = _Coerce # pScaliAddtional_}


-- | Name of the scope containing this set of SslCertificates.
scaliAddtional :: Lens' SSLCertificateAggregatedListItems (HashMap Text SSLCertificatesScopedList)
scaliAddtional
  = lens _scaliAddtional
      (\ s a -> s{_scaliAddtional = a})
      . _Coerce

instance FromJSON SSLCertificateAggregatedListItems
         where
        parseJSON
          = withObject "SSLCertificateAggregatedListItems"
              (\ o ->
                 SSLCertificateAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON SSLCertificateAggregatedListItems
         where
        toJSON = toJSON . _scaliAddtional

-- | MetadataFilter label name value pairs that are expected to match
-- corresponding labels presented as metadata to the loadbalancer.
--
-- /See:/ 'metadataFilterLabelMatch' smart constructor.
data MetadataFilterLabelMatch =
  MetadataFilterLabelMatch'
    { _mflmValue :: !(Maybe Text)
    , _mflmName :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'MetadataFilterLabelMatch' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'mflmValue'
--
-- * 'mflmName'
metadataFilterLabelMatch
    :: MetadataFilterLabelMatch
metadataFilterLabelMatch =
  MetadataFilterLabelMatch' {_mflmValue = Nothing, _mflmName = Nothing}


-- | The value of the label must match the specified value. value can have a
-- maximum length of 1024 characters.
mflmValue :: Lens' MetadataFilterLabelMatch (Maybe Text)
mflmValue
  = lens _mflmValue (\ s a -> s{_mflmValue = a})

-- | Name of metadata label. The name can have a maximum length of 1024
-- characters and must be at least 1 character long.
mflmName :: Lens' MetadataFilterLabelMatch (Maybe Text)
mflmName = lens _mflmName (\ s a -> s{_mflmName = a})

instance FromJSON MetadataFilterLabelMatch where
        parseJSON
          = withObject "MetadataFilterLabelMatch"
              (\ o ->
                 MetadataFilterLabelMatch' <$>
                   (o .:? "value") <*> (o .:? "name"))

instance ToJSON MetadataFilterLabelMatch where
        toJSON MetadataFilterLabelMatch'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _mflmValue,
                  ("name" .=) <$> _mflmName])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'forwardingRuleAggregatedListWarning' smart constructor.
data ForwardingRuleAggregatedListWarning =
  ForwardingRuleAggregatedListWarning'
    { _fralwData :: !(Maybe [ForwardingRuleAggregatedListWarningDataItem])
    , _fralwCode :: !(Maybe ForwardingRuleAggregatedListWarningCode)
    , _fralwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ForwardingRuleAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'fralwData'
--
-- * 'fralwCode'
--
-- * 'fralwMessage'
forwardingRuleAggregatedListWarning
    :: ForwardingRuleAggregatedListWarning
forwardingRuleAggregatedListWarning =
  ForwardingRuleAggregatedListWarning'
    {_fralwData = Nothing, _fralwCode = Nothing, _fralwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
fralwData :: Lens' ForwardingRuleAggregatedListWarning [ForwardingRuleAggregatedListWarningDataItem]
fralwData
  = lens _fralwData (\ s a -> s{_fralwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
fralwCode :: Lens' ForwardingRuleAggregatedListWarning (Maybe ForwardingRuleAggregatedListWarningCode)
fralwCode
  = lens _fralwCode (\ s a -> s{_fralwCode = a})

-- | [Output Only] A human-readable description of the warning code.
fralwMessage :: Lens' ForwardingRuleAggregatedListWarning (Maybe Text)
fralwMessage
  = lens _fralwMessage (\ s a -> s{_fralwMessage = a})

instance FromJSON ForwardingRuleAggregatedListWarning
         where
        parseJSON
          = withObject "ForwardingRuleAggregatedListWarning"
              (\ o ->
                 ForwardingRuleAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON ForwardingRuleAggregatedListWarning
         where
        toJSON ForwardingRuleAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _fralwData,
                  ("code" .=) <$> _fralwCode,
                  ("message" .=) <$> _fralwMessage])

-- | The interface for the external VPN gateway.
--
-- /See:/ 'externalVPNGatewayInterface' smart constructor.
data ExternalVPNGatewayInterface =
  ExternalVPNGatewayInterface'
    { _evgiIPAddress :: !(Maybe Text)
    , _evgiId :: !(Maybe (Textual Word32))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ExternalVPNGatewayInterface' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'evgiIPAddress'
--
-- * 'evgiId'
externalVPNGatewayInterface
    :: ExternalVPNGatewayInterface
externalVPNGatewayInterface =
  ExternalVPNGatewayInterface' {_evgiIPAddress = Nothing, _evgiId = Nothing}


-- | IP address of the interface in the external VPN gateway. Only IPv4 is
-- supported. This IP address can be either from your on-premise gateway or
-- another Cloud provider\'s VPN gateway, it cannot be an IP address from
-- Google Compute Engine.
evgiIPAddress :: Lens' ExternalVPNGatewayInterface (Maybe Text)
evgiIPAddress
  = lens _evgiIPAddress
      (\ s a -> s{_evgiIPAddress = a})

-- | The numeric ID of this interface. The allowed input values for this id
-- for different redundancy types of external VPN gateway: -
-- SINGLE_IP_INTERNALLY_REDUNDANT - 0 - TWO_IPS_REDUNDANCY - 0, 1 -
-- FOUR_IPS_REDUNDANCY - 0, 1, 2, 3
evgiId :: Lens' ExternalVPNGatewayInterface (Maybe Word32)
evgiId
  = lens _evgiId (\ s a -> s{_evgiId = a}) .
      mapping _Coerce

instance FromJSON ExternalVPNGatewayInterface where
        parseJSON
          = withObject "ExternalVPNGatewayInterface"
              (\ o ->
                 ExternalVPNGatewayInterface' <$>
                   (o .:? "ipAddress") <*> (o .:? "id"))

instance ToJSON ExternalVPNGatewayInterface where
        toJSON ExternalVPNGatewayInterface'{..}
          = object
              (catMaybes
                 [("ipAddress" .=) <$> _evgiIPAddress,
                  ("id" .=) <$> _evgiId])

--
-- /See:/ 'sslPolicyWarningsItem' smart constructor.
data SSLPolicyWarningsItem =
  SSLPolicyWarningsItem'
    { _spwiData :: !(Maybe [SSLPolicyWarningsItemDataItem])
    , _spwiCode :: !(Maybe SSLPolicyWarningsItemCode)
    , _spwiMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SSLPolicyWarningsItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'spwiData'
--
-- * 'spwiCode'
--
-- * 'spwiMessage'
sslPolicyWarningsItem
    :: SSLPolicyWarningsItem
sslPolicyWarningsItem =
  SSLPolicyWarningsItem'
    {_spwiData = Nothing, _spwiCode = Nothing, _spwiMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
spwiData :: Lens' SSLPolicyWarningsItem [SSLPolicyWarningsItemDataItem]
spwiData
  = lens _spwiData (\ s a -> s{_spwiData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
spwiCode :: Lens' SSLPolicyWarningsItem (Maybe SSLPolicyWarningsItemCode)
spwiCode = lens _spwiCode (\ s a -> s{_spwiCode = a})

-- | [Output Only] A human-readable description of the warning code.
spwiMessage :: Lens' SSLPolicyWarningsItem (Maybe Text)
spwiMessage
  = lens _spwiMessage (\ s a -> s{_spwiMessage = a})

instance FromJSON SSLPolicyWarningsItem where
        parseJSON
          = withObject "SSLPolicyWarningsItem"
              (\ o ->
                 SSLPolicyWarningsItem' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON SSLPolicyWarningsItem where
        toJSON SSLPolicyWarningsItem'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _spwiData,
                  ("code" .=) <$> _spwiCode,
                  ("message" .=) <$> _spwiMessage])

--
-- /See:/ 'globalSetPolicyRequest' smart constructor.
data GlobalSetPolicyRequest =
  GlobalSetPolicyRequest'
    { _gsprEtag :: !(Maybe Bytes)
    , _gsprBindings :: !(Maybe [Binding])
    , _gsprPolicy :: !(Maybe Policy)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'GlobalSetPolicyRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'gsprEtag'
--
-- * 'gsprBindings'
--
-- * 'gsprPolicy'
globalSetPolicyRequest
    :: GlobalSetPolicyRequest
globalSetPolicyRequest =
  GlobalSetPolicyRequest'
    {_gsprEtag = Nothing, _gsprBindings = Nothing, _gsprPolicy = Nothing}


-- | Flatten Policy to create a backward compatible wire-format. Deprecated.
-- Use \'policy\' to specify the etag.
gsprEtag :: Lens' GlobalSetPolicyRequest (Maybe ByteString)
gsprEtag
  = lens _gsprEtag (\ s a -> s{_gsprEtag = a}) .
      mapping _Bytes

-- | Flatten Policy to create a backward compatible wire-format. Deprecated.
-- Use \'policy\' to specify bindings.
gsprBindings :: Lens' GlobalSetPolicyRequest [Binding]
gsprBindings
  = lens _gsprBindings (\ s a -> s{_gsprBindings = a})
      . _Default
      . _Coerce

-- | REQUIRED: The complete policy to be applied to the \'resource\'. The
-- size of the policy is limited to a few 10s of KB. An empty policy is in
-- general a valid policy but certain services (like Projects) might reject
-- them.
gsprPolicy :: Lens' GlobalSetPolicyRequest (Maybe Policy)
gsprPolicy
  = lens _gsprPolicy (\ s a -> s{_gsprPolicy = a})

instance FromJSON GlobalSetPolicyRequest where
        parseJSON
          = withObject "GlobalSetPolicyRequest"
              (\ o ->
                 GlobalSetPolicyRequest' <$>
                   (o .:? "etag") <*> (o .:? "bindings" .!= mempty) <*>
                     (o .:? "policy"))

instance ToJSON GlobalSetPolicyRequest where
        toJSON GlobalSetPolicyRequest'{..}
          = object
              (catMaybes
                 [("etag" .=) <$> _gsprEtag,
                  ("bindings" .=) <$> _gsprBindings,
                  ("policy" .=) <$> _gsprPolicy])

--
-- /See:/ 'regionAutoscalerListWarningDataItem' smart constructor.
data RegionAutoscalerListWarningDataItem =
  RegionAutoscalerListWarningDataItem'
    { _ralwdiaValue :: !(Maybe Text)
    , _ralwdiaKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionAutoscalerListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ralwdiaValue'
--
-- * 'ralwdiaKey'
regionAutoscalerListWarningDataItem
    :: RegionAutoscalerListWarningDataItem
regionAutoscalerListWarningDataItem =
  RegionAutoscalerListWarningDataItem'
    {_ralwdiaValue = Nothing, _ralwdiaKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
ralwdiaValue :: Lens' RegionAutoscalerListWarningDataItem (Maybe Text)
ralwdiaValue
  = lens _ralwdiaValue (\ s a -> s{_ralwdiaValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
ralwdiaKey :: Lens' RegionAutoscalerListWarningDataItem (Maybe Text)
ralwdiaKey
  = lens _ralwdiaKey (\ s a -> s{_ralwdiaKey = a})

instance FromJSON RegionAutoscalerListWarningDataItem
         where
        parseJSON
          = withObject "RegionAutoscalerListWarningDataItem"
              (\ o ->
                 RegionAutoscalerListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON RegionAutoscalerListWarningDataItem
         where
        toJSON RegionAutoscalerListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _ralwdiaValue,
                  ("key" .=) <$> _ralwdiaKey])

-- | A list of labels to apply for this resource. Each label key & value must
-- comply with RFC1035. Specifically, the name must be 1-63 characters long
-- and match the regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which
-- means the first character must be a lowercase letter, and all following
-- characters must be a dash, lowercase letter, or digit, except the last
-- character, which cannot be a dash. For example, \"webserver-frontend\":
-- \"images\". A label value can also be empty (e.g. \"my-label\": \"\").
--
-- /See:/ 'globalSetLabelsRequestLabels' smart constructor.
newtype GlobalSetLabelsRequestLabels =
  GlobalSetLabelsRequestLabels'
    { _gslrlAddtional :: HashMap Text Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'GlobalSetLabelsRequestLabels' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'gslrlAddtional'
globalSetLabelsRequestLabels
    :: HashMap Text Text -- ^ 'gslrlAddtional'
    -> GlobalSetLabelsRequestLabels
globalSetLabelsRequestLabels pGslrlAddtional_ =
  GlobalSetLabelsRequestLabels' {_gslrlAddtional = _Coerce # pGslrlAddtional_}


gslrlAddtional :: Lens' GlobalSetLabelsRequestLabels (HashMap Text Text)
gslrlAddtional
  = lens _gslrlAddtional
      (\ s a -> s{_gslrlAddtional = a})
      . _Coerce

instance FromJSON GlobalSetLabelsRequestLabels where
        parseJSON
          = withObject "GlobalSetLabelsRequestLabels"
              (\ o ->
                 GlobalSetLabelsRequestLabels' <$>
                   (parseJSONObject o))

instance ToJSON GlobalSetLabelsRequestLabels where
        toJSON = toJSON . _gslrlAddtional

-- | Informational warning which replaces the list of addresses when the list
-- is empty.
--
-- /See:/ 'targetPoolsScopedListWarning' smart constructor.
data TargetPoolsScopedListWarning =
  TargetPoolsScopedListWarning'
    { _tpslwData :: !(Maybe [TargetPoolsScopedListWarningDataItem])
    , _tpslwCode :: !(Maybe TargetPoolsScopedListWarningCode)
    , _tpslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetPoolsScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tpslwData'
--
-- * 'tpslwCode'
--
-- * 'tpslwMessage'
targetPoolsScopedListWarning
    :: TargetPoolsScopedListWarning
targetPoolsScopedListWarning =
  TargetPoolsScopedListWarning'
    {_tpslwData = Nothing, _tpslwCode = Nothing, _tpslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
tpslwData :: Lens' TargetPoolsScopedListWarning [TargetPoolsScopedListWarningDataItem]
tpslwData
  = lens _tpslwData (\ s a -> s{_tpslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
tpslwCode :: Lens' TargetPoolsScopedListWarning (Maybe TargetPoolsScopedListWarningCode)
tpslwCode
  = lens _tpslwCode (\ s a -> s{_tpslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
tpslwMessage :: Lens' TargetPoolsScopedListWarning (Maybe Text)
tpslwMessage
  = lens _tpslwMessage (\ s a -> s{_tpslwMessage = a})

instance FromJSON TargetPoolsScopedListWarning where
        parseJSON
          = withObject "TargetPoolsScopedListWarning"
              (\ o ->
                 TargetPoolsScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON TargetPoolsScopedListWarning where
        toJSON TargetPoolsScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _tpslwData,
                  ("code" .=) <$> _tpslwCode,
                  ("message" .=) <$> _tpslwMessage])

--
-- /See:/ 'healthStatus' smart constructor.
data HealthStatus =
  HealthStatus'
    { _hsAnnotations :: !(Maybe HealthStatusAnnotations)
    , _hsForwardingRuleIP :: !(Maybe Text)
    , _hsIPAddress :: !(Maybe Text)
    , _hsForwardingRule :: !(Maybe Text)
    , _hsWeight :: !(Maybe Text)
    , _hsWeightError :: !(Maybe HealthStatusWeightError)
    , _hsHealthState :: !(Maybe HealthStatusHealthState)
    , _hsPort :: !(Maybe (Textual Int32))
    , _hsInstance :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HealthStatus' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hsAnnotations'
--
-- * 'hsForwardingRuleIP'
--
-- * 'hsIPAddress'
--
-- * 'hsForwardingRule'
--
-- * 'hsWeight'
--
-- * 'hsWeightError'
--
-- * 'hsHealthState'
--
-- * 'hsPort'
--
-- * 'hsInstance'
healthStatus
    :: HealthStatus
healthStatus =
  HealthStatus'
    { _hsAnnotations = Nothing
    , _hsForwardingRuleIP = Nothing
    , _hsIPAddress = Nothing
    , _hsForwardingRule = Nothing
    , _hsWeight = Nothing
    , _hsWeightError = Nothing
    , _hsHealthState = Nothing
    , _hsPort = Nothing
    , _hsInstance = Nothing
    }


-- | Metadata defined as annotations for network endpoint.
hsAnnotations :: Lens' HealthStatus (Maybe HealthStatusAnnotations)
hsAnnotations
  = lens _hsAnnotations
      (\ s a -> s{_hsAnnotations = a})

-- | A forwarding rule IP address assigned to this instance.
hsForwardingRuleIP :: Lens' HealthStatus (Maybe Text)
hsForwardingRuleIP
  = lens _hsForwardingRuleIP
      (\ s a -> s{_hsForwardingRuleIP = a})

-- | For target pool based Network Load Balancing, it indicates the
-- forwarding rule\'s IP address assigned to this instance. For other types
-- of load balancing, the field indicates VM internal ip.
hsIPAddress :: Lens' HealthStatus (Maybe Text)
hsIPAddress
  = lens _hsIPAddress (\ s a -> s{_hsIPAddress = a})

-- | URL of the forwarding rule associated with the health status of the
-- instance.
hsForwardingRule :: Lens' HealthStatus (Maybe Text)
hsForwardingRule
  = lens _hsForwardingRule
      (\ s a -> s{_hsForwardingRule = a})

hsWeight :: Lens' HealthStatus (Maybe Text)
hsWeight = lens _hsWeight (\ s a -> s{_hsWeight = a})

hsWeightError :: Lens' HealthStatus (Maybe HealthStatusWeightError)
hsWeightError
  = lens _hsWeightError
      (\ s a -> s{_hsWeightError = a})

-- | Health state of the instance.
hsHealthState :: Lens' HealthStatus (Maybe HealthStatusHealthState)
hsHealthState
  = lens _hsHealthState
      (\ s a -> s{_hsHealthState = a})

-- | The named port of the instance group, not necessarily the port that is
-- health-checked.
hsPort :: Lens' HealthStatus (Maybe Int32)
hsPort
  = lens _hsPort (\ s a -> s{_hsPort = a}) .
      mapping _Coerce

-- | URL of the instance resource.
hsInstance :: Lens' HealthStatus (Maybe Text)
hsInstance
  = lens _hsInstance (\ s a -> s{_hsInstance = a})

instance FromJSON HealthStatus where
        parseJSON
          = withObject "HealthStatus"
              (\ o ->
                 HealthStatus' <$>
                   (o .:? "annotations") <*> (o .:? "forwardingRuleIp")
                     <*> (o .:? "ipAddress")
                     <*> (o .:? "forwardingRule")
                     <*> (o .:? "weight")
                     <*> (o .:? "weightError")
                     <*> (o .:? "healthState")
                     <*> (o .:? "port")
                     <*> (o .:? "instance"))

instance ToJSON HealthStatus where
        toJSON HealthStatus'{..}
          = object
              (catMaybes
                 [("annotations" .=) <$> _hsAnnotations,
                  ("forwardingRuleIp" .=) <$> _hsForwardingRuleIP,
                  ("ipAddress" .=) <$> _hsIPAddress,
                  ("forwardingRule" .=) <$> _hsForwardingRule,
                  ("weight" .=) <$> _hsWeight,
                  ("weightError" .=) <$> _hsWeightError,
                  ("healthState" .=) <$> _hsHealthState,
                  ("port" .=) <$> _hsPort,
                  ("instance" .=) <$> _hsInstance])

--
-- /See:/ 'vpnGatewaysScopedListWarningDataItem' smart constructor.
data VPNGatewaysScopedListWarningDataItem =
  VPNGatewaysScopedListWarningDataItem'
    { _vgslwdiValue :: !(Maybe Text)
    , _vgslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNGatewaysScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vgslwdiValue'
--
-- * 'vgslwdiKey'
vpnGatewaysScopedListWarningDataItem
    :: VPNGatewaysScopedListWarningDataItem
vpnGatewaysScopedListWarningDataItem =
  VPNGatewaysScopedListWarningDataItem'
    {_vgslwdiValue = Nothing, _vgslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
vgslwdiValue :: Lens' VPNGatewaysScopedListWarningDataItem (Maybe Text)
vgslwdiValue
  = lens _vgslwdiValue (\ s a -> s{_vgslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
vgslwdiKey :: Lens' VPNGatewaysScopedListWarningDataItem (Maybe Text)
vgslwdiKey
  = lens _vgslwdiKey (\ s a -> s{_vgslwdiKey = a})

instance FromJSON
           VPNGatewaysScopedListWarningDataItem
         where
        parseJSON
          = withObject "VPNGatewaysScopedListWarningDataItem"
              (\ o ->
                 VPNGatewaysScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON VPNGatewaysScopedListWarningDataItem
         where
        toJSON VPNGatewaysScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _vgslwdiValue,
                  ("key" .=) <$> _vgslwdiKey])

-- | Contains a list of TargetTcpProxy resources.
--
-- /See:/ 'targetTCPProxyList' smart constructor.
data TargetTCPProxyList =
  TargetTCPProxyList'
    { _ttplNextPageToken :: !(Maybe Text)
    , _ttplKind :: !Text
    , _ttplItems :: !(Maybe [TargetTCPProxy])
    , _ttplSelfLink :: !(Maybe Text)
    , _ttplWarning :: !(Maybe TargetTCPProxyListWarning)
    , _ttplId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetTCPProxyList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ttplNextPageToken'
--
-- * 'ttplKind'
--
-- * 'ttplItems'
--
-- * 'ttplSelfLink'
--
-- * 'ttplWarning'
--
-- * 'ttplId'
targetTCPProxyList
    :: TargetTCPProxyList
targetTCPProxyList =
  TargetTCPProxyList'
    { _ttplNextPageToken = Nothing
    , _ttplKind = "compute#targetTcpProxyList"
    , _ttplItems = Nothing
    , _ttplSelfLink = Nothing
    , _ttplWarning = Nothing
    , _ttplId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
ttplNextPageToken :: Lens' TargetTCPProxyList (Maybe Text)
ttplNextPageToken
  = lens _ttplNextPageToken
      (\ s a -> s{_ttplNextPageToken = a})

-- | Type of resource.
ttplKind :: Lens' TargetTCPProxyList Text
ttplKind = lens _ttplKind (\ s a -> s{_ttplKind = a})

-- | A list of TargetTcpProxy resources.
ttplItems :: Lens' TargetTCPProxyList [TargetTCPProxy]
ttplItems
  = lens _ttplItems (\ s a -> s{_ttplItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
ttplSelfLink :: Lens' TargetTCPProxyList (Maybe Text)
ttplSelfLink
  = lens _ttplSelfLink (\ s a -> s{_ttplSelfLink = a})

-- | [Output Only] Informational warning message.
ttplWarning :: Lens' TargetTCPProxyList (Maybe TargetTCPProxyListWarning)
ttplWarning
  = lens _ttplWarning (\ s a -> s{_ttplWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
ttplId :: Lens' TargetTCPProxyList (Maybe Text)
ttplId = lens _ttplId (\ s a -> s{_ttplId = a})

instance FromJSON TargetTCPProxyList where
        parseJSON
          = withObject "TargetTCPProxyList"
              (\ o ->
                 TargetTCPProxyList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#targetTcpProxyList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON TargetTCPProxyList where
        toJSON TargetTCPProxyList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _ttplNextPageToken,
                  Just ("kind" .= _ttplKind),
                  ("items" .=) <$> _ttplItems,
                  ("selfLink" .=) <$> _ttplSelfLink,
                  ("warning" .=) <$> _ttplWarning,
                  ("id" .=) <$> _ttplId])

-- | Represents a Region resource. A region is a geographical area where a
-- resource is located. For more information, read Regions and Zones. (==
-- resource_for {$api_version}.regions ==)
--
-- /See:/ 'region' smart constructor.
data Region =
  Region'
    { _regeStatus :: !(Maybe RegionStatus)
    , _regeZones :: !(Maybe [Text])
    , _regeKind :: !Text
    , _regeSelfLink :: !(Maybe Text)
    , _regeName :: !(Maybe Text)
    , _regeCreationTimestamp :: !(Maybe Text)
    , _regeSupportsPzs :: !(Maybe Bool)
    , _regeQuotas :: !(Maybe [Quota])
    , _regeId :: !(Maybe (Textual Word64))
    , _regeDescription :: !(Maybe Text)
    , _regeDeprecated :: !(Maybe DeprecationStatus)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Region' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'regeStatus'
--
-- * 'regeZones'
--
-- * 'regeKind'
--
-- * 'regeSelfLink'
--
-- * 'regeName'
--
-- * 'regeCreationTimestamp'
--
-- * 'regeSupportsPzs'
--
-- * 'regeQuotas'
--
-- * 'regeId'
--
-- * 'regeDescription'
--
-- * 'regeDeprecated'
region
    :: Region
region =
  Region'
    { _regeStatus = Nothing
    , _regeZones = Nothing
    , _regeKind = "compute#region"
    , _regeSelfLink = Nothing
    , _regeName = Nothing
    , _regeCreationTimestamp = Nothing
    , _regeSupportsPzs = Nothing
    , _regeQuotas = Nothing
    , _regeId = Nothing
    , _regeDescription = Nothing
    , _regeDeprecated = Nothing
    }


-- | [Output Only] Status of the region, either UP or DOWN.
regeStatus :: Lens' Region (Maybe RegionStatus)
regeStatus
  = lens _regeStatus (\ s a -> s{_regeStatus = a})

-- | [Output Only] A list of zones available in this region, in the form of
-- resource URLs.
regeZones :: Lens' Region [Text]
regeZones
  = lens _regeZones (\ s a -> s{_regeZones = a}) .
      _Default
      . _Coerce

-- | [Output Only] Type of the resource. Always compute#region for regions.
regeKind :: Lens' Region Text
regeKind = lens _regeKind (\ s a -> s{_regeKind = a})

-- | [Output Only] Server-defined URL for the resource.
regeSelfLink :: Lens' Region (Maybe Text)
regeSelfLink
  = lens _regeSelfLink (\ s a -> s{_regeSelfLink = a})

-- | [Output Only] Name of the resource.
regeName :: Lens' Region (Maybe Text)
regeName = lens _regeName (\ s a -> s{_regeName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
regeCreationTimestamp :: Lens' Region (Maybe Text)
regeCreationTimestamp
  = lens _regeCreationTimestamp
      (\ s a -> s{_regeCreationTimestamp = a})

-- | [Output Only] Reserved for future use.
regeSupportsPzs :: Lens' Region (Maybe Bool)
regeSupportsPzs
  = lens _regeSupportsPzs
      (\ s a -> s{_regeSupportsPzs = a})

-- | [Output Only] Quotas assigned to this region.
regeQuotas :: Lens' Region [Quota]
regeQuotas
  = lens _regeQuotas (\ s a -> s{_regeQuotas = a}) .
      _Default
      . _Coerce

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
regeId :: Lens' Region (Maybe Word64)
regeId
  = lens _regeId (\ s a -> s{_regeId = a}) .
      mapping _Coerce

-- | [Output Only] Textual description of the resource.
regeDescription :: Lens' Region (Maybe Text)
regeDescription
  = lens _regeDescription
      (\ s a -> s{_regeDescription = a})

-- | [Output Only] The deprecation status associated with this region.
regeDeprecated :: Lens' Region (Maybe DeprecationStatus)
regeDeprecated
  = lens _regeDeprecated
      (\ s a -> s{_regeDeprecated = a})

instance FromJSON Region where
        parseJSON
          = withObject "Region"
              (\ o ->
                 Region' <$>
                   (o .:? "status") <*> (o .:? "zones" .!= mempty) <*>
                     (o .:? "kind" .!= "compute#region")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "supportsPzs")
                     <*> (o .:? "quotas" .!= mempty)
                     <*> (o .:? "id")
                     <*> (o .:? "description")
                     <*> (o .:? "deprecated"))

instance ToJSON Region where
        toJSON Region'{..}
          = object
              (catMaybes
                 [("status" .=) <$> _regeStatus,
                  ("zones" .=) <$> _regeZones,
                  Just ("kind" .= _regeKind),
                  ("selfLink" .=) <$> _regeSelfLink,
                  ("name" .=) <$> _regeName,
                  ("creationTimestamp" .=) <$> _regeCreationTimestamp,
                  ("supportsPzs" .=) <$> _regeSupportsPzs,
                  ("quotas" .=) <$> _regeQuotas, ("id" .=) <$> _regeId,
                  ("description" .=) <$> _regeDescription,
                  ("deprecated" .=) <$> _regeDeprecated])

-- | Represents a HA VPN gateway. HA VPN is a high-availability (HA) Cloud
-- VPN solution that lets you securely connect your on-premises network to
-- your Google Cloud Virtual Private Cloud network through an IPsec VPN
-- connection in a single region. For more information about Cloud HA VPN
-- solutions, see Cloud VPN topologies . (== resource_for
-- {$api_version}.vpnGateways ==)
--
-- /See:/ 'vpnGateway' smart constructor.
data VPNGateway =
  VPNGateway'
    { _vgKind :: !Text
    , _vgNetwork :: !(Maybe Text)
    , _vgSelfLink :: !(Maybe Text)
    , _vgName :: !(Maybe Text)
    , _vgCreationTimestamp :: !(Maybe Text)
    , _vgId :: !(Maybe (Textual Word64))
    , _vgLabels :: !(Maybe VPNGatewayLabels)
    , _vgRegion :: !(Maybe Text)
    , _vgLabelFingerprint :: !(Maybe Bytes)
    , _vgDescription :: !(Maybe Text)
    , _vgVPNInterfaces :: !(Maybe [VPNGatewayVPNGatewayInterface])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNGateway' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vgKind'
--
-- * 'vgNetwork'
--
-- * 'vgSelfLink'
--
-- * 'vgName'
--
-- * 'vgCreationTimestamp'
--
-- * 'vgId'
--
-- * 'vgLabels'
--
-- * 'vgRegion'
--
-- * 'vgLabelFingerprint'
--
-- * 'vgDescription'
--
-- * 'vgVPNInterfaces'
vpnGateway
    :: VPNGateway
vpnGateway =
  VPNGateway'
    { _vgKind = "compute#vpnGateway"
    , _vgNetwork = Nothing
    , _vgSelfLink = Nothing
    , _vgName = Nothing
    , _vgCreationTimestamp = Nothing
    , _vgId = Nothing
    , _vgLabels = Nothing
    , _vgRegion = Nothing
    , _vgLabelFingerprint = Nothing
    , _vgDescription = Nothing
    , _vgVPNInterfaces = Nothing
    }


-- | [Output Only] Type of resource. Always compute#vpnGateway for VPN
-- gateways.
vgKind :: Lens' VPNGateway Text
vgKind = lens _vgKind (\ s a -> s{_vgKind = a})

-- | URL of the network to which this VPN gateway is attached. Provided by
-- the client when the VPN gateway is created.
vgNetwork :: Lens' VPNGateway (Maybe Text)
vgNetwork
  = lens _vgNetwork (\ s a -> s{_vgNetwork = a})

-- | [Output Only] Server-defined URL for the resource.
vgSelfLink :: Lens' VPNGateway (Maybe Text)
vgSelfLink
  = lens _vgSelfLink (\ s a -> s{_vgSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
vgName :: Lens' VPNGateway (Maybe Text)
vgName = lens _vgName (\ s a -> s{_vgName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
vgCreationTimestamp :: Lens' VPNGateway (Maybe Text)
vgCreationTimestamp
  = lens _vgCreationTimestamp
      (\ s a -> s{_vgCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
vgId :: Lens' VPNGateway (Maybe Word64)
vgId
  = lens _vgId (\ s a -> s{_vgId = a}) .
      mapping _Coerce

-- | Labels for this resource. These can only be added or modified by the
-- setLabels method. Each label key\/value pair must comply with RFC1035.
-- Label values may be empty.
vgLabels :: Lens' VPNGateway (Maybe VPNGatewayLabels)
vgLabels = lens _vgLabels (\ s a -> s{_vgLabels = a})

-- | [Output Only] URL of the region where the VPN gateway resides.
vgRegion :: Lens' VPNGateway (Maybe Text)
vgRegion = lens _vgRegion (\ s a -> s{_vgRegion = a})

-- | A fingerprint for the labels being applied to this VpnGateway, which is
-- essentially a hash of the labels set used for optimistic locking. The
-- fingerprint is initially generated by Compute Engine and changes after
-- every request to modify or update labels. You must always provide an
-- up-to-date fingerprint hash in order to update or change labels,
-- otherwise the request will fail with error 412 conditionNotMet. To see
-- the latest fingerprint, make a get() request to retrieve an VpnGateway.
vgLabelFingerprint :: Lens' VPNGateway (Maybe ByteString)
vgLabelFingerprint
  = lens _vgLabelFingerprint
      (\ s a -> s{_vgLabelFingerprint = a})
      . mapping _Bytes

-- | An optional description of this resource. Provide this property when you
-- create the resource.
vgDescription :: Lens' VPNGateway (Maybe Text)
vgDescription
  = lens _vgDescription
      (\ s a -> s{_vgDescription = a})

-- | The list of VPN interfaces associated with this VPN gateway.
vgVPNInterfaces :: Lens' VPNGateway [VPNGatewayVPNGatewayInterface]
vgVPNInterfaces
  = lens _vgVPNInterfaces
      (\ s a -> s{_vgVPNInterfaces = a})
      . _Default
      . _Coerce

instance FromJSON VPNGateway where
        parseJSON
          = withObject "VPNGateway"
              (\ o ->
                 VPNGateway' <$>
                   (o .:? "kind" .!= "compute#vpnGateway") <*>
                     (o .:? "network")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "labels")
                     <*> (o .:? "region")
                     <*> (o .:? "labelFingerprint")
                     <*> (o .:? "description")
                     <*> (o .:? "vpnInterfaces" .!= mempty))

instance ToJSON VPNGateway where
        toJSON VPNGateway'{..}
          = object
              (catMaybes
                 [Just ("kind" .= _vgKind),
                  ("network" .=) <$> _vgNetwork,
                  ("selfLink" .=) <$> _vgSelfLink,
                  ("name" .=) <$> _vgName,
                  ("creationTimestamp" .=) <$> _vgCreationTimestamp,
                  ("id" .=) <$> _vgId, ("labels" .=) <$> _vgLabels,
                  ("region" .=) <$> _vgRegion,
                  ("labelFingerprint" .=) <$> _vgLabelFingerprint,
                  ("description" .=) <$> _vgDescription,
                  ("vpnInterfaces" .=) <$> _vgVPNInterfaces])

-- | A policy that specifies how requests intended for the route\'s backends
-- are shadowed to a separate mirrored backend service. Loadbalancer does
-- not wait for responses from the shadow service. Prior to sending traffic
-- to the shadow service, the host \/ authority header is suffixed with
-- -shadow.
--
-- /See:/ 'requestMirrorPolicy' smart constructor.
newtype RequestMirrorPolicy =
  RequestMirrorPolicy'
    { _rmpBackendService :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RequestMirrorPolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rmpBackendService'
requestMirrorPolicy
    :: RequestMirrorPolicy
requestMirrorPolicy = RequestMirrorPolicy' {_rmpBackendService = Nothing}


-- | The full or partial URL to the BackendService resource being mirrored
-- to.
rmpBackendService :: Lens' RequestMirrorPolicy (Maybe Text)
rmpBackendService
  = lens _rmpBackendService
      (\ s a -> s{_rmpBackendService = a})

instance FromJSON RequestMirrorPolicy where
        parseJSON
          = withObject "RequestMirrorPolicy"
              (\ o ->
                 RequestMirrorPolicy' <$> (o .:? "backendService"))

instance ToJSON RequestMirrorPolicy where
        toJSON RequestMirrorPolicy'{..}
          = object
              (catMaybes
                 [("backendService" .=) <$> _rmpBackendService])

--
-- /See:/ 'publicDelegatedPrefixesScopedList' smart constructor.
data PublicDelegatedPrefixesScopedList =
  PublicDelegatedPrefixesScopedList'
    { _pdpslPublicDelegatedPrefixes :: !(Maybe [PublicDelegatedPrefix])
    , _pdpslWarning :: !(Maybe PublicDelegatedPrefixesScopedListWarning)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PublicDelegatedPrefixesScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pdpslPublicDelegatedPrefixes'
--
-- * 'pdpslWarning'
publicDelegatedPrefixesScopedList
    :: PublicDelegatedPrefixesScopedList
publicDelegatedPrefixesScopedList =
  PublicDelegatedPrefixesScopedList'
    {_pdpslPublicDelegatedPrefixes = Nothing, _pdpslWarning = Nothing}


-- | [Output Only] A list of PublicDelegatedPrefixes contained in this scope.
pdpslPublicDelegatedPrefixes :: Lens' PublicDelegatedPrefixesScopedList [PublicDelegatedPrefix]
pdpslPublicDelegatedPrefixes
  = lens _pdpslPublicDelegatedPrefixes
      (\ s a -> s{_pdpslPublicDelegatedPrefixes = a})
      . _Default
      . _Coerce

-- | [Output Only] Informational warning which replaces the list of public
-- delegated prefixes when the list is empty.
pdpslWarning :: Lens' PublicDelegatedPrefixesScopedList (Maybe PublicDelegatedPrefixesScopedListWarning)
pdpslWarning
  = lens _pdpslWarning (\ s a -> s{_pdpslWarning = a})

instance FromJSON PublicDelegatedPrefixesScopedList
         where
        parseJSON
          = withObject "PublicDelegatedPrefixesScopedList"
              (\ o ->
                 PublicDelegatedPrefixesScopedList' <$>
                   (o .:? "publicDelegatedPrefixes" .!= mempty) <*>
                     (o .:? "warning"))

instance ToJSON PublicDelegatedPrefixesScopedList
         where
        toJSON PublicDelegatedPrefixesScopedList'{..}
          = object
              (catMaybes
                 [("publicDelegatedPrefixes" .=) <$>
                    _pdpslPublicDelegatedPrefixes,
                  ("warning" .=) <$> _pdpslWarning])

--
-- /See:/ 'operationListWarningDataItem' smart constructor.
data OperationListWarningDataItem =
  OperationListWarningDataItem'
    { _olwdiValue :: !(Maybe Text)
    , _olwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'OperationListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'olwdiValue'
--
-- * 'olwdiKey'
operationListWarningDataItem
    :: OperationListWarningDataItem
operationListWarningDataItem =
  OperationListWarningDataItem' {_olwdiValue = Nothing, _olwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
olwdiValue :: Lens' OperationListWarningDataItem (Maybe Text)
olwdiValue
  = lens _olwdiValue (\ s a -> s{_olwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
olwdiKey :: Lens' OperationListWarningDataItem (Maybe Text)
olwdiKey = lens _olwdiKey (\ s a -> s{_olwdiKey = a})

instance FromJSON OperationListWarningDataItem where
        parseJSON
          = withObject "OperationListWarningDataItem"
              (\ o ->
                 OperationListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON OperationListWarningDataItem where
        toJSON OperationListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _olwdiValue,
                  ("key" .=) <$> _olwdiKey])

-- | Guest OS features.
--
-- /See:/ 'guestOSFeature' smart constructor.
newtype GuestOSFeature =
  GuestOSFeature'
    { _gofType :: Maybe GuestOSFeatureType
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'GuestOSFeature' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'gofType'
guestOSFeature
    :: GuestOSFeature
guestOSFeature = GuestOSFeature' {_gofType = Nothing}


-- | The ID of a supported feature. Read Enabling guest operating system
-- features to see a list of available options.
gofType :: Lens' GuestOSFeature (Maybe GuestOSFeatureType)
gofType = lens _gofType (\ s a -> s{_gofType = a})

instance FromJSON GuestOSFeature where
        parseJSON
          = withObject "GuestOSFeature"
              (\ o -> GuestOSFeature' <$> (o .:? "type"))

instance ToJSON GuestOSFeature where
        toJSON GuestOSFeature'{..}
          = object (catMaybes [("type" .=) <$> _gofType])

-- | Represents a Cloud VPN Tunnel resource. For more information about VPN,
-- read the the Cloud VPN Overview. (== resource_for
-- {$api_version}.vpnTunnels ==)
--
-- /See:/ 'vpnTunnel' smart constructor.
data VPNTunnel =
  VPNTunnel'
    { _vtDetailedStatus :: !(Maybe Text)
    , _vtStatus :: !(Maybe VPNTunnelStatus)
    , _vtLocalTrafficSelector :: !(Maybe [Text])
    , _vtVPNGatewayInterface :: !(Maybe (Textual Int32))
    , _vtKind :: !Text
    , _vtPeerIP :: !(Maybe Text)
    , _vtRouter :: !(Maybe Text)
    , _vtTargetVPNGateway :: !(Maybe Text)
    , _vtRemoteTrafficSelector :: !(Maybe [Text])
    , _vtSelfLink :: !(Maybe Text)
    , _vtSharedSecret :: !(Maybe Text)
    , _vtName :: !(Maybe Text)
    , _vtPeerExternalGateway :: !(Maybe Text)
    , _vtCreationTimestamp :: !(Maybe Text)
    , _vtPeerExternalGatewayInterface :: !(Maybe (Textual Int32))
    , _vtSharedSecretHash :: !(Maybe Text)
    , _vtId :: !(Maybe (Textual Word64))
    , _vtIkeVersion :: !(Maybe (Textual Int32))
    , _vtRegion :: !(Maybe Text)
    , _vtVPNGateway :: !(Maybe Text)
    , _vtPeerGcpGateway :: !(Maybe Text)
    , _vtDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNTunnel' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vtDetailedStatus'
--
-- * 'vtStatus'
--
-- * 'vtLocalTrafficSelector'
--
-- * 'vtVPNGatewayInterface'
--
-- * 'vtKind'
--
-- * 'vtPeerIP'
--
-- * 'vtRouter'
--
-- * 'vtTargetVPNGateway'
--
-- * 'vtRemoteTrafficSelector'
--
-- * 'vtSelfLink'
--
-- * 'vtSharedSecret'
--
-- * 'vtName'
--
-- * 'vtPeerExternalGateway'
--
-- * 'vtCreationTimestamp'
--
-- * 'vtPeerExternalGatewayInterface'
--
-- * 'vtSharedSecretHash'
--
-- * 'vtId'
--
-- * 'vtIkeVersion'
--
-- * 'vtRegion'
--
-- * 'vtVPNGateway'
--
-- * 'vtPeerGcpGateway'
--
-- * 'vtDescription'
vpnTunnel
    :: VPNTunnel
vpnTunnel =
  VPNTunnel'
    { _vtDetailedStatus = Nothing
    , _vtStatus = Nothing
    , _vtLocalTrafficSelector = Nothing
    , _vtVPNGatewayInterface = Nothing
    , _vtKind = "compute#vpnTunnel"
    , _vtPeerIP = Nothing
    , _vtRouter = Nothing
    , _vtTargetVPNGateway = Nothing
    , _vtRemoteTrafficSelector = Nothing
    , _vtSelfLink = Nothing
    , _vtSharedSecret = Nothing
    , _vtName = Nothing
    , _vtPeerExternalGateway = Nothing
    , _vtCreationTimestamp = Nothing
    , _vtPeerExternalGatewayInterface = Nothing
    , _vtSharedSecretHash = Nothing
    , _vtId = Nothing
    , _vtIkeVersion = Nothing
    , _vtRegion = Nothing
    , _vtVPNGateway = Nothing
    , _vtPeerGcpGateway = Nothing
    , _vtDescription = Nothing
    }


-- | [Output Only] Detailed status message for the VPN tunnel.
vtDetailedStatus :: Lens' VPNTunnel (Maybe Text)
vtDetailedStatus
  = lens _vtDetailedStatus
      (\ s a -> s{_vtDetailedStatus = a})

-- | [Output Only] The status of the VPN tunnel, which can be one of the
-- following: - PROVISIONING: Resource is being allocated for the VPN
-- tunnel. - WAITING_FOR_FULL_CONFIG: Waiting to receive all VPN-related
-- configs from the user. Network, TargetVpnGateway, VpnTunnel,
-- ForwardingRule, and Route resources are needed to setup the VPN tunnel.
-- - FIRST_HANDSHAKE: Successful first handshake with the peer VPN. -
-- ESTABLISHED: Secure session is successfully established with the peer
-- VPN. - NETWORK_ERROR: Deprecated, replaced by NO_INCOMING_PACKETS -
-- AUTHORIZATION_ERROR: Auth error (for example, bad shared secret). -
-- NEGOTIATION_FAILURE: Handshake failed. - DEPROVISIONING: Resources are
-- being deallocated for the VPN tunnel. - FAILED: Tunnel creation has
-- failed and the tunnel is not ready to be used. - NO_INCOMING_PACKETS: No
-- incoming packets from peer. - REJECTED: Tunnel configuration was
-- rejected, can be result of being denied access. - ALLOCATING_RESOURCES:
-- Cloud VPN is in the process of allocating all required resources. -
-- STOPPED: Tunnel is stopped due to its Forwarding Rules being deleted for
-- Classic VPN tunnels or the project is in frozen state. -
-- PEER_IDENTITY_MISMATCH: Peer identity does not match peer IP, probably
-- behind NAT. - TS_NARROWING_NOT_ALLOWED: Traffic selector narrowing not
-- allowed for an HA-VPN tunnel.
vtStatus :: Lens' VPNTunnel (Maybe VPNTunnelStatus)
vtStatus = lens _vtStatus (\ s a -> s{_vtStatus = a})

-- | Local traffic selector to use when establishing the VPN tunnel with the
-- peer VPN gateway. The value should be a CIDR formatted string, for
-- example: 192.168.0.0\/16. The ranges must be disjoint. Only IPv4 is
-- supported.
vtLocalTrafficSelector :: Lens' VPNTunnel [Text]
vtLocalTrafficSelector
  = lens _vtLocalTrafficSelector
      (\ s a -> s{_vtLocalTrafficSelector = a})
      . _Default
      . _Coerce

-- | The interface ID of the VPN gateway with which this VPN tunnel is
-- associated.
vtVPNGatewayInterface :: Lens' VPNTunnel (Maybe Int32)
vtVPNGatewayInterface
  = lens _vtVPNGatewayInterface
      (\ s a -> s{_vtVPNGatewayInterface = a})
      . mapping _Coerce

-- | [Output Only] Type of resource. Always compute#vpnTunnel for VPN
-- tunnels.
vtKind :: Lens' VPNTunnel Text
vtKind = lens _vtKind (\ s a -> s{_vtKind = a})

-- | IP address of the peer VPN gateway. Only IPv4 is supported.
vtPeerIP :: Lens' VPNTunnel (Maybe Text)
vtPeerIP = lens _vtPeerIP (\ s a -> s{_vtPeerIP = a})

-- | URL of the router resource to be used for dynamic routing.
vtRouter :: Lens' VPNTunnel (Maybe Text)
vtRouter = lens _vtRouter (\ s a -> s{_vtRouter = a})

-- | URL of the Target VPN gateway with which this VPN tunnel is associated.
-- Provided by the client when the VPN tunnel is created.
vtTargetVPNGateway :: Lens' VPNTunnel (Maybe Text)
vtTargetVPNGateway
  = lens _vtTargetVPNGateway
      (\ s a -> s{_vtTargetVPNGateway = a})

-- | Remote traffic selectors to use when establishing the VPN tunnel with
-- the peer VPN gateway. The value should be a CIDR formatted string, for
-- example: 192.168.0.0\/16. The ranges should be disjoint. Only IPv4 is
-- supported.
vtRemoteTrafficSelector :: Lens' VPNTunnel [Text]
vtRemoteTrafficSelector
  = lens _vtRemoteTrafficSelector
      (\ s a -> s{_vtRemoteTrafficSelector = a})
      . _Default
      . _Coerce

-- | [Output Only] Server-defined URL for the resource.
vtSelfLink :: Lens' VPNTunnel (Maybe Text)
vtSelfLink
  = lens _vtSelfLink (\ s a -> s{_vtSelfLink = a})

-- | Shared secret used to set the secure session between the Cloud VPN
-- gateway and the peer VPN gateway.
vtSharedSecret :: Lens' VPNTunnel (Maybe Text)
vtSharedSecret
  = lens _vtSharedSecret
      (\ s a -> s{_vtSharedSecret = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
vtName :: Lens' VPNTunnel (Maybe Text)
vtName = lens _vtName (\ s a -> s{_vtName = a})

-- | URL of the peer side external VPN gateway to which this VPN tunnel is
-- connected. Provided by the client when the VPN tunnel is created. This
-- field is exclusive with the field peerGcpGateway.
vtPeerExternalGateway :: Lens' VPNTunnel (Maybe Text)
vtPeerExternalGateway
  = lens _vtPeerExternalGateway
      (\ s a -> s{_vtPeerExternalGateway = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
vtCreationTimestamp :: Lens' VPNTunnel (Maybe Text)
vtCreationTimestamp
  = lens _vtCreationTimestamp
      (\ s a -> s{_vtCreationTimestamp = a})

-- | The interface ID of the external VPN gateway to which this VPN tunnel is
-- connected. Provided by the client when the VPN tunnel is created.
vtPeerExternalGatewayInterface :: Lens' VPNTunnel (Maybe Int32)
vtPeerExternalGatewayInterface
  = lens _vtPeerExternalGatewayInterface
      (\ s a -> s{_vtPeerExternalGatewayInterface = a})
      . mapping _Coerce

-- | Hash of the shared secret.
vtSharedSecretHash :: Lens' VPNTunnel (Maybe Text)
vtSharedSecretHash
  = lens _vtSharedSecretHash
      (\ s a -> s{_vtSharedSecretHash = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
vtId :: Lens' VPNTunnel (Maybe Word64)
vtId
  = lens _vtId (\ s a -> s{_vtId = a}) .
      mapping _Coerce

-- | IKE protocol version to use when establishing the VPN tunnel with the
-- peer VPN gateway. Acceptable IKE versions are 1 or 2. The default
-- version is 2.
vtIkeVersion :: Lens' VPNTunnel (Maybe Int32)
vtIkeVersion
  = lens _vtIkeVersion (\ s a -> s{_vtIkeVersion = a})
      . mapping _Coerce

-- | [Output Only] URL of the region where the VPN tunnel resides. You must
-- specify this field as part of the HTTP request URL. It is not settable
-- as a field in the request body.
vtRegion :: Lens' VPNTunnel (Maybe Text)
vtRegion = lens _vtRegion (\ s a -> s{_vtRegion = a})

-- | URL of the VPN gateway with which this VPN tunnel is associated.
-- Provided by the client when the VPN tunnel is created. This must be used
-- (instead of target_vpn_gateway) if a High Availability VPN gateway
-- resource is created.
vtVPNGateway :: Lens' VPNTunnel (Maybe Text)
vtVPNGateway
  = lens _vtVPNGateway (\ s a -> s{_vtVPNGateway = a})

-- | URL of the peer side HA GCP VPN gateway to which this VPN tunnel is
-- connected. Provided by the client when the VPN tunnel is created. This
-- field can be used when creating highly available VPN from VPC network to
-- VPC network, the field is exclusive with the field peerExternalGateway.
-- If provided, the VPN tunnel will automatically use the same
-- vpnGatewayInterface ID in the peer GCP VPN gateway.
vtPeerGcpGateway :: Lens' VPNTunnel (Maybe Text)
vtPeerGcpGateway
  = lens _vtPeerGcpGateway
      (\ s a -> s{_vtPeerGcpGateway = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource.
vtDescription :: Lens' VPNTunnel (Maybe Text)
vtDescription
  = lens _vtDescription
      (\ s a -> s{_vtDescription = a})

instance FromJSON VPNTunnel where
        parseJSON
          = withObject "VPNTunnel"
              (\ o ->
                 VPNTunnel' <$>
                   (o .:? "detailedStatus") <*> (o .:? "status") <*>
                     (o .:? "localTrafficSelector" .!= mempty)
                     <*> (o .:? "vpnGatewayInterface")
                     <*> (o .:? "kind" .!= "compute#vpnTunnel")
                     <*> (o .:? "peerIp")
                     <*> (o .:? "router")
                     <*> (o .:? "targetVpnGateway")
                     <*> (o .:? "remoteTrafficSelector" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "sharedSecret")
                     <*> (o .:? "name")
                     <*> (o .:? "peerExternalGateway")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "peerExternalGatewayInterface")
                     <*> (o .:? "sharedSecretHash")
                     <*> (o .:? "id")
                     <*> (o .:? "ikeVersion")
                     <*> (o .:? "region")
                     <*> (o .:? "vpnGateway")
                     <*> (o .:? "peerGcpGateway")
                     <*> (o .:? "description"))

instance ToJSON VPNTunnel where
        toJSON VPNTunnel'{..}
          = object
              (catMaybes
                 [("detailedStatus" .=) <$> _vtDetailedStatus,
                  ("status" .=) <$> _vtStatus,
                  ("localTrafficSelector" .=) <$>
                    _vtLocalTrafficSelector,
                  ("vpnGatewayInterface" .=) <$>
                    _vtVPNGatewayInterface,
                  Just ("kind" .= _vtKind),
                  ("peerIp" .=) <$> _vtPeerIP,
                  ("router" .=) <$> _vtRouter,
                  ("targetVpnGateway" .=) <$> _vtTargetVPNGateway,
                  ("remoteTrafficSelector" .=) <$>
                    _vtRemoteTrafficSelector,
                  ("selfLink" .=) <$> _vtSelfLink,
                  ("sharedSecret" .=) <$> _vtSharedSecret,
                  ("name" .=) <$> _vtName,
                  ("peerExternalGateway" .=) <$>
                    _vtPeerExternalGateway,
                  ("creationTimestamp" .=) <$> _vtCreationTimestamp,
                  ("peerExternalGatewayInterface" .=) <$>
                    _vtPeerExternalGatewayInterface,
                  ("sharedSecretHash" .=) <$> _vtSharedSecretHash,
                  ("id" .=) <$> _vtId,
                  ("ikeVersion" .=) <$> _vtIkeVersion,
                  ("region" .=) <$> _vtRegion,
                  ("vpnGateway" .=) <$> _vtVPNGateway,
                  ("peerGcpGateway" .=) <$> _vtPeerGcpGateway,
                  ("description" .=) <$> _vtDescription])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'instanceGroupManagerAggregatedListWarning' smart constructor.
data InstanceGroupManagerAggregatedListWarning =
  InstanceGroupManagerAggregatedListWarning'
    { _igmalwData :: !(Maybe [InstanceGroupManagerAggregatedListWarningDataItem])
    , _igmalwCode :: !(Maybe InstanceGroupManagerAggregatedListWarningCode)
    , _igmalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagerAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmalwData'
--
-- * 'igmalwCode'
--
-- * 'igmalwMessage'
instanceGroupManagerAggregatedListWarning
    :: InstanceGroupManagerAggregatedListWarning
instanceGroupManagerAggregatedListWarning =
  InstanceGroupManagerAggregatedListWarning'
    {_igmalwData = Nothing, _igmalwCode = Nothing, _igmalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
igmalwData :: Lens' InstanceGroupManagerAggregatedListWarning [InstanceGroupManagerAggregatedListWarningDataItem]
igmalwData
  = lens _igmalwData (\ s a -> s{_igmalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
igmalwCode :: Lens' InstanceGroupManagerAggregatedListWarning (Maybe InstanceGroupManagerAggregatedListWarningCode)
igmalwCode
  = lens _igmalwCode (\ s a -> s{_igmalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
igmalwMessage :: Lens' InstanceGroupManagerAggregatedListWarning (Maybe Text)
igmalwMessage
  = lens _igmalwMessage
      (\ s a -> s{_igmalwMessage = a})

instance FromJSON
           InstanceGroupManagerAggregatedListWarning
         where
        parseJSON
          = withObject
              "InstanceGroupManagerAggregatedListWarning"
              (\ o ->
                 InstanceGroupManagerAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON
           InstanceGroupManagerAggregatedListWarning
         where
        toJSON InstanceGroupManagerAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _igmalwData,
                  ("code" .=) <$> _igmalwCode,
                  ("message" .=) <$> _igmalwMessage])

--
-- /See:/ 'diskListWarningDataItem' smart constructor.
data DiskListWarningDataItem =
  DiskListWarningDataItem'
    { _dlwdiValue :: !(Maybe Text)
    , _dlwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'DiskListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dlwdiValue'
--
-- * 'dlwdiKey'
diskListWarningDataItem
    :: DiskListWarningDataItem
diskListWarningDataItem =
  DiskListWarningDataItem' {_dlwdiValue = Nothing, _dlwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
dlwdiValue :: Lens' DiskListWarningDataItem (Maybe Text)
dlwdiValue
  = lens _dlwdiValue (\ s a -> s{_dlwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
dlwdiKey :: Lens' DiskListWarningDataItem (Maybe Text)
dlwdiKey = lens _dlwdiKey (\ s a -> s{_dlwdiKey = a})

instance FromJSON DiskListWarningDataItem where
        parseJSON
          = withObject "DiskListWarningDataItem"
              (\ o ->
                 DiskListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON DiskListWarningDataItem where
        toJSON DiskListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _dlwdiValue,
                  ("key" .=) <$> _dlwdiKey])

-- | A specification of the parameters to use when creating the instance
-- template from a source instance.
--
-- /See:/ 'sourceInstanceParams' smart constructor.
newtype SourceInstanceParams =
  SourceInstanceParams'
    { _sipDiskConfigs :: Maybe [DiskInstantiationConfig]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SourceInstanceParams' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sipDiskConfigs'
sourceInstanceParams
    :: SourceInstanceParams
sourceInstanceParams = SourceInstanceParams' {_sipDiskConfigs = Nothing}


-- | Attached disks configuration. If not provided, defaults are applied: For
-- boot disk and any other R\/W disks, new custom images will be created
-- from each disk. For read-only disks, they will be attached in read-only
-- mode. Local SSD disks will be created as blank volumes.
sipDiskConfigs :: Lens' SourceInstanceParams [DiskInstantiationConfig]
sipDiskConfigs
  = lens _sipDiskConfigs
      (\ s a -> s{_sipDiskConfigs = a})
      . _Default
      . _Coerce

instance FromJSON SourceInstanceParams where
        parseJSON
          = withObject "SourceInstanceParams"
              (\ o ->
                 SourceInstanceParams' <$>
                   (o .:? "diskConfigs" .!= mempty))

instance ToJSON SourceInstanceParams where
        toJSON SourceInstanceParams'{..}
          = object
              (catMaybes [("diskConfigs" .=) <$> _sipDiskConfigs])

-- | An alias IP range attached to an instance\'s network interface.
--
-- /See:/ 'aliasIPRange' smart constructor.
data AliasIPRange =
  AliasIPRange'
    { _airIPCIdRRange :: !(Maybe Text)
    , _airSubnetworkRangeName :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AliasIPRange' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'airIPCIdRRange'
--
-- * 'airSubnetworkRangeName'
aliasIPRange
    :: AliasIPRange
aliasIPRange =
  AliasIPRange' {_airIPCIdRRange = Nothing, _airSubnetworkRangeName = Nothing}


-- | The IP alias ranges to allocate for this interface. This IP CIDR range
-- must belong to the specified subnetwork and cannot contain IP addresses
-- reserved by system or used by other network interfaces. This range may
-- be a single IP address (such as 10.2.3.4), a netmask (such as \/24) or a
-- CIDR-formatted string (such as 10.1.2.0\/24).
airIPCIdRRange :: Lens' AliasIPRange (Maybe Text)
airIPCIdRRange
  = lens _airIPCIdRRange
      (\ s a -> s{_airIPCIdRRange = a})

-- | The name of a subnetwork secondary IP range from which to allocate an IP
-- alias range. If not specified, the primary range of the subnetwork is
-- used.
airSubnetworkRangeName :: Lens' AliasIPRange (Maybe Text)
airSubnetworkRangeName
  = lens _airSubnetworkRangeName
      (\ s a -> s{_airSubnetworkRangeName = a})

instance FromJSON AliasIPRange where
        parseJSON
          = withObject "AliasIPRange"
              (\ o ->
                 AliasIPRange' <$>
                   (o .:? "ipCidrRange") <*>
                     (o .:? "subnetworkRangeName"))

instance ToJSON AliasIPRange where
        toJSON AliasIPRange'{..}
          = object
              (catMaybes
                 [("ipCidrRange" .=) <$> _airIPCIdRRange,
                  ("subnetworkRangeName" .=) <$>
                    _airSubnetworkRangeName])

--
-- /See:/ 'locationPolicyLocation' smart constructor.
newtype LocationPolicyLocation =
  LocationPolicyLocation'
    { _lplPreference :: Maybe LocationPolicyLocationPreference
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'LocationPolicyLocation' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'lplPreference'
locationPolicyLocation
    :: LocationPolicyLocation
locationPolicyLocation = LocationPolicyLocation' {_lplPreference = Nothing}


-- | Preference for a given location: ALLOW or DENY.
lplPreference :: Lens' LocationPolicyLocation (Maybe LocationPolicyLocationPreference)
lplPreference
  = lens _lplPreference
      (\ s a -> s{_lplPreference = a})

instance FromJSON LocationPolicyLocation where
        parseJSON
          = withObject "LocationPolicyLocation"
              (\ o ->
                 LocationPolicyLocation' <$> (o .:? "preference"))

instance ToJSON LocationPolicyLocation where
        toJSON LocationPolicyLocation'{..}
          = object
              (catMaybes [("preference" .=) <$> _lplPreference])

--
-- /See:/ 'nodeTypesScopedListWarningDataItem' smart constructor.
data NodeTypesScopedListWarningDataItem =
  NodeTypesScopedListWarningDataItem'
    { _ntslwditValue :: !(Maybe Text)
    , _ntslwditKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeTypesScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ntslwditValue'
--
-- * 'ntslwditKey'
nodeTypesScopedListWarningDataItem
    :: NodeTypesScopedListWarningDataItem
nodeTypesScopedListWarningDataItem =
  NodeTypesScopedListWarningDataItem'
    {_ntslwditValue = Nothing, _ntslwditKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
ntslwditValue :: Lens' NodeTypesScopedListWarningDataItem (Maybe Text)
ntslwditValue
  = lens _ntslwditValue
      (\ s a -> s{_ntslwditValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
ntslwditKey :: Lens' NodeTypesScopedListWarningDataItem (Maybe Text)
ntslwditKey
  = lens _ntslwditKey (\ s a -> s{_ntslwditKey = a})

instance FromJSON NodeTypesScopedListWarningDataItem
         where
        parseJSON
          = withObject "NodeTypesScopedListWarningDataItem"
              (\ o ->
                 NodeTypesScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON NodeTypesScopedListWarningDataItem
         where
        toJSON NodeTypesScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _ntslwditValue,
                  ("key" .=) <$> _ntslwditKey])

-- | Describes the auto-registration of the Forwarding Rule to Service
-- Directory. The region and project of the Service Directory resource
-- generated from this registration will be the same as this Forwarding
-- Rule.
--
-- /See:/ 'forwardingRuleServiceDirectoryRegistration' smart constructor.
data ForwardingRuleServiceDirectoryRegistration =
  ForwardingRuleServiceDirectoryRegistration'
    { _frsdrService :: !(Maybe Text)
    , _frsdrNamespace :: !(Maybe Text)
    , _frsdrServiceDirectoryRegion :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ForwardingRuleServiceDirectoryRegistration' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'frsdrService'
--
-- * 'frsdrNamespace'
--
-- * 'frsdrServiceDirectoryRegion'
forwardingRuleServiceDirectoryRegistration
    :: ForwardingRuleServiceDirectoryRegistration
forwardingRuleServiceDirectoryRegistration =
  ForwardingRuleServiceDirectoryRegistration'
    { _frsdrService = Nothing
    , _frsdrNamespace = Nothing
    , _frsdrServiceDirectoryRegion = Nothing
    }


-- | Service Directory service to register the forwarding rule under.
frsdrService :: Lens' ForwardingRuleServiceDirectoryRegistration (Maybe Text)
frsdrService
  = lens _frsdrService (\ s a -> s{_frsdrService = a})

-- | Service Directory namespace to register the forwarding rule under.
frsdrNamespace :: Lens' ForwardingRuleServiceDirectoryRegistration (Maybe Text)
frsdrNamespace
  = lens _frsdrNamespace
      (\ s a -> s{_frsdrNamespace = a})

-- | [Optional] Service Directory region to register this global forwarding
-- rule under. Default to \"us-central1\". Only used for PSC for Google
-- APIs. All PSC for Google APIs Forwarding Rules on the same network
-- should use the same Service Directory region.
frsdrServiceDirectoryRegion :: Lens' ForwardingRuleServiceDirectoryRegistration (Maybe Text)
frsdrServiceDirectoryRegion
  = lens _frsdrServiceDirectoryRegion
      (\ s a -> s{_frsdrServiceDirectoryRegion = a})

instance FromJSON
           ForwardingRuleServiceDirectoryRegistration
         where
        parseJSON
          = withObject
              "ForwardingRuleServiceDirectoryRegistration"
              (\ o ->
                 ForwardingRuleServiceDirectoryRegistration' <$>
                   (o .:? "service") <*> (o .:? "namespace") <*>
                     (o .:? "serviceDirectoryRegion"))

instance ToJSON
           ForwardingRuleServiceDirectoryRegistration
         where
        toJSON
          ForwardingRuleServiceDirectoryRegistration'{..}
          = object
              (catMaybes
                 [("service" .=) <$> _frsdrService,
                  ("namespace" .=) <$> _frsdrNamespace,
                  ("serviceDirectoryRegion" .=) <$>
                    _frsdrServiceDirectoryRegion])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'targetInstanceListWarning' smart constructor.
data TargetInstanceListWarning =
  TargetInstanceListWarning'
    { _tilwData :: !(Maybe [TargetInstanceListWarningDataItem])
    , _tilwCode :: !(Maybe TargetInstanceListWarningCode)
    , _tilwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetInstanceListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tilwData'
--
-- * 'tilwCode'
--
-- * 'tilwMessage'
targetInstanceListWarning
    :: TargetInstanceListWarning
targetInstanceListWarning =
  TargetInstanceListWarning'
    {_tilwData = Nothing, _tilwCode = Nothing, _tilwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
tilwData :: Lens' TargetInstanceListWarning [TargetInstanceListWarningDataItem]
tilwData
  = lens _tilwData (\ s a -> s{_tilwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
tilwCode :: Lens' TargetInstanceListWarning (Maybe TargetInstanceListWarningCode)
tilwCode = lens _tilwCode (\ s a -> s{_tilwCode = a})

-- | [Output Only] A human-readable description of the warning code.
tilwMessage :: Lens' TargetInstanceListWarning (Maybe Text)
tilwMessage
  = lens _tilwMessage (\ s a -> s{_tilwMessage = a})

instance FromJSON TargetInstanceListWarning where
        parseJSON
          = withObject "TargetInstanceListWarning"
              (\ o ->
                 TargetInstanceListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON TargetInstanceListWarning where
        toJSON TargetInstanceListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _tilwData,
                  ("code" .=) <$> _tilwCode,
                  ("message" .=) <$> _tilwMessage])

-- | Represent a sole-tenant Node Type resource. Each node within a node
-- group must have a node type. A node type specifies the total amount of
-- cores and memory for that node. Currently, the only available node type
-- is n1-node-96-624 node type that has 96 vCPUs and 624 GB of memory,
-- available in multiple zones. For more information read Node types. (==
-- resource_for {$api_version}.nodeTypes ==)
--
-- /See:/ 'nodeType' smart constructor.
data NodeType =
  NodeType'
    { _ntKind :: !Text
    , _ntZone :: !(Maybe Text)
    , _ntCPUPlatform :: !(Maybe Text)
    , _ntLocalSsdGb :: !(Maybe (Textual Int32))
    , _ntSelfLink :: !(Maybe Text)
    , _ntName :: !(Maybe Text)
    , _ntCreationTimestamp :: !(Maybe Text)
    , _ntId :: !(Maybe (Textual Word64))
    , _ntGuestCPUs :: !(Maybe (Textual Int32))
    , _ntMemoryMb :: !(Maybe (Textual Int32))
    , _ntDescription :: !(Maybe Text)
    , _ntDeprecated :: !(Maybe DeprecationStatus)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeType' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ntKind'
--
-- * 'ntZone'
--
-- * 'ntCPUPlatform'
--
-- * 'ntLocalSsdGb'
--
-- * 'ntSelfLink'
--
-- * 'ntName'
--
-- * 'ntCreationTimestamp'
--
-- * 'ntId'
--
-- * 'ntGuestCPUs'
--
-- * 'ntMemoryMb'
--
-- * 'ntDescription'
--
-- * 'ntDeprecated'
nodeType
    :: NodeType
nodeType =
  NodeType'
    { _ntKind = "compute#nodeType"
    , _ntZone = Nothing
    , _ntCPUPlatform = Nothing
    , _ntLocalSsdGb = Nothing
    , _ntSelfLink = Nothing
    , _ntName = Nothing
    , _ntCreationTimestamp = Nothing
    , _ntId = Nothing
    , _ntGuestCPUs = Nothing
    , _ntMemoryMb = Nothing
    , _ntDescription = Nothing
    , _ntDeprecated = Nothing
    }


-- | [Output Only] The type of the resource. Always compute#nodeType for node
-- types.
ntKind :: Lens' NodeType Text
ntKind = lens _ntKind (\ s a -> s{_ntKind = a})

-- | [Output Only] The name of the zone where the node type resides, such as
-- us-central1-a.
ntZone :: Lens' NodeType (Maybe Text)
ntZone = lens _ntZone (\ s a -> s{_ntZone = a})

-- | [Output Only] The CPU platform used by this node type.
ntCPUPlatform :: Lens' NodeType (Maybe Text)
ntCPUPlatform
  = lens _ntCPUPlatform
      (\ s a -> s{_ntCPUPlatform = a})

-- | [Output Only] Local SSD available to the node type, defined in GB.
ntLocalSsdGb :: Lens' NodeType (Maybe Int32)
ntLocalSsdGb
  = lens _ntLocalSsdGb (\ s a -> s{_ntLocalSsdGb = a})
      . mapping _Coerce

-- | [Output Only] Server-defined URL for the resource.
ntSelfLink :: Lens' NodeType (Maybe Text)
ntSelfLink
  = lens _ntSelfLink (\ s a -> s{_ntSelfLink = a})

-- | [Output Only] Name of the resource.
ntName :: Lens' NodeType (Maybe Text)
ntName = lens _ntName (\ s a -> s{_ntName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
ntCreationTimestamp :: Lens' NodeType (Maybe Text)
ntCreationTimestamp
  = lens _ntCreationTimestamp
      (\ s a -> s{_ntCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
ntId :: Lens' NodeType (Maybe Word64)
ntId
  = lens _ntId (\ s a -> s{_ntId = a}) .
      mapping _Coerce

-- | [Output Only] The number of virtual CPUs that are available to the node
-- type.
ntGuestCPUs :: Lens' NodeType (Maybe Int32)
ntGuestCPUs
  = lens _ntGuestCPUs (\ s a -> s{_ntGuestCPUs = a}) .
      mapping _Coerce

-- | [Output Only] The amount of physical memory available to the node type,
-- defined in MB.
ntMemoryMb :: Lens' NodeType (Maybe Int32)
ntMemoryMb
  = lens _ntMemoryMb (\ s a -> s{_ntMemoryMb = a}) .
      mapping _Coerce

-- | [Output Only] An optional textual description of the resource.
ntDescription :: Lens' NodeType (Maybe Text)
ntDescription
  = lens _ntDescription
      (\ s a -> s{_ntDescription = a})

-- | [Output Only] The deprecation status associated with this node type.
ntDeprecated :: Lens' NodeType (Maybe DeprecationStatus)
ntDeprecated
  = lens _ntDeprecated (\ s a -> s{_ntDeprecated = a})

instance FromJSON NodeType where
        parseJSON
          = withObject "NodeType"
              (\ o ->
                 NodeType' <$>
                   (o .:? "kind" .!= "compute#nodeType") <*>
                     (o .:? "zone")
                     <*> (o .:? "cpuPlatform")
                     <*> (o .:? "localSsdGb")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "guestCpus")
                     <*> (o .:? "memoryMb")
                     <*> (o .:? "description")
                     <*> (o .:? "deprecated"))

instance ToJSON NodeType where
        toJSON NodeType'{..}
          = object
              (catMaybes
                 [Just ("kind" .= _ntKind), ("zone" .=) <$> _ntZone,
                  ("cpuPlatform" .=) <$> _ntCPUPlatform,
                  ("localSsdGb" .=) <$> _ntLocalSsdGb,
                  ("selfLink" .=) <$> _ntSelfLink,
                  ("name" .=) <$> _ntName,
                  ("creationTimestamp" .=) <$> _ntCreationTimestamp,
                  ("id" .=) <$> _ntId,
                  ("guestCpus" .=) <$> _ntGuestCPUs,
                  ("memoryMb" .=) <$> _ntMemoryMb,
                  ("description" .=) <$> _ntDescription,
                  ("deprecated" .=) <$> _ntDeprecated])

-- | Authorization-related information used by Cloud Audit Logging.
--
-- /See:/ 'authorizationLoggingOptions' smart constructor.
newtype AuthorizationLoggingOptions =
  AuthorizationLoggingOptions'
    { _aloPermissionType :: Maybe AuthorizationLoggingOptionsPermissionType
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AuthorizationLoggingOptions' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'aloPermissionType'
authorizationLoggingOptions
    :: AuthorizationLoggingOptions
authorizationLoggingOptions =
  AuthorizationLoggingOptions' {_aloPermissionType = Nothing}


-- | The type of the permission that was checked.
aloPermissionType :: Lens' AuthorizationLoggingOptions (Maybe AuthorizationLoggingOptionsPermissionType)
aloPermissionType
  = lens _aloPermissionType
      (\ s a -> s{_aloPermissionType = a})

instance FromJSON AuthorizationLoggingOptions where
        parseJSON
          = withObject "AuthorizationLoggingOptions"
              (\ o ->
                 AuthorizationLoggingOptions' <$>
                   (o .:? "permissionType"))

instance ToJSON AuthorizationLoggingOptions where
        toJSON AuthorizationLoggingOptions'{..}
          = object
              (catMaybes
                 [("permissionType" .=) <$> _aloPermissionType])

-- | An Identity and Access Management (IAM) policy, which specifies access
-- controls for Google Cloud resources. A \`Policy\` is a collection of
-- \`bindings\`. A \`binding\` binds one or more \`members\` to a single
-- \`role\`. Members can be user accounts, service accounts, Google groups,
-- and domains (such as G Suite). A \`role\` is a named list of
-- permissions; each \`role\` can be an IAM predefined role or a
-- user-created custom role. For some types of Google Cloud resources, a
-- \`binding\` can also specify a \`condition\`, which is a logical
-- expression that allows access to a resource only if the expression
-- evaluates to \`true\`. A condition can add constraints based on
-- attributes of the request, the resource, or both. To learn which
-- resources support conditions in their IAM policies, see the [IAM
-- documentation](https:\/\/cloud.google.com\/iam\/help\/conditions\/resource-policies).
-- **JSON example:** { \"bindings\": [ { \"role\":
-- \"roles\/resourcemanager.organizationAdmin\", \"members\": [
-- \"user:mike\'example.com\", \"group:admins\'example.com\",
-- \"domain:google.com\",
-- \"serviceAccount:my-project-id\'appspot.gserviceaccount.com\" ] }, {
-- \"role\": \"roles\/resourcemanager.organizationViewer\", \"members\": [
-- \"user:eve\'example.com\" ], \"condition\": { \"title\": \"expirable
-- access\", \"description\": \"Does not grant access after Sep 2020\",
-- \"expression\": \"request.time \<
-- timestamp(\'2020-10-01T00:00:00.000Z\')\", } } ], \"etag\":
-- \"BwWWja0YfJA=\", \"version\": 3 } **YAML example:** bindings: -
-- members: - user:mike\'example.com - group:admins\'example.com -
-- domain:google.com -
-- serviceAccount:my-project-id\'appspot.gserviceaccount.com role:
-- roles\/resourcemanager.organizationAdmin - members: -
-- user:eve\'example.com role: roles\/resourcemanager.organizationViewer
-- condition: title: expirable access description: Does not grant access
-- after Sep 2020 expression: request.time \<
-- timestamp(\'2020-10-01T00:00:00.000Z\') - etag: BwWWja0YfJA= - version:
-- 3 For a description of IAM and its features, see the [IAM
-- documentation](https:\/\/cloud.google.com\/iam\/docs\/).
--
-- /See:/ 'policy' smart constructor.
data Policy =
  Policy'
    { _pAuditConfigs :: !(Maybe [AuditConfig])
    , _pEtag :: !(Maybe Bytes)
    , _pRules :: !(Maybe [Rule])
    , _pVersion :: !(Maybe (Textual Int32))
    , _pBindings :: !(Maybe [Binding])
    , _pIAMOwned :: !(Maybe Bool)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Policy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pAuditConfigs'
--
-- * 'pEtag'
--
-- * 'pRules'
--
-- * 'pVersion'
--
-- * 'pBindings'
--
-- * 'pIAMOwned'
policy
    :: Policy
policy =
  Policy'
    { _pAuditConfigs = Nothing
    , _pEtag = Nothing
    , _pRules = Nothing
    , _pVersion = Nothing
    , _pBindings = Nothing
    , _pIAMOwned = Nothing
    }


-- | Specifies cloud audit logging configuration for this policy.
pAuditConfigs :: Lens' Policy [AuditConfig]
pAuditConfigs
  = lens _pAuditConfigs
      (\ s a -> s{_pAuditConfigs = a})
      . _Default
      . _Coerce

-- | \`etag\` is used for optimistic concurrency control as a way to help
-- prevent simultaneous updates of a policy from overwriting each other. It
-- is strongly suggested that systems make use of the \`etag\` in the
-- read-modify-write cycle to perform policy updates in order to avoid race
-- conditions: An \`etag\` is returned in the response to \`getIamPolicy\`,
-- and systems are expected to put that etag in the request to
-- \`setIamPolicy\` to ensure that their change will be applied to the same
-- version of the policy. **Important:** If you use IAM Conditions, you
-- must include the \`etag\` field whenever you call \`setIamPolicy\`. If
-- you omit this field, then IAM allows you to overwrite a version \`3\`
-- policy with a version \`1\` policy, and all of the conditions in the
-- version \`3\` policy are lost.
pEtag :: Lens' Policy (Maybe ByteString)
pEtag
  = lens _pEtag (\ s a -> s{_pEtag = a}) .
      mapping _Bytes

-- | If more than one rule is specified, the rules are applied in the
-- following manner: - All matching LOG rules are always applied. - If any
-- DENY\/DENY_WITH_LOG rule matches, permission is denied. Logging will be
-- applied if one or more matching rule requires logging. - Otherwise, if
-- any ALLOW\/ALLOW_WITH_LOG rule matches, permission is granted. Logging
-- will be applied if one or more matching rule requires logging. -
-- Otherwise, if no rule applies, permission is denied.
pRules :: Lens' Policy [Rule]
pRules
  = lens _pRules (\ s a -> s{_pRules = a}) . _Default .
      _Coerce

-- | Specifies the format of the policy. Valid values are \`0\`, \`1\`, and
-- \`3\`. Requests that specify an invalid value are rejected. Any
-- operation that affects conditional role bindings must specify version
-- \`3\`. This requirement applies to the following operations: * Getting a
-- policy that includes a conditional role binding * Adding a conditional
-- role binding to a policy * Changing a conditional role binding in a
-- policy * Removing any role binding, with or without a condition, from a
-- policy that includes conditions **Important:** If you use IAM
-- Conditions, you must include the \`etag\` field whenever you call
-- \`setIamPolicy\`. If you omit this field, then IAM allows you to
-- overwrite a version \`3\` policy with a version \`1\` policy, and all of
-- the conditions in the version \`3\` policy are lost. If a policy does
-- not include any conditions, operations on that policy may specify any
-- valid version or leave the field unset. To learn which resources support
-- conditions in their IAM policies, see the [IAM
-- documentation](https:\/\/cloud.google.com\/iam\/help\/conditions\/resource-policies).
pVersion :: Lens' Policy (Maybe Int32)
pVersion
  = lens _pVersion (\ s a -> s{_pVersion = a}) .
      mapping _Coerce

-- | Associates a list of \`members\` to a \`role\`. Optionally, may specify
-- a \`condition\` that determines how and when the \`bindings\` are
-- applied. Each of the \`bindings\` must contain at least one member.
pBindings :: Lens' Policy [Binding]
pBindings
  = lens _pBindings (\ s a -> s{_pBindings = a}) .
      _Default
      . _Coerce

-- |
pIAMOwned :: Lens' Policy (Maybe Bool)
pIAMOwned
  = lens _pIAMOwned (\ s a -> s{_pIAMOwned = a})

instance FromJSON Policy where
        parseJSON
          = withObject "Policy"
              (\ o ->
                 Policy' <$>
                   (o .:? "auditConfigs" .!= mempty) <*> (o .:? "etag")
                     <*> (o .:? "rules" .!= mempty)
                     <*> (o .:? "version")
                     <*> (o .:? "bindings" .!= mempty)
                     <*> (o .:? "iamOwned"))

instance ToJSON Policy where
        toJSON Policy'{..}
          = object
              (catMaybes
                 [("auditConfigs" .=) <$> _pAuditConfigs,
                  ("etag" .=) <$> _pEtag, ("rules" .=) <$> _pRules,
                  ("version" .=) <$> _pVersion,
                  ("bindings" .=) <$> _pBindings,
                  ("iamOwned" .=) <$> _pIAMOwned])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'operationAggregatedListWarning' smart constructor.
data OperationAggregatedListWarning =
  OperationAggregatedListWarning'
    { _oalwData :: !(Maybe [OperationAggregatedListWarningDataItem])
    , _oalwCode :: !(Maybe OperationAggregatedListWarningCode)
    , _oalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'OperationAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'oalwData'
--
-- * 'oalwCode'
--
-- * 'oalwMessage'
operationAggregatedListWarning
    :: OperationAggregatedListWarning
operationAggregatedListWarning =
  OperationAggregatedListWarning'
    {_oalwData = Nothing, _oalwCode = Nothing, _oalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
oalwData :: Lens' OperationAggregatedListWarning [OperationAggregatedListWarningDataItem]
oalwData
  = lens _oalwData (\ s a -> s{_oalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
oalwCode :: Lens' OperationAggregatedListWarning (Maybe OperationAggregatedListWarningCode)
oalwCode = lens _oalwCode (\ s a -> s{_oalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
oalwMessage :: Lens' OperationAggregatedListWarning (Maybe Text)
oalwMessage
  = lens _oalwMessage (\ s a -> s{_oalwMessage = a})

instance FromJSON OperationAggregatedListWarning
         where
        parseJSON
          = withObject "OperationAggregatedListWarning"
              (\ o ->
                 OperationAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON OperationAggregatedListWarning where
        toJSON OperationAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _oalwData,
                  ("code" .=) <$> _oalwCode,
                  ("message" .=) <$> _oalwMessage])

--
-- /See:/ 'targetInstanceAggregatedListWarningDataItem' smart constructor.
data TargetInstanceAggregatedListWarningDataItem =
  TargetInstanceAggregatedListWarningDataItem'
    { _tialwdiValue :: !(Maybe Text)
    , _tialwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetInstanceAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tialwdiValue'
--
-- * 'tialwdiKey'
targetInstanceAggregatedListWarningDataItem
    :: TargetInstanceAggregatedListWarningDataItem
targetInstanceAggregatedListWarningDataItem =
  TargetInstanceAggregatedListWarningDataItem'
    {_tialwdiValue = Nothing, _tialwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
tialwdiValue :: Lens' TargetInstanceAggregatedListWarningDataItem (Maybe Text)
tialwdiValue
  = lens _tialwdiValue (\ s a -> s{_tialwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
tialwdiKey :: Lens' TargetInstanceAggregatedListWarningDataItem (Maybe Text)
tialwdiKey
  = lens _tialwdiKey (\ s a -> s{_tialwdiKey = a})

instance FromJSON
           TargetInstanceAggregatedListWarningDataItem
         where
        parseJSON
          = withObject
              "TargetInstanceAggregatedListWarningDataItem"
              (\ o ->
                 TargetInstanceAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           TargetInstanceAggregatedListWarningDataItem
         where
        toJSON
          TargetInstanceAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _tialwdiValue,
                  ("key" .=) <$> _tialwdiKey])

-- | [Output Only] Informational warning which replaces the list of
-- operations when the list is empty.
--
-- /See:/ 'operationsScopedListWarning' smart constructor.
data OperationsScopedListWarning =
  OperationsScopedListWarning'
    { _oslwData :: !(Maybe [OperationsScopedListWarningDataItem])
    , _oslwCode :: !(Maybe OperationsScopedListWarningCode)
    , _oslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'OperationsScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'oslwData'
--
-- * 'oslwCode'
--
-- * 'oslwMessage'
operationsScopedListWarning
    :: OperationsScopedListWarning
operationsScopedListWarning =
  OperationsScopedListWarning'
    {_oslwData = Nothing, _oslwCode = Nothing, _oslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
oslwData :: Lens' OperationsScopedListWarning [OperationsScopedListWarningDataItem]
oslwData
  = lens _oslwData (\ s a -> s{_oslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
oslwCode :: Lens' OperationsScopedListWarning (Maybe OperationsScopedListWarningCode)
oslwCode = lens _oslwCode (\ s a -> s{_oslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
oslwMessage :: Lens' OperationsScopedListWarning (Maybe Text)
oslwMessage
  = lens _oslwMessage (\ s a -> s{_oslwMessage = a})

instance FromJSON OperationsScopedListWarning where
        parseJSON
          = withObject "OperationsScopedListWarning"
              (\ o ->
                 OperationsScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON OperationsScopedListWarning where
        toJSON OperationsScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _oslwData,
                  ("code" .=) <$> _oslwCode,
                  ("message" .=) <$> _oslwMessage])

--
-- /See:/ 'regionDiskTypeListWarningDataItem' smart constructor.
data RegionDiskTypeListWarningDataItem =
  RegionDiskTypeListWarningDataItem'
    { _rdtlwdiValue :: !(Maybe Text)
    , _rdtlwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionDiskTypeListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rdtlwdiValue'
--
-- * 'rdtlwdiKey'
regionDiskTypeListWarningDataItem
    :: RegionDiskTypeListWarningDataItem
regionDiskTypeListWarningDataItem =
  RegionDiskTypeListWarningDataItem'
    {_rdtlwdiValue = Nothing, _rdtlwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
rdtlwdiValue :: Lens' RegionDiskTypeListWarningDataItem (Maybe Text)
rdtlwdiValue
  = lens _rdtlwdiValue (\ s a -> s{_rdtlwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
rdtlwdiKey :: Lens' RegionDiskTypeListWarningDataItem (Maybe Text)
rdtlwdiKey
  = lens _rdtlwdiKey (\ s a -> s{_rdtlwdiKey = a})

instance FromJSON RegionDiskTypeListWarningDataItem
         where
        parseJSON
          = withObject "RegionDiskTypeListWarningDataItem"
              (\ o ->
                 RegionDiskTypeListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON RegionDiskTypeListWarningDataItem
         where
        toJSON RegionDiskTypeListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _rdtlwdiValue,
                  ("key" .=) <$> _rdtlwdiKey])

--
-- /See:/ 'forwardingRuleListWarningDataItem' smart constructor.
data ForwardingRuleListWarningDataItem =
  ForwardingRuleListWarningDataItem'
    { _frlwdiValue :: !(Maybe Text)
    , _frlwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ForwardingRuleListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'frlwdiValue'
--
-- * 'frlwdiKey'
forwardingRuleListWarningDataItem
    :: ForwardingRuleListWarningDataItem
forwardingRuleListWarningDataItem =
  ForwardingRuleListWarningDataItem'
    {_frlwdiValue = Nothing, _frlwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
frlwdiValue :: Lens' ForwardingRuleListWarningDataItem (Maybe Text)
frlwdiValue
  = lens _frlwdiValue (\ s a -> s{_frlwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
frlwdiKey :: Lens' ForwardingRuleListWarningDataItem (Maybe Text)
frlwdiKey
  = lens _frlwdiKey (\ s a -> s{_frlwdiKey = a})

instance FromJSON ForwardingRuleListWarningDataItem
         where
        parseJSON
          = withObject "ForwardingRuleListWarningDataItem"
              (\ o ->
                 ForwardingRuleListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON ForwardingRuleListWarningDataItem
         where
        toJSON ForwardingRuleListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _frlwdiValue,
                  ("key" .=) <$> _frlwdiKey])

-- | Sets the scheduling options for an Instance. NextID: 21
--
-- /See:/ 'scheduling' smart constructor.
data Scheduling =
  Scheduling'
    { _sMinNodeCPUs :: !(Maybe (Textual Int32))
    , _sAutomaticRestart :: !(Maybe Bool)
    , _sNodeAffinities :: !(Maybe [SchedulingNodeAffinity])
    , _sOnHostMaintenance :: !(Maybe SchedulingOnHostMaintenance)
    , _sLocationHint :: !(Maybe Text)
    , _sPreemptible :: !(Maybe Bool)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Scheduling' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sMinNodeCPUs'
--
-- * 'sAutomaticRestart'
--
-- * 'sNodeAffinities'
--
-- * 'sOnHostMaintenance'
--
-- * 'sLocationHint'
--
-- * 'sPreemptible'
scheduling
    :: Scheduling
scheduling =
  Scheduling'
    { _sMinNodeCPUs = Nothing
    , _sAutomaticRestart = Nothing
    , _sNodeAffinities = Nothing
    , _sOnHostMaintenance = Nothing
    , _sLocationHint = Nothing
    , _sPreemptible = Nothing
    }


-- | The minimum number of virtual CPUs this instance will consume when
-- running on a sole-tenant node.
sMinNodeCPUs :: Lens' Scheduling (Maybe Int32)
sMinNodeCPUs
  = lens _sMinNodeCPUs (\ s a -> s{_sMinNodeCPUs = a})
      . mapping _Coerce

-- | Specifies whether the instance should be automatically restarted if it
-- is terminated by Compute Engine (not terminated by a user). You can only
-- set the automatic restart option for standard instances. Preemptible
-- instances cannot be automatically restarted. By default, this is set to
-- true so an instance is automatically restarted if it is terminated by
-- Compute Engine.
sAutomaticRestart :: Lens' Scheduling (Maybe Bool)
sAutomaticRestart
  = lens _sAutomaticRestart
      (\ s a -> s{_sAutomaticRestart = a})

-- | A set of node affinity and anti-affinity configurations. Refer to
-- Configuring node affinity for more information. Overrides
-- reservationAffinity.
sNodeAffinities :: Lens' Scheduling [SchedulingNodeAffinity]
sNodeAffinities
  = lens _sNodeAffinities
      (\ s a -> s{_sNodeAffinities = a})
      . _Default
      . _Coerce

-- | Defines the maintenance behavior for this instance. For standard
-- instances, the default behavior is MIGRATE. For preemptible instances,
-- the default and only possible behavior is TERMINATE. For more
-- information, see Setting Instance Scheduling Options.
sOnHostMaintenance :: Lens' Scheduling (Maybe SchedulingOnHostMaintenance)
sOnHostMaintenance
  = lens _sOnHostMaintenance
      (\ s a -> s{_sOnHostMaintenance = a})

-- | An opaque location hint used to place the instance close to other
-- resources. This field is for use by internal tools that use the public
-- API.
sLocationHint :: Lens' Scheduling (Maybe Text)
sLocationHint
  = lens _sLocationHint
      (\ s a -> s{_sLocationHint = a})

-- | Defines whether the instance is preemptible. This can only be set during
-- instance creation or while the instance is stopped and therefore, in a
-- \`TERMINATED\` state. See Instance Life Cycle for more information on
-- the possible instance states.
sPreemptible :: Lens' Scheduling (Maybe Bool)
sPreemptible
  = lens _sPreemptible (\ s a -> s{_sPreemptible = a})

instance FromJSON Scheduling where
        parseJSON
          = withObject "Scheduling"
              (\ o ->
                 Scheduling' <$>
                   (o .:? "minNodeCpus") <*> (o .:? "automaticRestart")
                     <*> (o .:? "nodeAffinities" .!= mempty)
                     <*> (o .:? "onHostMaintenance")
                     <*> (o .:? "locationHint")
                     <*> (o .:? "preemptible"))

instance ToJSON Scheduling where
        toJSON Scheduling'{..}
          = object
              (catMaybes
                 [("minNodeCpus" .=) <$> _sMinNodeCPUs,
                  ("automaticRestart" .=) <$> _sAutomaticRestart,
                  ("nodeAffinities" .=) <$> _sNodeAffinities,
                  ("onHostMaintenance" .=) <$> _sOnHostMaintenance,
                  ("locationHint" .=) <$> _sLocationHint,
                  ("preemptible" .=) <$> _sPreemptible])

--
-- /See:/ 'vpnTunnelsScopedListWarningDataItem' smart constructor.
data VPNTunnelsScopedListWarningDataItem =
  VPNTunnelsScopedListWarningDataItem'
    { _vtslwdiValue :: !(Maybe Text)
    , _vtslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNTunnelsScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vtslwdiValue'
--
-- * 'vtslwdiKey'
vpnTunnelsScopedListWarningDataItem
    :: VPNTunnelsScopedListWarningDataItem
vpnTunnelsScopedListWarningDataItem =
  VPNTunnelsScopedListWarningDataItem'
    {_vtslwdiValue = Nothing, _vtslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
vtslwdiValue :: Lens' VPNTunnelsScopedListWarningDataItem (Maybe Text)
vtslwdiValue
  = lens _vtslwdiValue (\ s a -> s{_vtslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
vtslwdiKey :: Lens' VPNTunnelsScopedListWarningDataItem (Maybe Text)
vtslwdiKey
  = lens _vtslwdiKey (\ s a -> s{_vtslwdiKey = a})

instance FromJSON VPNTunnelsScopedListWarningDataItem
         where
        parseJSON
          = withObject "VPNTunnelsScopedListWarningDataItem"
              (\ o ->
                 VPNTunnelsScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON VPNTunnelsScopedListWarningDataItem
         where
        toJSON VPNTunnelsScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _vtslwdiValue,
                  ("key" .=) <$> _vtslwdiKey])

-- | Response to the list request, and contains a list of interconnects.
--
-- /See:/ 'interconnectList' smart constructor.
data InterconnectList =
  InterconnectList'
    { _intnNextPageToken :: !(Maybe Text)
    , _intnKind :: !Text
    , _intnItems :: !(Maybe [Interconnect])
    , _intnSelfLink :: !(Maybe Text)
    , _intnWarning :: !(Maybe InterconnectListWarning)
    , _intnId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'intnNextPageToken'
--
-- * 'intnKind'
--
-- * 'intnItems'
--
-- * 'intnSelfLink'
--
-- * 'intnWarning'
--
-- * 'intnId'
interconnectList
    :: InterconnectList
interconnectList =
  InterconnectList'
    { _intnNextPageToken = Nothing
    , _intnKind = "compute#interconnectList"
    , _intnItems = Nothing
    , _intnSelfLink = Nothing
    , _intnWarning = Nothing
    , _intnId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
intnNextPageToken :: Lens' InterconnectList (Maybe Text)
intnNextPageToken
  = lens _intnNextPageToken
      (\ s a -> s{_intnNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#interconnectList for
-- lists of interconnects.
intnKind :: Lens' InterconnectList Text
intnKind = lens _intnKind (\ s a -> s{_intnKind = a})

-- | A list of Interconnect resources.
intnItems :: Lens' InterconnectList [Interconnect]
intnItems
  = lens _intnItems (\ s a -> s{_intnItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
intnSelfLink :: Lens' InterconnectList (Maybe Text)
intnSelfLink
  = lens _intnSelfLink (\ s a -> s{_intnSelfLink = a})

-- | [Output Only] Informational warning message.
intnWarning :: Lens' InterconnectList (Maybe InterconnectListWarning)
intnWarning
  = lens _intnWarning (\ s a -> s{_intnWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
intnId :: Lens' InterconnectList (Maybe Text)
intnId = lens _intnId (\ s a -> s{_intnId = a})

instance FromJSON InterconnectList where
        parseJSON
          = withObject "InterconnectList"
              (\ o ->
                 InterconnectList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#interconnectList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON InterconnectList where
        toJSON InterconnectList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _intnNextPageToken,
                  Just ("kind" .= _intnKind),
                  ("items" .=) <$> _intnItems,
                  ("selfLink" .=) <$> _intnSelfLink,
                  ("warning" .=) <$> _intnWarning,
                  ("id" .=) <$> _intnId])

--
-- /See:/ 'targetPoolListWarningDataItem' smart constructor.
data TargetPoolListWarningDataItem =
  TargetPoolListWarningDataItem'
    { _tplwdiValue :: !(Maybe Text)
    , _tplwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetPoolListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tplwdiValue'
--
-- * 'tplwdiKey'
targetPoolListWarningDataItem
    :: TargetPoolListWarningDataItem
targetPoolListWarningDataItem =
  TargetPoolListWarningDataItem' {_tplwdiValue = Nothing, _tplwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
tplwdiValue :: Lens' TargetPoolListWarningDataItem (Maybe Text)
tplwdiValue
  = lens _tplwdiValue (\ s a -> s{_tplwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
tplwdiKey :: Lens' TargetPoolListWarningDataItem (Maybe Text)
tplwdiKey
  = lens _tplwdiKey (\ s a -> s{_tplwdiKey = a})

instance FromJSON TargetPoolListWarningDataItem where
        parseJSON
          = withObject "TargetPoolListWarningDataItem"
              (\ o ->
                 TargetPoolListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON TargetPoolListWarningDataItem where
        toJSON TargetPoolListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _tplwdiValue,
                  ("key" .=) <$> _tplwdiKey])

-- | Represent a sole-tenant Node Template resource. You can use a template
-- to define properties for nodes in a node group. For more information,
-- read Creating node groups and instances. (== resource_for
-- {$api_version}.nodeTemplates ==)
--
-- /See:/ 'nodeTemplate' smart constructor.
data NodeTemplate =
  NodeTemplate'
    { _nttStatus :: !(Maybe NodeTemplateStatus)
    , _nttKind :: !Text
    , _nttSelfLink :: !(Maybe Text)
    , _nttServerBinding :: !(Maybe ServerBinding)
    , _nttAccelerators :: !(Maybe [AcceleratorConfig])
    , _nttName :: !(Maybe Text)
    , _nttStatusMessage :: !(Maybe Text)
    , _nttCreationTimestamp :: !(Maybe Text)
    , _nttNodeAffinityLabels :: !(Maybe NodeTemplateNodeAffinityLabels)
    , _nttId :: !(Maybe (Textual Word64))
    , _nttNodeTypeFlexibility :: !(Maybe NodeTemplateNodeTypeFlexibility)
    , _nttNodeType :: !(Maybe Text)
    , _nttRegion :: !(Maybe Text)
    , _nttDisks :: !(Maybe [LocalDisk])
    , _nttDescription :: !(Maybe Text)
    , _nttCPUOvercommitType :: !(Maybe NodeTemplateCPUOvercommitType)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeTemplate' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nttStatus'
--
-- * 'nttKind'
--
-- * 'nttSelfLink'
--
-- * 'nttServerBinding'
--
-- * 'nttAccelerators'
--
-- * 'nttName'
--
-- * 'nttStatusMessage'
--
-- * 'nttCreationTimestamp'
--
-- * 'nttNodeAffinityLabels'
--
-- * 'nttId'
--
-- * 'nttNodeTypeFlexibility'
--
-- * 'nttNodeType'
--
-- * 'nttRegion'
--
-- * 'nttDisks'
--
-- * 'nttDescription'
--
-- * 'nttCPUOvercommitType'
nodeTemplate
    :: NodeTemplate
nodeTemplate =
  NodeTemplate'
    { _nttStatus = Nothing
    , _nttKind = "compute#nodeTemplate"
    , _nttSelfLink = Nothing
    , _nttServerBinding = Nothing
    , _nttAccelerators = Nothing
    , _nttName = Nothing
    , _nttStatusMessage = Nothing
    , _nttCreationTimestamp = Nothing
    , _nttNodeAffinityLabels = Nothing
    , _nttId = Nothing
    , _nttNodeTypeFlexibility = Nothing
    , _nttNodeType = Nothing
    , _nttRegion = Nothing
    , _nttDisks = Nothing
    , _nttDescription = Nothing
    , _nttCPUOvercommitType = Nothing
    }


-- | [Output Only] The status of the node template. One of the following
-- values: CREATING, READY, and DELETING.
nttStatus :: Lens' NodeTemplate (Maybe NodeTemplateStatus)
nttStatus
  = lens _nttStatus (\ s a -> s{_nttStatus = a})

-- | [Output Only] The type of the resource. Always compute#nodeTemplate for
-- node templates.
nttKind :: Lens' NodeTemplate Text
nttKind = lens _nttKind (\ s a -> s{_nttKind = a})

-- | [Output Only] Server-defined URL for the resource.
nttSelfLink :: Lens' NodeTemplate (Maybe Text)
nttSelfLink
  = lens _nttSelfLink (\ s a -> s{_nttSelfLink = a})

-- | Sets the binding properties for the physical server. Valid values
-- include: - [Default] RESTART_NODE_ON_ANY_SERVER: Restarts VMs on any
-- available physical server - RESTART_NODE_ON_MINIMAL_SERVER: Restarts VMs
-- on the same physical server whenever possible See Sole-tenant node
-- options for more information.
nttServerBinding :: Lens' NodeTemplate (Maybe ServerBinding)
nttServerBinding
  = lens _nttServerBinding
      (\ s a -> s{_nttServerBinding = a})

nttAccelerators :: Lens' NodeTemplate [AcceleratorConfig]
nttAccelerators
  = lens _nttAccelerators
      (\ s a -> s{_nttAccelerators = a})
      . _Default
      . _Coerce

-- | The name of the resource, provided by the client when initially creating
-- the resource. The resource name must be 1-63 characters long, and comply
-- with RFC1035. Specifically, the name must be 1-63 characters long and
-- match the regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means
-- the first character must be a lowercase letter, and all following
-- characters must be a dash, lowercase letter, or digit, except the last
-- character, which cannot be a dash.
nttName :: Lens' NodeTemplate (Maybe Text)
nttName = lens _nttName (\ s a -> s{_nttName = a})

-- | [Output Only] An optional, human-readable explanation of the status.
nttStatusMessage :: Lens' NodeTemplate (Maybe Text)
nttStatusMessage
  = lens _nttStatusMessage
      (\ s a -> s{_nttStatusMessage = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
nttCreationTimestamp :: Lens' NodeTemplate (Maybe Text)
nttCreationTimestamp
  = lens _nttCreationTimestamp
      (\ s a -> s{_nttCreationTimestamp = a})

-- | Labels to use for node affinity, which will be used in instance
-- scheduling.
nttNodeAffinityLabels :: Lens' NodeTemplate (Maybe NodeTemplateNodeAffinityLabels)
nttNodeAffinityLabels
  = lens _nttNodeAffinityLabels
      (\ s a -> s{_nttNodeAffinityLabels = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
nttId :: Lens' NodeTemplate (Maybe Word64)
nttId
  = lens _nttId (\ s a -> s{_nttId = a}) .
      mapping _Coerce

-- | The flexible properties of the desired node type. Node groups that use
-- this node template will create nodes of a type that matches these
-- properties. This field is mutually exclusive with the node_type
-- property; you can only define one or the other, but not both.
nttNodeTypeFlexibility :: Lens' NodeTemplate (Maybe NodeTemplateNodeTypeFlexibility)
nttNodeTypeFlexibility
  = lens _nttNodeTypeFlexibility
      (\ s a -> s{_nttNodeTypeFlexibility = a})

-- | The node type to use for nodes group that are created from this
-- template.
nttNodeType :: Lens' NodeTemplate (Maybe Text)
nttNodeType
  = lens _nttNodeType (\ s a -> s{_nttNodeType = a})

-- | [Output Only] The name of the region where the node template resides,
-- such as us-central1.
nttRegion :: Lens' NodeTemplate (Maybe Text)
nttRegion
  = lens _nttRegion (\ s a -> s{_nttRegion = a})

nttDisks :: Lens' NodeTemplate [LocalDisk]
nttDisks
  = lens _nttDisks (\ s a -> s{_nttDisks = a}) .
      _Default
      . _Coerce

-- | An optional description of this resource. Provide this property when you
-- create the resource.
nttDescription :: Lens' NodeTemplate (Maybe Text)
nttDescription
  = lens _nttDescription
      (\ s a -> s{_nttDescription = a})

-- | CPU overcommit.
nttCPUOvercommitType :: Lens' NodeTemplate (Maybe NodeTemplateCPUOvercommitType)
nttCPUOvercommitType
  = lens _nttCPUOvercommitType
      (\ s a -> s{_nttCPUOvercommitType = a})

instance FromJSON NodeTemplate where
        parseJSON
          = withObject "NodeTemplate"
              (\ o ->
                 NodeTemplate' <$>
                   (o .:? "status") <*>
                     (o .:? "kind" .!= "compute#nodeTemplate")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "serverBinding")
                     <*> (o .:? "accelerators" .!= mempty)
                     <*> (o .:? "name")
                     <*> (o .:? "statusMessage")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "nodeAffinityLabels")
                     <*> (o .:? "id")
                     <*> (o .:? "nodeTypeFlexibility")
                     <*> (o .:? "nodeType")
                     <*> (o .:? "region")
                     <*> (o .:? "disks" .!= mempty)
                     <*> (o .:? "description")
                     <*> (o .:? "cpuOvercommitType"))

instance ToJSON NodeTemplate where
        toJSON NodeTemplate'{..}
          = object
              (catMaybes
                 [("status" .=) <$> _nttStatus,
                  Just ("kind" .= _nttKind),
                  ("selfLink" .=) <$> _nttSelfLink,
                  ("serverBinding" .=) <$> _nttServerBinding,
                  ("accelerators" .=) <$> _nttAccelerators,
                  ("name" .=) <$> _nttName,
                  ("statusMessage" .=) <$> _nttStatusMessage,
                  ("creationTimestamp" .=) <$> _nttCreationTimestamp,
                  ("nodeAffinityLabels" .=) <$> _nttNodeAffinityLabels,
                  ("id" .=) <$> _nttId,
                  ("nodeTypeFlexibility" .=) <$>
                    _nttNodeTypeFlexibility,
                  ("nodeType" .=) <$> _nttNodeType,
                  ("region" .=) <$> _nttRegion,
                  ("disks" .=) <$> _nttDisks,
                  ("description" .=) <$> _nttDescription,
                  ("cpuOvercommitType" .=) <$> _nttCPUOvercommitType])

--
-- /See:/ 'networksGetEffectiveFirewallsResponse' smart constructor.
data NetworksGetEffectiveFirewallsResponse =
  NetworksGetEffectiveFirewallsResponse'
    { _ngefrFirewallPolicys :: !(Maybe [NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy])
    , _ngefrFirewalls :: !(Maybe [Firewall])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworksGetEffectiveFirewallsResponse' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ngefrFirewallPolicys'
--
-- * 'ngefrFirewalls'
networksGetEffectiveFirewallsResponse
    :: NetworksGetEffectiveFirewallsResponse
networksGetEffectiveFirewallsResponse =
  NetworksGetEffectiveFirewallsResponse'
    {_ngefrFirewallPolicys = Nothing, _ngefrFirewalls = Nothing}


-- | Effective firewalls from firewall policy.
ngefrFirewallPolicys :: Lens' NetworksGetEffectiveFirewallsResponse [NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy]
ngefrFirewallPolicys
  = lens _ngefrFirewallPolicys
      (\ s a -> s{_ngefrFirewallPolicys = a})
      . _Default
      . _Coerce

-- | Effective firewalls on the network.
ngefrFirewalls :: Lens' NetworksGetEffectiveFirewallsResponse [Firewall]
ngefrFirewalls
  = lens _ngefrFirewalls
      (\ s a -> s{_ngefrFirewalls = a})
      . _Default
      . _Coerce

instance FromJSON
           NetworksGetEffectiveFirewallsResponse
         where
        parseJSON
          = withObject "NetworksGetEffectiveFirewallsResponse"
              (\ o ->
                 NetworksGetEffectiveFirewallsResponse' <$>
                   (o .:? "firewallPolicys" .!= mempty) <*>
                     (o .:? "firewalls" .!= mempty))

instance ToJSON NetworksGetEffectiveFirewallsResponse
         where
        toJSON NetworksGetEffectiveFirewallsResponse'{..}
          = object
              (catMaybes
                 [("firewallPolicys" .=) <$> _ngefrFirewallPolicys,
                  ("firewalls" .=) <$> _ngefrFirewalls])

--
-- /See:/ 'networkEndpointGroupList' smart constructor.
data NetworkEndpointGroupList =
  NetworkEndpointGroupList'
    { _neglNextPageToken :: !(Maybe Text)
    , _neglKind :: !Text
    , _neglItems :: !(Maybe [NetworkEndpointGroup])
    , _neglSelfLink :: !(Maybe Text)
    , _neglWarning :: !(Maybe NetworkEndpointGroupListWarning)
    , _neglId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkEndpointGroupList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'neglNextPageToken'
--
-- * 'neglKind'
--
-- * 'neglItems'
--
-- * 'neglSelfLink'
--
-- * 'neglWarning'
--
-- * 'neglId'
networkEndpointGroupList
    :: NetworkEndpointGroupList
networkEndpointGroupList =
  NetworkEndpointGroupList'
    { _neglNextPageToken = Nothing
    , _neglKind = "compute#networkEndpointGroupList"
    , _neglItems = Nothing
    , _neglSelfLink = Nothing
    , _neglWarning = Nothing
    , _neglId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
neglNextPageToken :: Lens' NetworkEndpointGroupList (Maybe Text)
neglNextPageToken
  = lens _neglNextPageToken
      (\ s a -> s{_neglNextPageToken = a})

-- | [Output Only] The resource type, which is always
-- compute#networkEndpointGroupList for network endpoint group lists.
neglKind :: Lens' NetworkEndpointGroupList Text
neglKind = lens _neglKind (\ s a -> s{_neglKind = a})

-- | A list of NetworkEndpointGroup resources.
neglItems :: Lens' NetworkEndpointGroupList [NetworkEndpointGroup]
neglItems
  = lens _neglItems (\ s a -> s{_neglItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
neglSelfLink :: Lens' NetworkEndpointGroupList (Maybe Text)
neglSelfLink
  = lens _neglSelfLink (\ s a -> s{_neglSelfLink = a})

-- | [Output Only] Informational warning message.
neglWarning :: Lens' NetworkEndpointGroupList (Maybe NetworkEndpointGroupListWarning)
neglWarning
  = lens _neglWarning (\ s a -> s{_neglWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
neglId :: Lens' NetworkEndpointGroupList (Maybe Text)
neglId = lens _neglId (\ s a -> s{_neglId = a})

instance FromJSON NetworkEndpointGroupList where
        parseJSON
          = withObject "NetworkEndpointGroupList"
              (\ o ->
                 NetworkEndpointGroupList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#networkEndpointGroupList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON NetworkEndpointGroupList where
        toJSON NetworkEndpointGroupList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _neglNextPageToken,
                  Just ("kind" .= _neglKind),
                  ("items" .=) <$> _neglItems,
                  ("selfLink" .=) <$> _neglSelfLink,
                  ("warning" .=) <$> _neglWarning,
                  ("id" .=) <$> _neglId])

--
-- /See:/ 'targetHTTPProxiesScopedListWarningDataItem' smart constructor.
data TargetHTTPProxiesScopedListWarningDataItem =
  TargetHTTPProxiesScopedListWarningDataItem'
    { _thttppslwdiValue :: !(Maybe Text)
    , _thttppslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetHTTPProxiesScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'thttppslwdiValue'
--
-- * 'thttppslwdiKey'
targetHTTPProxiesScopedListWarningDataItem
    :: TargetHTTPProxiesScopedListWarningDataItem
targetHTTPProxiesScopedListWarningDataItem =
  TargetHTTPProxiesScopedListWarningDataItem'
    {_thttppslwdiValue = Nothing, _thttppslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
thttppslwdiValue :: Lens' TargetHTTPProxiesScopedListWarningDataItem (Maybe Text)
thttppslwdiValue
  = lens _thttppslwdiValue
      (\ s a -> s{_thttppslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
thttppslwdiKey :: Lens' TargetHTTPProxiesScopedListWarningDataItem (Maybe Text)
thttppslwdiKey
  = lens _thttppslwdiKey
      (\ s a -> s{_thttppslwdiKey = a})

instance FromJSON
           TargetHTTPProxiesScopedListWarningDataItem
         where
        parseJSON
          = withObject
              "TargetHTTPProxiesScopedListWarningDataItem"
              (\ o ->
                 TargetHTTPProxiesScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           TargetHTTPProxiesScopedListWarningDataItem
         where
        toJSON
          TargetHTTPProxiesScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _thttppslwdiValue,
                  ("key" .=) <$> _thttppslwdiKey])

-- | Contains a list of Subnetwork resources.
--
-- /See:/ 'subnetworkList' smart constructor.
data SubnetworkList =
  SubnetworkList'
    { _slNextPageToken :: !(Maybe Text)
    , _slKind :: !Text
    , _slItems :: !(Maybe [Subnetwork])
    , _slSelfLink :: !(Maybe Text)
    , _slWarning :: !(Maybe SubnetworkListWarning)
    , _slId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SubnetworkList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'slNextPageToken'
--
-- * 'slKind'
--
-- * 'slItems'
--
-- * 'slSelfLink'
--
-- * 'slWarning'
--
-- * 'slId'
subnetworkList
    :: SubnetworkList
subnetworkList =
  SubnetworkList'
    { _slNextPageToken = Nothing
    , _slKind = "compute#subnetworkList"
    , _slItems = Nothing
    , _slSelfLink = Nothing
    , _slWarning = Nothing
    , _slId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
slNextPageToken :: Lens' SubnetworkList (Maybe Text)
slNextPageToken
  = lens _slNextPageToken
      (\ s a -> s{_slNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#subnetworkList for lists
-- of subnetworks.
slKind :: Lens' SubnetworkList Text
slKind = lens _slKind (\ s a -> s{_slKind = a})

-- | A list of Subnetwork resources.
slItems :: Lens' SubnetworkList [Subnetwork]
slItems
  = lens _slItems (\ s a -> s{_slItems = a}) . _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
slSelfLink :: Lens' SubnetworkList (Maybe Text)
slSelfLink
  = lens _slSelfLink (\ s a -> s{_slSelfLink = a})

-- | [Output Only] Informational warning message.
slWarning :: Lens' SubnetworkList (Maybe SubnetworkListWarning)
slWarning
  = lens _slWarning (\ s a -> s{_slWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
slId :: Lens' SubnetworkList (Maybe Text)
slId = lens _slId (\ s a -> s{_slId = a})

instance FromJSON SubnetworkList where
        parseJSON
          = withObject "SubnetworkList"
              (\ o ->
                 SubnetworkList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#subnetworkList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON SubnetworkList where
        toJSON SubnetworkList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _slNextPageToken,
                  Just ("kind" .= _slKind), ("items" .=) <$> _slItems,
                  ("selfLink" .=) <$> _slSelfLink,
                  ("warning" .=) <$> _slWarning, ("id" .=) <$> _slId])

-- | Labels for this resource. These can only be added or modified by the
-- setLabels method. Each label key\/value pair must comply with RFC1035.
-- Label values may be empty.
--
-- /See:/ 'forwardingRuleLabels' smart constructor.
newtype ForwardingRuleLabels =
  ForwardingRuleLabels'
    { _frlAddtional :: HashMap Text Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ForwardingRuleLabels' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'frlAddtional'
forwardingRuleLabels
    :: HashMap Text Text -- ^ 'frlAddtional'
    -> ForwardingRuleLabels
forwardingRuleLabels pFrlAddtional_ =
  ForwardingRuleLabels' {_frlAddtional = _Coerce # pFrlAddtional_}


frlAddtional :: Lens' ForwardingRuleLabels (HashMap Text Text)
frlAddtional
  = lens _frlAddtional (\ s a -> s{_frlAddtional = a})
      . _Coerce

instance FromJSON ForwardingRuleLabels where
        parseJSON
          = withObject "ForwardingRuleLabels"
              (\ o ->
                 ForwardingRuleLabels' <$> (parseJSONObject o))

instance ToJSON ForwardingRuleLabels where
        toJSON = toJSON . _frlAddtional

-- | Informational warning which replaces the list of forwarding rules when
-- the list is empty.
--
-- /See:/ 'forwardingRulesScopedListWarning' smart constructor.
data ForwardingRulesScopedListWarning =
  ForwardingRulesScopedListWarning'
    { _frslwData :: !(Maybe [ForwardingRulesScopedListWarningDataItem])
    , _frslwCode :: !(Maybe ForwardingRulesScopedListWarningCode)
    , _frslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ForwardingRulesScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'frslwData'
--
-- * 'frslwCode'
--
-- * 'frslwMessage'
forwardingRulesScopedListWarning
    :: ForwardingRulesScopedListWarning
forwardingRulesScopedListWarning =
  ForwardingRulesScopedListWarning'
    {_frslwData = Nothing, _frslwCode = Nothing, _frslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
frslwData :: Lens' ForwardingRulesScopedListWarning [ForwardingRulesScopedListWarningDataItem]
frslwData
  = lens _frslwData (\ s a -> s{_frslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
frslwCode :: Lens' ForwardingRulesScopedListWarning (Maybe ForwardingRulesScopedListWarningCode)
frslwCode
  = lens _frslwCode (\ s a -> s{_frslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
frslwMessage :: Lens' ForwardingRulesScopedListWarning (Maybe Text)
frslwMessage
  = lens _frslwMessage (\ s a -> s{_frslwMessage = a})

instance FromJSON ForwardingRulesScopedListWarning
         where
        parseJSON
          = withObject "ForwardingRulesScopedListWarning"
              (\ o ->
                 ForwardingRulesScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON ForwardingRulesScopedListWarning
         where
        toJSON ForwardingRulesScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _frslwData,
                  ("code" .=) <$> _frslwCode,
                  ("message" .=) <$> _frslwMessage])

-- | Contains a list of HttpHealthCheck resources.
--
-- /See:/ 'hTTPHealthCheckList' smart constructor.
data HTTPHealthCheckList =
  HTTPHealthCheckList'
    { _httphclNextPageToken :: !(Maybe Text)
    , _httphclKind :: !Text
    , _httphclItems :: !(Maybe [HTTPHealthCheck])
    , _httphclSelfLink :: !(Maybe Text)
    , _httphclWarning :: !(Maybe HTTPHealthCheckListWarning)
    , _httphclId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HTTPHealthCheckList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'httphclNextPageToken'
--
-- * 'httphclKind'
--
-- * 'httphclItems'
--
-- * 'httphclSelfLink'
--
-- * 'httphclWarning'
--
-- * 'httphclId'
hTTPHealthCheckList
    :: HTTPHealthCheckList
hTTPHealthCheckList =
  HTTPHealthCheckList'
    { _httphclNextPageToken = Nothing
    , _httphclKind = "compute#httpHealthCheckList"
    , _httphclItems = Nothing
    , _httphclSelfLink = Nothing
    , _httphclWarning = Nothing
    , _httphclId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
httphclNextPageToken :: Lens' HTTPHealthCheckList (Maybe Text)
httphclNextPageToken
  = lens _httphclNextPageToken
      (\ s a -> s{_httphclNextPageToken = a})

-- | Type of resource.
httphclKind :: Lens' HTTPHealthCheckList Text
httphclKind
  = lens _httphclKind (\ s a -> s{_httphclKind = a})

-- | A list of HttpHealthCheck resources.
httphclItems :: Lens' HTTPHealthCheckList [HTTPHealthCheck]
httphclItems
  = lens _httphclItems (\ s a -> s{_httphclItems = a})
      . _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
httphclSelfLink :: Lens' HTTPHealthCheckList (Maybe Text)
httphclSelfLink
  = lens _httphclSelfLink
      (\ s a -> s{_httphclSelfLink = a})

-- | [Output Only] Informational warning message.
httphclWarning :: Lens' HTTPHealthCheckList (Maybe HTTPHealthCheckListWarning)
httphclWarning
  = lens _httphclWarning
      (\ s a -> s{_httphclWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
httphclId :: Lens' HTTPHealthCheckList (Maybe Text)
httphclId
  = lens _httphclId (\ s a -> s{_httphclId = a})

instance FromJSON HTTPHealthCheckList where
        parseJSON
          = withObject "HTTPHealthCheckList"
              (\ o ->
                 HTTPHealthCheckList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#httpHealthCheckList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON HTTPHealthCheckList where
        toJSON HTTPHealthCheckList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _httphclNextPageToken,
                  Just ("kind" .= _httphclKind),
                  ("items" .=) <$> _httphclItems,
                  ("selfLink" .=) <$> _httphclSelfLink,
                  ("warning" .=) <$> _httphclWarning,
                  ("id" .=) <$> _httphclId])

-- | [Output Only] The warning that replaces the list of managed instance
-- groups when the list is empty.
--
-- /See:/ 'instanceGroupManagersScopedListWarning' smart constructor.
data InstanceGroupManagersScopedListWarning =
  InstanceGroupManagersScopedListWarning'
    { _igmslwData :: !(Maybe [InstanceGroupManagersScopedListWarningDataItem])
    , _igmslwCode :: !(Maybe InstanceGroupManagersScopedListWarningCode)
    , _igmslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagersScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmslwData'
--
-- * 'igmslwCode'
--
-- * 'igmslwMessage'
instanceGroupManagersScopedListWarning
    :: InstanceGroupManagersScopedListWarning
instanceGroupManagersScopedListWarning =
  InstanceGroupManagersScopedListWarning'
    {_igmslwData = Nothing, _igmslwCode = Nothing, _igmslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
igmslwData :: Lens' InstanceGroupManagersScopedListWarning [InstanceGroupManagersScopedListWarningDataItem]
igmslwData
  = lens _igmslwData (\ s a -> s{_igmslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
igmslwCode :: Lens' InstanceGroupManagersScopedListWarning (Maybe InstanceGroupManagersScopedListWarningCode)
igmslwCode
  = lens _igmslwCode (\ s a -> s{_igmslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
igmslwMessage :: Lens' InstanceGroupManagersScopedListWarning (Maybe Text)
igmslwMessage
  = lens _igmslwMessage
      (\ s a -> s{_igmslwMessage = a})

instance FromJSON
           InstanceGroupManagersScopedListWarning
         where
        parseJSON
          = withObject "InstanceGroupManagersScopedListWarning"
              (\ o ->
                 InstanceGroupManagersScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON
           InstanceGroupManagersScopedListWarning
         where
        toJSON InstanceGroupManagersScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _igmslwData,
                  ("code" .=) <$> _igmslwCode,
                  ("message" .=) <$> _igmslwMessage])

--
-- /See:/ 'sslPoliciesList' smart constructor.
data SSLPoliciesList =
  SSLPoliciesList'
    { _sslplNextPageToken :: !(Maybe Text)
    , _sslplKind :: !Text
    , _sslplItems :: !(Maybe [SSLPolicy])
    , _sslplSelfLink :: !(Maybe Text)
    , _sslplWarning :: !(Maybe SSLPoliciesListWarning)
    , _sslplId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SSLPoliciesList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sslplNextPageToken'
--
-- * 'sslplKind'
--
-- * 'sslplItems'
--
-- * 'sslplSelfLink'
--
-- * 'sslplWarning'
--
-- * 'sslplId'
sslPoliciesList
    :: SSLPoliciesList
sslPoliciesList =
  SSLPoliciesList'
    { _sslplNextPageToken = Nothing
    , _sslplKind = "compute#sslPoliciesList"
    , _sslplItems = Nothing
    , _sslplSelfLink = Nothing
    , _sslplWarning = Nothing
    , _sslplId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
sslplNextPageToken :: Lens' SSLPoliciesList (Maybe Text)
sslplNextPageToken
  = lens _sslplNextPageToken
      (\ s a -> s{_sslplNextPageToken = a})

-- | [Output Only] Type of the resource. Always compute#sslPoliciesList for
-- lists of sslPolicies.
sslplKind :: Lens' SSLPoliciesList Text
sslplKind
  = lens _sslplKind (\ s a -> s{_sslplKind = a})

-- | A list of SslPolicy resources.
sslplItems :: Lens' SSLPoliciesList [SSLPolicy]
sslplItems
  = lens _sslplItems (\ s a -> s{_sslplItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
sslplSelfLink :: Lens' SSLPoliciesList (Maybe Text)
sslplSelfLink
  = lens _sslplSelfLink
      (\ s a -> s{_sslplSelfLink = a})

-- | [Output Only] Informational warning message.
sslplWarning :: Lens' SSLPoliciesList (Maybe SSLPoliciesListWarning)
sslplWarning
  = lens _sslplWarning (\ s a -> s{_sslplWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
sslplId :: Lens' SSLPoliciesList (Maybe Text)
sslplId = lens _sslplId (\ s a -> s{_sslplId = a})

instance FromJSON SSLPoliciesList where
        parseJSON
          = withObject "SSLPoliciesList"
              (\ o ->
                 SSLPoliciesList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#sslPoliciesList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON SSLPoliciesList where
        toJSON SSLPoliciesList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _sslplNextPageToken,
                  Just ("kind" .= _sslplKind),
                  ("items" .=) <$> _sslplItems,
                  ("selfLink" .=) <$> _sslplSelfLink,
                  ("warning" .=) <$> _sslplWarning,
                  ("id" .=) <$> _sslplId])

--
-- /See:/ 'urlMapsValidateRequest' smart constructor.
newtype URLMapsValidateRequest =
  URLMapsValidateRequest'
    { _umvrResource :: Maybe URLMap
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'URLMapsValidateRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'umvrResource'
urlMapsValidateRequest
    :: URLMapsValidateRequest
urlMapsValidateRequest = URLMapsValidateRequest' {_umvrResource = Nothing}


-- | Content of the UrlMap to be validated.
umvrResource :: Lens' URLMapsValidateRequest (Maybe URLMap)
umvrResource
  = lens _umvrResource (\ s a -> s{_umvrResource = a})

instance FromJSON URLMapsValidateRequest where
        parseJSON
          = withObject "URLMapsValidateRequest"
              (\ o ->
                 URLMapsValidateRequest' <$> (o .:? "resource"))

instance ToJSON URLMapsValidateRequest where
        toJSON URLMapsValidateRequest'{..}
          = object
              (catMaybes [("resource" .=) <$> _umvrResource])

--
-- /See:/ 'instanceGroupManagersSetTargetPoolsRequest' smart constructor.
data InstanceGroupManagersSetTargetPoolsRequest =
  InstanceGroupManagersSetTargetPoolsRequest'
    { _igmstprFingerprint :: !(Maybe Bytes)
    , _igmstprTargetPools :: !(Maybe [Text])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagersSetTargetPoolsRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmstprFingerprint'
--
-- * 'igmstprTargetPools'
instanceGroupManagersSetTargetPoolsRequest
    :: InstanceGroupManagersSetTargetPoolsRequest
instanceGroupManagersSetTargetPoolsRequest =
  InstanceGroupManagersSetTargetPoolsRequest'
    {_igmstprFingerprint = Nothing, _igmstprTargetPools = Nothing}


-- | The fingerprint of the target pools information. Use this optional
-- property to prevent conflicts when multiple users change the target
-- pools settings concurrently. Obtain the fingerprint with the
-- instanceGroupManagers.get method. Then, include the fingerprint in your
-- request to ensure that you do not overwrite changes that were applied
-- from another concurrent request.
igmstprFingerprint :: Lens' InstanceGroupManagersSetTargetPoolsRequest (Maybe ByteString)
igmstprFingerprint
  = lens _igmstprFingerprint
      (\ s a -> s{_igmstprFingerprint = a})
      . mapping _Bytes

-- | The list of target pool URLs that instances in this managed instance
-- group belong to. The managed instance group applies these target pools
-- to all of the instances in the group. Existing instances and new
-- instances in the group all receive these target pool settings.
igmstprTargetPools :: Lens' InstanceGroupManagersSetTargetPoolsRequest [Text]
igmstprTargetPools
  = lens _igmstprTargetPools
      (\ s a -> s{_igmstprTargetPools = a})
      . _Default
      . _Coerce

instance FromJSON
           InstanceGroupManagersSetTargetPoolsRequest
         where
        parseJSON
          = withObject
              "InstanceGroupManagersSetTargetPoolsRequest"
              (\ o ->
                 InstanceGroupManagersSetTargetPoolsRequest' <$>
                   (o .:? "fingerprint") <*>
                     (o .:? "targetPools" .!= mempty))

instance ToJSON
           InstanceGroupManagersSetTargetPoolsRequest
         where
        toJSON
          InstanceGroupManagersSetTargetPoolsRequest'{..}
          = object
              (catMaybes
                 [("fingerprint" .=) <$> _igmstprFingerprint,
                  ("targetPools" .=) <$> _igmstprTargetPools])

-- | A snapshot schedule policy specifies when and how frequently snapshots
-- are to be created for the target disk. Also specifies how many and how
-- long these scheduled snapshots should be retained.
--
-- /See:/ 'resourcePolicySnapshotSchedulePolicy' smart constructor.
data ResourcePolicySnapshotSchedulePolicy =
  ResourcePolicySnapshotSchedulePolicy'
    { _rpsspSchedule :: !(Maybe ResourcePolicySnapshotSchedulePolicySchedule)
    , _rpsspRetentionPolicy :: !(Maybe ResourcePolicySnapshotSchedulePolicyRetentionPolicy)
    , _rpsspSnapshotProperties :: !(Maybe ResourcePolicySnapshotSchedulePolicySnapshotProperties)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePolicySnapshotSchedulePolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rpsspSchedule'
--
-- * 'rpsspRetentionPolicy'
--
-- * 'rpsspSnapshotProperties'
resourcePolicySnapshotSchedulePolicy
    :: ResourcePolicySnapshotSchedulePolicy
resourcePolicySnapshotSchedulePolicy =
  ResourcePolicySnapshotSchedulePolicy'
    { _rpsspSchedule = Nothing
    , _rpsspRetentionPolicy = Nothing
    , _rpsspSnapshotProperties = Nothing
    }


-- | A Vm Maintenance Policy specifies what kind of infrastructure
-- maintenance we are allowed to perform on this VM and when. Schedule that
-- is applied to disks covered by this policy.
rpsspSchedule :: Lens' ResourcePolicySnapshotSchedulePolicy (Maybe ResourcePolicySnapshotSchedulePolicySchedule)
rpsspSchedule
  = lens _rpsspSchedule
      (\ s a -> s{_rpsspSchedule = a})

-- | Retention policy applied to snapshots created by this resource policy.
rpsspRetentionPolicy :: Lens' ResourcePolicySnapshotSchedulePolicy (Maybe ResourcePolicySnapshotSchedulePolicyRetentionPolicy)
rpsspRetentionPolicy
  = lens _rpsspRetentionPolicy
      (\ s a -> s{_rpsspRetentionPolicy = a})

-- | Properties with which snapshots are created such as labels, encryption
-- keys.
rpsspSnapshotProperties :: Lens' ResourcePolicySnapshotSchedulePolicy (Maybe ResourcePolicySnapshotSchedulePolicySnapshotProperties)
rpsspSnapshotProperties
  = lens _rpsspSnapshotProperties
      (\ s a -> s{_rpsspSnapshotProperties = a})

instance FromJSON
           ResourcePolicySnapshotSchedulePolicy
         where
        parseJSON
          = withObject "ResourcePolicySnapshotSchedulePolicy"
              (\ o ->
                 ResourcePolicySnapshotSchedulePolicy' <$>
                   (o .:? "schedule") <*> (o .:? "retentionPolicy") <*>
                     (o .:? "snapshotProperties"))

instance ToJSON ResourcePolicySnapshotSchedulePolicy
         where
        toJSON ResourcePolicySnapshotSchedulePolicy'{..}
          = object
              (catMaybes
                 [("schedule" .=) <$> _rpsspSchedule,
                  ("retentionPolicy" .=) <$> _rpsspRetentionPolicy,
                  ("snapshotProperties" .=) <$>
                    _rpsspSnapshotProperties])

-- | Per-instance properties to be set on individual instances. To be
-- extended in the future.
--
-- /See:/ 'bulkInsertInstanceResourcePerInstanceProperties' smart constructor.
newtype BulkInsertInstanceResourcePerInstanceProperties =
  BulkInsertInstanceResourcePerInstanceProperties'
    { _biirpipName :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BulkInsertInstanceResourcePerInstanceProperties' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'biirpipName'
bulkInsertInstanceResourcePerInstanceProperties
    :: BulkInsertInstanceResourcePerInstanceProperties
bulkInsertInstanceResourcePerInstanceProperties =
  BulkInsertInstanceResourcePerInstanceProperties' {_biirpipName = Nothing}


-- | This field is only temporary. It will be removed. Do not use it.
biirpipName :: Lens' BulkInsertInstanceResourcePerInstanceProperties (Maybe Text)
biirpipName
  = lens _biirpipName (\ s a -> s{_biirpipName = a})

instance FromJSON
           BulkInsertInstanceResourcePerInstanceProperties
         where
        parseJSON
          = withObject
              "BulkInsertInstanceResourcePerInstanceProperties"
              (\ o ->
                 BulkInsertInstanceResourcePerInstanceProperties' <$>
                   (o .:? "name"))

instance ToJSON
           BulkInsertInstanceResourcePerInstanceProperties
         where
        toJSON
          BulkInsertInstanceResourcePerInstanceProperties'{..}
          = object (catMaybes [("name" .=) <$> _biirpipName])

--
-- /See:/ 'targetHTTPSProxiesScopedListWarningDataItem' smart constructor.
data TargetHTTPSProxiesScopedListWarningDataItem =
  TargetHTTPSProxiesScopedListWarningDataItem'
    { _thpslwdiValue :: !(Maybe Text)
    , _thpslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetHTTPSProxiesScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'thpslwdiValue'
--
-- * 'thpslwdiKey'
targetHTTPSProxiesScopedListWarningDataItem
    :: TargetHTTPSProxiesScopedListWarningDataItem
targetHTTPSProxiesScopedListWarningDataItem =
  TargetHTTPSProxiesScopedListWarningDataItem'
    {_thpslwdiValue = Nothing, _thpslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
thpslwdiValue :: Lens' TargetHTTPSProxiesScopedListWarningDataItem (Maybe Text)
thpslwdiValue
  = lens _thpslwdiValue
      (\ s a -> s{_thpslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
thpslwdiKey :: Lens' TargetHTTPSProxiesScopedListWarningDataItem (Maybe Text)
thpslwdiKey
  = lens _thpslwdiKey (\ s a -> s{_thpslwdiKey = a})

instance FromJSON
           TargetHTTPSProxiesScopedListWarningDataItem
         where
        parseJSON
          = withObject
              "TargetHTTPSProxiesScopedListWarningDataItem"
              (\ o ->
                 TargetHTTPSProxiesScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           TargetHTTPSProxiesScopedListWarningDataItem
         where
        toJSON
          TargetHTTPSProxiesScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _thpslwdiValue,
                  ("key" .=) <$> _thpslwdiKey])

--
-- /See:/ 'networksGetEffectiveFirewallsResponseEffectiveFirewallPolicy' smart constructor.
data NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy =
  NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy'
    { _ngefrefpRules :: !(Maybe [FirewallPolicyRule])
    , _ngefrefpShortName :: !(Maybe Text)
    , _ngefrefpName :: !(Maybe Text)
    , _ngefrefpDisplayName :: !(Maybe Text)
    , _ngefrefpType :: !(Maybe NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicyType)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ngefrefpRules'
--
-- * 'ngefrefpShortName'
--
-- * 'ngefrefpName'
--
-- * 'ngefrefpDisplayName'
--
-- * 'ngefrefpType'
networksGetEffectiveFirewallsResponseEffectiveFirewallPolicy
    :: NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy
networksGetEffectiveFirewallsResponseEffectiveFirewallPolicy =
  NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy'
    { _ngefrefpRules = Nothing
    , _ngefrefpShortName = Nothing
    , _ngefrefpName = Nothing
    , _ngefrefpDisplayName = Nothing
    , _ngefrefpType = Nothing
    }


-- | The rules that apply to the network.
ngefrefpRules :: Lens' NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy [FirewallPolicyRule]
ngefrefpRules
  = lens _ngefrefpRules
      (\ s a -> s{_ngefrefpRules = a})
      . _Default
      . _Coerce

-- | [Output Only] The short name of the firewall policy.
ngefrefpShortName :: Lens' NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy (Maybe Text)
ngefrefpShortName
  = lens _ngefrefpShortName
      (\ s a -> s{_ngefrefpShortName = a})

-- | [Output Only] The name of the firewall policy.
ngefrefpName :: Lens' NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy (Maybe Text)
ngefrefpName
  = lens _ngefrefpName (\ s a -> s{_ngefrefpName = a})

-- | [Output Only] Deprecated, please use short name instead. The display
-- name of the firewall policy.
ngefrefpDisplayName :: Lens' NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy (Maybe Text)
ngefrefpDisplayName
  = lens _ngefrefpDisplayName
      (\ s a -> s{_ngefrefpDisplayName = a})

-- | [Output Only] The type of the firewall policy.
ngefrefpType :: Lens' NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy (Maybe NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicyType)
ngefrefpType
  = lens _ngefrefpType (\ s a -> s{_ngefrefpType = a})

instance FromJSON
           NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy
         where
        parseJSON
          = withObject
              "NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy"
              (\ o ->
                 NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy'
                   <$>
                   (o .:? "rules" .!= mempty) <*> (o .:? "shortName")
                     <*> (o .:? "name")
                     <*> (o .:? "displayName")
                     <*> (o .:? "type"))

instance ToJSON
           NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy
         where
        toJSON
          NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy'{..}
          = object
              (catMaybes
                 [("rules" .=) <$> _ngefrefpRules,
                  ("shortName" .=) <$> _ngefrefpShortName,
                  ("name" .=) <$> _ngefrefpName,
                  ("displayName" .=) <$> _ngefrefpDisplayName,
                  ("type" .=) <$> _ngefrefpType])

-- | Represents a regional Commitment resource. Creating a commitment
-- resource means that you are purchasing a committed use contract with an
-- explicit start and end time. You can create commitments based on vCPUs
-- and memory usage and receive discounted rates. For full details, read
-- Signing Up for Committed Use Discounts. (== resource_for
-- {$api_version}.regionCommitments ==)
--
-- /See:/ 'commitment' smart constructor.
data Commitment =
  Commitment'
    { _cStatus :: !(Maybe CommitmentStatus)
    , _cKind :: !Text
    , _cCategory :: !(Maybe CommitmentCategory)
    , _cPlan :: !(Maybe CommitmentPlan)
    , _cResources :: !(Maybe [ResourceCommitment])
    , _cLicenseResource :: !(Maybe LicenseResourceCommitment)
    , _cEndTimestamp :: !(Maybe Text)
    , _cSelfLink :: !(Maybe Text)
    , _cName :: !(Maybe Text)
    , _cStatusMessage :: !(Maybe Text)
    , _cCreationTimestamp :: !(Maybe Text)
    , _cId :: !(Maybe (Textual Word64))
    , _cRegion :: !(Maybe Text)
    , _cReservations :: !(Maybe [Reservation])
    , _cStartTimestamp :: !(Maybe Text)
    , _cDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Commitment' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'cStatus'
--
-- * 'cKind'
--
-- * 'cCategory'
--
-- * 'cPlan'
--
-- * 'cResources'
--
-- * 'cLicenseResource'
--
-- * 'cEndTimestamp'
--
-- * 'cSelfLink'
--
-- * 'cName'
--
-- * 'cStatusMessage'
--
-- * 'cCreationTimestamp'
--
-- * 'cId'
--
-- * 'cRegion'
--
-- * 'cReservations'
--
-- * 'cStartTimestamp'
--
-- * 'cDescription'
commitment
    :: Commitment
commitment =
  Commitment'
    { _cStatus = Nothing
    , _cKind = "compute#commitment"
    , _cCategory = Nothing
    , _cPlan = Nothing
    , _cResources = Nothing
    , _cLicenseResource = Nothing
    , _cEndTimestamp = Nothing
    , _cSelfLink = Nothing
    , _cName = Nothing
    , _cStatusMessage = Nothing
    , _cCreationTimestamp = Nothing
    , _cId = Nothing
    , _cRegion = Nothing
    , _cReservations = Nothing
    , _cStartTimestamp = Nothing
    , _cDescription = Nothing
    }


-- | [Output Only] Status of the commitment with regards to eventual
-- expiration (each commitment has an end date defined). One of the
-- following values: NOT_YET_ACTIVE, ACTIVE, EXPIRED.
cStatus :: Lens' Commitment (Maybe CommitmentStatus)
cStatus = lens _cStatus (\ s a -> s{_cStatus = a})

-- | [Output Only] Type of the resource. Always compute#commitment for
-- commitments.
cKind :: Lens' Commitment Text
cKind = lens _cKind (\ s a -> s{_cKind = a})

-- | The category of the commitment. Category MACHINE specifies commitments
-- composed of machine resources such as VCPU or MEMORY, listed in
-- resources. Category LICENSE specifies commitments composed of software
-- licenses, listed in licenseResources. Note that only MACHINE commitments
-- should have a Type specified.
cCategory :: Lens' Commitment (Maybe CommitmentCategory)
cCategory
  = lens _cCategory (\ s a -> s{_cCategory = a})

-- | The plan for this commitment, which determines duration and discount
-- rate. The currently supported plans are TWELVE_MONTH (1 year), and
-- THIRTY_SIX_MONTH (3 years).
cPlan :: Lens' Commitment (Maybe CommitmentPlan)
cPlan = lens _cPlan (\ s a -> s{_cPlan = a})

-- | A list of commitment amounts for particular resources. Note that VCPU
-- and MEMORY resource commitments must occur together.
cResources :: Lens' Commitment [ResourceCommitment]
cResources
  = lens _cResources (\ s a -> s{_cResources = a}) .
      _Default
      . _Coerce

-- | The license specification required as part of a license commitment.
cLicenseResource :: Lens' Commitment (Maybe LicenseResourceCommitment)
cLicenseResource
  = lens _cLicenseResource
      (\ s a -> s{_cLicenseResource = a})

-- | [Output Only] Commitment end time in RFC3339 text format.
cEndTimestamp :: Lens' Commitment (Maybe Text)
cEndTimestamp
  = lens _cEndTimestamp
      (\ s a -> s{_cEndTimestamp = a})

-- | [Output Only] Server-defined URL for the resource.
cSelfLink :: Lens' Commitment (Maybe Text)
cSelfLink
  = lens _cSelfLink (\ s a -> s{_cSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
cName :: Lens' Commitment (Maybe Text)
cName = lens _cName (\ s a -> s{_cName = a})

-- | [Output Only] An optional, human-readable explanation of the status.
cStatusMessage :: Lens' Commitment (Maybe Text)
cStatusMessage
  = lens _cStatusMessage
      (\ s a -> s{_cStatusMessage = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
cCreationTimestamp :: Lens' Commitment (Maybe Text)
cCreationTimestamp
  = lens _cCreationTimestamp
      (\ s a -> s{_cCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
cId :: Lens' Commitment (Maybe Word64)
cId
  = lens _cId (\ s a -> s{_cId = a}) . mapping _Coerce

-- | [Output Only] URL of the region where this commitment may be used.
cRegion :: Lens' Commitment (Maybe Text)
cRegion = lens _cRegion (\ s a -> s{_cRegion = a})

-- | List of reservations in this commitment.
cReservations :: Lens' Commitment [Reservation]
cReservations
  = lens _cReservations
      (\ s a -> s{_cReservations = a})
      . _Default
      . _Coerce

-- | [Output Only] Commitment start time in RFC3339 text format.
cStartTimestamp :: Lens' Commitment (Maybe Text)
cStartTimestamp
  = lens _cStartTimestamp
      (\ s a -> s{_cStartTimestamp = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource.
cDescription :: Lens' Commitment (Maybe Text)
cDescription
  = lens _cDescription (\ s a -> s{_cDescription = a})

instance FromJSON Commitment where
        parseJSON
          = withObject "Commitment"
              (\ o ->
                 Commitment' <$>
                   (o .:? "status") <*>
                     (o .:? "kind" .!= "compute#commitment")
                     <*> (o .:? "category")
                     <*> (o .:? "plan")
                     <*> (o .:? "resources" .!= mempty)
                     <*> (o .:? "licenseResource")
                     <*> (o .:? "endTimestamp")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "statusMessage")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "region")
                     <*> (o .:? "reservations" .!= mempty)
                     <*> (o .:? "startTimestamp")
                     <*> (o .:? "description"))

instance ToJSON Commitment where
        toJSON Commitment'{..}
          = object
              (catMaybes
                 [("status" .=) <$> _cStatus, Just ("kind" .= _cKind),
                  ("category" .=) <$> _cCategory,
                  ("plan" .=) <$> _cPlan,
                  ("resources" .=) <$> _cResources,
                  ("licenseResource" .=) <$> _cLicenseResource,
                  ("endTimestamp" .=) <$> _cEndTimestamp,
                  ("selfLink" .=) <$> _cSelfLink,
                  ("name" .=) <$> _cName,
                  ("statusMessage" .=) <$> _cStatusMessage,
                  ("creationTimestamp" .=) <$> _cCreationTimestamp,
                  ("id" .=) <$> _cId, ("region" .=) <$> _cRegion,
                  ("reservations" .=) <$> _cReservations,
                  ("startTimestamp" .=) <$> _cStartTimestamp,
                  ("description" .=) <$> _cDescription])

-- | Contains a list of HttpsHealthCheck resources.
--
-- /See:/ 'httpsHealthCheckList' smart constructor.
data HTTPSHealthCheckList =
  HTTPSHealthCheckList'
    { _hhclNextPageToken :: !(Maybe Text)
    , _hhclKind :: !Text
    , _hhclItems :: !(Maybe [HTTPSHealthCheck])
    , _hhclSelfLink :: !(Maybe Text)
    , _hhclWarning :: !(Maybe HTTPSHealthCheckListWarning)
    , _hhclId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HTTPSHealthCheckList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hhclNextPageToken'
--
-- * 'hhclKind'
--
-- * 'hhclItems'
--
-- * 'hhclSelfLink'
--
-- * 'hhclWarning'
--
-- * 'hhclId'
httpsHealthCheckList
    :: HTTPSHealthCheckList
httpsHealthCheckList =
  HTTPSHealthCheckList'
    { _hhclNextPageToken = Nothing
    , _hhclKind = "compute#httpsHealthCheckList"
    , _hhclItems = Nothing
    , _hhclSelfLink = Nothing
    , _hhclWarning = Nothing
    , _hhclId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
hhclNextPageToken :: Lens' HTTPSHealthCheckList (Maybe Text)
hhclNextPageToken
  = lens _hhclNextPageToken
      (\ s a -> s{_hhclNextPageToken = a})

-- | Type of resource.
hhclKind :: Lens' HTTPSHealthCheckList Text
hhclKind = lens _hhclKind (\ s a -> s{_hhclKind = a})

-- | A list of HttpsHealthCheck resources.
hhclItems :: Lens' HTTPSHealthCheckList [HTTPSHealthCheck]
hhclItems
  = lens _hhclItems (\ s a -> s{_hhclItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
hhclSelfLink :: Lens' HTTPSHealthCheckList (Maybe Text)
hhclSelfLink
  = lens _hhclSelfLink (\ s a -> s{_hhclSelfLink = a})

-- | [Output Only] Informational warning message.
hhclWarning :: Lens' HTTPSHealthCheckList (Maybe HTTPSHealthCheckListWarning)
hhclWarning
  = lens _hhclWarning (\ s a -> s{_hhclWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
hhclId :: Lens' HTTPSHealthCheckList (Maybe Text)
hhclId = lens _hhclId (\ s a -> s{_hhclId = a})

instance FromJSON HTTPSHealthCheckList where
        parseJSON
          = withObject "HTTPSHealthCheckList"
              (\ o ->
                 HTTPSHealthCheckList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#httpsHealthCheckList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON HTTPSHealthCheckList where
        toJSON HTTPSHealthCheckList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _hhclNextPageToken,
                  Just ("kind" .= _hhclKind),
                  ("items" .=) <$> _hhclItems,
                  ("selfLink" .=) <$> _hhclSelfLink,
                  ("warning" .=) <$> _hhclWarning,
                  ("id" .=) <$> _hhclId])

--
-- /See:/ 'addressListWarningDataItem' smart constructor.
data AddressListWarningDataItem =
  AddressListWarningDataItem'
    { _addValue :: !(Maybe Text)
    , _addKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AddressListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'addValue'
--
-- * 'addKey'
addressListWarningDataItem
    :: AddressListWarningDataItem
addressListWarningDataItem =
  AddressListWarningDataItem' {_addValue = Nothing, _addKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
addValue :: Lens' AddressListWarningDataItem (Maybe Text)
addValue = lens _addValue (\ s a -> s{_addValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
addKey :: Lens' AddressListWarningDataItem (Maybe Text)
addKey = lens _addKey (\ s a -> s{_addKey = a})

instance FromJSON AddressListWarningDataItem where
        parseJSON
          = withObject "AddressListWarningDataItem"
              (\ o ->
                 AddressListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON AddressListWarningDataItem where
        toJSON AddressListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _addValue, ("key" .=) <$> _addKey])

--
-- /See:/ 'operationErrorErrorsItem' smart constructor.
data OperationErrorErrorsItem =
  OperationErrorErrorsItem'
    { _oeeiLocation :: !(Maybe Text)
    , _oeeiCode :: !(Maybe Text)
    , _oeeiMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'OperationErrorErrorsItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'oeeiLocation'
--
-- * 'oeeiCode'
--
-- * 'oeeiMessage'
operationErrorErrorsItem
    :: OperationErrorErrorsItem
operationErrorErrorsItem =
  OperationErrorErrorsItem'
    {_oeeiLocation = Nothing, _oeeiCode = Nothing, _oeeiMessage = Nothing}


-- | [Output Only] Indicates the field in the request that caused the error.
-- This property is optional.
oeeiLocation :: Lens' OperationErrorErrorsItem (Maybe Text)
oeeiLocation
  = lens _oeeiLocation (\ s a -> s{_oeeiLocation = a})

-- | [Output Only] The error type identifier for this error.
oeeiCode :: Lens' OperationErrorErrorsItem (Maybe Text)
oeeiCode = lens _oeeiCode (\ s a -> s{_oeeiCode = a})

-- | [Output Only] An optional, human-readable error message.
oeeiMessage :: Lens' OperationErrorErrorsItem (Maybe Text)
oeeiMessage
  = lens _oeeiMessage (\ s a -> s{_oeeiMessage = a})

instance FromJSON OperationErrorErrorsItem where
        parseJSON
          = withObject "OperationErrorErrorsItem"
              (\ o ->
                 OperationErrorErrorsItem' <$>
                   (o .:? "location") <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON OperationErrorErrorsItem where
        toJSON OperationErrorErrorsItem'{..}
          = object
              (catMaybes
                 [("location" .=) <$> _oeeiLocation,
                  ("code" .=) <$> _oeeiCode,
                  ("message" .=) <$> _oeeiMessage])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'commitmentListWarning' smart constructor.
data CommitmentListWarning =
  CommitmentListWarning'
    { _clwData :: !(Maybe [CommitmentListWarningDataItem])
    , _clwCode :: !(Maybe CommitmentListWarningCode)
    , _clwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'CommitmentListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'clwData'
--
-- * 'clwCode'
--
-- * 'clwMessage'
commitmentListWarning
    :: CommitmentListWarning
commitmentListWarning =
  CommitmentListWarning'
    {_clwData = Nothing, _clwCode = Nothing, _clwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
clwData :: Lens' CommitmentListWarning [CommitmentListWarningDataItem]
clwData
  = lens _clwData (\ s a -> s{_clwData = a}) . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
clwCode :: Lens' CommitmentListWarning (Maybe CommitmentListWarningCode)
clwCode = lens _clwCode (\ s a -> s{_clwCode = a})

-- | [Output Only] A human-readable description of the warning code.
clwMessage :: Lens' CommitmentListWarning (Maybe Text)
clwMessage
  = lens _clwMessage (\ s a -> s{_clwMessage = a})

instance FromJSON CommitmentListWarning where
        parseJSON
          = withObject "CommitmentListWarning"
              (\ o ->
                 CommitmentListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON CommitmentListWarning where
        toJSON CommitmentListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _clwData, ("code" .=) <$> _clwCode,
                  ("message" .=) <$> _clwMessage])

-- | Represents a License resource. A License represents billing and
-- aggregate usage data for public and marketplace images. Caution This
-- resource is intended for use only by third-party partners who are
-- creating Cloud Marketplace images. (== resource_for
-- {$api_version}.licenses ==)
--
-- /See:/ 'license' smart constructor.
data License =
  License'
    { _lChargesUseFee :: !(Maybe Bool)
    , _lKind :: !Text
    , _lResourceRequirements :: !(Maybe LicenseResourceRequirements)
    , _lTransferable :: !(Maybe Bool)
    , _lSelfLink :: !(Maybe Text)
    , _lName :: !(Maybe Text)
    , _lCreationTimestamp :: !(Maybe Text)
    , _lId :: !(Maybe (Textual Word64))
    , _lDescription :: !(Maybe Text)
    , _lLicenseCode :: !(Maybe (Textual Word64))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'License' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'lChargesUseFee'
--
-- * 'lKind'
--
-- * 'lResourceRequirements'
--
-- * 'lTransferable'
--
-- * 'lSelfLink'
--
-- * 'lName'
--
-- * 'lCreationTimestamp'
--
-- * 'lId'
--
-- * 'lDescription'
--
-- * 'lLicenseCode'
license
    :: License
license =
  License'
    { _lChargesUseFee = Nothing
    , _lKind = "compute#license"
    , _lResourceRequirements = Nothing
    , _lTransferable = Nothing
    , _lSelfLink = Nothing
    , _lName = Nothing
    , _lCreationTimestamp = Nothing
    , _lId = Nothing
    , _lDescription = Nothing
    , _lLicenseCode = Nothing
    }


-- | [Output Only] Deprecated. This field no longer reflects whether a
-- license charges a usage fee.
lChargesUseFee :: Lens' License (Maybe Bool)
lChargesUseFee
  = lens _lChargesUseFee
      (\ s a -> s{_lChargesUseFee = a})

-- | [Output Only] Type of resource. Always compute#license for licenses.
lKind :: Lens' License Text
lKind = lens _lKind (\ s a -> s{_lKind = a})

lResourceRequirements :: Lens' License (Maybe LicenseResourceRequirements)
lResourceRequirements
  = lens _lResourceRequirements
      (\ s a -> s{_lResourceRequirements = a})

-- | If false, licenses will not be copied from the source resource when
-- creating an image from a disk, disk from snapshot, or snapshot from
-- disk.
lTransferable :: Lens' License (Maybe Bool)
lTransferable
  = lens _lTransferable
      (\ s a -> s{_lTransferable = a})

-- | [Output Only] Server-defined URL for the resource.
lSelfLink :: Lens' License (Maybe Text)
lSelfLink
  = lens _lSelfLink (\ s a -> s{_lSelfLink = a})

-- | Name of the resource. The name must be 1-63 characters long and comply
-- with RFC1035.
lName :: Lens' License (Maybe Text)
lName = lens _lName (\ s a -> s{_lName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
lCreationTimestamp :: Lens' License (Maybe Text)
lCreationTimestamp
  = lens _lCreationTimestamp
      (\ s a -> s{_lCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
lId :: Lens' License (Maybe Word64)
lId
  = lens _lId (\ s a -> s{_lId = a}) . mapping _Coerce

-- | An optional textual description of the resource; provided by the client
-- when the resource is created.
lDescription :: Lens' License (Maybe Text)
lDescription
  = lens _lDescription (\ s a -> s{_lDescription = a})

-- | [Output Only] The unique code used to attach this license to images,
-- snapshots, and disks.
lLicenseCode :: Lens' License (Maybe Word64)
lLicenseCode
  = lens _lLicenseCode (\ s a -> s{_lLicenseCode = a})
      . mapping _Coerce

instance FromJSON License where
        parseJSON
          = withObject "License"
              (\ o ->
                 License' <$>
                   (o .:? "chargesUseFee") <*>
                     (o .:? "kind" .!= "compute#license")
                     <*> (o .:? "resourceRequirements")
                     <*> (o .:? "transferable")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "description")
                     <*> (o .:? "licenseCode"))

instance ToJSON License where
        toJSON License'{..}
          = object
              (catMaybes
                 [("chargesUseFee" .=) <$> _lChargesUseFee,
                  Just ("kind" .= _lKind),
                  ("resourceRequirements" .=) <$>
                    _lResourceRequirements,
                  ("transferable" .=) <$> _lTransferable,
                  ("selfLink" .=) <$> _lSelfLink,
                  ("name" .=) <$> _lName,
                  ("creationTimestamp" .=) <$> _lCreationTimestamp,
                  ("id" .=) <$> _lId,
                  ("description" .=) <$> _lDescription,
                  ("licenseCode" .=) <$> _lLicenseCode])

-- | A path-matching rule for a URL. If matched, will use the specified
-- BackendService to handle the traffic arriving at this URL.
--
-- /See:/ 'pathRule' smart constructor.
data PathRule =
  PathRule'
    { _prService :: !(Maybe Text)
    , _prRouteAction :: !(Maybe HTTPRouteAction)
    , _prPaths :: !(Maybe [Text])
    , _prURLRedirect :: !(Maybe HTTPRedirectAction)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PathRule' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'prService'
--
-- * 'prRouteAction'
--
-- * 'prPaths'
--
-- * 'prURLRedirect'
pathRule
    :: PathRule
pathRule =
  PathRule'
    { _prService = Nothing
    , _prRouteAction = Nothing
    , _prPaths = Nothing
    , _prURLRedirect = Nothing
    }


-- | The full or partial URL of the backend service resource to which traffic
-- is directed if this rule is matched. If routeAction is additionally
-- specified, advanced routing actions like URL Rewrites, etc. take effect
-- prior to sending the request to the backend. However, if service is
-- specified, routeAction cannot contain any weightedBackendService s.
-- Conversely, if routeAction specifies any weightedBackendServices,
-- service must not be specified. Only one of urlRedirect, service or
-- routeAction.weightedBackendService must be set.
prService :: Lens' PathRule (Maybe Text)
prService
  = lens _prService (\ s a -> s{_prService = a})

-- | In response to a matching path, the load balancer performs advanced
-- routing actions like URL rewrites, header transformations, etc. prior to
-- forwarding the request to the selected backend. If routeAction specifies
-- any weightedBackendServices, service must not be set. Conversely if
-- service is set, routeAction cannot contain any weightedBackendServices.
-- Only one of routeAction or urlRedirect must be set. UrlMaps for external
-- HTTP(S) load balancers support only the urlRewrite action within a
-- pathRule\'s routeAction.
prRouteAction :: Lens' PathRule (Maybe HTTPRouteAction)
prRouteAction
  = lens _prRouteAction
      (\ s a -> s{_prRouteAction = a})

-- | The list of path patterns to match. Each must start with \/ and the only
-- place a * is allowed is at the end following a \/. The string fed to the
-- path matcher does not include any text after the first ? or #, and those
-- chars are not allowed here.
prPaths :: Lens' PathRule [Text]
prPaths
  = lens _prPaths (\ s a -> s{_prPaths = a}) . _Default
      . _Coerce

-- | When a path pattern is matched, the request is redirected to a URL
-- specified by urlRedirect. If urlRedirect is specified, service or
-- routeAction must not be set. Not supported when the URL map is bound to
-- target gRPC proxy.
prURLRedirect :: Lens' PathRule (Maybe HTTPRedirectAction)
prURLRedirect
  = lens _prURLRedirect
      (\ s a -> s{_prURLRedirect = a})

instance FromJSON PathRule where
        parseJSON
          = withObject "PathRule"
              (\ o ->
                 PathRule' <$>
                   (o .:? "service") <*> (o .:? "routeAction") <*>
                     (o .:? "paths" .!= mempty)
                     <*> (o .:? "urlRedirect"))

instance ToJSON PathRule where
        toJSON PathRule'{..}
          = object
              (catMaybes
                 [("service" .=) <$> _prService,
                  ("routeAction" .=) <$> _prRouteAction,
                  ("paths" .=) <$> _prPaths,
                  ("urlRedirect" .=) <$> _prURLRedirect])

--
-- /See:/ 'licenseCodeLicenseAlias' smart constructor.
data LicenseCodeLicenseAlias =
  LicenseCodeLicenseAlias'
    { _lclaSelfLink :: !(Maybe Text)
    , _lclaDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'LicenseCodeLicenseAlias' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'lclaSelfLink'
--
-- * 'lclaDescription'
licenseCodeLicenseAlias
    :: LicenseCodeLicenseAlias
licenseCodeLicenseAlias =
  LicenseCodeLicenseAlias' {_lclaSelfLink = Nothing, _lclaDescription = Nothing}


-- | [Output Only] URL of license corresponding to this License Code.
lclaSelfLink :: Lens' LicenseCodeLicenseAlias (Maybe Text)
lclaSelfLink
  = lens _lclaSelfLink (\ s a -> s{_lclaSelfLink = a})

-- | [Output Only] Description of this License Code.
lclaDescription :: Lens' LicenseCodeLicenseAlias (Maybe Text)
lclaDescription
  = lens _lclaDescription
      (\ s a -> s{_lclaDescription = a})

instance FromJSON LicenseCodeLicenseAlias where
        parseJSON
          = withObject "LicenseCodeLicenseAlias"
              (\ o ->
                 LicenseCodeLicenseAlias' <$>
                   (o .:? "selfLink") <*> (o .:? "description"))

instance ToJSON LicenseCodeLicenseAlias where
        toJSON LicenseCodeLicenseAlias'{..}
          = object
              (catMaybes
                 [("selfLink" .=) <$> _lclaSelfLink,
                  ("description" .=) <$> _lclaDescription])

--
-- /See:/ 'notificationEndpointListWarningDataItem' smart constructor.
data NotificationEndpointListWarningDataItem =
  NotificationEndpointListWarningDataItem'
    { _nelwdiValue :: !(Maybe Text)
    , _nelwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NotificationEndpointListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nelwdiValue'
--
-- * 'nelwdiKey'
notificationEndpointListWarningDataItem
    :: NotificationEndpointListWarningDataItem
notificationEndpointListWarningDataItem =
  NotificationEndpointListWarningDataItem'
    {_nelwdiValue = Nothing, _nelwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
nelwdiValue :: Lens' NotificationEndpointListWarningDataItem (Maybe Text)
nelwdiValue
  = lens _nelwdiValue (\ s a -> s{_nelwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
nelwdiKey :: Lens' NotificationEndpointListWarningDataItem (Maybe Text)
nelwdiKey
  = lens _nelwdiKey (\ s a -> s{_nelwdiKey = a})

instance FromJSON
           NotificationEndpointListWarningDataItem
         where
        parseJSON
          = withObject
              "NotificationEndpointListWarningDataItem"
              (\ o ->
                 NotificationEndpointListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           NotificationEndpointListWarningDataItem
         where
        toJSON NotificationEndpointListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _nelwdiValue,
                  ("key" .=) <$> _nelwdiKey])

--
-- /See:/ 'interconnectAttachmentsScopedListWarningDataItem' smart constructor.
data InterconnectAttachmentsScopedListWarningDataItem =
  InterconnectAttachmentsScopedListWarningDataItem'
    { _iaslwdiValue :: !(Maybe Text)
    , _iaslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectAttachmentsScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iaslwdiValue'
--
-- * 'iaslwdiKey'
interconnectAttachmentsScopedListWarningDataItem
    :: InterconnectAttachmentsScopedListWarningDataItem
interconnectAttachmentsScopedListWarningDataItem =
  InterconnectAttachmentsScopedListWarningDataItem'
    {_iaslwdiValue = Nothing, _iaslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
iaslwdiValue :: Lens' InterconnectAttachmentsScopedListWarningDataItem (Maybe Text)
iaslwdiValue
  = lens _iaslwdiValue (\ s a -> s{_iaslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
iaslwdiKey :: Lens' InterconnectAttachmentsScopedListWarningDataItem (Maybe Text)
iaslwdiKey
  = lens _iaslwdiKey (\ s a -> s{_iaslwdiKey = a})

instance FromJSON
           InterconnectAttachmentsScopedListWarningDataItem
         where
        parseJSON
          = withObject
              "InterconnectAttachmentsScopedListWarningDataItem"
              (\ o ->
                 InterconnectAttachmentsScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           InterconnectAttachmentsScopedListWarningDataItem
         where
        toJSON
          InterconnectAttachmentsScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _iaslwdiValue,
                  ("key" .=) <$> _iaslwdiKey])

--
-- /See:/ 'securityPolicyListWarningDataItem' smart constructor.
data SecurityPolicyListWarningDataItem =
  SecurityPolicyListWarningDataItem'
    { _secValue :: !(Maybe Text)
    , _secKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SecurityPolicyListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'secValue'
--
-- * 'secKey'
securityPolicyListWarningDataItem
    :: SecurityPolicyListWarningDataItem
securityPolicyListWarningDataItem =
  SecurityPolicyListWarningDataItem' {_secValue = Nothing, _secKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
secValue :: Lens' SecurityPolicyListWarningDataItem (Maybe Text)
secValue = lens _secValue (\ s a -> s{_secValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
secKey :: Lens' SecurityPolicyListWarningDataItem (Maybe Text)
secKey = lens _secKey (\ s a -> s{_secKey = a})

instance FromJSON SecurityPolicyListWarningDataItem
         where
        parseJSON
          = withObject "SecurityPolicyListWarningDataItem"
              (\ o ->
                 SecurityPolicyListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON SecurityPolicyListWarningDataItem
         where
        toJSON SecurityPolicyListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _secValue, ("key" .=) <$> _secKey])

-- | Configuration of preserved resources.
--
-- /See:/ 'statefulPolicyPreservedState' smart constructor.
newtype StatefulPolicyPreservedState =
  StatefulPolicyPreservedState'
    { _sppsDisks :: Maybe StatefulPolicyPreservedStateDisks
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'StatefulPolicyPreservedState' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sppsDisks'
statefulPolicyPreservedState
    :: StatefulPolicyPreservedState
statefulPolicyPreservedState =
  StatefulPolicyPreservedState' {_sppsDisks = Nothing}


-- | Disks created on the instances that will be preserved on instance
-- delete, update, etc. This map is keyed with the device names of the
-- disks.
sppsDisks :: Lens' StatefulPolicyPreservedState (Maybe StatefulPolicyPreservedStateDisks)
sppsDisks
  = lens _sppsDisks (\ s a -> s{_sppsDisks = a})

instance FromJSON StatefulPolicyPreservedState where
        parseJSON
          = withObject "StatefulPolicyPreservedState"
              (\ o ->
                 StatefulPolicyPreservedState' <$> (o .:? "disks"))

instance ToJSON StatefulPolicyPreservedState where
        toJSON StatefulPolicyPreservedState'{..}
          = object (catMaybes [("disks" .=) <$> _sppsDisks])

-- | Represents a Target gRPC Proxy resource. A target gRPC proxy is a
-- component of load balancers intended for load balancing gRPC traffic.
-- Only global forwarding rules with load balancing scheme
-- INTERNAL_SELF_MANAGED can reference a target gRPC proxy. The target gRPC
-- Proxy references a URL map that specifies how traffic is routed to gRPC
-- backend services. (== resource_for {$api_version}.targetGrpcProxies ==)
--
-- /See:/ 'targetGrpcProxy' smart constructor.
data TargetGrpcProxy =
  TargetGrpcProxy'
    { _tgpURLMap :: !(Maybe Text)
    , _tgpKind :: !Text
    , _tgpValidateForProxyless :: !(Maybe Bool)
    , _tgpFingerprint :: !(Maybe Bytes)
    , _tgpSelfLinkWithId :: !(Maybe Text)
    , _tgpSelfLink :: !(Maybe Text)
    , _tgpName :: !(Maybe Text)
    , _tgpCreationTimestamp :: !(Maybe Text)
    , _tgpId :: !(Maybe (Textual Word64))
    , _tgpDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetGrpcProxy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tgpURLMap'
--
-- * 'tgpKind'
--
-- * 'tgpValidateForProxyless'
--
-- * 'tgpFingerprint'
--
-- * 'tgpSelfLinkWithId'
--
-- * 'tgpSelfLink'
--
-- * 'tgpName'
--
-- * 'tgpCreationTimestamp'
--
-- * 'tgpId'
--
-- * 'tgpDescription'
targetGrpcProxy
    :: TargetGrpcProxy
targetGrpcProxy =
  TargetGrpcProxy'
    { _tgpURLMap = Nothing
    , _tgpKind = "compute#targetGrpcProxy"
    , _tgpValidateForProxyless = Nothing
    , _tgpFingerprint = Nothing
    , _tgpSelfLinkWithId = Nothing
    , _tgpSelfLink = Nothing
    , _tgpName = Nothing
    , _tgpCreationTimestamp = Nothing
    , _tgpId = Nothing
    , _tgpDescription = Nothing
    }


-- | URL to the UrlMap resource that defines the mapping from URL to the
-- BackendService. The protocol field in the BackendService must be set to
-- GRPC.
tgpURLMap :: Lens' TargetGrpcProxy (Maybe Text)
tgpURLMap
  = lens _tgpURLMap (\ s a -> s{_tgpURLMap = a})

-- | [Output Only] Type of the resource. Always compute#targetGrpcProxy for
-- target grpc proxies.
tgpKind :: Lens' TargetGrpcProxy Text
tgpKind = lens _tgpKind (\ s a -> s{_tgpKind = a})

-- | If true, indicates that the BackendServices referenced by the urlMap may
-- be accessed by gRPC applications without using a sidecar proxy. This
-- will enable configuration checks on urlMap and its referenced
-- BackendServices to not allow unsupported features. A gRPC application
-- must use \"xds:\/\/\/\" scheme in the target URI of the service it is
-- connecting to. If false, indicates that the BackendServices referenced
-- by the urlMap will be accessed by gRPC applications via a sidecar proxy.
-- In this case, a gRPC application must not use \"xds:\/\/\/\" scheme in
-- the target URI of the service it is connecting to
tgpValidateForProxyless :: Lens' TargetGrpcProxy (Maybe Bool)
tgpValidateForProxyless
  = lens _tgpValidateForProxyless
      (\ s a -> s{_tgpValidateForProxyless = a})

-- | Fingerprint of this resource. A hash of the contents stored in this
-- object. This field is used in optimistic locking. This field will be
-- ignored when inserting a TargetGrpcProxy. An up-to-date fingerprint must
-- be provided in order to patch\/update the TargetGrpcProxy; otherwise,
-- the request will fail with error 412 conditionNotMet. To see the latest
-- fingerprint, make a get() request to retrieve the TargetGrpcProxy.
tgpFingerprint :: Lens' TargetGrpcProxy (Maybe ByteString)
tgpFingerprint
  = lens _tgpFingerprint
      (\ s a -> s{_tgpFingerprint = a})
      . mapping _Bytes

-- | [Output Only] Server-defined URL with id for the resource.
tgpSelfLinkWithId :: Lens' TargetGrpcProxy (Maybe Text)
tgpSelfLinkWithId
  = lens _tgpSelfLinkWithId
      (\ s a -> s{_tgpSelfLinkWithId = a})

-- | [Output Only] Server-defined URL for the resource.
tgpSelfLink :: Lens' TargetGrpcProxy (Maybe Text)
tgpSelfLink
  = lens _tgpSelfLink (\ s a -> s{_tgpSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
tgpName :: Lens' TargetGrpcProxy (Maybe Text)
tgpName = lens _tgpName (\ s a -> s{_tgpName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
tgpCreationTimestamp :: Lens' TargetGrpcProxy (Maybe Text)
tgpCreationTimestamp
  = lens _tgpCreationTimestamp
      (\ s a -> s{_tgpCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource type. The server
-- generates this identifier.
tgpId :: Lens' TargetGrpcProxy (Maybe Word64)
tgpId
  = lens _tgpId (\ s a -> s{_tgpId = a}) .
      mapping _Coerce

-- | An optional description of this resource. Provide this property when you
-- create the resource.
tgpDescription :: Lens' TargetGrpcProxy (Maybe Text)
tgpDescription
  = lens _tgpDescription
      (\ s a -> s{_tgpDescription = a})

instance FromJSON TargetGrpcProxy where
        parseJSON
          = withObject "TargetGrpcProxy"
              (\ o ->
                 TargetGrpcProxy' <$>
                   (o .:? "urlMap") <*>
                     (o .:? "kind" .!= "compute#targetGrpcProxy")
                     <*> (o .:? "validateForProxyless")
                     <*> (o .:? "fingerprint")
                     <*> (o .:? "selfLinkWithId")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "description"))

instance ToJSON TargetGrpcProxy where
        toJSON TargetGrpcProxy'{..}
          = object
              (catMaybes
                 [("urlMap" .=) <$> _tgpURLMap,
                  Just ("kind" .= _tgpKind),
                  ("validateForProxyless" .=) <$>
                    _tgpValidateForProxyless,
                  ("fingerprint" .=) <$> _tgpFingerprint,
                  ("selfLinkWithId" .=) <$> _tgpSelfLinkWithId,
                  ("selfLink" .=) <$> _tgpSelfLink,
                  ("name" .=) <$> _tgpName,
                  ("creationTimestamp" .=) <$> _tgpCreationTimestamp,
                  ("id" .=) <$> _tgpId,
                  ("description" .=) <$> _tgpDescription])

-- | Provides the configuration for logging a type of permissions. Example: {
-- \"audit_log_configs\": [ { \"log_type\": \"DATA_READ\",
-- \"exempted_members\": [ \"user:jose\'example.com\" ] }, { \"log_type\":
-- \"DATA_WRITE\" } ] } This enables \'DATA_READ\' and \'DATA_WRITE\'
-- logging, while exempting jose\'example.com from DATA_READ logging.
--
-- /See:/ 'auditLogConfig' smart constructor.
data AuditLogConfig =
  AuditLogConfig'
    { _alcLogType :: !(Maybe AuditLogConfigLogType)
    , _alcIgnoreChildExemptions :: !(Maybe Bool)
    , _alcExemptedMembers :: !(Maybe [Text])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AuditLogConfig' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'alcLogType'
--
-- * 'alcIgnoreChildExemptions'
--
-- * 'alcExemptedMembers'
auditLogConfig
    :: AuditLogConfig
auditLogConfig =
  AuditLogConfig'
    { _alcLogType = Nothing
    , _alcIgnoreChildExemptions = Nothing
    , _alcExemptedMembers = Nothing
    }


-- | The log type that this config enables.
alcLogType :: Lens' AuditLogConfig (Maybe AuditLogConfigLogType)
alcLogType
  = lens _alcLogType (\ s a -> s{_alcLogType = a})

-- |
alcIgnoreChildExemptions :: Lens' AuditLogConfig (Maybe Bool)
alcIgnoreChildExemptions
  = lens _alcIgnoreChildExemptions
      (\ s a -> s{_alcIgnoreChildExemptions = a})

-- | Specifies the identities that do not cause logging for this type of
-- permission. Follows the same format of [Binding.members][].
alcExemptedMembers :: Lens' AuditLogConfig [Text]
alcExemptedMembers
  = lens _alcExemptedMembers
      (\ s a -> s{_alcExemptedMembers = a})
      . _Default
      . _Coerce

instance FromJSON AuditLogConfig where
        parseJSON
          = withObject "AuditLogConfig"
              (\ o ->
                 AuditLogConfig' <$>
                   (o .:? "logType") <*> (o .:? "ignoreChildExemptions")
                     <*> (o .:? "exemptedMembers" .!= mempty))

instance ToJSON AuditLogConfig where
        toJSON AuditLogConfig'{..}
          = object
              (catMaybes
                 [("logType" .=) <$> _alcLogType,
                  ("ignoreChildExemptions" .=) <$>
                    _alcIgnoreChildExemptions,
                  ("exemptedMembers" .=) <$> _alcExemptedMembers])

-- | A guest attributes namespace\/key\/value entry.
--
-- /See:/ 'guestAttributesEntry' smart constructor.
data GuestAttributesEntry =
  GuestAttributesEntry'
    { _gaeValue :: !(Maybe Text)
    , _gaeNamespace :: !(Maybe Text)
    , _gaeKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'GuestAttributesEntry' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'gaeValue'
--
-- * 'gaeNamespace'
--
-- * 'gaeKey'
guestAttributesEntry
    :: GuestAttributesEntry
guestAttributesEntry =
  GuestAttributesEntry'
    {_gaeValue = Nothing, _gaeNamespace = Nothing, _gaeKey = Nothing}


-- | Value for the guest attribute entry.
gaeValue :: Lens' GuestAttributesEntry (Maybe Text)
gaeValue = lens _gaeValue (\ s a -> s{_gaeValue = a})

-- | Namespace for the guest attribute entry.
gaeNamespace :: Lens' GuestAttributesEntry (Maybe Text)
gaeNamespace
  = lens _gaeNamespace (\ s a -> s{_gaeNamespace = a})

-- | Key for the guest attribute entry.
gaeKey :: Lens' GuestAttributesEntry (Maybe Text)
gaeKey = lens _gaeKey (\ s a -> s{_gaeKey = a})

instance FromJSON GuestAttributesEntry where
        parseJSON
          = withObject "GuestAttributesEntry"
              (\ o ->
                 GuestAttributesEntry' <$>
                   (o .:? "value") <*> (o .:? "namespace") <*>
                     (o .:? "key"))

instance ToJSON GuestAttributesEntry where
        toJSON GuestAttributesEntry'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _gaeValue,
                  ("namespace" .=) <$> _gaeNamespace,
                  ("key" .=) <$> _gaeKey])

--
-- /See:/ 'commitmentsScopedListWarningDataItem' smart constructor.
data CommitmentsScopedListWarningDataItem =
  CommitmentsScopedListWarningDataItem'
    { _cslwdiValue :: !(Maybe Text)
    , _cslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'CommitmentsScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'cslwdiValue'
--
-- * 'cslwdiKey'
commitmentsScopedListWarningDataItem
    :: CommitmentsScopedListWarningDataItem
commitmentsScopedListWarningDataItem =
  CommitmentsScopedListWarningDataItem'
    {_cslwdiValue = Nothing, _cslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
cslwdiValue :: Lens' CommitmentsScopedListWarningDataItem (Maybe Text)
cslwdiValue
  = lens _cslwdiValue (\ s a -> s{_cslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
cslwdiKey :: Lens' CommitmentsScopedListWarningDataItem (Maybe Text)
cslwdiKey
  = lens _cslwdiKey (\ s a -> s{_cslwdiKey = a})

instance FromJSON
           CommitmentsScopedListWarningDataItem
         where
        parseJSON
          = withObject "CommitmentsScopedListWarningDataItem"
              (\ o ->
                 CommitmentsScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON CommitmentsScopedListWarningDataItem
         where
        toJSON CommitmentsScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _cslwdiValue,
                  ("key" .=) <$> _cslwdiKey])

-- | Represents an Interconnect Attachment (VLAN) resource. You can use
-- Interconnect attachments (VLANS) to connect your Virtual Private Cloud
-- networks to your on-premises networks through an Interconnect. For more
-- information, read Creating VLAN Attachments. (== resource_for
-- {$api_version}.interconnectAttachments ==)
--
-- /See:/ 'interconnectAttachment' smart constructor.
data InterconnectAttachment =
  InterconnectAttachment'
    { _iaMtu :: !(Maybe (Textual Int32))
    , _iaState :: !(Maybe InterconnectAttachmentState)
    , _iaPartnerASN :: !(Maybe (Textual Int64))
    , _iaPairingKey :: !(Maybe Text)
    , _iaKind :: !Text
    , _iaCustomerRouterIPAddress :: !(Maybe Text)
    , _iaIPsecInternalAddresses :: !(Maybe [Text])
    , _iaPartnerMetadata :: !(Maybe InterconnectAttachmentPartnerMetadata)
    , _iaRouter :: !(Maybe Text)
    , _iaOperationalStatus :: !(Maybe InterconnectAttachmentOperationalStatus)
    , _iaDataplaneVersion :: !(Maybe (Textual Int32))
    , _iaSelfLink :: !(Maybe Text)
    , _iaName :: !(Maybe Text)
    , _iaBandwidth :: !(Maybe InterconnectAttachmentBandwidth)
    , _iaEncryption :: !(Maybe InterconnectAttachmentEncryption)
    , _iaGoogleReferenceId :: !(Maybe Text)
    , _iaCreationTimestamp :: !(Maybe Text)
    , _iaEdgeAvailabilityDomain :: !(Maybe InterconnectAttachmentEdgeAvailabilityDomain)
    , _iaInterconnect :: !(Maybe Text)
    , _iaAdminEnabled :: !(Maybe Bool)
    , _iaVLANTag8021q :: !(Maybe (Textual Int32))
    , _iaCloudRouterIPAddress :: !(Maybe Text)
    , _iaId :: !(Maybe (Textual Word64))
    , _iaCandidateSubnets :: !(Maybe [Text])
    , _iaRegion :: !(Maybe Text)
    , _iaType :: !(Maybe InterconnectAttachmentType)
    , _iaDescription :: !(Maybe Text)
    , _iaPrivateInterconnectInfo :: !(Maybe InterconnectAttachmentPrivateInfo)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectAttachment' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iaMtu'
--
-- * 'iaState'
--
-- * 'iaPartnerASN'
--
-- * 'iaPairingKey'
--
-- * 'iaKind'
--
-- * 'iaCustomerRouterIPAddress'
--
-- * 'iaIPsecInternalAddresses'
--
-- * 'iaPartnerMetadata'
--
-- * 'iaRouter'
--
-- * 'iaOperationalStatus'
--
-- * 'iaDataplaneVersion'
--
-- * 'iaSelfLink'
--
-- * 'iaName'
--
-- * 'iaBandwidth'
--
-- * 'iaEncryption'
--
-- * 'iaGoogleReferenceId'
--
-- * 'iaCreationTimestamp'
--
-- * 'iaEdgeAvailabilityDomain'
--
-- * 'iaInterconnect'
--
-- * 'iaAdminEnabled'
--
-- * 'iaVLANTag8021q'
--
-- * 'iaCloudRouterIPAddress'
--
-- * 'iaId'
--
-- * 'iaCandidateSubnets'
--
-- * 'iaRegion'
--
-- * 'iaType'
--
-- * 'iaDescription'
--
-- * 'iaPrivateInterconnectInfo'
interconnectAttachment
    :: InterconnectAttachment
interconnectAttachment =
  InterconnectAttachment'
    { _iaMtu = Nothing
    , _iaState = Nothing
    , _iaPartnerASN = Nothing
    , _iaPairingKey = Nothing
    , _iaKind = "compute#interconnectAttachment"
    , _iaCustomerRouterIPAddress = Nothing
    , _iaIPsecInternalAddresses = Nothing
    , _iaPartnerMetadata = Nothing
    , _iaRouter = Nothing
    , _iaOperationalStatus = Nothing
    , _iaDataplaneVersion = Nothing
    , _iaSelfLink = Nothing
    , _iaName = Nothing
    , _iaBandwidth = Nothing
    , _iaEncryption = Nothing
    , _iaGoogleReferenceId = Nothing
    , _iaCreationTimestamp = Nothing
    , _iaEdgeAvailabilityDomain = Nothing
    , _iaInterconnect = Nothing
    , _iaAdminEnabled = Nothing
    , _iaVLANTag8021q = Nothing
    , _iaCloudRouterIPAddress = Nothing
    , _iaId = Nothing
    , _iaCandidateSubnets = Nothing
    , _iaRegion = Nothing
    , _iaType = Nothing
    , _iaDescription = Nothing
    , _iaPrivateInterconnectInfo = Nothing
    }


-- | Maximum Transmission Unit (MTU), in bytes, of packets passing through
-- this interconnect attachment. Only 1440 and 1500 are allowed. If not
-- specified, the value will default to 1440.
iaMtu :: Lens' InterconnectAttachment (Maybe Int32)
iaMtu
  = lens _iaMtu (\ s a -> s{_iaMtu = a}) .
      mapping _Coerce

-- | [Output Only] The current state of this attachment\'s functionality.
-- Enum values ACTIVE and UNPROVISIONED are shared by DEDICATED\/PRIVATE,
-- PARTNER, and PARTNER_PROVIDER interconnect attachments, while enum
-- values PENDING_PARTNER, PARTNER_REQUEST_RECEIVED, and PENDING_CUSTOMER
-- are used for only PARTNER and PARTNER_PROVIDER interconnect attachments.
-- This state can take one of the following values: - ACTIVE: The
-- attachment has been turned up and is ready to use. - UNPROVISIONED: The
-- attachment is not ready to use yet, because turnup is not complete. -
-- PENDING_PARTNER: A newly-created PARTNER attachment that has not yet
-- been configured on the Partner side. - PARTNER_REQUEST_RECEIVED: A
-- PARTNER attachment is in the process of provisioning after a
-- PARTNER_PROVIDER attachment was created that references it. -
-- PENDING_CUSTOMER: A PARTNER or PARTNER_PROVIDER attachment that is
-- waiting for a customer to activate it. - DEFUNCT: The attachment was
-- deleted externally and is no longer functional. This could be because
-- the associated Interconnect was removed, or because the other side of a
-- Partner attachment was deleted.
iaState :: Lens' InterconnectAttachment (Maybe InterconnectAttachmentState)
iaState = lens _iaState (\ s a -> s{_iaState = a})

-- | Optional BGP ASN for the router supplied by a Layer 3 Partner if they
-- configured BGP on behalf of the customer. Output only for PARTNER type,
-- input only for PARTNER_PROVIDER, not available for DEDICATED.
iaPartnerASN :: Lens' InterconnectAttachment (Maybe Int64)
iaPartnerASN
  = lens _iaPartnerASN (\ s a -> s{_iaPartnerASN = a})
      . mapping _Coerce

-- | [Output only for type PARTNER. Input only for PARTNER_PROVIDER. Not
-- present for DEDICATED]. The opaque identifier of an PARTNER attachment
-- used to initiate provisioning with a selected partner. Of the form
-- \"XXXXX\/region\/domain\"
iaPairingKey :: Lens' InterconnectAttachment (Maybe Text)
iaPairingKey
  = lens _iaPairingKey (\ s a -> s{_iaPairingKey = a})

-- | [Output Only] Type of the resource. Always
-- compute#interconnectAttachment for interconnect attachments.
iaKind :: Lens' InterconnectAttachment Text
iaKind = lens _iaKind (\ s a -> s{_iaKind = a})

-- | [Output Only] IPv4 address + prefix length to be configured on the
-- customer router subinterface for this interconnect attachment.
iaCustomerRouterIPAddress :: Lens' InterconnectAttachment (Maybe Text)
iaCustomerRouterIPAddress
  = lens _iaCustomerRouterIPAddress
      (\ s a -> s{_iaCustomerRouterIPAddress = a})

-- | List of URL of addresses that have been reserved for the VLAN
-- attachment. Used only for the VLAN attachment that has the encryption
-- option as IPSEC. The addresses must be regional internal IP address
-- ranges. When creating an HA VPN gateway over the VLAN attachment, if the
-- attachment is configured to use a regional internal IP address, then the
-- VPN gateway\'s IP address is allocated from the IP address range
-- specified here. For example, if the HA VPN gateway\'s interface 0 is
-- paired to this VLAN attachment, then a regional internal IP address for
-- the VPN gateway interface 0 will be allocated from the IP address
-- specified for this VLAN attachment. If this field is not specified when
-- creating the VLAN attachment, then later on when creating an HA VPN
-- gateway on this VLAN attachment, the HA VPN gateway\'s IP address is
-- allocated from the regional external IP address pool. Not currently
-- available publicly.
iaIPsecInternalAddresses :: Lens' InterconnectAttachment [Text]
iaIPsecInternalAddresses
  = lens _iaIPsecInternalAddresses
      (\ s a -> s{_iaIPsecInternalAddresses = a})
      . _Default
      . _Coerce

-- | Informational metadata about Partner attachments from Partners to
-- display to customers. Output only for for PARTNER type, mutable for
-- PARTNER_PROVIDER, not available for DEDICATED.
iaPartnerMetadata :: Lens' InterconnectAttachment (Maybe InterconnectAttachmentPartnerMetadata)
iaPartnerMetadata
  = lens _iaPartnerMetadata
      (\ s a -> s{_iaPartnerMetadata = a})

-- | URL of the Cloud Router to be used for dynamic routing. This router must
-- be in the same region as this InterconnectAttachment. The
-- InterconnectAttachment will automatically connect the Interconnect to
-- the network & region within which the Cloud Router is configured.
iaRouter :: Lens' InterconnectAttachment (Maybe Text)
iaRouter = lens _iaRouter (\ s a -> s{_iaRouter = a})

-- | [Output Only] The current status of whether or not this interconnect
-- attachment is functional, which can take one of the following values: -
-- OS_ACTIVE: The attachment has been turned up and is ready to use. -
-- OS_UNPROVISIONED: The attachment is not ready to use yet, because turnup
-- is not complete.
iaOperationalStatus :: Lens' InterconnectAttachment (Maybe InterconnectAttachmentOperationalStatus)
iaOperationalStatus
  = lens _iaOperationalStatus
      (\ s a -> s{_iaOperationalStatus = a})

-- | [Output Only] Dataplane version for this InterconnectAttachment.
iaDataplaneVersion :: Lens' InterconnectAttachment (Maybe Int32)
iaDataplaneVersion
  = lens _iaDataplaneVersion
      (\ s a -> s{_iaDataplaneVersion = a})
      . mapping _Coerce

-- | [Output Only] Server-defined URL for the resource.
iaSelfLink :: Lens' InterconnectAttachment (Maybe Text)
iaSelfLink
  = lens _iaSelfLink (\ s a -> s{_iaSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
iaName :: Lens' InterconnectAttachment (Maybe Text)
iaName = lens _iaName (\ s a -> s{_iaName = a})

-- | Provisioned bandwidth capacity for the interconnect attachment. For
-- attachments of type DEDICATED, the user can set the bandwidth. For
-- attachments of type PARTNER, the Google Partner that is operating the
-- interconnect must set the bandwidth. Output only for PARTNER type,
-- mutable for PARTNER_PROVIDER and DEDICATED, and can take one of the
-- following values: - BPS_50M: 50 Mbit\/s - BPS_100M: 100 Mbit\/s -
-- BPS_200M: 200 Mbit\/s - BPS_300M: 300 Mbit\/s - BPS_400M: 400 Mbit\/s -
-- BPS_500M: 500 Mbit\/s - BPS_1G: 1 Gbit\/s - BPS_2G: 2 Gbit\/s - BPS_5G:
-- 5 Gbit\/s - BPS_10G: 10 Gbit\/s - BPS_20G: 20 Gbit\/s - BPS_50G: 50
-- Gbit\/s
iaBandwidth :: Lens' InterconnectAttachment (Maybe InterconnectAttachmentBandwidth)
iaBandwidth
  = lens _iaBandwidth (\ s a -> s{_iaBandwidth = a})

-- | Indicates the user-supplied encryption option of this VLAN attachment
-- (interconnectAttachment). Can only be specified at attachment creation
-- for PARTNER or DEDICATED attachments. Possible values are: - NONE - This
-- is the default value, which means that the VLAN attachment carries
-- unencrypted traffic. VMs are able to send traffic to, or receive traffic
-- from, such a VLAN attachment. - IPSEC - The VLAN attachment carries only
-- encrypted traffic that is encrypted by an IPsec device, such as an HA
-- VPN gateway or third-party IPsec VPN. VMs cannot directly send traffic
-- to, or receive traffic from, such a VLAN attachment. To use
-- IPsec-encrypted Cloud Interconnect, the VLAN attachment must be created
-- with this option. Not currently available publicly.
iaEncryption :: Lens' InterconnectAttachment (Maybe InterconnectAttachmentEncryption)
iaEncryption
  = lens _iaEncryption (\ s a -> s{_iaEncryption = a})

-- | [Output Only] Google reference ID, to be used when raising support
-- tickets with Google or otherwise to debug backend connectivity issues.
-- [Deprecated] This field is not used.
iaGoogleReferenceId :: Lens' InterconnectAttachment (Maybe Text)
iaGoogleReferenceId
  = lens _iaGoogleReferenceId
      (\ s a -> s{_iaGoogleReferenceId = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
iaCreationTimestamp :: Lens' InterconnectAttachment (Maybe Text)
iaCreationTimestamp
  = lens _iaCreationTimestamp
      (\ s a -> s{_iaCreationTimestamp = a})

-- | Desired availability domain for the attachment. Only available for type
-- PARTNER, at creation time, and can take one of the following values: -
-- AVAILABILITY_DOMAIN_ANY - AVAILABILITY_DOMAIN_1 - AVAILABILITY_DOMAIN_2
-- For improved reliability, customers should configure a pair of
-- attachments, one per availability domain. The selected availability
-- domain will be provided to the Partner via the pairing key, so that the
-- provisioned circuit will lie in the specified domain. If not specified,
-- the value will default to AVAILABILITY_DOMAIN_ANY.
iaEdgeAvailabilityDomain :: Lens' InterconnectAttachment (Maybe InterconnectAttachmentEdgeAvailabilityDomain)
iaEdgeAvailabilityDomain
  = lens _iaEdgeAvailabilityDomain
      (\ s a -> s{_iaEdgeAvailabilityDomain = a})

-- | URL of the underlying Interconnect object that this attachment\'s
-- traffic will traverse through.
iaInterconnect :: Lens' InterconnectAttachment (Maybe Text)
iaInterconnect
  = lens _iaInterconnect
      (\ s a -> s{_iaInterconnect = a})

-- | Determines whether this Attachment will carry packets. Not present for
-- PARTNER_PROVIDER.
iaAdminEnabled :: Lens' InterconnectAttachment (Maybe Bool)
iaAdminEnabled
  = lens _iaAdminEnabled
      (\ s a -> s{_iaAdminEnabled = a})

-- | The IEEE 802.1Q VLAN tag for this attachment, in the range 2-4094. Only
-- specified at creation time.
iaVLANTag8021q :: Lens' InterconnectAttachment (Maybe Int32)
iaVLANTag8021q
  = lens _iaVLANTag8021q
      (\ s a -> s{_iaVLANTag8021q = a})
      . mapping _Coerce

-- | [Output Only] IPv4 address + prefix length to be configured on Cloud
-- Router Interface for this interconnect attachment.
iaCloudRouterIPAddress :: Lens' InterconnectAttachment (Maybe Text)
iaCloudRouterIPAddress
  = lens _iaCloudRouterIPAddress
      (\ s a -> s{_iaCloudRouterIPAddress = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
iaId :: Lens' InterconnectAttachment (Maybe Word64)
iaId
  = lens _iaId (\ s a -> s{_iaId = a}) .
      mapping _Coerce

-- | Up to 16 candidate prefixes that can be used to restrict the allocation
-- of cloudRouterIpAddress and customerRouterIpAddress for this attachment.
-- All prefixes must be within link-local address space (169.254.0.0\/16)
-- and must be \/29 or shorter (\/28, \/27, etc). Google will attempt to
-- select an unused \/29 from the supplied candidate prefix(es). The
-- request will fail if all possible \/29s are in use on Google\'s edge. If
-- not supplied, Google will randomly select an unused \/29 from all of
-- link-local space.
iaCandidateSubnets :: Lens' InterconnectAttachment [Text]
iaCandidateSubnets
  = lens _iaCandidateSubnets
      (\ s a -> s{_iaCandidateSubnets = a})
      . _Default
      . _Coerce

-- | [Output Only] URL of the region where the regional interconnect
-- attachment resides. You must specify this field as part of the HTTP
-- request URL. It is not settable as a field in the request body.
iaRegion :: Lens' InterconnectAttachment (Maybe Text)
iaRegion = lens _iaRegion (\ s a -> s{_iaRegion = a})

-- | The type of interconnect attachment this is, which can take one of the
-- following values: - DEDICATED: an attachment to a Dedicated
-- Interconnect. - PARTNER: an attachment to a Partner Interconnect,
-- created by the customer. - PARTNER_PROVIDER: an attachment to a Partner
-- Interconnect, created by the partner.
iaType :: Lens' InterconnectAttachment (Maybe InterconnectAttachmentType)
iaType = lens _iaType (\ s a -> s{_iaType = a})

-- | An optional description of this resource.
iaDescription :: Lens' InterconnectAttachment (Maybe Text)
iaDescription
  = lens _iaDescription
      (\ s a -> s{_iaDescription = a})

-- | [Output Only] Information specific to an InterconnectAttachment. This
-- property is populated if the interconnect that this is attached to is of
-- type DEDICATED.
iaPrivateInterconnectInfo :: Lens' InterconnectAttachment (Maybe InterconnectAttachmentPrivateInfo)
iaPrivateInterconnectInfo
  = lens _iaPrivateInterconnectInfo
      (\ s a -> s{_iaPrivateInterconnectInfo = a})

instance FromJSON InterconnectAttachment where
        parseJSON
          = withObject "InterconnectAttachment"
              (\ o ->
                 InterconnectAttachment' <$>
                   (o .:? "mtu") <*> (o .:? "state") <*>
                     (o .:? "partnerAsn")
                     <*> (o .:? "pairingKey")
                     <*>
                     (o .:? "kind" .!= "compute#interconnectAttachment")
                     <*> (o .:? "customerRouterIpAddress")
                     <*> (o .:? "ipsecInternalAddresses" .!= mempty)
                     <*> (o .:? "partnerMetadata")
                     <*> (o .:? "router")
                     <*> (o .:? "operationalStatus")
                     <*> (o .:? "dataplaneVersion")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "bandwidth")
                     <*> (o .:? "encryption")
                     <*> (o .:? "googleReferenceId")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "edgeAvailabilityDomain")
                     <*> (o .:? "interconnect")
                     <*> (o .:? "adminEnabled")
                     <*> (o .:? "vlanTag8021q")
                     <*> (o .:? "cloudRouterIpAddress")
                     <*> (o .:? "id")
                     <*> (o .:? "candidateSubnets" .!= mempty)
                     <*> (o .:? "region")
                     <*> (o .:? "type")
                     <*> (o .:? "description")
                     <*> (o .:? "privateInterconnectInfo"))

instance ToJSON InterconnectAttachment where
        toJSON InterconnectAttachment'{..}
          = object
              (catMaybes
                 [("mtu" .=) <$> _iaMtu, ("state" .=) <$> _iaState,
                  ("partnerAsn" .=) <$> _iaPartnerASN,
                  ("pairingKey" .=) <$> _iaPairingKey,
                  Just ("kind" .= _iaKind),
                  ("customerRouterIpAddress" .=) <$>
                    _iaCustomerRouterIPAddress,
                  ("ipsecInternalAddresses" .=) <$>
                    _iaIPsecInternalAddresses,
                  ("partnerMetadata" .=) <$> _iaPartnerMetadata,
                  ("router" .=) <$> _iaRouter,
                  ("operationalStatus" .=) <$> _iaOperationalStatus,
                  ("dataplaneVersion" .=) <$> _iaDataplaneVersion,
                  ("selfLink" .=) <$> _iaSelfLink,
                  ("name" .=) <$> _iaName,
                  ("bandwidth" .=) <$> _iaBandwidth,
                  ("encryption" .=) <$> _iaEncryption,
                  ("googleReferenceId" .=) <$> _iaGoogleReferenceId,
                  ("creationTimestamp" .=) <$> _iaCreationTimestamp,
                  ("edgeAvailabilityDomain" .=) <$>
                    _iaEdgeAvailabilityDomain,
                  ("interconnect" .=) <$> _iaInterconnect,
                  ("adminEnabled" .=) <$> _iaAdminEnabled,
                  ("vlanTag8021q" .=) <$> _iaVLANTag8021q,
                  ("cloudRouterIpAddress" .=) <$>
                    _iaCloudRouterIPAddress,
                  ("id" .=) <$> _iaId,
                  ("candidateSubnets" .=) <$> _iaCandidateSubnets,
                  ("region" .=) <$> _iaRegion, ("type" .=) <$> _iaType,
                  ("description" .=) <$> _iaDescription,
                  ("privateInterconnectInfo" .=) <$>
                    _iaPrivateInterconnectInfo])

-- | Contains a list of instances.
--
-- /See:/ 'instanceList' smart constructor.
data InstanceList =
  InstanceList'
    { _insNextPageToken :: !(Maybe Text)
    , _insKind :: !Text
    , _insItems :: !(Maybe [Instance])
    , _insSelfLink :: !(Maybe Text)
    , _insWarning :: !(Maybe InstanceListWarning)
    , _insId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'insNextPageToken'
--
-- * 'insKind'
--
-- * 'insItems'
--
-- * 'insSelfLink'
--
-- * 'insWarning'
--
-- * 'insId'
instanceList
    :: InstanceList
instanceList =
  InstanceList'
    { _insNextPageToken = Nothing
    , _insKind = "compute#instanceList"
    , _insItems = Nothing
    , _insSelfLink = Nothing
    , _insWarning = Nothing
    , _insId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
insNextPageToken :: Lens' InstanceList (Maybe Text)
insNextPageToken
  = lens _insNextPageToken
      (\ s a -> s{_insNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#instanceList for lists of
-- Instance resources.
insKind :: Lens' InstanceList Text
insKind = lens _insKind (\ s a -> s{_insKind = a})

-- | A list of Instance resources.
insItems :: Lens' InstanceList [Instance]
insItems
  = lens _insItems (\ s a -> s{_insItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
insSelfLink :: Lens' InstanceList (Maybe Text)
insSelfLink
  = lens _insSelfLink (\ s a -> s{_insSelfLink = a})

-- | [Output Only] Informational warning message.
insWarning :: Lens' InstanceList (Maybe InstanceListWarning)
insWarning
  = lens _insWarning (\ s a -> s{_insWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
insId :: Lens' InstanceList (Maybe Text)
insId = lens _insId (\ s a -> s{_insId = a})

instance FromJSON InstanceList where
        parseJSON
          = withObject "InstanceList"
              (\ o ->
                 InstanceList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#instanceList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON InstanceList where
        toJSON InstanceList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _insNextPageToken,
                  Just ("kind" .= _insKind),
                  ("items" .=) <$> _insItems,
                  ("selfLink" .=) <$> _insSelfLink,
                  ("warning" .=) <$> _insWarning,
                  ("id" .=) <$> _insId])

-- | Labels to apply to scheduled snapshots. These can be later modified by
-- the setLabels method. Label values may be empty.
--
-- /See:/ 'resourcePolicySnapshotSchedulePolicySnapshotPropertiesLabels' smart constructor.
newtype ResourcePolicySnapshotSchedulePolicySnapshotPropertiesLabels =
  ResourcePolicySnapshotSchedulePolicySnapshotPropertiesLabels'
    { _rpsspsplAddtional :: HashMap Text Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePolicySnapshotSchedulePolicySnapshotPropertiesLabels' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rpsspsplAddtional'
resourcePolicySnapshotSchedulePolicySnapshotPropertiesLabels
    :: HashMap Text Text -- ^ 'rpsspsplAddtional'
    -> ResourcePolicySnapshotSchedulePolicySnapshotPropertiesLabels
resourcePolicySnapshotSchedulePolicySnapshotPropertiesLabels pRpsspsplAddtional_ =
  ResourcePolicySnapshotSchedulePolicySnapshotPropertiesLabels'
    {_rpsspsplAddtional = _Coerce # pRpsspsplAddtional_}


rpsspsplAddtional :: Lens' ResourcePolicySnapshotSchedulePolicySnapshotPropertiesLabels (HashMap Text Text)
rpsspsplAddtional
  = lens _rpsspsplAddtional
      (\ s a -> s{_rpsspsplAddtional = a})
      . _Coerce

instance FromJSON
           ResourcePolicySnapshotSchedulePolicySnapshotPropertiesLabels
         where
        parseJSON
          = withObject
              "ResourcePolicySnapshotSchedulePolicySnapshotPropertiesLabels"
              (\ o ->
                 ResourcePolicySnapshotSchedulePolicySnapshotPropertiesLabels'
                   <$> (parseJSONObject o))

instance ToJSON
           ResourcePolicySnapshotSchedulePolicySnapshotPropertiesLabels
         where
        toJSON = toJSON . _rpsspsplAddtional

-- | The labels to set for this resource.
--
-- /See:/ 'regionSetLabelsRequestLabels' smart constructor.
newtype RegionSetLabelsRequestLabels =
  RegionSetLabelsRequestLabels'
    { _rslrlAddtional :: HashMap Text Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionSetLabelsRequestLabels' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rslrlAddtional'
regionSetLabelsRequestLabels
    :: HashMap Text Text -- ^ 'rslrlAddtional'
    -> RegionSetLabelsRequestLabels
regionSetLabelsRequestLabels pRslrlAddtional_ =
  RegionSetLabelsRequestLabels' {_rslrlAddtional = _Coerce # pRslrlAddtional_}


rslrlAddtional :: Lens' RegionSetLabelsRequestLabels (HashMap Text Text)
rslrlAddtional
  = lens _rslrlAddtional
      (\ s a -> s{_rslrlAddtional = a})
      . _Coerce

instance FromJSON RegionSetLabelsRequestLabels where
        parseJSON
          = withObject "RegionSetLabelsRequestLabels"
              (\ o ->
                 RegionSetLabelsRequestLabels' <$>
                   (parseJSONObject o))

instance ToJSON RegionSetLabelsRequestLabels where
        toJSON = toJSON . _rslrlAddtional

--
-- /See:/ 'networkListWarningDataItem' smart constructor.
data NetworkListWarningDataItem =
  NetworkListWarningDataItem'
    { _nlwdiValue :: !(Maybe Text)
    , _nlwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nlwdiValue'
--
-- * 'nlwdiKey'
networkListWarningDataItem
    :: NetworkListWarningDataItem
networkListWarningDataItem =
  NetworkListWarningDataItem' {_nlwdiValue = Nothing, _nlwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
nlwdiValue :: Lens' NetworkListWarningDataItem (Maybe Text)
nlwdiValue
  = lens _nlwdiValue (\ s a -> s{_nlwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
nlwdiKey :: Lens' NetworkListWarningDataItem (Maybe Text)
nlwdiKey = lens _nlwdiKey (\ s a -> s{_nlwdiKey = a})

instance FromJSON NetworkListWarningDataItem where
        parseJSON
          = withObject "NetworkListWarningDataItem"
              (\ o ->
                 NetworkListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON NetworkListWarningDataItem where
        toJSON NetworkListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _nlwdiValue,
                  ("key" .=) <$> _nlwdiKey])

-- | Contains a list of PacketMirroring resources.
--
-- /See:/ 'packetMirroringList' smart constructor.
data PacketMirroringList =
  PacketMirroringList'
    { _pmlNextPageToken :: !(Maybe Text)
    , _pmlKind :: !Text
    , _pmlItems :: !(Maybe [PacketMirroring])
    , _pmlSelfLink :: !(Maybe Text)
    , _pmlWarning :: !(Maybe PacketMirroringListWarning)
    , _pmlId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PacketMirroringList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pmlNextPageToken'
--
-- * 'pmlKind'
--
-- * 'pmlItems'
--
-- * 'pmlSelfLink'
--
-- * 'pmlWarning'
--
-- * 'pmlId'
packetMirroringList
    :: PacketMirroringList
packetMirroringList =
  PacketMirroringList'
    { _pmlNextPageToken = Nothing
    , _pmlKind = "compute#packetMirroringList"
    , _pmlItems = Nothing
    , _pmlSelfLink = Nothing
    , _pmlWarning = Nothing
    , _pmlId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
pmlNextPageToken :: Lens' PacketMirroringList (Maybe Text)
pmlNextPageToken
  = lens _pmlNextPageToken
      (\ s a -> s{_pmlNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#packetMirroring for
-- packetMirrorings.
pmlKind :: Lens' PacketMirroringList Text
pmlKind = lens _pmlKind (\ s a -> s{_pmlKind = a})

-- | A list of PacketMirroring resources.
pmlItems :: Lens' PacketMirroringList [PacketMirroring]
pmlItems
  = lens _pmlItems (\ s a -> s{_pmlItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
pmlSelfLink :: Lens' PacketMirroringList (Maybe Text)
pmlSelfLink
  = lens _pmlSelfLink (\ s a -> s{_pmlSelfLink = a})

-- | [Output Only] Informational warning message.
pmlWarning :: Lens' PacketMirroringList (Maybe PacketMirroringListWarning)
pmlWarning
  = lens _pmlWarning (\ s a -> s{_pmlWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
pmlId :: Lens' PacketMirroringList (Maybe Text)
pmlId = lens _pmlId (\ s a -> s{_pmlId = a})

instance FromJSON PacketMirroringList where
        parseJSON
          = withObject "PacketMirroringList"
              (\ o ->
                 PacketMirroringList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#packetMirroringList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON PacketMirroringList where
        toJSON PacketMirroringList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _pmlNextPageToken,
                  Just ("kind" .= _pmlKind),
                  ("items" .=) <$> _pmlItems,
                  ("selfLink" .=) <$> _pmlSelfLink,
                  ("warning" .=) <$> _pmlWarning,
                  ("id" .=) <$> _pmlId])

-- | Message containing what to include in the cache key for a request for
-- Cloud CDN.
--
-- /See:/ 'cacheKeyPolicy' smart constructor.
data CacheKeyPolicy =
  CacheKeyPolicy'
    { _ckpQueryStringWhiteList :: !(Maybe [Text])
    , _ckpIncludeHost :: !(Maybe Bool)
    , _ckpIncludeProtocol :: !(Maybe Bool)
    , _ckpQueryStringBlackList :: !(Maybe [Text])
    , _ckpIncludeQueryString :: !(Maybe Bool)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'CacheKeyPolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ckpQueryStringWhiteList'
--
-- * 'ckpIncludeHost'
--
-- * 'ckpIncludeProtocol'
--
-- * 'ckpQueryStringBlackList'
--
-- * 'ckpIncludeQueryString'
cacheKeyPolicy
    :: CacheKeyPolicy
cacheKeyPolicy =
  CacheKeyPolicy'
    { _ckpQueryStringWhiteList = Nothing
    , _ckpIncludeHost = Nothing
    , _ckpIncludeProtocol = Nothing
    , _ckpQueryStringBlackList = Nothing
    , _ckpIncludeQueryString = Nothing
    }


-- | Names of query string parameters to include in cache keys. All other
-- parameters will be excluded. Either specify query_string_whitelist or
-- query_string_blacklist, not both. \'&\' and \'=\' will be percent
-- encoded and not treated as delimiters.
ckpQueryStringWhiteList :: Lens' CacheKeyPolicy [Text]
ckpQueryStringWhiteList
  = lens _ckpQueryStringWhiteList
      (\ s a -> s{_ckpQueryStringWhiteList = a})
      . _Default
      . _Coerce

-- | If true, requests to different hosts will be cached separately.
ckpIncludeHost :: Lens' CacheKeyPolicy (Maybe Bool)
ckpIncludeHost
  = lens _ckpIncludeHost
      (\ s a -> s{_ckpIncludeHost = a})

-- | If true, http and https requests will be cached separately.
ckpIncludeProtocol :: Lens' CacheKeyPolicy (Maybe Bool)
ckpIncludeProtocol
  = lens _ckpIncludeProtocol
      (\ s a -> s{_ckpIncludeProtocol = a})

-- | Names of query string parameters to exclude in cache keys. All other
-- parameters will be included. Either specify query_string_whitelist or
-- query_string_blacklist, not both. \'&\' and \'=\' will be percent
-- encoded and not treated as delimiters.
ckpQueryStringBlackList :: Lens' CacheKeyPolicy [Text]
ckpQueryStringBlackList
  = lens _ckpQueryStringBlackList
      (\ s a -> s{_ckpQueryStringBlackList = a})
      . _Default
      . _Coerce

-- | If true, include query string parameters in the cache key according to
-- query_string_whitelist and query_string_blacklist. If neither is set,
-- the entire query string will be included. If false, the query string
-- will be excluded from the cache key entirely.
ckpIncludeQueryString :: Lens' CacheKeyPolicy (Maybe Bool)
ckpIncludeQueryString
  = lens _ckpIncludeQueryString
      (\ s a -> s{_ckpIncludeQueryString = a})

instance FromJSON CacheKeyPolicy where
        parseJSON
          = withObject "CacheKeyPolicy"
              (\ o ->
                 CacheKeyPolicy' <$>
                   (o .:? "queryStringWhitelist" .!= mempty) <*>
                     (o .:? "includeHost")
                     <*> (o .:? "includeProtocol")
                     <*> (o .:? "queryStringBlacklist" .!= mempty)
                     <*> (o .:? "includeQueryString"))

instance ToJSON CacheKeyPolicy where
        toJSON CacheKeyPolicy'{..}
          = object
              (catMaybes
                 [("queryStringWhitelist" .=) <$>
                    _ckpQueryStringWhiteList,
                  ("includeHost" .=) <$> _ckpIncludeHost,
                  ("includeProtocol" .=) <$> _ckpIncludeProtocol,
                  ("queryStringBlacklist" .=) <$>
                    _ckpQueryStringBlackList,
                  ("includeQueryString" .=) <$>
                    _ckpIncludeQueryString])

--
-- /See:/ 'commitmentAggregatedListWarningDataItem' smart constructor.
data CommitmentAggregatedListWarningDataItem =
  CommitmentAggregatedListWarningDataItem'
    { _calwdiValue :: !(Maybe Text)
    , _calwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'CommitmentAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'calwdiValue'
--
-- * 'calwdiKey'
commitmentAggregatedListWarningDataItem
    :: CommitmentAggregatedListWarningDataItem
commitmentAggregatedListWarningDataItem =
  CommitmentAggregatedListWarningDataItem'
    {_calwdiValue = Nothing, _calwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
calwdiValue :: Lens' CommitmentAggregatedListWarningDataItem (Maybe Text)
calwdiValue
  = lens _calwdiValue (\ s a -> s{_calwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
calwdiKey :: Lens' CommitmentAggregatedListWarningDataItem (Maybe Text)
calwdiKey
  = lens _calwdiKey (\ s a -> s{_calwdiKey = a})

instance FromJSON
           CommitmentAggregatedListWarningDataItem
         where
        parseJSON
          = withObject
              "CommitmentAggregatedListWarningDataItem"
              (\ o ->
                 CommitmentAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           CommitmentAggregatedListWarningDataItem
         where
        toJSON CommitmentAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _calwdiValue,
                  ("key" .=) <$> _calwdiKey])

--
-- /See:/ 'regionInstanceGroupListWarningDataItem' smart constructor.
data RegionInstanceGroupListWarningDataItem =
  RegionInstanceGroupListWarningDataItem'
    { _riglwdiValue :: !(Maybe Text)
    , _riglwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'riglwdiValue'
--
-- * 'riglwdiKey'
regionInstanceGroupListWarningDataItem
    :: RegionInstanceGroupListWarningDataItem
regionInstanceGroupListWarningDataItem =
  RegionInstanceGroupListWarningDataItem'
    {_riglwdiValue = Nothing, _riglwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
riglwdiValue :: Lens' RegionInstanceGroupListWarningDataItem (Maybe Text)
riglwdiValue
  = lens _riglwdiValue (\ s a -> s{_riglwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
riglwdiKey :: Lens' RegionInstanceGroupListWarningDataItem (Maybe Text)
riglwdiKey
  = lens _riglwdiKey (\ s a -> s{_riglwdiKey = a})

instance FromJSON
           RegionInstanceGroupListWarningDataItem
         where
        parseJSON
          = withObject "RegionInstanceGroupListWarningDataItem"
              (\ o ->
                 RegionInstanceGroupListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           RegionInstanceGroupListWarningDataItem
         where
        toJSON RegionInstanceGroupListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _riglwdiValue,
                  ("key" .=) <$> _riglwdiKey])

-- | A list of SubnetworksScopedList resources.
--
-- /See:/ 'subnetworkAggregatedListItems' smart constructor.
newtype SubnetworkAggregatedListItems =
  SubnetworkAggregatedListItems'
    { _saliAddtional :: HashMap Text SubnetworksScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SubnetworkAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'saliAddtional'
subnetworkAggregatedListItems
    :: HashMap Text SubnetworksScopedList -- ^ 'saliAddtional'
    -> SubnetworkAggregatedListItems
subnetworkAggregatedListItems pSaliAddtional_ =
  SubnetworkAggregatedListItems' {_saliAddtional = _Coerce # pSaliAddtional_}


-- | Name of the scope containing this set of Subnetworks.
saliAddtional :: Lens' SubnetworkAggregatedListItems (HashMap Text SubnetworksScopedList)
saliAddtional
  = lens _saliAddtional
      (\ s a -> s{_saliAddtional = a})
      . _Coerce

instance FromJSON SubnetworkAggregatedListItems where
        parseJSON
          = withObject "SubnetworkAggregatedListItems"
              (\ o ->
                 SubnetworkAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON SubnetworkAggregatedListItems where
        toJSON = toJSON . _saliAddtional

--
-- /See:/ 'firewallPoliciesListAssociationsResponse' smart constructor.
data FirewallPoliciesListAssociationsResponse =
  FirewallPoliciesListAssociationsResponse'
    { _fplarKind :: !Text
    , _fplarAssociations :: !(Maybe [FirewallPolicyAssociation])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'FirewallPoliciesListAssociationsResponse' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'fplarKind'
--
-- * 'fplarAssociations'
firewallPoliciesListAssociationsResponse
    :: FirewallPoliciesListAssociationsResponse
firewallPoliciesListAssociationsResponse =
  FirewallPoliciesListAssociationsResponse'
    { _fplarKind = "compute#firewallPoliciesListAssociationsResponse"
    , _fplarAssociations = Nothing
    }


-- | [Output Only] Type of firewallPolicy associations. Always
-- compute#FirewallPoliciesListAssociations for lists of firewallPolicy
-- associations.
fplarKind :: Lens' FirewallPoliciesListAssociationsResponse Text
fplarKind
  = lens _fplarKind (\ s a -> s{_fplarKind = a})

-- | A list of associations.
fplarAssociations :: Lens' FirewallPoliciesListAssociationsResponse [FirewallPolicyAssociation]
fplarAssociations
  = lens _fplarAssociations
      (\ s a -> s{_fplarAssociations = a})
      . _Default
      . _Coerce

instance FromJSON
           FirewallPoliciesListAssociationsResponse
         where
        parseJSON
          = withObject
              "FirewallPoliciesListAssociationsResponse"
              (\ o ->
                 FirewallPoliciesListAssociationsResponse' <$>
                   (o .:? "kind" .!=
                      "compute#firewallPoliciesListAssociationsResponse")
                     <*> (o .:? "associations" .!= mempty))

instance ToJSON
           FirewallPoliciesListAssociationsResponse
         where
        toJSON FirewallPoliciesListAssociationsResponse'{..}
          = object
              (catMaybes
                 [Just ("kind" .= _fplarKind),
                  ("associations" .=) <$> _fplarAssociations])

-- | A list of NetworkEndpointGroupsScopedList resources.
--
-- /See:/ 'networkEndpointGroupAggregatedListItems' smart constructor.
newtype NetworkEndpointGroupAggregatedListItems =
  NetworkEndpointGroupAggregatedListItems'
    { _negaliAddtional :: HashMap Text NetworkEndpointGroupsScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkEndpointGroupAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'negaliAddtional'
networkEndpointGroupAggregatedListItems
    :: HashMap Text NetworkEndpointGroupsScopedList -- ^ 'negaliAddtional'
    -> NetworkEndpointGroupAggregatedListItems
networkEndpointGroupAggregatedListItems pNegaliAddtional_ =
  NetworkEndpointGroupAggregatedListItems'
    {_negaliAddtional = _Coerce # pNegaliAddtional_}


-- | The name of the scope that contains this set of network endpoint groups.
negaliAddtional :: Lens' NetworkEndpointGroupAggregatedListItems (HashMap Text NetworkEndpointGroupsScopedList)
negaliAddtional
  = lens _negaliAddtional
      (\ s a -> s{_negaliAddtional = a})
      . _Coerce

instance FromJSON
           NetworkEndpointGroupAggregatedListItems
         where
        parseJSON
          = withObject
              "NetworkEndpointGroupAggregatedListItems"
              (\ o ->
                 NetworkEndpointGroupAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON
           NetworkEndpointGroupAggregatedListItems
         where
        toJSON = toJSON . _negaliAddtional

--
-- /See:/ 'interconnectAttachmentAggregatedListWarningDataItem' smart constructor.
data InterconnectAttachmentAggregatedListWarningDataItem =
  InterconnectAttachmentAggregatedListWarningDataItem'
    { _iaalwdiValue :: !(Maybe Text)
    , _iaalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectAttachmentAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iaalwdiValue'
--
-- * 'iaalwdiKey'
interconnectAttachmentAggregatedListWarningDataItem
    :: InterconnectAttachmentAggregatedListWarningDataItem
interconnectAttachmentAggregatedListWarningDataItem =
  InterconnectAttachmentAggregatedListWarningDataItem'
    {_iaalwdiValue = Nothing, _iaalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
iaalwdiValue :: Lens' InterconnectAttachmentAggregatedListWarningDataItem (Maybe Text)
iaalwdiValue
  = lens _iaalwdiValue (\ s a -> s{_iaalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
iaalwdiKey :: Lens' InterconnectAttachmentAggregatedListWarningDataItem (Maybe Text)
iaalwdiKey
  = lens _iaalwdiKey (\ s a -> s{_iaalwdiKey = a})

instance FromJSON
           InterconnectAttachmentAggregatedListWarningDataItem
         where
        parseJSON
          = withObject
              "InterconnectAttachmentAggregatedListWarningDataItem"
              (\ o ->
                 InterconnectAttachmentAggregatedListWarningDataItem'
                   <$> (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           InterconnectAttachmentAggregatedListWarningDataItem
         where
        toJSON
          InterconnectAttachmentAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _iaalwdiValue,
                  ("key" .=) <$> _iaalwdiKey])

--
-- /See:/ 'firewallPolicyListWarningDataItem' smart constructor.
data FirewallPolicyListWarningDataItem =
  FirewallPolicyListWarningDataItem'
    { _fplwdiValue :: !(Maybe Text)
    , _fplwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'FirewallPolicyListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'fplwdiValue'
--
-- * 'fplwdiKey'
firewallPolicyListWarningDataItem
    :: FirewallPolicyListWarningDataItem
firewallPolicyListWarningDataItem =
  FirewallPolicyListWarningDataItem'
    {_fplwdiValue = Nothing, _fplwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
fplwdiValue :: Lens' FirewallPolicyListWarningDataItem (Maybe Text)
fplwdiValue
  = lens _fplwdiValue (\ s a -> s{_fplwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
fplwdiKey :: Lens' FirewallPolicyListWarningDataItem (Maybe Text)
fplwdiKey
  = lens _fplwdiKey (\ s a -> s{_fplwdiKey = a})

instance FromJSON FirewallPolicyListWarningDataItem
         where
        parseJSON
          = withObject "FirewallPolicyListWarningDataItem"
              (\ o ->
                 FirewallPolicyListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON FirewallPolicyListWarningDataItem
         where
        toJSON FirewallPolicyListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _fplwdiValue,
                  ("key" .=) <$> _fplwdiKey])

-- | Time window specified for weekly operations.
--
-- /See:/ 'resourcePolicyWeeklyCycle' smart constructor.
newtype ResourcePolicyWeeklyCycle =
  ResourcePolicyWeeklyCycle'
    { _rpwcDayOfWeeks :: Maybe [ResourcePolicyWeeklyCycleDayOfWeek]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePolicyWeeklyCycle' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rpwcDayOfWeeks'
resourcePolicyWeeklyCycle
    :: ResourcePolicyWeeklyCycle
resourcePolicyWeeklyCycle =
  ResourcePolicyWeeklyCycle' {_rpwcDayOfWeeks = Nothing}


-- | Up to 7 intervals\/windows, one for each day of the week.
rpwcDayOfWeeks :: Lens' ResourcePolicyWeeklyCycle [ResourcePolicyWeeklyCycleDayOfWeek]
rpwcDayOfWeeks
  = lens _rpwcDayOfWeeks
      (\ s a -> s{_rpwcDayOfWeeks = a})
      . _Default
      . _Coerce

instance FromJSON ResourcePolicyWeeklyCycle where
        parseJSON
          = withObject "ResourcePolicyWeeklyCycle"
              (\ o ->
                 ResourcePolicyWeeklyCycle' <$>
                   (o .:? "dayOfWeeks" .!= mempty))

instance ToJSON ResourcePolicyWeeklyCycle where
        toJSON ResourcePolicyWeeklyCycle'{..}
          = object
              (catMaybes [("dayOfWeeks" .=) <$> _rpwcDayOfWeeks])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'interconnectAttachmentListWarning' smart constructor.
data InterconnectAttachmentListWarning =
  InterconnectAttachmentListWarning'
    { _intData :: !(Maybe [InterconnectAttachmentListWarningDataItem])
    , _intCode :: !(Maybe InterconnectAttachmentListWarningCode)
    , _intMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectAttachmentListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'intData'
--
-- * 'intCode'
--
-- * 'intMessage'
interconnectAttachmentListWarning
    :: InterconnectAttachmentListWarning
interconnectAttachmentListWarning =
  InterconnectAttachmentListWarning'
    {_intData = Nothing, _intCode = Nothing, _intMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
intData :: Lens' InterconnectAttachmentListWarning [InterconnectAttachmentListWarningDataItem]
intData
  = lens _intData (\ s a -> s{_intData = a}) . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
intCode :: Lens' InterconnectAttachmentListWarning (Maybe InterconnectAttachmentListWarningCode)
intCode = lens _intCode (\ s a -> s{_intCode = a})

-- | [Output Only] A human-readable description of the warning code.
intMessage :: Lens' InterconnectAttachmentListWarning (Maybe Text)
intMessage
  = lens _intMessage (\ s a -> s{_intMessage = a})

instance FromJSON InterconnectAttachmentListWarning
         where
        parseJSON
          = withObject "InterconnectAttachmentListWarning"
              (\ o ->
                 InterconnectAttachmentListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON InterconnectAttachmentListWarning
         where
        toJSON InterconnectAttachmentListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _intData, ("code" .=) <$> _intCode,
                  ("message" .=) <$> _intMessage])

-- | A condition to be met.
--
-- /See:/ 'condition' smart constructor.
data Condition =
  Condition'
    { _cOp :: !(Maybe ConditionOp)
    , _cIAM :: !(Maybe ConditionIAM)
    , _cValues :: !(Maybe [Text])
    , _cSys :: !(Maybe ConditionSys)
    , _cSvc :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Condition' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'cOp'
--
-- * 'cIAM'
--
-- * 'cValues'
--
-- * 'cSys'
--
-- * 'cSvc'
condition
    :: Condition
condition =
  Condition'
    { _cOp = Nothing
    , _cIAM = Nothing
    , _cValues = Nothing
    , _cSys = Nothing
    , _cSvc = Nothing
    }


-- | An operator to apply the subject with.
cOp :: Lens' Condition (Maybe ConditionOp)
cOp = lens _cOp (\ s a -> s{_cOp = a})

-- | Trusted attributes supplied by the IAM system.
cIAM :: Lens' Condition (Maybe ConditionIAM)
cIAM = lens _cIAM (\ s a -> s{_cIAM = a})

-- | The objects of the condition.
cValues :: Lens' Condition [Text]
cValues
  = lens _cValues (\ s a -> s{_cValues = a}) . _Default
      . _Coerce

-- | Trusted attributes supplied by any service that owns resources and uses
-- the IAM system for access control.
cSys :: Lens' Condition (Maybe ConditionSys)
cSys = lens _cSys (\ s a -> s{_cSys = a})

-- | Trusted attributes discharged by the service.
cSvc :: Lens' Condition (Maybe Text)
cSvc = lens _cSvc (\ s a -> s{_cSvc = a})

instance FromJSON Condition where
        parseJSON
          = withObject "Condition"
              (\ o ->
                 Condition' <$>
                   (o .:? "op") <*> (o .:? "iam") <*>
                     (o .:? "values" .!= mempty)
                     <*> (o .:? "sys")
                     <*> (o .:? "svc"))

instance ToJSON Condition where
        toJSON Condition'{..}
          = object
              (catMaybes
                 [("op" .=) <$> _cOp, ("iam" .=) <$> _cIAM,
                  ("values" .=) <$> _cValues, ("sys" .=) <$> _cSys,
                  ("svc" .=) <$> _cSvc])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'addressAggregatedListWarning' smart constructor.
data AddressAggregatedListWarning =
  AddressAggregatedListWarning'
    { _addData :: !(Maybe [AddressAggregatedListWarningDataItem])
    , _addCode :: !(Maybe AddressAggregatedListWarningCode)
    , _addMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AddressAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'addData'
--
-- * 'addCode'
--
-- * 'addMessage'
addressAggregatedListWarning
    :: AddressAggregatedListWarning
addressAggregatedListWarning =
  AddressAggregatedListWarning'
    {_addData = Nothing, _addCode = Nothing, _addMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
addData :: Lens' AddressAggregatedListWarning [AddressAggregatedListWarningDataItem]
addData
  = lens _addData (\ s a -> s{_addData = a}) . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
addCode :: Lens' AddressAggregatedListWarning (Maybe AddressAggregatedListWarningCode)
addCode = lens _addCode (\ s a -> s{_addCode = a})

-- | [Output Only] A human-readable description of the warning code.
addMessage :: Lens' AddressAggregatedListWarning (Maybe Text)
addMessage
  = lens _addMessage (\ s a -> s{_addMessage = a})

instance FromJSON AddressAggregatedListWarning where
        parseJSON
          = withObject "AddressAggregatedListWarning"
              (\ o ->
                 AddressAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON AddressAggregatedListWarning where
        toJSON AddressAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _addData, ("code" .=) <$> _addCode,
                  ("message" .=) <$> _addMessage])

--
-- /See:/ 'managedInstanceLastAttempt' smart constructor.
newtype ManagedInstanceLastAttempt =
  ManagedInstanceLastAttempt'
    { _milaErrors :: Maybe ManagedInstanceLastAttemptErrors
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ManagedInstanceLastAttempt' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'milaErrors'
managedInstanceLastAttempt
    :: ManagedInstanceLastAttempt
managedInstanceLastAttempt = ManagedInstanceLastAttempt' {_milaErrors = Nothing}


-- | [Output Only] Encountered errors during the last attempt to create or
-- delete the instance.
milaErrors :: Lens' ManagedInstanceLastAttempt (Maybe ManagedInstanceLastAttemptErrors)
milaErrors
  = lens _milaErrors (\ s a -> s{_milaErrors = a})

instance FromJSON ManagedInstanceLastAttempt where
        parseJSON
          = withObject "ManagedInstanceLastAttempt"
              (\ o ->
                 ManagedInstanceLastAttempt' <$> (o .:? "errors"))

instance ToJSON ManagedInstanceLastAttempt where
        toJSON ManagedInstanceLastAttempt'{..}
          = object (catMaybes [("errors" .=) <$> _milaErrors])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'licensesListResponseWarning' smart constructor.
data LicensesListResponseWarning =
  LicensesListResponseWarning'
    { _llrwData :: !(Maybe [LicensesListResponseWarningDataItem])
    , _llrwCode :: !(Maybe LicensesListResponseWarningCode)
    , _llrwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'LicensesListResponseWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'llrwData'
--
-- * 'llrwCode'
--
-- * 'llrwMessage'
licensesListResponseWarning
    :: LicensesListResponseWarning
licensesListResponseWarning =
  LicensesListResponseWarning'
    {_llrwData = Nothing, _llrwCode = Nothing, _llrwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
llrwData :: Lens' LicensesListResponseWarning [LicensesListResponseWarningDataItem]
llrwData
  = lens _llrwData (\ s a -> s{_llrwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
llrwCode :: Lens' LicensesListResponseWarning (Maybe LicensesListResponseWarningCode)
llrwCode = lens _llrwCode (\ s a -> s{_llrwCode = a})

-- | [Output Only] A human-readable description of the warning code.
llrwMessage :: Lens' LicensesListResponseWarning (Maybe Text)
llrwMessage
  = lens _llrwMessage (\ s a -> s{_llrwMessage = a})

instance FromJSON LicensesListResponseWarning where
        parseJSON
          = withObject "LicensesListResponseWarning"
              (\ o ->
                 LicensesListResponseWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON LicensesListResponseWarning where
        toJSON LicensesListResponseWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _llrwData,
                  ("code" .=) <$> _llrwCode,
                  ("message" .=) <$> _llrwMessage])

--
-- /See:/ 'autoscalerStatusDetails' smart constructor.
data AutoscalerStatusDetails =
  AutoscalerStatusDetails'
    { _asdType :: !(Maybe AutoscalerStatusDetailsType)
    , _asdMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AutoscalerStatusDetails' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'asdType'
--
-- * 'asdMessage'
autoscalerStatusDetails
    :: AutoscalerStatusDetails
autoscalerStatusDetails =
  AutoscalerStatusDetails' {_asdType = Nothing, _asdMessage = Nothing}


-- | The type of error, warning, or notice returned. Current set of possible
-- values: - ALL_INSTANCES_UNHEALTHY (WARNING): All instances in the
-- instance group are unhealthy (not in RUNNING state). -
-- BACKEND_SERVICE_DOES_NOT_EXIST (ERROR): There is no backend service
-- attached to the instance group. - CAPPED_AT_MAX_NUM_REPLICAS (WARNING):
-- Autoscaler recommends a size greater than maxNumReplicas. -
-- CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE (WARNING): The custom metric
-- samples are not exported often enough to be a credible base for
-- autoscaling. - CUSTOM_METRIC_INVALID (ERROR): The custom metric that was
-- specified does not exist or does not have the necessary labels. -
-- MIN_EQUALS_MAX (WARNING): The minNumReplicas is equal to maxNumReplicas.
-- This means the autoscaler cannot add or remove instances from the
-- instance group. - MISSING_CUSTOM_METRIC_DATA_POINTS (WARNING): The
-- autoscaler did not receive any data from the custom metric configured
-- for autoscaling. - MISSING_LOAD_BALANCING_DATA_POINTS (WARNING): The
-- autoscaler is configured to scale based on a load balancing signal but
-- the instance group has not received any requests from the load balancer.
-- - MODE_OFF (WARNING): Autoscaling is turned off. The number of instances
-- in the group won\'t change automatically. The autoscaling configuration
-- is preserved. - MODE_ONLY_UP (WARNING): Autoscaling is in the
-- \"Autoscale only out\" mode. The autoscaler can add instances but not
-- remove any. - MORE_THAN_ONE_BACKEND_SERVICE (ERROR): The instance group
-- cannot be autoscaled because it has more than one backend service
-- attached to it. - NOT_ENOUGH_QUOTA_AVAILABLE (ERROR): There is
-- insufficient quota for the necessary resources, such as CPU or number of
-- instances. - REGION_RESOURCE_STOCKOUT (ERROR): Shown only for regional
-- autoscalers: there is a resource stockout in the chosen region. -
-- SCALING_TARGET_DOES_NOT_EXIST (ERROR): The target to be scaled does not
-- exist. - UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION (ERROR):
-- Autoscaling does not work with an HTTP\/S load balancer that has been
-- configured for maxRate. - ZONE_RESOURCE_STOCKOUT (ERROR): For zonal
-- autoscalers: there is a resource stockout in the chosen zone. For
-- regional autoscalers: in at least one of the zones you\'re using there
-- is a resource stockout. New values might be added in the future. Some of
-- the values might not be available in all API versions.
asdType :: Lens' AutoscalerStatusDetails (Maybe AutoscalerStatusDetailsType)
asdType = lens _asdType (\ s a -> s{_asdType = a})

-- | The status message.
asdMessage :: Lens' AutoscalerStatusDetails (Maybe Text)
asdMessage
  = lens _asdMessage (\ s a -> s{_asdMessage = a})

instance FromJSON AutoscalerStatusDetails where
        parseJSON
          = withObject "AutoscalerStatusDetails"
              (\ o ->
                 AutoscalerStatusDetails' <$>
                   (o .:? "type") <*> (o .:? "message"))

instance ToJSON AutoscalerStatusDetails where
        toJSON AutoscalerStatusDetails'{..}
          = object
              (catMaybes
                 [("type" .=) <$> _asdType,
                  ("message" .=) <$> _asdMessage])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'targetGrpcProxyListWarning' smart constructor.
data TargetGrpcProxyListWarning =
  TargetGrpcProxyListWarning'
    { _tgplwData :: !(Maybe [TargetGrpcProxyListWarningDataItem])
    , _tgplwCode :: !(Maybe TargetGrpcProxyListWarningCode)
    , _tgplwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetGrpcProxyListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tgplwData'
--
-- * 'tgplwCode'
--
-- * 'tgplwMessage'
targetGrpcProxyListWarning
    :: TargetGrpcProxyListWarning
targetGrpcProxyListWarning =
  TargetGrpcProxyListWarning'
    {_tgplwData = Nothing, _tgplwCode = Nothing, _tgplwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
tgplwData :: Lens' TargetGrpcProxyListWarning [TargetGrpcProxyListWarningDataItem]
tgplwData
  = lens _tgplwData (\ s a -> s{_tgplwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
tgplwCode :: Lens' TargetGrpcProxyListWarning (Maybe TargetGrpcProxyListWarningCode)
tgplwCode
  = lens _tgplwCode (\ s a -> s{_tgplwCode = a})

-- | [Output Only] A human-readable description of the warning code.
tgplwMessage :: Lens' TargetGrpcProxyListWarning (Maybe Text)
tgplwMessage
  = lens _tgplwMessage (\ s a -> s{_tgplwMessage = a})

instance FromJSON TargetGrpcProxyListWarning where
        parseJSON
          = withObject "TargetGrpcProxyListWarning"
              (\ o ->
                 TargetGrpcProxyListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON TargetGrpcProxyListWarning where
        toJSON TargetGrpcProxyListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _tgplwData,
                  ("code" .=) <$> _tgplwCode,
                  ("message" .=) <$> _tgplwMessage])

-- | Contains a list of BackendService resources.
--
-- /See:/ 'backendServiceList' smart constructor.
data BackendServiceList =
  BackendServiceList'
    { _bslNextPageToken :: !(Maybe Text)
    , _bslKind :: !Text
    , _bslItems :: !(Maybe [BackendService])
    , _bslSelfLink :: !(Maybe Text)
    , _bslWarning :: !(Maybe BackendServiceListWarning)
    , _bslId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendServiceList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bslNextPageToken'
--
-- * 'bslKind'
--
-- * 'bslItems'
--
-- * 'bslSelfLink'
--
-- * 'bslWarning'
--
-- * 'bslId'
backendServiceList
    :: BackendServiceList
backendServiceList =
  BackendServiceList'
    { _bslNextPageToken = Nothing
    , _bslKind = "compute#backendServiceList"
    , _bslItems = Nothing
    , _bslSelfLink = Nothing
    , _bslWarning = Nothing
    , _bslId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
bslNextPageToken :: Lens' BackendServiceList (Maybe Text)
bslNextPageToken
  = lens _bslNextPageToken
      (\ s a -> s{_bslNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#backendServiceList for
-- lists of backend services.
bslKind :: Lens' BackendServiceList Text
bslKind = lens _bslKind (\ s a -> s{_bslKind = a})

-- | A list of BackendService resources.
bslItems :: Lens' BackendServiceList [BackendService]
bslItems
  = lens _bslItems (\ s a -> s{_bslItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
bslSelfLink :: Lens' BackendServiceList (Maybe Text)
bslSelfLink
  = lens _bslSelfLink (\ s a -> s{_bslSelfLink = a})

-- | [Output Only] Informational warning message.
bslWarning :: Lens' BackendServiceList (Maybe BackendServiceListWarning)
bslWarning
  = lens _bslWarning (\ s a -> s{_bslWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
bslId :: Lens' BackendServiceList (Maybe Text)
bslId = lens _bslId (\ s a -> s{_bslId = a})

instance FromJSON BackendServiceList where
        parseJSON
          = withObject "BackendServiceList"
              (\ o ->
                 BackendServiceList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#backendServiceList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON BackendServiceList where
        toJSON BackendServiceList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _bslNextPageToken,
                  Just ("kind" .= _bslKind),
                  ("items" .=) <$> _bslItems,
                  ("selfLink" .=) <$> _bslSelfLink,
                  ("warning" .=) <$> _bslWarning,
                  ("id" .=) <$> _bslId])

--
-- /See:/ 'xpnHostListWarningDataItem' smart constructor.
data XpnHostListWarningDataItem =
  XpnHostListWarningDataItem'
    { _xhlwdiValue :: !(Maybe Text)
    , _xhlwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'XpnHostListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'xhlwdiValue'
--
-- * 'xhlwdiKey'
xpnHostListWarningDataItem
    :: XpnHostListWarningDataItem
xpnHostListWarningDataItem =
  XpnHostListWarningDataItem' {_xhlwdiValue = Nothing, _xhlwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
xhlwdiValue :: Lens' XpnHostListWarningDataItem (Maybe Text)
xhlwdiValue
  = lens _xhlwdiValue (\ s a -> s{_xhlwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
xhlwdiKey :: Lens' XpnHostListWarningDataItem (Maybe Text)
xhlwdiKey
  = lens _xhlwdiKey (\ s a -> s{_xhlwdiKey = a})

instance FromJSON XpnHostListWarningDataItem where
        parseJSON
          = withObject "XpnHostListWarningDataItem"
              (\ o ->
                 XpnHostListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON XpnHostListWarningDataItem where
        toJSON XpnHostListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _xhlwdiValue,
                  ("key" .=) <$> _xhlwdiKey])

-- | Custom fields. These can be used to create a counter with arbitrary
-- field\/value pairs. See: go\/rpcsp-custom-fields.
--
-- /See:/ 'logConfigCounterOptionsCustomField' smart constructor.
data LogConfigCounterOptionsCustomField =
  LogConfigCounterOptionsCustomField'
    { _lccocfValue :: !(Maybe Text)
    , _lccocfName :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'LogConfigCounterOptionsCustomField' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'lccocfValue'
--
-- * 'lccocfName'
logConfigCounterOptionsCustomField
    :: LogConfigCounterOptionsCustomField
logConfigCounterOptionsCustomField =
  LogConfigCounterOptionsCustomField'
    {_lccocfValue = Nothing, _lccocfName = Nothing}


-- | Value is the field value. It is important that in contrast to the
-- CounterOptions.field, the value here is a constant that is not derived
-- from the IAMContext.
lccocfValue :: Lens' LogConfigCounterOptionsCustomField (Maybe Text)
lccocfValue
  = lens _lccocfValue (\ s a -> s{_lccocfValue = a})

-- | Name is the field name.
lccocfName :: Lens' LogConfigCounterOptionsCustomField (Maybe Text)
lccocfName
  = lens _lccocfName (\ s a -> s{_lccocfName = a})

instance FromJSON LogConfigCounterOptionsCustomField
         where
        parseJSON
          = withObject "LogConfigCounterOptionsCustomField"
              (\ o ->
                 LogConfigCounterOptionsCustomField' <$>
                   (o .:? "value") <*> (o .:? "name"))

instance ToJSON LogConfigCounterOptionsCustomField
         where
        toJSON LogConfigCounterOptionsCustomField'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _lccocfValue,
                  ("name" .=) <$> _lccocfName])

--
-- /See:/ 'zoneListWarningDataItem' smart constructor.
data ZoneListWarningDataItem =
  ZoneListWarningDataItem'
    { _zlwdiValue :: !(Maybe Text)
    , _zlwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ZoneListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'zlwdiValue'
--
-- * 'zlwdiKey'
zoneListWarningDataItem
    :: ZoneListWarningDataItem
zoneListWarningDataItem =
  ZoneListWarningDataItem' {_zlwdiValue = Nothing, _zlwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
zlwdiValue :: Lens' ZoneListWarningDataItem (Maybe Text)
zlwdiValue
  = lens _zlwdiValue (\ s a -> s{_zlwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
zlwdiKey :: Lens' ZoneListWarningDataItem (Maybe Text)
zlwdiKey = lens _zlwdiKey (\ s a -> s{_zlwdiKey = a})

instance FromJSON ZoneListWarningDataItem where
        parseJSON
          = withObject "ZoneListWarningDataItem"
              (\ o ->
                 ZoneListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON ZoneListWarningDataItem where
        toJSON ZoneListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _zlwdiValue,
                  ("key" .=) <$> _zlwdiKey])

--
-- /See:/ 'regionSetPolicyRequest' smart constructor.
data RegionSetPolicyRequest =
  RegionSetPolicyRequest'
    { _rsprEtag :: !(Maybe Bytes)
    , _rsprBindings :: !(Maybe [Binding])
    , _rsprPolicy :: !(Maybe Policy)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionSetPolicyRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rsprEtag'
--
-- * 'rsprBindings'
--
-- * 'rsprPolicy'
regionSetPolicyRequest
    :: RegionSetPolicyRequest
regionSetPolicyRequest =
  RegionSetPolicyRequest'
    {_rsprEtag = Nothing, _rsprBindings = Nothing, _rsprPolicy = Nothing}


-- | Flatten Policy to create a backward compatible wire-format. Deprecated.
-- Use \'policy\' to specify the etag.
rsprEtag :: Lens' RegionSetPolicyRequest (Maybe ByteString)
rsprEtag
  = lens _rsprEtag (\ s a -> s{_rsprEtag = a}) .
      mapping _Bytes

-- | Flatten Policy to create a backwacd compatible wire-format. Deprecated.
-- Use \'policy\' to specify bindings.
rsprBindings :: Lens' RegionSetPolicyRequest [Binding]
rsprBindings
  = lens _rsprBindings (\ s a -> s{_rsprBindings = a})
      . _Default
      . _Coerce

-- | REQUIRED: The complete policy to be applied to the \'resource\'. The
-- size of the policy is limited to a few 10s of KB. An empty policy is in
-- general a valid policy but certain services (like Projects) might reject
-- them.
rsprPolicy :: Lens' RegionSetPolicyRequest (Maybe Policy)
rsprPolicy
  = lens _rsprPolicy (\ s a -> s{_rsprPolicy = a})

instance FromJSON RegionSetPolicyRequest where
        parseJSON
          = withObject "RegionSetPolicyRequest"
              (\ o ->
                 RegionSetPolicyRequest' <$>
                   (o .:? "etag") <*> (o .:? "bindings" .!= mempty) <*>
                     (o .:? "policy"))

instance ToJSON RegionSetPolicyRequest where
        toJSON RegionSetPolicyRequest'{..}
          = object
              (catMaybes
                 [("etag" .=) <$> _rsprEtag,
                  ("bindings" .=) <$> _rsprBindings,
                  ("policy" .=) <$> _rsprPolicy])

-- | [Output Only] An informational warning that replaces the list of
-- instance groups when the list is empty.
--
-- /See:/ 'instanceGroupsScopedListWarning' smart constructor.
data InstanceGroupsScopedListWarning =
  InstanceGroupsScopedListWarning'
    { _igslwData :: !(Maybe [InstanceGroupsScopedListWarningDataItem])
    , _igslwCode :: !(Maybe InstanceGroupsScopedListWarningCode)
    , _igslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupsScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igslwData'
--
-- * 'igslwCode'
--
-- * 'igslwMessage'
instanceGroupsScopedListWarning
    :: InstanceGroupsScopedListWarning
instanceGroupsScopedListWarning =
  InstanceGroupsScopedListWarning'
    {_igslwData = Nothing, _igslwCode = Nothing, _igslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
igslwData :: Lens' InstanceGroupsScopedListWarning [InstanceGroupsScopedListWarningDataItem]
igslwData
  = lens _igslwData (\ s a -> s{_igslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
igslwCode :: Lens' InstanceGroupsScopedListWarning (Maybe InstanceGroupsScopedListWarningCode)
igslwCode
  = lens _igslwCode (\ s a -> s{_igslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
igslwMessage :: Lens' InstanceGroupsScopedListWarning (Maybe Text)
igslwMessage
  = lens _igslwMessage (\ s a -> s{_igslwMessage = a})

instance FromJSON InstanceGroupsScopedListWarning
         where
        parseJSON
          = withObject "InstanceGroupsScopedListWarning"
              (\ o ->
                 InstanceGroupsScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON InstanceGroupsScopedListWarning where
        toJSON InstanceGroupsScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _igslwData,
                  ("code" .=) <$> _igslwCode,
                  ("message" .=) <$> _igslwMessage])

-- | Preserved state for a given instance.
--
-- /See:/ 'preservedState' smart constructor.
data PreservedState =
  PreservedState'
    { _psMetadata :: !(Maybe PreservedStateMetadata)
    , _psDisks :: !(Maybe PreservedStateDisks)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PreservedState' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'psMetadata'
--
-- * 'psDisks'
preservedState
    :: PreservedState
preservedState = PreservedState' {_psMetadata = Nothing, _psDisks = Nothing}


-- | Preserved metadata defined for this instance.
psMetadata :: Lens' PreservedState (Maybe PreservedStateMetadata)
psMetadata
  = lens _psMetadata (\ s a -> s{_psMetadata = a})

-- | Preserved disks defined for this instance. This map is keyed with the
-- device names of the disks.
psDisks :: Lens' PreservedState (Maybe PreservedStateDisks)
psDisks = lens _psDisks (\ s a -> s{_psDisks = a})

instance FromJSON PreservedState where
        parseJSON
          = withObject "PreservedState"
              (\ o ->
                 PreservedState' <$>
                   (o .:? "metadata") <*> (o .:? "disks"))

instance ToJSON PreservedState where
        toJSON PreservedState'{..}
          = object
              (catMaybes
                 [("metadata" .=) <$> _psMetadata,
                  ("disks" .=) <$> _psDisks])

-- | CPU utilization policy.
--
-- /See:/ 'autoscalingPolicyCPUUtilization' smart constructor.
data AutoscalingPolicyCPUUtilization =
  AutoscalingPolicyCPUUtilization'
    { _apcuUtilizationTarget :: !(Maybe (Textual Double))
    , _apcuPredictiveMethod :: !(Maybe AutoscalingPolicyCPUUtilizationPredictiveMethod)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AutoscalingPolicyCPUUtilization' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'apcuUtilizationTarget'
--
-- * 'apcuPredictiveMethod'
autoscalingPolicyCPUUtilization
    :: AutoscalingPolicyCPUUtilization
autoscalingPolicyCPUUtilization =
  AutoscalingPolicyCPUUtilization'
    {_apcuUtilizationTarget = Nothing, _apcuPredictiveMethod = Nothing}


-- | The target CPU utilization that the autoscaler maintains. Must be a
-- float value in the range (0, 1]. If not specified, the default is 0.6.
-- If the CPU level is below the target utilization, the autoscaler scales
-- in the number of instances until it reaches the minimum number of
-- instances you specified or until the average CPU of your instances
-- reaches the target utilization. If the average CPU is above the target
-- utilization, the autoscaler scales out until it reaches the maximum
-- number of instances you specified or until the average utilization
-- reaches the target utilization.
apcuUtilizationTarget :: Lens' AutoscalingPolicyCPUUtilization (Maybe Double)
apcuUtilizationTarget
  = lens _apcuUtilizationTarget
      (\ s a -> s{_apcuUtilizationTarget = a})
      . mapping _Coerce

-- | Indicates whether predictive autoscaling based on CPU metric is enabled.
-- Valid values are: * NONE (default). No predictive method is used. The
-- autoscaler scales the group to meet current demand based on real-time
-- metrics. * OPTIMIZE_AVAILABILITY. Predictive autoscaling improves
-- availability by monitoring daily and weekly load patterns and scaling
-- out ahead of anticipated demand.
apcuPredictiveMethod :: Lens' AutoscalingPolicyCPUUtilization (Maybe AutoscalingPolicyCPUUtilizationPredictiveMethod)
apcuPredictiveMethod
  = lens _apcuPredictiveMethod
      (\ s a -> s{_apcuPredictiveMethod = a})

instance FromJSON AutoscalingPolicyCPUUtilization
         where
        parseJSON
          = withObject "AutoscalingPolicyCPUUtilization"
              (\ o ->
                 AutoscalingPolicyCPUUtilization' <$>
                   (o .:? "utilizationTarget") <*>
                     (o .:? "predictiveMethod"))

instance ToJSON AutoscalingPolicyCPUUtilization where
        toJSON AutoscalingPolicyCPUUtilization'{..}
          = object
              (catMaybes
                 [("utilizationTarget" .=) <$> _apcuUtilizationTarget,
                  ("predictiveMethod" .=) <$> _apcuPredictiveMethod])

--
-- /See:/ 'instanceGroupsScopedListWarningDataItem' smart constructor.
data InstanceGroupsScopedListWarningDataItem =
  InstanceGroupsScopedListWarningDataItem'
    { _igslwdiValue :: !(Maybe Text)
    , _igslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupsScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igslwdiValue'
--
-- * 'igslwdiKey'
instanceGroupsScopedListWarningDataItem
    :: InstanceGroupsScopedListWarningDataItem
instanceGroupsScopedListWarningDataItem =
  InstanceGroupsScopedListWarningDataItem'
    {_igslwdiValue = Nothing, _igslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
igslwdiValue :: Lens' InstanceGroupsScopedListWarningDataItem (Maybe Text)
igslwdiValue
  = lens _igslwdiValue (\ s a -> s{_igslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
igslwdiKey :: Lens' InstanceGroupsScopedListWarningDataItem (Maybe Text)
igslwdiKey
  = lens _igslwdiKey (\ s a -> s{_igslwdiKey = a})

instance FromJSON
           InstanceGroupsScopedListWarningDataItem
         where
        parseJSON
          = withObject
              "InstanceGroupsScopedListWarningDataItem"
              (\ o ->
                 InstanceGroupsScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           InstanceGroupsScopedListWarningDataItem
         where
        toJSON InstanceGroupsScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _igslwdiValue,
                  ("key" .=) <$> _igslwdiKey])

--
-- /See:/ 'securityPolicyRuleMatcherConfig' smart constructor.
newtype SecurityPolicyRuleMatcherConfig =
  SecurityPolicyRuleMatcherConfig'
    { _sprmcSrcIPRanges :: Maybe [Text]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SecurityPolicyRuleMatcherConfig' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sprmcSrcIPRanges'
securityPolicyRuleMatcherConfig
    :: SecurityPolicyRuleMatcherConfig
securityPolicyRuleMatcherConfig =
  SecurityPolicyRuleMatcherConfig' {_sprmcSrcIPRanges = Nothing}


-- | CIDR IP address range. Maximum number of src_ip_ranges allowed is 10.
sprmcSrcIPRanges :: Lens' SecurityPolicyRuleMatcherConfig [Text]
sprmcSrcIPRanges
  = lens _sprmcSrcIPRanges
      (\ s a -> s{_sprmcSrcIPRanges = a})
      . _Default
      . _Coerce

instance FromJSON SecurityPolicyRuleMatcherConfig
         where
        parseJSON
          = withObject "SecurityPolicyRuleMatcherConfig"
              (\ o ->
                 SecurityPolicyRuleMatcherConfig' <$>
                   (o .:? "srcIpRanges" .!= mempty))

instance ToJSON SecurityPolicyRuleMatcherConfig where
        toJSON SecurityPolicyRuleMatcherConfig'{..}
          = object
              (catMaybes
                 [("srcIpRanges" .=) <$> _sprmcSrcIPRanges])

--
-- /See:/ 'licensesListResponseWarningDataItem' smart constructor.
data LicensesListResponseWarningDataItem =
  LicensesListResponseWarningDataItem'
    { _llrwdiValue :: !(Maybe Text)
    , _llrwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'LicensesListResponseWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'llrwdiValue'
--
-- * 'llrwdiKey'
licensesListResponseWarningDataItem
    :: LicensesListResponseWarningDataItem
licensesListResponseWarningDataItem =
  LicensesListResponseWarningDataItem'
    {_llrwdiValue = Nothing, _llrwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
llrwdiValue :: Lens' LicensesListResponseWarningDataItem (Maybe Text)
llrwdiValue
  = lens _llrwdiValue (\ s a -> s{_llrwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
llrwdiKey :: Lens' LicensesListResponseWarningDataItem (Maybe Text)
llrwdiKey
  = lens _llrwdiKey (\ s a -> s{_llrwdiKey = a})

instance FromJSON LicensesListResponseWarningDataItem
         where
        parseJSON
          = withObject "LicensesListResponseWarningDataItem"
              (\ o ->
                 LicensesListResponseWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON LicensesListResponseWarningDataItem
         where
        toJSON LicensesListResponseWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _llrwdiValue,
                  ("key" .=) <$> _llrwdiKey])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'xpnHostListWarning' smart constructor.
data XpnHostListWarning =
  XpnHostListWarning'
    { _xhlwData :: !(Maybe [XpnHostListWarningDataItem])
    , _xhlwCode :: !(Maybe XpnHostListWarningCode)
    , _xhlwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'XpnHostListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'xhlwData'
--
-- * 'xhlwCode'
--
-- * 'xhlwMessage'
xpnHostListWarning
    :: XpnHostListWarning
xpnHostListWarning =
  XpnHostListWarning'
    {_xhlwData = Nothing, _xhlwCode = Nothing, _xhlwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
xhlwData :: Lens' XpnHostListWarning [XpnHostListWarningDataItem]
xhlwData
  = lens _xhlwData (\ s a -> s{_xhlwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
xhlwCode :: Lens' XpnHostListWarning (Maybe XpnHostListWarningCode)
xhlwCode = lens _xhlwCode (\ s a -> s{_xhlwCode = a})

-- | [Output Only] A human-readable description of the warning code.
xhlwMessage :: Lens' XpnHostListWarning (Maybe Text)
xhlwMessage
  = lens _xhlwMessage (\ s a -> s{_xhlwMessage = a})

instance FromJSON XpnHostListWarning where
        parseJSON
          = withObject "XpnHostListWarning"
              (\ o ->
                 XpnHostListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON XpnHostListWarning where
        toJSON XpnHostListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _xhlwData,
                  ("code" .=) <$> _xhlwCode,
                  ("message" .=) <$> _xhlwMessage])

-- | A Duration represents a fixed-length span of time represented as a count
-- of seconds and fractions of seconds at nanosecond resolution. It is
-- independent of any calendar and concepts like \"day\" or \"month\".
-- Range is approximately 10,000 years.
--
-- /See:/ 'duration' smart constructor.
data Duration =
  Duration'
    { _dNanos :: !(Maybe (Textual Int32))
    , _dSeconds :: !(Maybe (Textual Int64))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Duration' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'dNanos'
--
-- * 'dSeconds'
duration
    :: Duration
duration = Duration' {_dNanos = Nothing, _dSeconds = Nothing}


-- | Span of time that\'s a fraction of a second at nanosecond resolution.
-- Durations less than one second are represented with a 0 \`seconds\`
-- field and a positive \`nanos\` field. Must be from 0 to 999,999,999
-- inclusive.
dNanos :: Lens' Duration (Maybe Int32)
dNanos
  = lens _dNanos (\ s a -> s{_dNanos = a}) .
      mapping _Coerce

-- | Span of time at a resolution of a second. Must be from 0 to
-- 315,576,000,000 inclusive. Note: these bounds are computed from: 60
-- sec\/min * 60 min\/hr * 24 hr\/day * 365.25 days\/year * 10000 years
dSeconds :: Lens' Duration (Maybe Int64)
dSeconds
  = lens _dSeconds (\ s a -> s{_dSeconds = a}) .
      mapping _Coerce

instance FromJSON Duration where
        parseJSON
          = withObject "Duration"
              (\ o ->
                 Duration' <$> (o .:? "nanos") <*> (o .:? "seconds"))

instance ToJSON Duration where
        toJSON Duration'{..}
          = object
              (catMaybes
                 [("nanos" .=) <$> _dNanos,
                  ("seconds" .=) <$> _dSeconds])

--
-- /See:/ 'resourceGroupReference' smart constructor.
newtype ResourceGroupReference =
  ResourceGroupReference'
    { _rgrGroup :: Maybe Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourceGroupReference' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rgrGroup'
resourceGroupReference
    :: ResourceGroupReference
resourceGroupReference = ResourceGroupReference' {_rgrGroup = Nothing}


-- | A URI referencing one of the instance groups or network endpoint groups
-- listed in the backend service.
rgrGroup :: Lens' ResourceGroupReference (Maybe Text)
rgrGroup = lens _rgrGroup (\ s a -> s{_rgrGroup = a})

instance FromJSON ResourceGroupReference where
        parseJSON
          = withObject "ResourceGroupReference"
              (\ o -> ResourceGroupReference' <$> (o .:? "group"))

instance ToJSON ResourceGroupReference where
        toJSON ResourceGroupReference'{..}
          = object (catMaybes [("group" .=) <$> _rgrGroup])

-- | Contains a list of VmEndpointNatMappings.
--
-- /See:/ 'vMEndpointNATMAppingsList' smart constructor.
data VMEndpointNATMAppingsList =
  VMEndpointNATMAppingsList'
    { _vmenatmalNextPageToken :: !(Maybe Text)
    , _vmenatmalKind :: !Text
    , _vmenatmalResult :: !(Maybe [VMEndpointNATMAppings])
    , _vmenatmalSelfLink :: !(Maybe Text)
    , _vmenatmalWarning :: !(Maybe VMEndpointNATMAppingsListWarning)
    , _vmenatmalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VMEndpointNATMAppingsList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vmenatmalNextPageToken'
--
-- * 'vmenatmalKind'
--
-- * 'vmenatmalResult'
--
-- * 'vmenatmalSelfLink'
--
-- * 'vmenatmalWarning'
--
-- * 'vmenatmalId'
vMEndpointNATMAppingsList
    :: VMEndpointNATMAppingsList
vMEndpointNATMAppingsList =
  VMEndpointNATMAppingsList'
    { _vmenatmalNextPageToken = Nothing
    , _vmenatmalKind = "compute#vmEndpointNatMappingsList"
    , _vmenatmalResult = Nothing
    , _vmenatmalSelfLink = Nothing
    , _vmenatmalWarning = Nothing
    , _vmenatmalId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
vmenatmalNextPageToken :: Lens' VMEndpointNATMAppingsList (Maybe Text)
vmenatmalNextPageToken
  = lens _vmenatmalNextPageToken
      (\ s a -> s{_vmenatmalNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#vmEndpointNatMappingsList
-- for lists of Nat mappings of VM endpoints.
vmenatmalKind :: Lens' VMEndpointNATMAppingsList Text
vmenatmalKind
  = lens _vmenatmalKind
      (\ s a -> s{_vmenatmalKind = a})

-- | [Output Only] A list of Nat mapping information of VM endpoints.
vmenatmalResult :: Lens' VMEndpointNATMAppingsList [VMEndpointNATMAppings]
vmenatmalResult
  = lens _vmenatmalResult
      (\ s a -> s{_vmenatmalResult = a})
      . _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
vmenatmalSelfLink :: Lens' VMEndpointNATMAppingsList (Maybe Text)
vmenatmalSelfLink
  = lens _vmenatmalSelfLink
      (\ s a -> s{_vmenatmalSelfLink = a})

-- | [Output Only] Informational warning message.
vmenatmalWarning :: Lens' VMEndpointNATMAppingsList (Maybe VMEndpointNATMAppingsListWarning)
vmenatmalWarning
  = lens _vmenatmalWarning
      (\ s a -> s{_vmenatmalWarning = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
vmenatmalId :: Lens' VMEndpointNATMAppingsList (Maybe Text)
vmenatmalId
  = lens _vmenatmalId (\ s a -> s{_vmenatmalId = a})

instance FromJSON VMEndpointNATMAppingsList where
        parseJSON
          = withObject "VMEndpointNATMAppingsList"
              (\ o ->
                 VMEndpointNATMAppingsList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!=
                        "compute#vmEndpointNatMappingsList")
                     <*> (o .:? "result" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON VMEndpointNATMAppingsList where
        toJSON VMEndpointNATMAppingsList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _vmenatmalNextPageToken,
                  Just ("kind" .= _vmenatmalKind),
                  ("result" .=) <$> _vmenatmalResult,
                  ("selfLink" .=) <$> _vmenatmalSelfLink,
                  ("warning" .=) <$> _vmenatmalWarning,
                  ("id" .=) <$> _vmenatmalId])

--
-- /See:/ 'sslCertificateAggregatedList' smart constructor.
data SSLCertificateAggregatedList =
  SSLCertificateAggregatedList'
    { _scalUnreachables :: !(Maybe [Text])
    , _scalNextPageToken :: !(Maybe Text)
    , _scalKind :: !Text
    , _scalItems :: !(Maybe SSLCertificateAggregatedListItems)
    , _scalSelfLink :: !(Maybe Text)
    , _scalWarning :: !(Maybe SSLCertificateAggregatedListWarning)
    , _scalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SSLCertificateAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'scalUnreachables'
--
-- * 'scalNextPageToken'
--
-- * 'scalKind'
--
-- * 'scalItems'
--
-- * 'scalSelfLink'
--
-- * 'scalWarning'
--
-- * 'scalId'
sslCertificateAggregatedList
    :: SSLCertificateAggregatedList
sslCertificateAggregatedList =
  SSLCertificateAggregatedList'
    { _scalUnreachables = Nothing
    , _scalNextPageToken = Nothing
    , _scalKind = "compute#sslCertificateAggregatedList"
    , _scalItems = Nothing
    , _scalSelfLink = Nothing
    , _scalWarning = Nothing
    , _scalId = Nothing
    }


-- | [Output Only] Unreachable resources.
scalUnreachables :: Lens' SSLCertificateAggregatedList [Text]
scalUnreachables
  = lens _scalUnreachables
      (\ s a -> s{_scalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
scalNextPageToken :: Lens' SSLCertificateAggregatedList (Maybe Text)
scalNextPageToken
  = lens _scalNextPageToken
      (\ s a -> s{_scalNextPageToken = a})

-- | [Output Only] Type of resource. Always
-- compute#sslCertificateAggregatedList for lists of SSL Certificates.
scalKind :: Lens' SSLCertificateAggregatedList Text
scalKind = lens _scalKind (\ s a -> s{_scalKind = a})

-- | A list of SslCertificatesScopedList resources.
scalItems :: Lens' SSLCertificateAggregatedList (Maybe SSLCertificateAggregatedListItems)
scalItems
  = lens _scalItems (\ s a -> s{_scalItems = a})

-- | [Output Only] Server-defined URL for this resource.
scalSelfLink :: Lens' SSLCertificateAggregatedList (Maybe Text)
scalSelfLink
  = lens _scalSelfLink (\ s a -> s{_scalSelfLink = a})

-- | [Output Only] Informational warning message.
scalWarning :: Lens' SSLCertificateAggregatedList (Maybe SSLCertificateAggregatedListWarning)
scalWarning
  = lens _scalWarning (\ s a -> s{_scalWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
scalId :: Lens' SSLCertificateAggregatedList (Maybe Text)
scalId = lens _scalId (\ s a -> s{_scalId = a})

instance FromJSON SSLCertificateAggregatedList where
        parseJSON
          = withObject "SSLCertificateAggregatedList"
              (\ o ->
                 SSLCertificateAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!=
                        "compute#sslCertificateAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON SSLCertificateAggregatedList where
        toJSON SSLCertificateAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _scalUnreachables,
                  ("nextPageToken" .=) <$> _scalNextPageToken,
                  Just ("kind" .= _scalKind),
                  ("items" .=) <$> _scalItems,
                  ("selfLink" .=) <$> _scalSelfLink,
                  ("warning" .=) <$> _scalWarning,
                  ("id" .=) <$> _scalId])

-- | Represents a Firewall Rule resource. Firewall rules allow or deny
-- ingress traffic to, and egress traffic from your instances. For more
-- information, read Firewall rules.
--
-- /See:/ 'firewall' smart constructor.
data Firewall =
  Firewall'
    { _fSourceTags :: !(Maybe [Text])
    , _fSourceServiceAccounts :: !(Maybe [Text])
    , _fPriority :: !(Maybe (Textual Int32))
    , _fDirection :: !(Maybe FirewallDirection)
    , _fKind :: !Text
    , _fDisabled :: !(Maybe Bool)
    , _fTargetTags :: !(Maybe [Text])
    , _fNetwork :: !(Maybe Text)
    , _fSourceRanges :: !(Maybe [Text])
    , _fSelfLink :: !(Maybe Text)
    , _fName :: !(Maybe Text)
    , _fDenied :: !(Maybe [FirewallDeniedItem])
    , _fCreationTimestamp :: !(Maybe Text)
    , _fId :: !(Maybe (Textual Word64))
    , _fAllowed :: !(Maybe [FirewallAllowedItem])
    , _fDestinationRanges :: !(Maybe [Text])
    , _fLogConfig :: !(Maybe FirewallLogConfig)
    , _fTargetServiceAccounts :: !(Maybe [Text])
    , _fDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Firewall' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'fSourceTags'
--
-- * 'fSourceServiceAccounts'
--
-- * 'fPriority'
--
-- * 'fDirection'
--
-- * 'fKind'
--
-- * 'fDisabled'
--
-- * 'fTargetTags'
--
-- * 'fNetwork'
--
-- * 'fSourceRanges'
--
-- * 'fSelfLink'
--
-- * 'fName'
--
-- * 'fDenied'
--
-- * 'fCreationTimestamp'
--
-- * 'fId'
--
-- * 'fAllowed'
--
-- * 'fDestinationRanges'
--
-- * 'fLogConfig'
--
-- * 'fTargetServiceAccounts'
--
-- * 'fDescription'
firewall
    :: Firewall
firewall =
  Firewall'
    { _fSourceTags = Nothing
    , _fSourceServiceAccounts = Nothing
    , _fPriority = Nothing
    , _fDirection = Nothing
    , _fKind = "compute#firewall"
    , _fDisabled = Nothing
    , _fTargetTags = Nothing
    , _fNetwork = Nothing
    , _fSourceRanges = Nothing
    , _fSelfLink = Nothing
    , _fName = Nothing
    , _fDenied = Nothing
    , _fCreationTimestamp = Nothing
    , _fId = Nothing
    , _fAllowed = Nothing
    , _fDestinationRanges = Nothing
    , _fLogConfig = Nothing
    , _fTargetServiceAccounts = Nothing
    , _fDescription = Nothing
    }


-- | If source tags are specified, the firewall rule applies only to traffic
-- with source IPs that match the primary network interfaces of VM
-- instances that have the tag and are in the same VPC network. Source tags
-- cannot be used to control traffic to an instance\'s external IP address,
-- it only applies to traffic between instances in the same virtual
-- network. Because tags are associated with instances, not IP addresses.
-- One or both of sourceRanges and sourceTags may be set. If both fields
-- are set, the firewall applies to traffic that has a source IP address
-- within sourceRanges OR a source IP from a resource with a matching tag
-- listed in the sourceTags field. The connection does not need to match
-- both fields for the firewall to apply.
fSourceTags :: Lens' Firewall [Text]
fSourceTags
  = lens _fSourceTags (\ s a -> s{_fSourceTags = a}) .
      _Default
      . _Coerce

-- | If source service accounts are specified, the firewall rules apply only
-- to traffic originating from an instance with a service account in this
-- list. Source service accounts cannot be used to control traffic to an
-- instance\'s external IP address because service accounts are associated
-- with an instance, not an IP address. sourceRanges can be set at the same
-- time as sourceServiceAccounts. If both are set, the firewall applies to
-- traffic that has a source IP address within the sourceRanges OR a source
-- IP that belongs to an instance with service account listed in
-- sourceServiceAccount. The connection does not need to match both fields
-- for the firewall to apply. sourceServiceAccounts cannot be used at the
-- same time as sourceTags or targetTags.
fSourceServiceAccounts :: Lens' Firewall [Text]
fSourceServiceAccounts
  = lens _fSourceServiceAccounts
      (\ s a -> s{_fSourceServiceAccounts = a})
      . _Default
      . _Coerce

-- | Priority for this rule. This is an integer between \`0\` and \`65535\`,
-- both inclusive. The default value is \`1000\`. Relative priorities
-- determine which rule takes effect if multiple rules apply. Lower values
-- indicate higher priority. For example, a rule with priority \`0\` has
-- higher precedence than a rule with priority \`1\`. DENY rules take
-- precedence over ALLOW rules if they have equal priority. Note that VPC
-- networks have implied rules with a priority of \`65535\`. To avoid
-- conflicts with the implied rules, use a priority number less than
-- \`65535\`.
fPriority :: Lens' Firewall (Maybe Int32)
fPriority
  = lens _fPriority (\ s a -> s{_fPriority = a}) .
      mapping _Coerce

-- | Direction of traffic to which this firewall applies, either \`INGRESS\`
-- or \`EGRESS\`. The default is \`INGRESS\`. For \`INGRESS\` traffic, you
-- cannot specify the destinationRanges field, and for \`EGRESS\` traffic,
-- you cannot specify the sourceRanges or sourceTags fields.
fDirection :: Lens' Firewall (Maybe FirewallDirection)
fDirection
  = lens _fDirection (\ s a -> s{_fDirection = a})

-- | [Output Only] Type of the resource. Always compute#firewall for firewall
-- rules.
fKind :: Lens' Firewall Text
fKind = lens _fKind (\ s a -> s{_fKind = a})

-- | Denotes whether the firewall rule is disabled. When set to true, the
-- firewall rule is not enforced and the network behaves as if it did not
-- exist. If this is unspecified, the firewall rule will be enabled.
fDisabled :: Lens' Firewall (Maybe Bool)
fDisabled
  = lens _fDisabled (\ s a -> s{_fDisabled = a})

-- | A list of tags that controls which instances the firewall rule applies
-- to. If targetTags are specified, then the firewall rule applies only to
-- instances in the VPC network that have one of those tags. If no
-- targetTags are specified, the firewall rule applies to all instances on
-- the specified network.
fTargetTags :: Lens' Firewall [Text]
fTargetTags
  = lens _fTargetTags (\ s a -> s{_fTargetTags = a}) .
      _Default
      . _Coerce

-- | URL of the network resource for this firewall rule. If not specified
-- when creating a firewall rule, the default network is used:
-- global\/networks\/default If you choose to specify this field, you can
-- specify the network as a full or partial URL. For example, the following
-- are all valid URLs: -
-- https:\/\/www.googleapis.com\/compute\/v1\/projects\/myproject\/global\/networks\/my-network
-- - projects\/myproject\/global\/networks\/my-network -
-- global\/networks\/default
fNetwork :: Lens' Firewall (Maybe Text)
fNetwork = lens _fNetwork (\ s a -> s{_fNetwork = a})

-- | If source ranges are specified, the firewall rule applies only to
-- traffic that has a source IP address in these ranges. These ranges must
-- be expressed in CIDR format. One or both of sourceRanges and sourceTags
-- may be set. If both fields are set, the rule applies to traffic that has
-- a source IP address within sourceRanges OR a source IP from a resource
-- with a matching tag listed in the sourceTags field. The connection does
-- not need to match both fields for the rule to apply. Only IPv4 is
-- supported.
fSourceRanges :: Lens' Firewall [Text]
fSourceRanges
  = lens _fSourceRanges
      (\ s a -> s{_fSourceRanges = a})
      . _Default
      . _Coerce

-- | [Output Only] Server-defined URL for the resource.
fSelfLink :: Lens' Firewall (Maybe Text)
fSelfLink
  = lens _fSelfLink (\ s a -> s{_fSelfLink = a})

-- | Name of the resource; provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?. The first character
-- must be a lowercase letter, and all following characters (except for the
-- last character) must be a dash, lowercase letter, or digit. The last
-- character must be a lowercase letter or digit.
fName :: Lens' Firewall (Maybe Text)
fName = lens _fName (\ s a -> s{_fName = a})

-- | The list of DENY rules specified by this firewall. Each rule specifies a
-- protocol and port-range tuple that describes a denied connection.
fDenied :: Lens' Firewall [FirewallDeniedItem]
fDenied
  = lens _fDenied (\ s a -> s{_fDenied = a}) . _Default
      . _Coerce

-- | [Output Only] Creation timestamp in RFC3339 text format.
fCreationTimestamp :: Lens' Firewall (Maybe Text)
fCreationTimestamp
  = lens _fCreationTimestamp
      (\ s a -> s{_fCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
fId :: Lens' Firewall (Maybe Word64)
fId
  = lens _fId (\ s a -> s{_fId = a}) . mapping _Coerce

-- | The list of ALLOW rules specified by this firewall. Each rule specifies
-- a protocol and port-range tuple that describes a permitted connection.
fAllowed :: Lens' Firewall [FirewallAllowedItem]
fAllowed
  = lens _fAllowed (\ s a -> s{_fAllowed = a}) .
      _Default
      . _Coerce

-- | If destination ranges are specified, the firewall rule applies only to
-- traffic that has destination IP address in these ranges. These ranges
-- must be expressed in CIDR format. Only IPv4 is supported.
fDestinationRanges :: Lens' Firewall [Text]
fDestinationRanges
  = lens _fDestinationRanges
      (\ s a -> s{_fDestinationRanges = a})
      . _Default
      . _Coerce

-- | This field denotes the logging options for a particular firewall rule.
-- If logging is enabled, logs will be exported to Cloud Logging.
fLogConfig :: Lens' Firewall (Maybe FirewallLogConfig)
fLogConfig
  = lens _fLogConfig (\ s a -> s{_fLogConfig = a})

-- | A list of service accounts indicating sets of instances located in the
-- network that may make network connections as specified in allowed[].
-- targetServiceAccounts cannot be used at the same time as targetTags or
-- sourceTags. If neither targetServiceAccounts nor targetTags are
-- specified, the firewall rule applies to all instances on the specified
-- network.
fTargetServiceAccounts :: Lens' Firewall [Text]
fTargetServiceAccounts
  = lens _fTargetServiceAccounts
      (\ s a -> s{_fTargetServiceAccounts = a})
      . _Default
      . _Coerce

-- | An optional description of this resource. Provide this field when you
-- create the resource.
fDescription :: Lens' Firewall (Maybe Text)
fDescription
  = lens _fDescription (\ s a -> s{_fDescription = a})

instance FromJSON Firewall where
        parseJSON
          = withObject "Firewall"
              (\ o ->
                 Firewall' <$>
                   (o .:? "sourceTags" .!= mempty) <*>
                     (o .:? "sourceServiceAccounts" .!= mempty)
                     <*> (o .:? "priority")
                     <*> (o .:? "direction")
                     <*> (o .:? "kind" .!= "compute#firewall")
                     <*> (o .:? "disabled")
                     <*> (o .:? "targetTags" .!= mempty)
                     <*> (o .:? "network")
                     <*> (o .:? "sourceRanges" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "denied" .!= mempty)
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "allowed" .!= mempty)
                     <*> (o .:? "destinationRanges" .!= mempty)
                     <*> (o .:? "logConfig")
                     <*> (o .:? "targetServiceAccounts" .!= mempty)
                     <*> (o .:? "description"))

instance ToJSON Firewall where
        toJSON Firewall'{..}
          = object
              (catMaybes
                 [("sourceTags" .=) <$> _fSourceTags,
                  ("sourceServiceAccounts" .=) <$>
                    _fSourceServiceAccounts,
                  ("priority" .=) <$> _fPriority,
                  ("direction" .=) <$> _fDirection,
                  Just ("kind" .= _fKind),
                  ("disabled" .=) <$> _fDisabled,
                  ("targetTags" .=) <$> _fTargetTags,
                  ("network" .=) <$> _fNetwork,
                  ("sourceRanges" .=) <$> _fSourceRanges,
                  ("selfLink" .=) <$> _fSelfLink,
                  ("name" .=) <$> _fName, ("denied" .=) <$> _fDenied,
                  ("creationTimestamp" .=) <$> _fCreationTimestamp,
                  ("id" .=) <$> _fId, ("allowed" .=) <$> _fAllowed,
                  ("destinationRanges" .=) <$> _fDestinationRanges,
                  ("logConfig" .=) <$> _fLogConfig,
                  ("targetServiceAccounts" .=) <$>
                    _fTargetServiceAccounts,
                  ("description" .=) <$> _fDescription])

--
-- /See:/ 'healthCheckServicesList' smart constructor.
data HealthCheckServicesList =
  HealthCheckServicesList'
    { _hNextPageToken :: !(Maybe Text)
    , _hKind :: !Text
    , _hItems :: !(Maybe [HealthCheckService])
    , _hSelfLink :: !(Maybe Text)
    , _hWarning :: !(Maybe HealthCheckServicesListWarning)
    , _hId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HealthCheckServicesList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hNextPageToken'
--
-- * 'hKind'
--
-- * 'hItems'
--
-- * 'hSelfLink'
--
-- * 'hWarning'
--
-- * 'hId'
healthCheckServicesList
    :: HealthCheckServicesList
healthCheckServicesList =
  HealthCheckServicesList'
    { _hNextPageToken = Nothing
    , _hKind = "compute#healthCheckServicesList"
    , _hItems = Nothing
    , _hSelfLink = Nothing
    , _hWarning = Nothing
    , _hId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
hNextPageToken :: Lens' HealthCheckServicesList (Maybe Text)
hNextPageToken
  = lens _hNextPageToken
      (\ s a -> s{_hNextPageToken = a})

-- | [Output Only] Type of the resource. Always
-- compute#healthCheckServicesList for lists of HealthCheckServices.
hKind :: Lens' HealthCheckServicesList Text
hKind = lens _hKind (\ s a -> s{_hKind = a})

-- | A list of HealthCheckService resources.
hItems :: Lens' HealthCheckServicesList [HealthCheckService]
hItems
  = lens _hItems (\ s a -> s{_hItems = a}) . _Default .
      _Coerce

-- | [Output Only] Server-defined URL for this resource.
hSelfLink :: Lens' HealthCheckServicesList (Maybe Text)
hSelfLink
  = lens _hSelfLink (\ s a -> s{_hSelfLink = a})

-- | [Output Only] Informational warning message.
hWarning :: Lens' HealthCheckServicesList (Maybe HealthCheckServicesListWarning)
hWarning = lens _hWarning (\ s a -> s{_hWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
hId :: Lens' HealthCheckServicesList (Maybe Text)
hId = lens _hId (\ s a -> s{_hId = a})

instance FromJSON HealthCheckServicesList where
        parseJSON
          = withObject "HealthCheckServicesList"
              (\ o ->
                 HealthCheckServicesList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#healthCheckServicesList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON HealthCheckServicesList where
        toJSON HealthCheckServicesList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _hNextPageToken,
                  Just ("kind" .= _hKind), ("items" .=) <$> _hItems,
                  ("selfLink" .=) <$> _hSelfLink,
                  ("warning" .=) <$> _hWarning, ("id" .=) <$> _hId])

-- | Informational warning which replaces the list of addresses when the list
-- is empty.
--
-- /See:/ 'interconnectAttachmentsScopedListWarning' smart constructor.
data InterconnectAttachmentsScopedListWarning =
  InterconnectAttachmentsScopedListWarning'
    { _iaslwData :: !(Maybe [InterconnectAttachmentsScopedListWarningDataItem])
    , _iaslwCode :: !(Maybe InterconnectAttachmentsScopedListWarningCode)
    , _iaslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectAttachmentsScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iaslwData'
--
-- * 'iaslwCode'
--
-- * 'iaslwMessage'
interconnectAttachmentsScopedListWarning
    :: InterconnectAttachmentsScopedListWarning
interconnectAttachmentsScopedListWarning =
  InterconnectAttachmentsScopedListWarning'
    {_iaslwData = Nothing, _iaslwCode = Nothing, _iaslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
iaslwData :: Lens' InterconnectAttachmentsScopedListWarning [InterconnectAttachmentsScopedListWarningDataItem]
iaslwData
  = lens _iaslwData (\ s a -> s{_iaslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
iaslwCode :: Lens' InterconnectAttachmentsScopedListWarning (Maybe InterconnectAttachmentsScopedListWarningCode)
iaslwCode
  = lens _iaslwCode (\ s a -> s{_iaslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
iaslwMessage :: Lens' InterconnectAttachmentsScopedListWarning (Maybe Text)
iaslwMessage
  = lens _iaslwMessage (\ s a -> s{_iaslwMessage = a})

instance FromJSON
           InterconnectAttachmentsScopedListWarning
         where
        parseJSON
          = withObject
              "InterconnectAttachmentsScopedListWarning"
              (\ o ->
                 InterconnectAttachmentsScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON
           InterconnectAttachmentsScopedListWarning
         where
        toJSON InterconnectAttachmentsScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _iaslwData,
                  ("code" .=) <$> _iaslwCode,
                  ("message" .=) <$> _iaslwMessage])

-- | UrlMaps A host-matching rule for a URL. If matched, will use the named
-- PathMatcher to select the BackendService.
--
-- /See:/ 'hostRule' smart constructor.
data HostRule =
  HostRule'
    { _hrHosts :: !(Maybe [Text])
    , _hrDescription :: !(Maybe Text)
    , _hrPathMatcher :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HostRule' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hrHosts'
--
-- * 'hrDescription'
--
-- * 'hrPathMatcher'
hostRule
    :: HostRule
hostRule =
  HostRule'
    {_hrHosts = Nothing, _hrDescription = Nothing, _hrPathMatcher = Nothing}


-- | The list of host patterns to match. They must be valid hostnames with
-- optional port numbers in the format host:port. * matches any string of
-- ([a-z0-9-.]*). In that case, * must be the first character and must be
-- followed in the pattern by either - or .. * based matching is not
-- supported when the URL map is bound to target gRPC proxy that has
-- validateForProxyless field set to true.
hrHosts :: Lens' HostRule [Text]
hrHosts
  = lens _hrHosts (\ s a -> s{_hrHosts = a}) . _Default
      . _Coerce

-- | An optional description of this resource. Provide this property when you
-- create the resource.
hrDescription :: Lens' HostRule (Maybe Text)
hrDescription
  = lens _hrDescription
      (\ s a -> s{_hrDescription = a})

-- | The name of the PathMatcher to use to match the path portion of the URL
-- if the hostRule matches the URL\'s host portion.
hrPathMatcher :: Lens' HostRule (Maybe Text)
hrPathMatcher
  = lens _hrPathMatcher
      (\ s a -> s{_hrPathMatcher = a})

instance FromJSON HostRule where
        parseJSON
          = withObject "HostRule"
              (\ o ->
                 HostRule' <$>
                   (o .:? "hosts" .!= mempty) <*> (o .:? "description")
                     <*> (o .:? "pathMatcher"))

instance ToJSON HostRule where
        toJSON HostRule'{..}
          = object
              (catMaybes
                 [("hosts" .=) <$> _hrHosts,
                  ("description" .=) <$> _hrDescription,
                  ("pathMatcher" .=) <$> _hrPathMatcher])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'securityPolicyListWarning' smart constructor.
data SecurityPolicyListWarning =
  SecurityPolicyListWarning'
    { _secData :: !(Maybe [SecurityPolicyListWarningDataItem])
    , _secCode :: !(Maybe SecurityPolicyListWarningCode)
    , _secMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SecurityPolicyListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'secData'
--
-- * 'secCode'
--
-- * 'secMessage'
securityPolicyListWarning
    :: SecurityPolicyListWarning
securityPolicyListWarning =
  SecurityPolicyListWarning'
    {_secData = Nothing, _secCode = Nothing, _secMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
secData :: Lens' SecurityPolicyListWarning [SecurityPolicyListWarningDataItem]
secData
  = lens _secData (\ s a -> s{_secData = a}) . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
secCode :: Lens' SecurityPolicyListWarning (Maybe SecurityPolicyListWarningCode)
secCode = lens _secCode (\ s a -> s{_secCode = a})

-- | [Output Only] A human-readable description of the warning code.
secMessage :: Lens' SecurityPolicyListWarning (Maybe Text)
secMessage
  = lens _secMessage (\ s a -> s{_secMessage = a})

instance FromJSON SecurityPolicyListWarning where
        parseJSON
          = withObject "SecurityPolicyListWarning"
              (\ o ->
                 SecurityPolicyListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON SecurityPolicyListWarning where
        toJSON SecurityPolicyListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _secData, ("code" .=) <$> _secCode,
                  ("message" .=) <$> _secMessage])

-- | A quotas entry.
--
-- /See:/ 'quota' smart constructor.
data Quota =
  Quota'
    { _qOwner :: !(Maybe Text)
    , _qMetric :: !(Maybe QuotaMetric)
    , _qLimit :: !(Maybe (Textual Double))
    , _qUsage :: !(Maybe (Textual Double))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Quota' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'qOwner'
--
-- * 'qMetric'
--
-- * 'qLimit'
--
-- * 'qUsage'
quota
    :: Quota
quota =
  Quota'
    { _qOwner = Nothing
    , _qMetric = Nothing
    , _qLimit = Nothing
    , _qUsage = Nothing
    }


-- | [Output Only] Owning resource. This is the resource on which this quota
-- is applied.
qOwner :: Lens' Quota (Maybe Text)
qOwner = lens _qOwner (\ s a -> s{_qOwner = a})

-- | [Output Only] Name of the quota metric.
qMetric :: Lens' Quota (Maybe QuotaMetric)
qMetric = lens _qMetric (\ s a -> s{_qMetric = a})

-- | [Output Only] Quota limit for this metric.
qLimit :: Lens' Quota (Maybe Double)
qLimit
  = lens _qLimit (\ s a -> s{_qLimit = a}) .
      mapping _Coerce

-- | [Output Only] Current usage of this metric.
qUsage :: Lens' Quota (Maybe Double)
qUsage
  = lens _qUsage (\ s a -> s{_qUsage = a}) .
      mapping _Coerce

instance FromJSON Quota where
        parseJSON
          = withObject "Quota"
              (\ o ->
                 Quota' <$>
                   (o .:? "owner") <*> (o .:? "metric") <*>
                     (o .:? "limit")
                     <*> (o .:? "usage"))

instance ToJSON Quota where
        toJSON Quota'{..}
          = object
              (catMaybes
                 [("owner" .=) <$> _qOwner,
                  ("metric" .=) <$> _qMetric, ("limit" .=) <$> _qLimit,
                  ("usage" .=) <$> _qUsage])

-- | Represents an Instance Group resource. Instance Groups can be used to
-- configure a target for load balancing. Instance groups can either be
-- managed or unmanaged. To create managed instance groups, use the
-- instanceGroupManager or regionInstanceGroupManager resource instead. Use
-- zonal unmanaged instance groups if you need to apply load balancing to
-- groups of heterogeneous instances or if you need to manage the instances
-- yourself. You cannot create regional unmanaged instance groups. For more
-- information, read Instance groups. (== resource_for
-- {$api_version}.instanceGroups ==) (== resource_for
-- {$api_version}.regionInstanceGroups ==)
--
-- /See:/ 'instanceGroup' smart constructor.
data InstanceGroup =
  InstanceGroup'
    { _ig1Size :: !(Maybe (Textual Int32))
    , _ig1Kind :: !Text
    , _ig1Fingerprint :: !(Maybe Bytes)
    , _ig1Network :: !(Maybe Text)
    , _ig1Zone :: !(Maybe Text)
    , _ig1SelfLink :: !(Maybe Text)
    , _ig1Name :: !(Maybe Text)
    , _ig1CreationTimestamp :: !(Maybe Text)
    , _ig1Subnetwork :: !(Maybe Text)
    , _ig1Id :: !(Maybe (Textual Word64))
    , _ig1Region :: !(Maybe Text)
    , _ig1Description :: !(Maybe Text)
    , _ig1NamedPorts :: !(Maybe [NamedPort])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroup' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ig1Size'
--
-- * 'ig1Kind'
--
-- * 'ig1Fingerprint'
--
-- * 'ig1Network'
--
-- * 'ig1Zone'
--
-- * 'ig1SelfLink'
--
-- * 'ig1Name'
--
-- * 'ig1CreationTimestamp'
--
-- * 'ig1Subnetwork'
--
-- * 'ig1Id'
--
-- * 'ig1Region'
--
-- * 'ig1Description'
--
-- * 'ig1NamedPorts'
instanceGroup
    :: InstanceGroup
instanceGroup =
  InstanceGroup'
    { _ig1Size = Nothing
    , _ig1Kind = "compute#instanceGroup"
    , _ig1Fingerprint = Nothing
    , _ig1Network = Nothing
    , _ig1Zone = Nothing
    , _ig1SelfLink = Nothing
    , _ig1Name = Nothing
    , _ig1CreationTimestamp = Nothing
    , _ig1Subnetwork = Nothing
    , _ig1Id = Nothing
    , _ig1Region = Nothing
    , _ig1Description = Nothing
    , _ig1NamedPorts = Nothing
    }


-- | [Output Only] The total number of instances in the instance group.
ig1Size :: Lens' InstanceGroup (Maybe Int32)
ig1Size
  = lens _ig1Size (\ s a -> s{_ig1Size = a}) .
      mapping _Coerce

-- | [Output Only] The resource type, which is always compute#instanceGroup
-- for instance groups.
ig1Kind :: Lens' InstanceGroup Text
ig1Kind = lens _ig1Kind (\ s a -> s{_ig1Kind = a})

-- | [Output Only] The fingerprint of the named ports. The system uses this
-- fingerprint to detect conflicts when multiple users change the named
-- ports concurrently.
ig1Fingerprint :: Lens' InstanceGroup (Maybe ByteString)
ig1Fingerprint
  = lens _ig1Fingerprint
      (\ s a -> s{_ig1Fingerprint = a})
      . mapping _Bytes

-- | [Output Only] The URL of the network to which all instances in the
-- instance group belong. If your instance has multiple network interfaces,
-- then the network and subnetwork fields only refer to the network and
-- subnet used by your primary interface (nic0).
ig1Network :: Lens' InstanceGroup (Maybe Text)
ig1Network
  = lens _ig1Network (\ s a -> s{_ig1Network = a})

-- | [Output Only] The URL of the zone where the instance group is located
-- (for zonal resources).
ig1Zone :: Lens' InstanceGroup (Maybe Text)
ig1Zone = lens _ig1Zone (\ s a -> s{_ig1Zone = a})

-- | [Output Only] The URL for this instance group. The server generates this
-- URL.
ig1SelfLink :: Lens' InstanceGroup (Maybe Text)
ig1SelfLink
  = lens _ig1SelfLink (\ s a -> s{_ig1SelfLink = a})

-- | The name of the instance group. The name must be 1-63 characters long,
-- and comply with RFC1035.
ig1Name :: Lens' InstanceGroup (Maybe Text)
ig1Name = lens _ig1Name (\ s a -> s{_ig1Name = a})

-- | [Output Only] The creation timestamp for this instance group in RFC3339
-- text format.
ig1CreationTimestamp :: Lens' InstanceGroup (Maybe Text)
ig1CreationTimestamp
  = lens _ig1CreationTimestamp
      (\ s a -> s{_ig1CreationTimestamp = a})

-- | [Output Only] The URL of the subnetwork to which all instances in the
-- instance group belong. If your instance has multiple network interfaces,
-- then the network and subnetwork fields only refer to the network and
-- subnet used by your primary interface (nic0).
ig1Subnetwork :: Lens' InstanceGroup (Maybe Text)
ig1Subnetwork
  = lens _ig1Subnetwork
      (\ s a -> s{_ig1Subnetwork = a})

-- | [Output Only] A unique identifier for this instance group, generated by
-- the server.
ig1Id :: Lens' InstanceGroup (Maybe Word64)
ig1Id
  = lens _ig1Id (\ s a -> s{_ig1Id = a}) .
      mapping _Coerce

-- | [Output Only] The URL of the region where the instance group is located
-- (for regional resources).
ig1Region :: Lens' InstanceGroup (Maybe Text)
ig1Region
  = lens _ig1Region (\ s a -> s{_ig1Region = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource.
ig1Description :: Lens' InstanceGroup (Maybe Text)
ig1Description
  = lens _ig1Description
      (\ s a -> s{_ig1Description = a})

-- | Assigns a name to a port number. For example: {name: \"http\", port: 80}
-- This allows the system to reference ports by the assigned name instead
-- of a port number. Named ports can also contain multiple ports. For
-- example: [{name: \"http\", port: 80},{name: \"http\", port: 8080}] Named
-- ports apply to all instances in this instance group.
ig1NamedPorts :: Lens' InstanceGroup [NamedPort]
ig1NamedPorts
  = lens _ig1NamedPorts
      (\ s a -> s{_ig1NamedPorts = a})
      . _Default
      . _Coerce

instance FromJSON InstanceGroup where
        parseJSON
          = withObject "InstanceGroup"
              (\ o ->
                 InstanceGroup' <$>
                   (o .:? "size") <*>
                     (o .:? "kind" .!= "compute#instanceGroup")
                     <*> (o .:? "fingerprint")
                     <*> (o .:? "network")
                     <*> (o .:? "zone")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "subnetwork")
                     <*> (o .:? "id")
                     <*> (o .:? "region")
                     <*> (o .:? "description")
                     <*> (o .:? "namedPorts" .!= mempty))

instance ToJSON InstanceGroup where
        toJSON InstanceGroup'{..}
          = object
              (catMaybes
                 [("size" .=) <$> _ig1Size, Just ("kind" .= _ig1Kind),
                  ("fingerprint" .=) <$> _ig1Fingerprint,
                  ("network" .=) <$> _ig1Network,
                  ("zone" .=) <$> _ig1Zone,
                  ("selfLink" .=) <$> _ig1SelfLink,
                  ("name" .=) <$> _ig1Name,
                  ("creationTimestamp" .=) <$> _ig1CreationTimestamp,
                  ("subnetwork" .=) <$> _ig1Subnetwork,
                  ("id" .=) <$> _ig1Id, ("region" .=) <$> _ig1Region,
                  ("description" .=) <$> _ig1Description,
                  ("namedPorts" .=) <$> _ig1NamedPorts])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'addressListWarning' smart constructor.
data AddressListWarning =
  AddressListWarning'
    { _alwlData :: !(Maybe [AddressListWarningDataItem])
    , _alwlCode :: !(Maybe AddressListWarningCode)
    , _alwlMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AddressListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'alwlData'
--
-- * 'alwlCode'
--
-- * 'alwlMessage'
addressListWarning
    :: AddressListWarning
addressListWarning =
  AddressListWarning'
    {_alwlData = Nothing, _alwlCode = Nothing, _alwlMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
alwlData :: Lens' AddressListWarning [AddressListWarningDataItem]
alwlData
  = lens _alwlData (\ s a -> s{_alwlData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
alwlCode :: Lens' AddressListWarning (Maybe AddressListWarningCode)
alwlCode = lens _alwlCode (\ s a -> s{_alwlCode = a})

-- | [Output Only] A human-readable description of the warning code.
alwlMessage :: Lens' AddressListWarning (Maybe Text)
alwlMessage
  = lens _alwlMessage (\ s a -> s{_alwlMessage = a})

instance FromJSON AddressListWarning where
        parseJSON
          = withObject "AddressListWarning"
              (\ o ->
                 AddressListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON AddressListWarning where
        toJSON AddressListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _alwlData,
                  ("code" .=) <$> _alwlCode,
                  ("message" .=) <$> _alwlMessage])

-- | Specified snapshot properties for scheduled snapshots created by this
-- policy.
--
-- /See:/ 'resourcePolicySnapshotSchedulePolicySnapshotProperties' smart constructor.
data ResourcePolicySnapshotSchedulePolicySnapshotProperties =
  ResourcePolicySnapshotSchedulePolicySnapshotProperties'
    { _rpsspspGuestFlush :: !(Maybe Bool)
    , _rpsspspChainName :: !(Maybe Text)
    , _rpsspspStorageLocations :: !(Maybe [Text])
    , _rpsspspLabels :: !(Maybe ResourcePolicySnapshotSchedulePolicySnapshotPropertiesLabels)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePolicySnapshotSchedulePolicySnapshotProperties' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rpsspspGuestFlush'
--
-- * 'rpsspspChainName'
--
-- * 'rpsspspStorageLocations'
--
-- * 'rpsspspLabels'
resourcePolicySnapshotSchedulePolicySnapshotProperties
    :: ResourcePolicySnapshotSchedulePolicySnapshotProperties
resourcePolicySnapshotSchedulePolicySnapshotProperties =
  ResourcePolicySnapshotSchedulePolicySnapshotProperties'
    { _rpsspspGuestFlush = Nothing
    , _rpsspspChainName = Nothing
    , _rpsspspStorageLocations = Nothing
    , _rpsspspLabels = Nothing
    }


-- | Indication to perform a \'guest aware\' snapshot.
rpsspspGuestFlush :: Lens' ResourcePolicySnapshotSchedulePolicySnapshotProperties (Maybe Bool)
rpsspspGuestFlush
  = lens _rpsspspGuestFlush
      (\ s a -> s{_rpsspspGuestFlush = a})

-- | Chain name that the snapshot is created in.
rpsspspChainName :: Lens' ResourcePolicySnapshotSchedulePolicySnapshotProperties (Maybe Text)
rpsspspChainName
  = lens _rpsspspChainName
      (\ s a -> s{_rpsspspChainName = a})

-- | Cloud Storage bucket storage location of the auto snapshot (regional or
-- multi-regional).
rpsspspStorageLocations :: Lens' ResourcePolicySnapshotSchedulePolicySnapshotProperties [Text]
rpsspspStorageLocations
  = lens _rpsspspStorageLocations
      (\ s a -> s{_rpsspspStorageLocations = a})
      . _Default
      . _Coerce

-- | Labels to apply to scheduled snapshots. These can be later modified by
-- the setLabels method. Label values may be empty.
rpsspspLabels :: Lens' ResourcePolicySnapshotSchedulePolicySnapshotProperties (Maybe ResourcePolicySnapshotSchedulePolicySnapshotPropertiesLabels)
rpsspspLabels
  = lens _rpsspspLabels
      (\ s a -> s{_rpsspspLabels = a})

instance FromJSON
           ResourcePolicySnapshotSchedulePolicySnapshotProperties
         where
        parseJSON
          = withObject
              "ResourcePolicySnapshotSchedulePolicySnapshotProperties"
              (\ o ->
                 ResourcePolicySnapshotSchedulePolicySnapshotProperties'
                   <$>
                   (o .:? "guestFlush") <*> (o .:? "chainName") <*>
                     (o .:? "storageLocations" .!= mempty)
                     <*> (o .:? "labels"))

instance ToJSON
           ResourcePolicySnapshotSchedulePolicySnapshotProperties
         where
        toJSON
          ResourcePolicySnapshotSchedulePolicySnapshotProperties'{..}
          = object
              (catMaybes
                 [("guestFlush" .=) <$> _rpsspspGuestFlush,
                  ("chainName" .=) <$> _rpsspspChainName,
                  ("storageLocations" .=) <$> _rpsspspStorageLocations,
                  ("labels" .=) <$> _rpsspspLabels])

--
-- /See:/ 'regionSetLabelsRequest' smart constructor.
data RegionSetLabelsRequest =
  RegionSetLabelsRequest'
    { _rslrLabels :: !(Maybe RegionSetLabelsRequestLabels)
    , _rslrLabelFingerprint :: !(Maybe Bytes)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionSetLabelsRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rslrLabels'
--
-- * 'rslrLabelFingerprint'
regionSetLabelsRequest
    :: RegionSetLabelsRequest
regionSetLabelsRequest =
  RegionSetLabelsRequest'
    {_rslrLabels = Nothing, _rslrLabelFingerprint = Nothing}


-- | The labels to set for this resource.
rslrLabels :: Lens' RegionSetLabelsRequest (Maybe RegionSetLabelsRequestLabels)
rslrLabels
  = lens _rslrLabels (\ s a -> s{_rslrLabels = a})

-- | The fingerprint of the previous set of labels for this resource, used to
-- detect conflicts. The fingerprint is initially generated by Compute
-- Engine and changes after every request to modify or update labels. You
-- must always provide an up-to-date fingerprint hash in order to update or
-- change labels. Make a get() request to the resource to get the latest
-- fingerprint.
rslrLabelFingerprint :: Lens' RegionSetLabelsRequest (Maybe ByteString)
rslrLabelFingerprint
  = lens _rslrLabelFingerprint
      (\ s a -> s{_rslrLabelFingerprint = a})
      . mapping _Bytes

instance FromJSON RegionSetLabelsRequest where
        parseJSON
          = withObject "RegionSetLabelsRequest"
              (\ o ->
                 RegionSetLabelsRequest' <$>
                   (o .:? "labels") <*> (o .:? "labelFingerprint"))

instance ToJSON RegionSetLabelsRequest where
        toJSON RegionSetLabelsRequest'{..}
          = object
              (catMaybes
                 [("labels" .=) <$> _rslrLabels,
                  ("labelFingerprint" .=) <$> _rslrLabelFingerprint])

-- | Informational warning which replaces the list of backend services when
-- the list is empty.
--
-- /See:/ 'targetHTTPSProxiesScopedListWarning' smart constructor.
data TargetHTTPSProxiesScopedListWarning =
  TargetHTTPSProxiesScopedListWarning'
    { _thpslwData :: !(Maybe [TargetHTTPSProxiesScopedListWarningDataItem])
    , _thpslwCode :: !(Maybe TargetHTTPSProxiesScopedListWarningCode)
    , _thpslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetHTTPSProxiesScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'thpslwData'
--
-- * 'thpslwCode'
--
-- * 'thpslwMessage'
targetHTTPSProxiesScopedListWarning
    :: TargetHTTPSProxiesScopedListWarning
targetHTTPSProxiesScopedListWarning =
  TargetHTTPSProxiesScopedListWarning'
    {_thpslwData = Nothing, _thpslwCode = Nothing, _thpslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
thpslwData :: Lens' TargetHTTPSProxiesScopedListWarning [TargetHTTPSProxiesScopedListWarningDataItem]
thpslwData
  = lens _thpslwData (\ s a -> s{_thpslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
thpslwCode :: Lens' TargetHTTPSProxiesScopedListWarning (Maybe TargetHTTPSProxiesScopedListWarningCode)
thpslwCode
  = lens _thpslwCode (\ s a -> s{_thpslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
thpslwMessage :: Lens' TargetHTTPSProxiesScopedListWarning (Maybe Text)
thpslwMessage
  = lens _thpslwMessage
      (\ s a -> s{_thpslwMessage = a})

instance FromJSON TargetHTTPSProxiesScopedListWarning
         where
        parseJSON
          = withObject "TargetHTTPSProxiesScopedListWarning"
              (\ o ->
                 TargetHTTPSProxiesScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON TargetHTTPSProxiesScopedListWarning
         where
        toJSON TargetHTTPSProxiesScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _thpslwData,
                  ("code" .=) <$> _thpslwCode,
                  ("message" .=) <$> _thpslwMessage])

--
-- /See:/ 'routerInterface' smart constructor.
data RouterInterface =
  RouterInterface'
    { _riLinkedInterconnectAttachment :: !(Maybe Text)
    , _riName :: !(Maybe Text)
    , _riManagementType :: !(Maybe RouterInterfaceManagementType)
    , _riIPRange :: !(Maybe Text)
    , _riLinkedVPNTunnel :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RouterInterface' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'riLinkedInterconnectAttachment'
--
-- * 'riName'
--
-- * 'riManagementType'
--
-- * 'riIPRange'
--
-- * 'riLinkedVPNTunnel'
routerInterface
    :: RouterInterface
routerInterface =
  RouterInterface'
    { _riLinkedInterconnectAttachment = Nothing
    , _riName = Nothing
    , _riManagementType = Nothing
    , _riIPRange = Nothing
    , _riLinkedVPNTunnel = Nothing
    }


-- | URI of the linked Interconnect attachment. It must be in the same region
-- as the router. Each interface can have one linked resource, which can be
-- a VPN tunnel, an Interconnect attachment, or a virtual machine instance.
riLinkedInterconnectAttachment :: Lens' RouterInterface (Maybe Text)
riLinkedInterconnectAttachment
  = lens _riLinkedInterconnectAttachment
      (\ s a -> s{_riLinkedInterconnectAttachment = a})

-- | Name of this interface entry. The name must be 1-63 characters long, and
-- comply with RFC1035. Specifically, the name must be 1-63 characters long
-- and match the regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which
-- means the first character must be a lowercase letter, and all following
-- characters must be a dash, lowercase letter, or digit, except the last
-- character, which cannot be a dash.
riName :: Lens' RouterInterface (Maybe Text)
riName = lens _riName (\ s a -> s{_riName = a})

-- | [Output Only] The resource that configures and manages this interface. -
-- MANAGED_BY_USER is the default value and can be managed directly by
-- users. - MANAGED_BY_ATTACHMENT is an interface that is configured and
-- managed by Cloud Interconnect, specifically, by an
-- InterconnectAttachment of type PARTNER. Google automatically creates,
-- updates, and deletes this type of interface when the PARTNER
-- InterconnectAttachment is created, updated, or deleted.
riManagementType :: Lens' RouterInterface (Maybe RouterInterfaceManagementType)
riManagementType
  = lens _riManagementType
      (\ s a -> s{_riManagementType = a})

-- | IP address and range of the interface. The IP range must be in the
-- RFC3927 link-local IP address space. The value must be a CIDR-formatted
-- string, for example: 169.254.0.1\/30. NOTE: Do not truncate the address
-- as it represents the IP address of the interface.
riIPRange :: Lens' RouterInterface (Maybe Text)
riIPRange
  = lens _riIPRange (\ s a -> s{_riIPRange = a})

-- | URI of the linked VPN tunnel, which must be in the same region as the
-- router. Each interface can have one linked resource, which can be a VPN
-- tunnel, an Interconnect attachment, or a virtual machine instance.
riLinkedVPNTunnel :: Lens' RouterInterface (Maybe Text)
riLinkedVPNTunnel
  = lens _riLinkedVPNTunnel
      (\ s a -> s{_riLinkedVPNTunnel = a})

instance FromJSON RouterInterface where
        parseJSON
          = withObject "RouterInterface"
              (\ o ->
                 RouterInterface' <$>
                   (o .:? "linkedInterconnectAttachment") <*>
                     (o .:? "name")
                     <*> (o .:? "managementType")
                     <*> (o .:? "ipRange")
                     <*> (o .:? "linkedVpnTunnel"))

instance ToJSON RouterInterface where
        toJSON RouterInterface'{..}
          = object
              (catMaybes
                 [("linkedInterconnectAttachment" .=) <$>
                    _riLinkedInterconnectAttachment,
                  ("name" .=) <$> _riName,
                  ("managementType" .=) <$> _riManagementType,
                  ("ipRange" .=) <$> _riIPRange,
                  ("linkedVpnTunnel" .=) <$> _riLinkedVPNTunnel])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'networkListWarning' smart constructor.
data NetworkListWarning =
  NetworkListWarning'
    { _nlwData :: !(Maybe [NetworkListWarningDataItem])
    , _nlwCode :: !(Maybe NetworkListWarningCode)
    , _nlwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nlwData'
--
-- * 'nlwCode'
--
-- * 'nlwMessage'
networkListWarning
    :: NetworkListWarning
networkListWarning =
  NetworkListWarning'
    {_nlwData = Nothing, _nlwCode = Nothing, _nlwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
nlwData :: Lens' NetworkListWarning [NetworkListWarningDataItem]
nlwData
  = lens _nlwData (\ s a -> s{_nlwData = a}) . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
nlwCode :: Lens' NetworkListWarning (Maybe NetworkListWarningCode)
nlwCode = lens _nlwCode (\ s a -> s{_nlwCode = a})

-- | [Output Only] A human-readable description of the warning code.
nlwMessage :: Lens' NetworkListWarning (Maybe Text)
nlwMessage
  = lens _nlwMessage (\ s a -> s{_nlwMessage = a})

instance FromJSON NetworkListWarning where
        parseJSON
          = withObject "NetworkListWarning"
              (\ o ->
                 NetworkListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON NetworkListWarning where
        toJSON NetworkListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _nlwData, ("code" .=) <$> _nlwCode,
                  ("message" .=) <$> _nlwMessage])

-- | Contains a list of Snapshot resources.
--
-- /See:/ 'snapshotList' smart constructor.
data SnapshotList =
  SnapshotList'
    { _sllNextPageToken :: !(Maybe Text)
    , _sllKind :: !Text
    , _sllItems :: !(Maybe [Snapshot])
    , _sllSelfLink :: !(Maybe Text)
    , _sllWarning :: !(Maybe SnapshotListWarning)
    , _sllId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SnapshotList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sllNextPageToken'
--
-- * 'sllKind'
--
-- * 'sllItems'
--
-- * 'sllSelfLink'
--
-- * 'sllWarning'
--
-- * 'sllId'
snapshotList
    :: SnapshotList
snapshotList =
  SnapshotList'
    { _sllNextPageToken = Nothing
    , _sllKind = "compute#snapshotList"
    , _sllItems = Nothing
    , _sllSelfLink = Nothing
    , _sllWarning = Nothing
    , _sllId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
sllNextPageToken :: Lens' SnapshotList (Maybe Text)
sllNextPageToken
  = lens _sllNextPageToken
      (\ s a -> s{_sllNextPageToken = a})

-- | Type of resource.
sllKind :: Lens' SnapshotList Text
sllKind = lens _sllKind (\ s a -> s{_sllKind = a})

-- | A list of Snapshot resources.
sllItems :: Lens' SnapshotList [Snapshot]
sllItems
  = lens _sllItems (\ s a -> s{_sllItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
sllSelfLink :: Lens' SnapshotList (Maybe Text)
sllSelfLink
  = lens _sllSelfLink (\ s a -> s{_sllSelfLink = a})

-- | [Output Only] Informational warning message.
sllWarning :: Lens' SnapshotList (Maybe SnapshotListWarning)
sllWarning
  = lens _sllWarning (\ s a -> s{_sllWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
sllId :: Lens' SnapshotList (Maybe Text)
sllId = lens _sllId (\ s a -> s{_sllId = a})

instance FromJSON SnapshotList where
        parseJSON
          = withObject "SnapshotList"
              (\ o ->
                 SnapshotList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#snapshotList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON SnapshotList where
        toJSON SnapshotList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _sllNextPageToken,
                  Just ("kind" .= _sllKind),
                  ("items" .=) <$> _sllItems,
                  ("selfLink" .=) <$> _sllSelfLink,
                  ("warning" .=) <$> _sllWarning,
                  ("id" .=) <$> _sllId])

-- | Diagnostics information about interconnect, contains detailed and
-- current technical information about Google\'s side of the connection.
--
-- /See:/ 'interconnectDiagnostics' smart constructor.
data InterconnectDiagnostics =
  InterconnectDiagnostics'
    { _idMACAddress :: !(Maybe Text)
    , _idArpCaches :: !(Maybe [InterconnectDiagnosticsARPEntry])
    , _idLinks :: !(Maybe [InterconnectDiagnosticsLinkStatus])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectDiagnostics' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'idMACAddress'
--
-- * 'idArpCaches'
--
-- * 'idLinks'
interconnectDiagnostics
    :: InterconnectDiagnostics
interconnectDiagnostics =
  InterconnectDiagnostics'
    {_idMACAddress = Nothing, _idArpCaches = Nothing, _idLinks = Nothing}


-- | The MAC address of the Interconnect\'s bundle interface.
idMACAddress :: Lens' InterconnectDiagnostics (Maybe Text)
idMACAddress
  = lens _idMACAddress (\ s a -> s{_idMACAddress = a})

-- | A list of InterconnectDiagnostics.ARPEntry objects, describing
-- individual neighbors currently seen by the Google router in the ARP
-- cache for the Interconnect. This will be empty when the Interconnect is
-- not bundled.
idArpCaches :: Lens' InterconnectDiagnostics [InterconnectDiagnosticsARPEntry]
idArpCaches
  = lens _idArpCaches (\ s a -> s{_idArpCaches = a}) .
      _Default
      . _Coerce

-- | A list of InterconnectDiagnostics.LinkStatus objects, describing the
-- status for each link on the Interconnect.
idLinks :: Lens' InterconnectDiagnostics [InterconnectDiagnosticsLinkStatus]
idLinks
  = lens _idLinks (\ s a -> s{_idLinks = a}) . _Default
      . _Coerce

instance FromJSON InterconnectDiagnostics where
        parseJSON
          = withObject "InterconnectDiagnostics"
              (\ o ->
                 InterconnectDiagnostics' <$>
                   (o .:? "macAddress") <*>
                     (o .:? "arpCaches" .!= mempty)
                     <*> (o .:? "links" .!= mempty))

instance ToJSON InterconnectDiagnostics where
        toJSON InterconnectDiagnostics'{..}
          = object
              (catMaybes
                 [("macAddress" .=) <$> _idMACAddress,
                  ("arpCaches" .=) <$> _idArpCaches,
                  ("links" .=) <$> _idLinks])

-- | Represents a License Code resource. A License Code is a unique
-- identifier used to represent a license resource. Caution This resource
-- is intended for use only by third-party partners who are creating Cloud
-- Marketplace images. (== resource_for {$api_version}.licenseCodes ==)
--
-- /See:/ 'licenseCode' smart constructor.
data LicenseCode =
  LicenseCode'
    { _lcState :: !(Maybe LicenseCodeState)
    , _lcKind :: !Text
    , _lcTransferable :: !(Maybe Bool)
    , _lcSelfLink :: !(Maybe Text)
    , _lcName :: !(Maybe Text)
    , _lcCreationTimestamp :: !(Maybe Text)
    , _lcId :: !(Maybe (Textual Word64))
    , _lcLicenseAlias :: !(Maybe [LicenseCodeLicenseAlias])
    , _lcDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'LicenseCode' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'lcState'
--
-- * 'lcKind'
--
-- * 'lcTransferable'
--
-- * 'lcSelfLink'
--
-- * 'lcName'
--
-- * 'lcCreationTimestamp'
--
-- * 'lcId'
--
-- * 'lcLicenseAlias'
--
-- * 'lcDescription'
licenseCode
    :: LicenseCode
licenseCode =
  LicenseCode'
    { _lcState = Nothing
    , _lcKind = "compute#licenseCode"
    , _lcTransferable = Nothing
    , _lcSelfLink = Nothing
    , _lcName = Nothing
    , _lcCreationTimestamp = Nothing
    , _lcId = Nothing
    , _lcLicenseAlias = Nothing
    , _lcDescription = Nothing
    }


-- | [Output Only] Current state of this License Code.
lcState :: Lens' LicenseCode (Maybe LicenseCodeState)
lcState = lens _lcState (\ s a -> s{_lcState = a})

-- | [Output Only] Type of resource. Always compute#licenseCode for licenses.
lcKind :: Lens' LicenseCode Text
lcKind = lens _lcKind (\ s a -> s{_lcKind = a})

-- | [Output Only] If true, the license will remain attached when creating
-- images or snapshots from disks. Otherwise, the license is not
-- transferred.
lcTransferable :: Lens' LicenseCode (Maybe Bool)
lcTransferable
  = lens _lcTransferable
      (\ s a -> s{_lcTransferable = a})

-- | [Output Only] Server-defined URL for the resource.
lcSelfLink :: Lens' LicenseCode (Maybe Text)
lcSelfLink
  = lens _lcSelfLink (\ s a -> s{_lcSelfLink = a})

-- | [Output Only] Name of the resource. The name is 1-20 characters long and
-- must be a valid 64 bit integer.
lcName :: Lens' LicenseCode (Maybe Text)
lcName = lens _lcName (\ s a -> s{_lcName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
lcCreationTimestamp :: Lens' LicenseCode (Maybe Text)
lcCreationTimestamp
  = lens _lcCreationTimestamp
      (\ s a -> s{_lcCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
lcId :: Lens' LicenseCode (Maybe Word64)
lcId
  = lens _lcId (\ s a -> s{_lcId = a}) .
      mapping _Coerce

-- | [Output Only] URL and description aliases of Licenses with the same
-- License Code.
lcLicenseAlias :: Lens' LicenseCode [LicenseCodeLicenseAlias]
lcLicenseAlias
  = lens _lcLicenseAlias
      (\ s a -> s{_lcLicenseAlias = a})
      . _Default
      . _Coerce

-- | [Output Only] Description of this License Code.
lcDescription :: Lens' LicenseCode (Maybe Text)
lcDescription
  = lens _lcDescription
      (\ s a -> s{_lcDescription = a})

instance FromJSON LicenseCode where
        parseJSON
          = withObject "LicenseCode"
              (\ o ->
                 LicenseCode' <$>
                   (o .:? "state") <*>
                     (o .:? "kind" .!= "compute#licenseCode")
                     <*> (o .:? "transferable")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "licenseAlias" .!= mempty)
                     <*> (o .:? "description"))

instance ToJSON LicenseCode where
        toJSON LicenseCode'{..}
          = object
              (catMaybes
                 [("state" .=) <$> _lcState, Just ("kind" .= _lcKind),
                  ("transferable" .=) <$> _lcTransferable,
                  ("selfLink" .=) <$> _lcSelfLink,
                  ("name" .=) <$> _lcName,
                  ("creationTimestamp" .=) <$> _lcCreationTimestamp,
                  ("id" .=) <$> _lcId,
                  ("licenseAlias" .=) <$> _lcLicenseAlias,
                  ("description" .=) <$> _lcDescription])

--
-- /See:/ 'testFailure' smart constructor.
data TestFailure =
  TestFailure'
    { _tfExpectedOutputURL :: !(Maybe Text)
    , _tfExpectedRedirectResponseCode :: !(Maybe (Textual Int32))
    , _tfPath :: !(Maybe Text)
    , _tfExpectedService :: !(Maybe Text)
    , _tfHeaders :: !(Maybe [URLMapTestHeader])
    , _tfActualOutputURL :: !(Maybe Text)
    , _tfActualRedirectResponseCode :: !(Maybe (Textual Int32))
    , _tfHost :: !(Maybe Text)
    , _tfActualService :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TestFailure' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tfExpectedOutputURL'
--
-- * 'tfExpectedRedirectResponseCode'
--
-- * 'tfPath'
--
-- * 'tfExpectedService'
--
-- * 'tfHeaders'
--
-- * 'tfActualOutputURL'
--
-- * 'tfActualRedirectResponseCode'
--
-- * 'tfHost'
--
-- * 'tfActualService'
testFailure
    :: TestFailure
testFailure =
  TestFailure'
    { _tfExpectedOutputURL = Nothing
    , _tfExpectedRedirectResponseCode = Nothing
    , _tfPath = Nothing
    , _tfExpectedService = Nothing
    , _tfHeaders = Nothing
    , _tfActualOutputURL = Nothing
    , _tfActualRedirectResponseCode = Nothing
    , _tfHost = Nothing
    , _tfActualService = Nothing
    }


-- | The expected output URL evaluated by load balancer containing the
-- scheme, host, path and query parameters.
tfExpectedOutputURL :: Lens' TestFailure (Maybe Text)
tfExpectedOutputURL
  = lens _tfExpectedOutputURL
      (\ s a -> s{_tfExpectedOutputURL = a})

-- | Expected HTTP status code for rule with \`urlRedirect\` calculated by
-- load balancer
tfExpectedRedirectResponseCode :: Lens' TestFailure (Maybe Int32)
tfExpectedRedirectResponseCode
  = lens _tfExpectedRedirectResponseCode
      (\ s a -> s{_tfExpectedRedirectResponseCode = a})
      . mapping _Coerce

-- | Path portion including query parameters in the URL.
tfPath :: Lens' TestFailure (Maybe Text)
tfPath = lens _tfPath (\ s a -> s{_tfPath = a})

-- | Expected BackendService or BackendBucket resource the given URL should
-- be mapped to.
tfExpectedService :: Lens' TestFailure (Maybe Text)
tfExpectedService
  = lens _tfExpectedService
      (\ s a -> s{_tfExpectedService = a})

-- | HTTP headers of the request.
tfHeaders :: Lens' TestFailure [URLMapTestHeader]
tfHeaders
  = lens _tfHeaders (\ s a -> s{_tfHeaders = a}) .
      _Default
      . _Coerce

-- | The actual output URL evaluated by load balancer containing the scheme,
-- host, path and query parameters.
tfActualOutputURL :: Lens' TestFailure (Maybe Text)
tfActualOutputURL
  = lens _tfActualOutputURL
      (\ s a -> s{_tfActualOutputURL = a})

-- | Actual HTTP status code for rule with \`urlRedirect\` calculated by load
-- balancer
tfActualRedirectResponseCode :: Lens' TestFailure (Maybe Int32)
tfActualRedirectResponseCode
  = lens _tfActualRedirectResponseCode
      (\ s a -> s{_tfActualRedirectResponseCode = a})
      . mapping _Coerce

-- | Host portion of the URL.
tfHost :: Lens' TestFailure (Maybe Text)
tfHost = lens _tfHost (\ s a -> s{_tfHost = a})

-- | BackendService or BackendBucket returned by load balancer.
tfActualService :: Lens' TestFailure (Maybe Text)
tfActualService
  = lens _tfActualService
      (\ s a -> s{_tfActualService = a})

instance FromJSON TestFailure where
        parseJSON
          = withObject "TestFailure"
              (\ o ->
                 TestFailure' <$>
                   (o .:? "expectedOutputUrl") <*>
                     (o .:? "expectedRedirectResponseCode")
                     <*> (o .:? "path")
                     <*> (o .:? "expectedService")
                     <*> (o .:? "headers" .!= mempty)
                     <*> (o .:? "actualOutputUrl")
                     <*> (o .:? "actualRedirectResponseCode")
                     <*> (o .:? "host")
                     <*> (o .:? "actualService"))

instance ToJSON TestFailure where
        toJSON TestFailure'{..}
          = object
              (catMaybes
                 [("expectedOutputUrl" .=) <$> _tfExpectedOutputURL,
                  ("expectedRedirectResponseCode" .=) <$>
                    _tfExpectedRedirectResponseCode,
                  ("path" .=) <$> _tfPath,
                  ("expectedService" .=) <$> _tfExpectedService,
                  ("headers" .=) <$> _tfHeaders,
                  ("actualOutputUrl" .=) <$> _tfActualOutputURL,
                  ("actualRedirectResponseCode" .=) <$>
                    _tfActualRedirectResponseCode,
                  ("host" .=) <$> _tfHost,
                  ("actualService" .=) <$> _tfActualService])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'notificationEndpointListWarning' smart constructor.
data NotificationEndpointListWarning =
  NotificationEndpointListWarning'
    { _nelwData :: !(Maybe [NotificationEndpointListWarningDataItem])
    , _nelwCode :: !(Maybe NotificationEndpointListWarningCode)
    , _nelwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NotificationEndpointListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nelwData'
--
-- * 'nelwCode'
--
-- * 'nelwMessage'
notificationEndpointListWarning
    :: NotificationEndpointListWarning
notificationEndpointListWarning =
  NotificationEndpointListWarning'
    {_nelwData = Nothing, _nelwCode = Nothing, _nelwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
nelwData :: Lens' NotificationEndpointListWarning [NotificationEndpointListWarningDataItem]
nelwData
  = lens _nelwData (\ s a -> s{_nelwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
nelwCode :: Lens' NotificationEndpointListWarning (Maybe NotificationEndpointListWarningCode)
nelwCode = lens _nelwCode (\ s a -> s{_nelwCode = a})

-- | [Output Only] A human-readable description of the warning code.
nelwMessage :: Lens' NotificationEndpointListWarning (Maybe Text)
nelwMessage
  = lens _nelwMessage (\ s a -> s{_nelwMessage = a})

instance FromJSON NotificationEndpointListWarning
         where
        parseJSON
          = withObject "NotificationEndpointListWarning"
              (\ o ->
                 NotificationEndpointListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON NotificationEndpointListWarning where
        toJSON NotificationEndpointListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _nelwData,
                  ("code" .=) <$> _nelwCode,
                  ("message" .=) <$> _nelwMessage])

--
-- /See:/ 'commitmentListWarningDataItem' smart constructor.
data CommitmentListWarningDataItem =
  CommitmentListWarningDataItem'
    { _clwdiValue :: !(Maybe Text)
    , _clwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'CommitmentListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'clwdiValue'
--
-- * 'clwdiKey'
commitmentListWarningDataItem
    :: CommitmentListWarningDataItem
commitmentListWarningDataItem =
  CommitmentListWarningDataItem' {_clwdiValue = Nothing, _clwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
clwdiValue :: Lens' CommitmentListWarningDataItem (Maybe Text)
clwdiValue
  = lens _clwdiValue (\ s a -> s{_clwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
clwdiKey :: Lens' CommitmentListWarningDataItem (Maybe Text)
clwdiKey = lens _clwdiKey (\ s a -> s{_clwdiKey = a})

instance FromJSON CommitmentListWarningDataItem where
        parseJSON
          = withObject "CommitmentListWarningDataItem"
              (\ o ->
                 CommitmentListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON CommitmentListWarningDataItem where
        toJSON CommitmentListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _clwdiValue,
                  ("key" .=) <$> _clwdiKey])

--
-- /See:/ 'managedInstanceVersion' smart constructor.
data ManagedInstanceVersion =
  ManagedInstanceVersion'
    { _mivInstanceTemplate :: !(Maybe Text)
    , _mivName :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ManagedInstanceVersion' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'mivInstanceTemplate'
--
-- * 'mivName'
managedInstanceVersion
    :: ManagedInstanceVersion
managedInstanceVersion =
  ManagedInstanceVersion' {_mivInstanceTemplate = Nothing, _mivName = Nothing}


-- | [Output Only] The intended template of the instance. This field is empty
-- when current_action is one of { DELETING, ABANDONING }.
mivInstanceTemplate :: Lens' ManagedInstanceVersion (Maybe Text)
mivInstanceTemplate
  = lens _mivInstanceTemplate
      (\ s a -> s{_mivInstanceTemplate = a})

-- | [Output Only] Name of the version.
mivName :: Lens' ManagedInstanceVersion (Maybe Text)
mivName = lens _mivName (\ s a -> s{_mivName = a})

instance FromJSON ManagedInstanceVersion where
        parseJSON
          = withObject "ManagedInstanceVersion"
              (\ o ->
                 ManagedInstanceVersion' <$>
                   (o .:? "instanceTemplate") <*> (o .:? "name"))

instance ToJSON ManagedInstanceVersion where
        toJSON ManagedInstanceVersion'{..}
          = object
              (catMaybes
                 [("instanceTemplate" .=) <$> _mivInstanceTemplate,
                  ("name" .=) <$> _mivName])

-- | [Output Only] Informational warning which replaces the list of
-- commitments when the list is empty.
--
-- /See:/ 'commitmentsScopedListWarning' smart constructor.
data CommitmentsScopedListWarning =
  CommitmentsScopedListWarning'
    { _cslwData :: !(Maybe [CommitmentsScopedListWarningDataItem])
    , _cslwCode :: !(Maybe CommitmentsScopedListWarningCode)
    , _cslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'CommitmentsScopedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'cslwData'
--
-- * 'cslwCode'
--
-- * 'cslwMessage'
commitmentsScopedListWarning
    :: CommitmentsScopedListWarning
commitmentsScopedListWarning =
  CommitmentsScopedListWarning'
    {_cslwData = Nothing, _cslwCode = Nothing, _cslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
cslwData :: Lens' CommitmentsScopedListWarning [CommitmentsScopedListWarningDataItem]
cslwData
  = lens _cslwData (\ s a -> s{_cslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
cslwCode :: Lens' CommitmentsScopedListWarning (Maybe CommitmentsScopedListWarningCode)
cslwCode = lens _cslwCode (\ s a -> s{_cslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
cslwMessage :: Lens' CommitmentsScopedListWarning (Maybe Text)
cslwMessage
  = lens _cslwMessage (\ s a -> s{_cslwMessage = a})

instance FromJSON CommitmentsScopedListWarning where
        parseJSON
          = withObject "CommitmentsScopedListWarning"
              (\ o ->
                 CommitmentsScopedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON CommitmentsScopedListWarning where
        toJSON CommitmentsScopedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _cslwData,
                  ("code" .=) <$> _cslwCode,
                  ("message" .=) <$> _cslwMessage])

-- | An instance\'s serial console output.
--
-- /See:/ 'serialPortOutput' smart constructor.
data SerialPortOutput =
  SerialPortOutput'
    { _spoNext :: !(Maybe (Textual Int64))
    , _spoContents :: !(Maybe Text)
    , _spoKind :: !Text
    , _spoStart :: !(Maybe (Textual Int64))
    , _spoSelfLink :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SerialPortOutput' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'spoNext'
--
-- * 'spoContents'
--
-- * 'spoKind'
--
-- * 'spoStart'
--
-- * 'spoSelfLink'
serialPortOutput
    :: SerialPortOutput
serialPortOutput =
  SerialPortOutput'
    { _spoNext = Nothing
    , _spoContents = Nothing
    , _spoKind = "compute#serialPortOutput"
    , _spoStart = Nothing
    , _spoSelfLink = Nothing
    }


-- | [Output Only] The position of the next byte of content, regardless of
-- whether the content exists, following the output returned in the
-- \`contents\` property. Use this value in the next request as the start
-- parameter.
spoNext :: Lens' SerialPortOutput (Maybe Int64)
spoNext
  = lens _spoNext (\ s a -> s{_spoNext = a}) .
      mapping _Coerce

-- | [Output Only] The contents of the console output.
spoContents :: Lens' SerialPortOutput (Maybe Text)
spoContents
  = lens _spoContents (\ s a -> s{_spoContents = a})

-- | [Output Only] Type of the resource. Always compute#serialPortOutput for
-- serial port output.
spoKind :: Lens' SerialPortOutput Text
spoKind = lens _spoKind (\ s a -> s{_spoKind = a})

-- | The starting byte position of the output that was returned. This should
-- match the start parameter sent with the request. If the serial console
-- output exceeds the size of the buffer (1 MB), older output is
-- overwritten by newer content. The output start value will indicate the
-- byte position of the output that was returned, which might be different
-- than the \`start\` value that was specified in the request.
spoStart :: Lens' SerialPortOutput (Maybe Int64)
spoStart
  = lens _spoStart (\ s a -> s{_spoStart = a}) .
      mapping _Coerce

-- | [Output Only] Server-defined URL for this resource.
spoSelfLink :: Lens' SerialPortOutput (Maybe Text)
spoSelfLink
  = lens _spoSelfLink (\ s a -> s{_spoSelfLink = a})

instance FromJSON SerialPortOutput where
        parseJSON
          = withObject "SerialPortOutput"
              (\ o ->
                 SerialPortOutput' <$>
                   (o .:? "next") <*> (o .:? "contents") <*>
                     (o .:? "kind" .!= "compute#serialPortOutput")
                     <*> (o .:? "start")
                     <*> (o .:? "selfLink"))

instance ToJSON SerialPortOutput where
        toJSON SerialPortOutput'{..}
          = object
              (catMaybes
                 [("next" .=) <$> _spoNext,
                  ("contents" .=) <$> _spoContents,
                  Just ("kind" .= _spoKind),
                  ("start" .=) <$> _spoStart,
                  ("selfLink" .=) <$> _spoSelfLink])

--
-- /See:/ 'instanceGroupManagerStatusStatefulPerInstanceConfigs' smart constructor.
newtype InstanceGroupManagerStatusStatefulPerInstanceConfigs =
  InstanceGroupManagerStatusStatefulPerInstanceConfigs'
    { _igmsspicAllEffective :: Maybe Bool
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagerStatusStatefulPerInstanceConfigs' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmsspicAllEffective'
instanceGroupManagerStatusStatefulPerInstanceConfigs
    :: InstanceGroupManagerStatusStatefulPerInstanceConfigs
instanceGroupManagerStatusStatefulPerInstanceConfigs =
  InstanceGroupManagerStatusStatefulPerInstanceConfigs'
    {_igmsspicAllEffective = Nothing}


-- | A bit indicating if all of the group\'s per-instance configs (listed in
-- the output of a listPerInstanceConfigs API call) have status EFFECTIVE
-- or there are no per-instance-configs.
igmsspicAllEffective :: Lens' InstanceGroupManagerStatusStatefulPerInstanceConfigs (Maybe Bool)
igmsspicAllEffective
  = lens _igmsspicAllEffective
      (\ s a -> s{_igmsspicAllEffective = a})

instance FromJSON
           InstanceGroupManagerStatusStatefulPerInstanceConfigs
         where
        parseJSON
          = withObject
              "InstanceGroupManagerStatusStatefulPerInstanceConfigs"
              (\ o ->
                 InstanceGroupManagerStatusStatefulPerInstanceConfigs'
                   <$> (o .:? "allEffective"))

instance ToJSON
           InstanceGroupManagerStatusStatefulPerInstanceConfigs
         where
        toJSON
          InstanceGroupManagerStatusStatefulPerInstanceConfigs'{..}
          = object
              (catMaybes
                 [("allEffective" .=) <$> _igmsspicAllEffective])

-- | Preserved metadata defined for this instance.
--
-- /See:/ 'preservedStateMetadata' smart constructor.
newtype PreservedStateMetadata =
  PreservedStateMetadata'
    { _psmAddtional :: HashMap Text Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PreservedStateMetadata' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'psmAddtional'
preservedStateMetadata
    :: HashMap Text Text -- ^ 'psmAddtional'
    -> PreservedStateMetadata
preservedStateMetadata pPsmAddtional_ =
  PreservedStateMetadata' {_psmAddtional = _Coerce # pPsmAddtional_}


psmAddtional :: Lens' PreservedStateMetadata (HashMap Text Text)
psmAddtional
  = lens _psmAddtional (\ s a -> s{_psmAddtional = a})
      . _Coerce

instance FromJSON PreservedStateMetadata where
        parseJSON
          = withObject "PreservedStateMetadata"
              (\ o ->
                 PreservedStateMetadata' <$> (parseJSONObject o))

instance ToJSON PreservedStateMetadata where
        toJSON = toJSON . _psmAddtional

--
-- /See:/ 'targetVPNGatewayAggregatedList' smart constructor.
data TargetVPNGatewayAggregatedList =
  TargetVPNGatewayAggregatedList'
    { _tvgalUnreachables :: !(Maybe [Text])
    , _tvgalNextPageToken :: !(Maybe Text)
    , _tvgalKind :: !Text
    , _tvgalItems :: !(Maybe TargetVPNGatewayAggregatedListItems)
    , _tvgalSelfLink :: !(Maybe Text)
    , _tvgalWarning :: !(Maybe TargetVPNGatewayAggregatedListWarning)
    , _tvgalId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetVPNGatewayAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tvgalUnreachables'
--
-- * 'tvgalNextPageToken'
--
-- * 'tvgalKind'
--
-- * 'tvgalItems'
--
-- * 'tvgalSelfLink'
--
-- * 'tvgalWarning'
--
-- * 'tvgalId'
targetVPNGatewayAggregatedList
    :: TargetVPNGatewayAggregatedList
targetVPNGatewayAggregatedList =
  TargetVPNGatewayAggregatedList'
    { _tvgalUnreachables = Nothing
    , _tvgalNextPageToken = Nothing
    , _tvgalKind = "compute#targetVpnGatewayAggregatedList"
    , _tvgalItems = Nothing
    , _tvgalSelfLink = Nothing
    , _tvgalWarning = Nothing
    , _tvgalId = Nothing
    }


-- | [Output Only] Unreachable resources.
tvgalUnreachables :: Lens' TargetVPNGatewayAggregatedList [Text]
tvgalUnreachables
  = lens _tvgalUnreachables
      (\ s a -> s{_tvgalUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
tvgalNextPageToken :: Lens' TargetVPNGatewayAggregatedList (Maybe Text)
tvgalNextPageToken
  = lens _tvgalNextPageToken
      (\ s a -> s{_tvgalNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#targetVpnGateway for
-- target VPN gateways.
tvgalKind :: Lens' TargetVPNGatewayAggregatedList Text
tvgalKind
  = lens _tvgalKind (\ s a -> s{_tvgalKind = a})

-- | A list of TargetVpnGateway resources.
tvgalItems :: Lens' TargetVPNGatewayAggregatedList (Maybe TargetVPNGatewayAggregatedListItems)
tvgalItems
  = lens _tvgalItems (\ s a -> s{_tvgalItems = a})

-- | [Output Only] Server-defined URL for this resource.
tvgalSelfLink :: Lens' TargetVPNGatewayAggregatedList (Maybe Text)
tvgalSelfLink
  = lens _tvgalSelfLink
      (\ s a -> s{_tvgalSelfLink = a})

-- | [Output Only] Informational warning message.
tvgalWarning :: Lens' TargetVPNGatewayAggregatedList (Maybe TargetVPNGatewayAggregatedListWarning)
tvgalWarning
  = lens _tvgalWarning (\ s a -> s{_tvgalWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
tvgalId :: Lens' TargetVPNGatewayAggregatedList (Maybe Text)
tvgalId = lens _tvgalId (\ s a -> s{_tvgalId = a})

instance FromJSON TargetVPNGatewayAggregatedList
         where
        parseJSON
          = withObject "TargetVPNGatewayAggregatedList"
              (\ o ->
                 TargetVPNGatewayAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!=
                        "compute#targetVpnGatewayAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON TargetVPNGatewayAggregatedList where
        toJSON TargetVPNGatewayAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _tvgalUnreachables,
                  ("nextPageToken" .=) <$> _tvgalNextPageToken,
                  Just ("kind" .= _tvgalKind),
                  ("items" .=) <$> _tvgalItems,
                  ("selfLink" .=) <$> _tvgalSelfLink,
                  ("warning" .=) <$> _tvgalWarning,
                  ("id" .=) <$> _tvgalId])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'interconnectAttachmentAggregatedListWarning' smart constructor.
data InterconnectAttachmentAggregatedListWarning =
  InterconnectAttachmentAggregatedListWarning'
    { _iaalwData :: !(Maybe [InterconnectAttachmentAggregatedListWarningDataItem])
    , _iaalwCode :: !(Maybe InterconnectAttachmentAggregatedListWarningCode)
    , _iaalwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectAttachmentAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iaalwData'
--
-- * 'iaalwCode'
--
-- * 'iaalwMessage'
interconnectAttachmentAggregatedListWarning
    :: InterconnectAttachmentAggregatedListWarning
interconnectAttachmentAggregatedListWarning =
  InterconnectAttachmentAggregatedListWarning'
    {_iaalwData = Nothing, _iaalwCode = Nothing, _iaalwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
iaalwData :: Lens' InterconnectAttachmentAggregatedListWarning [InterconnectAttachmentAggregatedListWarningDataItem]
iaalwData
  = lens _iaalwData (\ s a -> s{_iaalwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
iaalwCode :: Lens' InterconnectAttachmentAggregatedListWarning (Maybe InterconnectAttachmentAggregatedListWarningCode)
iaalwCode
  = lens _iaalwCode (\ s a -> s{_iaalwCode = a})

-- | [Output Only] A human-readable description of the warning code.
iaalwMessage :: Lens' InterconnectAttachmentAggregatedListWarning (Maybe Text)
iaalwMessage
  = lens _iaalwMessage (\ s a -> s{_iaalwMessage = a})

instance FromJSON
           InterconnectAttachmentAggregatedListWarning
         where
        parseJSON
          = withObject
              "InterconnectAttachmentAggregatedListWarning"
              (\ o ->
                 InterconnectAttachmentAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON
           InterconnectAttachmentAggregatedListWarning
         where
        toJSON
          InterconnectAttachmentAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _iaalwData,
                  ("code" .=) <$> _iaalwCode,
                  ("message" .=) <$> _iaalwMessage])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'firewallPolicyListWarning' smart constructor.
data FirewallPolicyListWarning =
  FirewallPolicyListWarning'
    { _fplwData :: !(Maybe [FirewallPolicyListWarningDataItem])
    , _fplwCode :: !(Maybe FirewallPolicyListWarningCode)
    , _fplwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'FirewallPolicyListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'fplwData'
--
-- * 'fplwCode'
--
-- * 'fplwMessage'
firewallPolicyListWarning
    :: FirewallPolicyListWarning
firewallPolicyListWarning =
  FirewallPolicyListWarning'
    {_fplwData = Nothing, _fplwCode = Nothing, _fplwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
fplwData :: Lens' FirewallPolicyListWarning [FirewallPolicyListWarningDataItem]
fplwData
  = lens _fplwData (\ s a -> s{_fplwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
fplwCode :: Lens' FirewallPolicyListWarning (Maybe FirewallPolicyListWarningCode)
fplwCode = lens _fplwCode (\ s a -> s{_fplwCode = a})

-- | [Output Only] A human-readable description of the warning code.
fplwMessage :: Lens' FirewallPolicyListWarning (Maybe Text)
fplwMessage
  = lens _fplwMessage (\ s a -> s{_fplwMessage = a})

instance FromJSON FirewallPolicyListWarning where
        parseJSON
          = withObject "FirewallPolicyListWarning"
              (\ o ->
                 FirewallPolicyListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON FirewallPolicyListWarning where
        toJSON FirewallPolicyListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _fplwData,
                  ("code" .=) <$> _fplwCode,
                  ("message" .=) <$> _fplwMessage])

--
-- /See:/ 'metadataItemsItem' smart constructor.
data MetadataItemsItem =
  MetadataItemsItem'
    { _miiValue :: !(Maybe Text)
    , _miiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'MetadataItemsItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'miiValue'
--
-- * 'miiKey'
metadataItemsItem
    :: MetadataItemsItem
metadataItemsItem = MetadataItemsItem' {_miiValue = Nothing, _miiKey = Nothing}


-- | Value for the metadata entry. These are free-form strings, and only have
-- meaning as interpreted by the image running in the instance. The only
-- restriction placed on values is that their size must be less than or
-- equal to 262144 bytes (256 KiB).
miiValue :: Lens' MetadataItemsItem (Maybe Text)
miiValue = lens _miiValue (\ s a -> s{_miiValue = a})

-- | Key for the metadata entry. Keys must conform to the following regexp:
-- [a-zA-Z0-9-_]+, and be less than 128 bytes in length. This is reflected
-- as part of a URL in the metadata server. Additionally, to avoid
-- ambiguity, keys must not conflict with any other metadata keys for the
-- project.
miiKey :: Lens' MetadataItemsItem (Maybe Text)
miiKey = lens _miiKey (\ s a -> s{_miiKey = a})

instance FromJSON MetadataItemsItem where
        parseJSON
          = withObject "MetadataItemsItem"
              (\ o ->
                 MetadataItemsItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON MetadataItemsItem where
        toJSON MetadataItemsItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _miiValue, ("key" .=) <$> _miiKey])

--
-- /See:/ 'instancesAddResourcePoliciesRequest' smart constructor.
newtype InstancesAddResourcePoliciesRequest =
  InstancesAddResourcePoliciesRequest'
    { _iarprResourcePolicies :: Maybe [Text]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstancesAddResourcePoliciesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iarprResourcePolicies'
instancesAddResourcePoliciesRequest
    :: InstancesAddResourcePoliciesRequest
instancesAddResourcePoliciesRequest =
  InstancesAddResourcePoliciesRequest' {_iarprResourcePolicies = Nothing}


-- | Resource policies to be added to this instance.
iarprResourcePolicies :: Lens' InstancesAddResourcePoliciesRequest [Text]
iarprResourcePolicies
  = lens _iarprResourcePolicies
      (\ s a -> s{_iarprResourcePolicies = a})
      . _Default
      . _Coerce

instance FromJSON InstancesAddResourcePoliciesRequest
         where
        parseJSON
          = withObject "InstancesAddResourcePoliciesRequest"
              (\ o ->
                 InstancesAddResourcePoliciesRequest' <$>
                   (o .:? "resourcePolicies" .!= mempty))

instance ToJSON InstancesAddResourcePoliciesRequest
         where
        toJSON InstancesAddResourcePoliciesRequest'{..}
          = object
              (catMaybes
                 [("resourcePolicies" .=) <$> _iarprResourcePolicies])

-- | Represents a customer-supplied Signing Key used by Cloud CDN Signed URLs
--
-- /See:/ 'signedURLKey' smart constructor.
data SignedURLKey =
  SignedURLKey'
    { _sukKeyValue :: !(Maybe Text)
    , _sukKeyName :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SignedURLKey' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'sukKeyValue'
--
-- * 'sukKeyName'
signedURLKey
    :: SignedURLKey
signedURLKey = SignedURLKey' {_sukKeyValue = Nothing, _sukKeyName = Nothing}


-- | 128-bit key value used for signing the URL. The key value must be a
-- valid RFC 4648 Section 5 base64url encoded string.
sukKeyValue :: Lens' SignedURLKey (Maybe Text)
sukKeyValue
  = lens _sukKeyValue (\ s a -> s{_sukKeyValue = a})

-- | Name of the key. The name must be 1-63 characters long, and comply with
-- RFC1035. Specifically, the name must be 1-63 characters long and match
-- the regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the
-- first character must be a lowercase letter, and all following characters
-- must be a dash, lowercase letter, or digit, except the last character,
-- which cannot be a dash.
sukKeyName :: Lens' SignedURLKey (Maybe Text)
sukKeyName
  = lens _sukKeyName (\ s a -> s{_sukKeyName = a})

instance FromJSON SignedURLKey where
        parseJSON
          = withObject "SignedURLKey"
              (\ o ->
                 SignedURLKey' <$>
                   (o .:? "keyValue") <*> (o .:? "keyName"))

instance ToJSON SignedURLKey where
        toJSON SignedURLKey'{..}
          = object
              (catMaybes
                 [("keyValue" .=) <$> _sukKeyValue,
                  ("keyName" .=) <$> _sukKeyName])

-- | Represents a Target HTTPS Proxy resource. Google Compute Engine has two
-- Target HTTPS Proxy resources: *
-- [Global](\/compute\/docs\/reference\/rest\/{$api_version}\/targetHttpsProxies)
-- *
-- [Regional](\/compute\/docs\/reference\/rest\/{$api_version}\/regionTargetHttpsProxies)
-- A target HTTPS proxy is a component of GCP HTTPS load balancers. *
-- targetHttpsProxies are used by external HTTPS load balancers. *
-- regionTargetHttpsProxies are used by internal HTTPS load balancers.
-- Forwarding rules reference a target HTTPS proxy, and the target proxy
-- then references a URL map. For more information, read Using Target
-- Proxies and Forwarding rule concepts. (== resource_for
-- {$api_version}.targetHttpsProxies ==) (== resource_for
-- {$api_version}.regionTargetHttpsProxies ==)
--
-- /See:/ 'targetHTTPSProxy' smart constructor.
data TargetHTTPSProxy =
  TargetHTTPSProxy'
    { _thpSSLPolicy :: !(Maybe Text)
    , _thpURLMap :: !(Maybe Text)
    , _thpSSLCertificates :: !(Maybe [Text])
    , _thpQuicOverride :: !(Maybe TargetHTTPSProxyQuicOverride)
    , _thpProxyBind :: !(Maybe Bool)
    , _thpKind :: !Text
    , _thpFingerprint :: !(Maybe Bytes)
    , _thpServerTLSPolicy :: !(Maybe Text)
    , _thpSelfLink :: !(Maybe Text)
    , _thpName :: !(Maybe Text)
    , _thpCreationTimestamp :: !(Maybe Text)
    , _thpId :: !(Maybe (Textual Word64))
    , _thpRegion :: !(Maybe Text)
    , _thpAuthorizationPolicy :: !(Maybe Text)
    , _thpDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetHTTPSProxy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'thpSSLPolicy'
--
-- * 'thpURLMap'
--
-- * 'thpSSLCertificates'
--
-- * 'thpQuicOverride'
--
-- * 'thpProxyBind'
--
-- * 'thpKind'
--
-- * 'thpFingerprint'
--
-- * 'thpServerTLSPolicy'
--
-- * 'thpSelfLink'
--
-- * 'thpName'
--
-- * 'thpCreationTimestamp'
--
-- * 'thpId'
--
-- * 'thpRegion'
--
-- * 'thpAuthorizationPolicy'
--
-- * 'thpDescription'
targetHTTPSProxy
    :: TargetHTTPSProxy
targetHTTPSProxy =
  TargetHTTPSProxy'
    { _thpSSLPolicy = Nothing
    , _thpURLMap = Nothing
    , _thpSSLCertificates = Nothing
    , _thpQuicOverride = Nothing
    , _thpProxyBind = Nothing
    , _thpKind = "compute#targetHttpsProxy"
    , _thpFingerprint = Nothing
    , _thpServerTLSPolicy = Nothing
    , _thpSelfLink = Nothing
    , _thpName = Nothing
    , _thpCreationTimestamp = Nothing
    , _thpId = Nothing
    , _thpRegion = Nothing
    , _thpAuthorizationPolicy = Nothing
    , _thpDescription = Nothing
    }


-- | URL of SslPolicy resource that will be associated with the
-- TargetHttpsProxy resource. If not set, the TargetHttpsProxy resource has
-- no SSL policy configured.
thpSSLPolicy :: Lens' TargetHTTPSProxy (Maybe Text)
thpSSLPolicy
  = lens _thpSSLPolicy (\ s a -> s{_thpSSLPolicy = a})

-- | A fully-qualified or valid partial URL to the UrlMap resource that
-- defines the mapping from URL to the BackendService. For example, the
-- following are all valid URLs for specifying a URL map: -
-- https:\/\/www.googleapis.compute\/v1\/projects\/project\/global\/urlMaps\/url-map
-- - projects\/project\/global\/urlMaps\/url-map - global\/urlMaps\/url-map
thpURLMap :: Lens' TargetHTTPSProxy (Maybe Text)
thpURLMap
  = lens _thpURLMap (\ s a -> s{_thpURLMap = a})

-- | URLs to SslCertificate resources that are used to authenticate
-- connections between users and the load balancer. At least one SSL
-- certificate must be specified. Currently, you may specify up to 15 SSL
-- certificates. sslCertificates do not apply when the load balancing
-- scheme is set to INTERNAL_SELF_MANAGED.
thpSSLCertificates :: Lens' TargetHTTPSProxy [Text]
thpSSLCertificates
  = lens _thpSSLCertificates
      (\ s a -> s{_thpSSLCertificates = a})
      . _Default
      . _Coerce

-- | Specifies the QUIC override policy for this TargetHttpsProxy resource.
-- This setting determines whether the load balancer attempts to negotiate
-- QUIC with clients. You can specify NONE, ENABLE, or DISABLE. - When
-- quic-override is set to NONE, Google manages whether QUIC is used. -
-- When quic-override is set to ENABLE, the load balancer uses QUIC when
-- possible. - When quic-override is set to DISABLE, the load balancer
-- doesn\'t use QUIC. - If the quic-override flag is not specified, NONE is
-- implied.
thpQuicOverride :: Lens' TargetHTTPSProxy (Maybe TargetHTTPSProxyQuicOverride)
thpQuicOverride
  = lens _thpQuicOverride
      (\ s a -> s{_thpQuicOverride = a})

-- | This field only applies when the forwarding rule that references this
-- target proxy has a loadBalancingScheme set to INTERNAL_SELF_MANAGED.
-- When this field is set to true, Envoy proxies set up inbound traffic
-- interception and bind to the IP address and port specified in the
-- forwarding rule. This is generally useful when using Traffic Director to
-- configure Envoy as a gateway or middle proxy (in other words, not a
-- sidecar proxy). The Envoy proxy listens for inbound requests and handles
-- requests when it receives them. The default is false.
thpProxyBind :: Lens' TargetHTTPSProxy (Maybe Bool)
thpProxyBind
  = lens _thpProxyBind (\ s a -> s{_thpProxyBind = a})

-- | [Output Only] Type of resource. Always compute#targetHttpsProxy for
-- target HTTPS proxies.
thpKind :: Lens' TargetHTTPSProxy Text
thpKind = lens _thpKind (\ s a -> s{_thpKind = a})

-- | Fingerprint of this resource. A hash of the contents stored in this
-- object. This field is used in optimistic locking. This field will be
-- ignored when inserting a TargetHttpsProxy. An up-to-date fingerprint
-- must be provided in order to patch the TargetHttpsProxy; otherwise, the
-- request will fail with error 412 conditionNotMet. To see the latest
-- fingerprint, make a get() request to retrieve the TargetHttpsProxy.
thpFingerprint :: Lens' TargetHTTPSProxy (Maybe ByteString)
thpFingerprint
  = lens _thpFingerprint
      (\ s a -> s{_thpFingerprint = a})
      . mapping _Bytes

-- | Optional. A URL referring to a networksecurity.ServerTlsPolicy resource
-- that describes how the proxy should authenticate inbound traffic.
-- serverTlsPolicy only applies to a global TargetHttpsProxy attached to
-- globalForwardingRules with the loadBalancingScheme set to
-- INTERNAL_SELF_MANAGED. If left blank, communications are not encrypted.
-- Note: This field currently has no impact.
thpServerTLSPolicy :: Lens' TargetHTTPSProxy (Maybe Text)
thpServerTLSPolicy
  = lens _thpServerTLSPolicy
      (\ s a -> s{_thpServerTLSPolicy = a})

-- | [Output Only] Server-defined URL for the resource.
thpSelfLink :: Lens' TargetHTTPSProxy (Maybe Text)
thpSelfLink
  = lens _thpSelfLink (\ s a -> s{_thpSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
thpName :: Lens' TargetHTTPSProxy (Maybe Text)
thpName = lens _thpName (\ s a -> s{_thpName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
thpCreationTimestamp :: Lens' TargetHTTPSProxy (Maybe Text)
thpCreationTimestamp
  = lens _thpCreationTimestamp
      (\ s a -> s{_thpCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
thpId :: Lens' TargetHTTPSProxy (Maybe Word64)
thpId
  = lens _thpId (\ s a -> s{_thpId = a}) .
      mapping _Coerce

-- | [Output Only] URL of the region where the regional TargetHttpsProxy
-- resides. This field is not applicable to global TargetHttpsProxies.
thpRegion :: Lens' TargetHTTPSProxy (Maybe Text)
thpRegion
  = lens _thpRegion (\ s a -> s{_thpRegion = a})

-- | Optional. A URL referring to a networksecurity.AuthorizationPolicy
-- resource that describes how the proxy should authorize inbound traffic.
-- If left blank, access will not be restricted by an authorization policy.
-- Refer to the AuthorizationPolicy resource for additional details.
-- authorizationPolicy only applies to a global TargetHttpsProxy attached
-- to globalForwardingRules with the loadBalancingScheme set to
-- INTERNAL_SELF_MANAGED. Note: This field currently has no impact.
thpAuthorizationPolicy :: Lens' TargetHTTPSProxy (Maybe Text)
thpAuthorizationPolicy
  = lens _thpAuthorizationPolicy
      (\ s a -> s{_thpAuthorizationPolicy = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource.
thpDescription :: Lens' TargetHTTPSProxy (Maybe Text)
thpDescription
  = lens _thpDescription
      (\ s a -> s{_thpDescription = a})

instance FromJSON TargetHTTPSProxy where
        parseJSON
          = withObject "TargetHTTPSProxy"
              (\ o ->
                 TargetHTTPSProxy' <$>
                   (o .:? "sslPolicy") <*> (o .:? "urlMap") <*>
                     (o .:? "sslCertificates" .!= mempty)
                     <*> (o .:? "quicOverride")
                     <*> (o .:? "proxyBind")
                     <*> (o .:? "kind" .!= "compute#targetHttpsProxy")
                     <*> (o .:? "fingerprint")
                     <*> (o .:? "serverTlsPolicy")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "region")
                     <*> (o .:? "authorizationPolicy")
                     <*> (o .:? "description"))

instance ToJSON TargetHTTPSProxy where
        toJSON TargetHTTPSProxy'{..}
          = object
              (catMaybes
                 [("sslPolicy" .=) <$> _thpSSLPolicy,
                  ("urlMap" .=) <$> _thpURLMap,
                  ("sslCertificates" .=) <$> _thpSSLCertificates,
                  ("quicOverride" .=) <$> _thpQuicOverride,
                  ("proxyBind" .=) <$> _thpProxyBind,
                  Just ("kind" .= _thpKind),
                  ("fingerprint" .=) <$> _thpFingerprint,
                  ("serverTlsPolicy" .=) <$> _thpServerTLSPolicy,
                  ("selfLink" .=) <$> _thpSelfLink,
                  ("name" .=) <$> _thpName,
                  ("creationTimestamp" .=) <$> _thpCreationTimestamp,
                  ("id" .=) <$> _thpId, ("region" .=) <$> _thpRegion,
                  ("authorizationPolicy" .=) <$>
                    _thpAuthorizationPolicy,
                  ("description" .=) <$> _thpDescription])

-- | Message containing connection draining configuration.
--
-- /See:/ 'connectionDraining' smart constructor.
newtype ConnectionDraining =
  ConnectionDraining'
    { _cdDrainingTimeoutSec :: Maybe (Textual Int32)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ConnectionDraining' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'cdDrainingTimeoutSec'
connectionDraining
    :: ConnectionDraining
connectionDraining = ConnectionDraining' {_cdDrainingTimeoutSec = Nothing}


-- | Configures a duration timeout for existing requests on a removed backend
-- instance. For supported load balancers and protocols, as described in
-- Enabling connection draining.
cdDrainingTimeoutSec :: Lens' ConnectionDraining (Maybe Int32)
cdDrainingTimeoutSec
  = lens _cdDrainingTimeoutSec
      (\ s a -> s{_cdDrainingTimeoutSec = a})
      . mapping _Coerce

instance FromJSON ConnectionDraining where
        parseJSON
          = withObject "ConnectionDraining"
              (\ o ->
                 ConnectionDraining' <$> (o .:? "drainingTimeoutSec"))

instance ToJSON ConnectionDraining where
        toJSON ConnectionDraining'{..}
          = object
              (catMaybes
                 [("drainingTimeoutSec" .=) <$>
                    _cdDrainingTimeoutSec])

-- | An InstanceSchedulePolicy specifies when and how frequent certain
-- operations are performed on the instance.
--
-- /See:/ 'resourcePolicyInstanceSchedulePolicy' smart constructor.
data ResourcePolicyInstanceSchedulePolicy =
  ResourcePolicyInstanceSchedulePolicy'
    { _rpispStartTime :: !(Maybe Text)
    , _rpispVMStartSchedule :: !(Maybe ResourcePolicyInstanceSchedulePolicySchedule)
    , _rpispVMStopSchedule :: !(Maybe ResourcePolicyInstanceSchedulePolicySchedule)
    , _rpispTimeZone :: !(Maybe Text)
    , _rpispExpirationTime :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ResourcePolicyInstanceSchedulePolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rpispStartTime'
--
-- * 'rpispVMStartSchedule'
--
-- * 'rpispVMStopSchedule'
--
-- * 'rpispTimeZone'
--
-- * 'rpispExpirationTime'
resourcePolicyInstanceSchedulePolicy
    :: ResourcePolicyInstanceSchedulePolicy
resourcePolicyInstanceSchedulePolicy =
  ResourcePolicyInstanceSchedulePolicy'
    { _rpispStartTime = Nothing
    , _rpispVMStartSchedule = Nothing
    , _rpispVMStopSchedule = Nothing
    , _rpispTimeZone = Nothing
    , _rpispExpirationTime = Nothing
    }


-- | The start time of the schedule. The timestamp is an RFC3339 string.
rpispStartTime :: Lens' ResourcePolicyInstanceSchedulePolicy (Maybe Text)
rpispStartTime
  = lens _rpispStartTime
      (\ s a -> s{_rpispStartTime = a})

-- | Specifies the schedule for starting instances.
rpispVMStartSchedule :: Lens' ResourcePolicyInstanceSchedulePolicy (Maybe ResourcePolicyInstanceSchedulePolicySchedule)
rpispVMStartSchedule
  = lens _rpispVMStartSchedule
      (\ s a -> s{_rpispVMStartSchedule = a})

-- | Specifies the schedule for stopping instances.
rpispVMStopSchedule :: Lens' ResourcePolicyInstanceSchedulePolicy (Maybe ResourcePolicyInstanceSchedulePolicySchedule)
rpispVMStopSchedule
  = lens _rpispVMStopSchedule
      (\ s a -> s{_rpispVMStopSchedule = a})

-- | Specifies the time zone to be used in interpreting Schedule.schedule.
-- The value of this field must be a time zone name from the tz database:
-- http:\/\/en.wikipedia.org\/wiki\/Tz_database.
rpispTimeZone :: Lens' ResourcePolicyInstanceSchedulePolicy (Maybe Text)
rpispTimeZone
  = lens _rpispTimeZone
      (\ s a -> s{_rpispTimeZone = a})

-- | The expiration time of the schedule. The timestamp is an RFC3339 string.
rpispExpirationTime :: Lens' ResourcePolicyInstanceSchedulePolicy (Maybe Text)
rpispExpirationTime
  = lens _rpispExpirationTime
      (\ s a -> s{_rpispExpirationTime = a})

instance FromJSON
           ResourcePolicyInstanceSchedulePolicy
         where
        parseJSON
          = withObject "ResourcePolicyInstanceSchedulePolicy"
              (\ o ->
                 ResourcePolicyInstanceSchedulePolicy' <$>
                   (o .:? "startTime") <*> (o .:? "vmStartSchedule") <*>
                     (o .:? "vmStopSchedule")
                     <*> (o .:? "timeZone")
                     <*> (o .:? "expirationTime"))

instance ToJSON ResourcePolicyInstanceSchedulePolicy
         where
        toJSON ResourcePolicyInstanceSchedulePolicy'{..}
          = object
              (catMaybes
                 [("startTime" .=) <$> _rpispStartTime,
                  ("vmStartSchedule" .=) <$> _rpispVMStartSchedule,
                  ("vmStopSchedule" .=) <$> _rpispVMStopSchedule,
                  ("timeZone" .=) <$> _rpispTimeZone,
                  ("expirationTime" .=) <$> _rpispExpirationTime])

-- | HTTP headers used in UrlMapTests.
--
-- /See:/ 'urlMapTestHeader' smart constructor.
data URLMapTestHeader =
  URLMapTestHeader'
    { _umthValue :: !(Maybe Text)
    , _umthName :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'URLMapTestHeader' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'umthValue'
--
-- * 'umthName'
urlMapTestHeader
    :: URLMapTestHeader
urlMapTestHeader = URLMapTestHeader' {_umthValue = Nothing, _umthName = Nothing}


-- | Header value.
umthValue :: Lens' URLMapTestHeader (Maybe Text)
umthValue
  = lens _umthValue (\ s a -> s{_umthValue = a})

-- | Header name.
umthName :: Lens' URLMapTestHeader (Maybe Text)
umthName = lens _umthName (\ s a -> s{_umthName = a})

instance FromJSON URLMapTestHeader where
        parseJSON
          = withObject "URLMapTestHeader"
              (\ o ->
                 URLMapTestHeader' <$>
                   (o .:? "value") <*> (o .:? "name"))

instance ToJSON URLMapTestHeader where
        toJSON URLMapTestHeader'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _umthValue,
                  ("name" .=) <$> _umthName])

--
-- /See:/ 'interconnectAttachmentListWarningDataItem' smart constructor.
data InterconnectAttachmentListWarningDataItem =
  InterconnectAttachmentListWarningDataItem'
    { _ialwdiValue :: !(Maybe Text)
    , _ialwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectAttachmentListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ialwdiValue'
--
-- * 'ialwdiKey'
interconnectAttachmentListWarningDataItem
    :: InterconnectAttachmentListWarningDataItem
interconnectAttachmentListWarningDataItem =
  InterconnectAttachmentListWarningDataItem'
    {_ialwdiValue = Nothing, _ialwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
ialwdiValue :: Lens' InterconnectAttachmentListWarningDataItem (Maybe Text)
ialwdiValue
  = lens _ialwdiValue (\ s a -> s{_ialwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
ialwdiKey :: Lens' InterconnectAttachmentListWarningDataItem (Maybe Text)
ialwdiKey
  = lens _ialwdiKey (\ s a -> s{_ialwdiKey = a})

instance FromJSON
           InterconnectAttachmentListWarningDataItem
         where
        parseJSON
          = withObject
              "InterconnectAttachmentListWarningDataItem"
              (\ o ->
                 InterconnectAttachmentListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           InterconnectAttachmentListWarningDataItem
         where
        toJSON InterconnectAttachmentListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _ialwdiValue,
                  ("key" .=) <$> _ialwdiKey])

--
-- /See:/ 'cacheInvalidationRule' smart constructor.
data CacheInvalidationRule =
  CacheInvalidationRule'
    { _cirPath :: !(Maybe Text)
    , _cirHost :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'CacheInvalidationRule' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'cirPath'
--
-- * 'cirHost'
cacheInvalidationRule
    :: CacheInvalidationRule
cacheInvalidationRule =
  CacheInvalidationRule' {_cirPath = Nothing, _cirHost = Nothing}


cirPath :: Lens' CacheInvalidationRule (Maybe Text)
cirPath = lens _cirPath (\ s a -> s{_cirPath = a})

-- | If set, this invalidation rule will only apply to requests with a Host
-- header matching host.
cirHost :: Lens' CacheInvalidationRule (Maybe Text)
cirHost = lens _cirHost (\ s a -> s{_cirHost = a})

instance FromJSON CacheInvalidationRule where
        parseJSON
          = withObject "CacheInvalidationRule"
              (\ o ->
                 CacheInvalidationRule' <$>
                   (o .:? "path") <*> (o .:? "host"))

instance ToJSON CacheInvalidationRule where
        toJSON CacheInvalidationRule'{..}
          = object
              (catMaybes
                 [("path" .=) <$> _cirPath, ("host" .=) <$> _cirHost])

--
-- /See:/ 'sslCertificatesScopedList' smart constructor.
data SSLCertificatesScopedList =
  SSLCertificatesScopedList'
    { _scslSSLCertificates :: !(Maybe [SSLCertificate])
    , _scslWarning :: !(Maybe SSLCertificatesScopedListWarning)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SSLCertificatesScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'scslSSLCertificates'
--
-- * 'scslWarning'
sslCertificatesScopedList
    :: SSLCertificatesScopedList
sslCertificatesScopedList =
  SSLCertificatesScopedList'
    {_scslSSLCertificates = Nothing, _scslWarning = Nothing}


-- | List of SslCertificates contained in this scope.
scslSSLCertificates :: Lens' SSLCertificatesScopedList [SSLCertificate]
scslSSLCertificates
  = lens _scslSSLCertificates
      (\ s a -> s{_scslSSLCertificates = a})
      . _Default
      . _Coerce

-- | Informational warning which replaces the list of backend services when
-- the list is empty.
scslWarning :: Lens' SSLCertificatesScopedList (Maybe SSLCertificatesScopedListWarning)
scslWarning
  = lens _scslWarning (\ s a -> s{_scslWarning = a})

instance FromJSON SSLCertificatesScopedList where
        parseJSON
          = withObject "SSLCertificatesScopedList"
              (\ o ->
                 SSLCertificatesScopedList' <$>
                   (o .:? "sslCertificates" .!= mempty) <*>
                     (o .:? "warning"))

instance ToJSON SSLCertificatesScopedList where
        toJSON SSLCertificatesScopedList'{..}
          = object
              (catMaybes
                 [("sslCertificates" .=) <$> _scslSSLCertificates,
                  ("warning" .=) <$> _scslWarning])

--
-- /See:/ 'addressAggregatedListWarningDataItem' smart constructor.
data AddressAggregatedListWarningDataItem =
  AddressAggregatedListWarningDataItem'
    { _aalwdiaValue :: !(Maybe Text)
    , _aalwdiaKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AddressAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'aalwdiaValue'
--
-- * 'aalwdiaKey'
addressAggregatedListWarningDataItem
    :: AddressAggregatedListWarningDataItem
addressAggregatedListWarningDataItem =
  AddressAggregatedListWarningDataItem'
    {_aalwdiaValue = Nothing, _aalwdiaKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
aalwdiaValue :: Lens' AddressAggregatedListWarningDataItem (Maybe Text)
aalwdiaValue
  = lens _aalwdiaValue (\ s a -> s{_aalwdiaValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
aalwdiaKey :: Lens' AddressAggregatedListWarningDataItem (Maybe Text)
aalwdiaKey
  = lens _aalwdiaKey (\ s a -> s{_aalwdiaKey = a})

instance FromJSON
           AddressAggregatedListWarningDataItem
         where
        parseJSON
          = withObject "AddressAggregatedListWarningDataItem"
              (\ o ->
                 AddressAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON AddressAggregatedListWarningDataItem
         where
        toJSON AddressAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _aalwdiaValue,
                  ("key" .=) <$> _aalwdiaKey])

--
-- /See:/ 'targetVPNGatewaysScopedList' smart constructor.
data TargetVPNGatewaysScopedList =
  TargetVPNGatewaysScopedList'
    { _tvgslTargetVPNGateways :: !(Maybe [TargetVPNGateway])
    , _tvgslWarning :: !(Maybe TargetVPNGatewaysScopedListWarning)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetVPNGatewaysScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tvgslTargetVPNGateways'
--
-- * 'tvgslWarning'
targetVPNGatewaysScopedList
    :: TargetVPNGatewaysScopedList
targetVPNGatewaysScopedList =
  TargetVPNGatewaysScopedList'
    {_tvgslTargetVPNGateways = Nothing, _tvgslWarning = Nothing}


-- | [Output Only] A list of target VPN gateways contained in this scope.
tvgslTargetVPNGateways :: Lens' TargetVPNGatewaysScopedList [TargetVPNGateway]
tvgslTargetVPNGateways
  = lens _tvgslTargetVPNGateways
      (\ s a -> s{_tvgslTargetVPNGateways = a})
      . _Default
      . _Coerce

-- | [Output Only] Informational warning which replaces the list of addresses
-- when the list is empty.
tvgslWarning :: Lens' TargetVPNGatewaysScopedList (Maybe TargetVPNGatewaysScopedListWarning)
tvgslWarning
  = lens _tvgslWarning (\ s a -> s{_tvgslWarning = a})

instance FromJSON TargetVPNGatewaysScopedList where
        parseJSON
          = withObject "TargetVPNGatewaysScopedList"
              (\ o ->
                 TargetVPNGatewaysScopedList' <$>
                   (o .:? "targetVpnGateways" .!= mempty) <*>
                     (o .:? "warning"))

instance ToJSON TargetVPNGatewaysScopedList where
        toJSON TargetVPNGatewaysScopedList'{..}
          = object
              (catMaybes
                 [("targetVpnGateways" .=) <$>
                    _tvgslTargetVPNGateways,
                  ("warning" .=) <$> _tvgslWarning])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'commitmentAggregatedListWarning' smart constructor.
data CommitmentAggregatedListWarning =
  CommitmentAggregatedListWarning'
    { _calwData :: !(Maybe [CommitmentAggregatedListWarningDataItem])
    , _calwCode :: !(Maybe CommitmentAggregatedListWarningCode)
    , _calwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'CommitmentAggregatedListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'calwData'
--
-- * 'calwCode'
--
-- * 'calwMessage'
commitmentAggregatedListWarning
    :: CommitmentAggregatedListWarning
commitmentAggregatedListWarning =
  CommitmentAggregatedListWarning'
    {_calwData = Nothing, _calwCode = Nothing, _calwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
calwData :: Lens' CommitmentAggregatedListWarning [CommitmentAggregatedListWarningDataItem]
calwData
  = lens _calwData (\ s a -> s{_calwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
calwCode :: Lens' CommitmentAggregatedListWarning (Maybe CommitmentAggregatedListWarningCode)
calwCode = lens _calwCode (\ s a -> s{_calwCode = a})

-- | [Output Only] A human-readable description of the warning code.
calwMessage :: Lens' CommitmentAggregatedListWarning (Maybe Text)
calwMessage
  = lens _calwMessage (\ s a -> s{_calwMessage = a})

instance FromJSON CommitmentAggregatedListWarning
         where
        parseJSON
          = withObject "CommitmentAggregatedListWarning"
              (\ o ->
                 CommitmentAggregatedListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON CommitmentAggregatedListWarning where
        toJSON CommitmentAggregatedListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _calwData,
                  ("code" .=) <$> _calwCode,
                  ("message" .=) <$> _calwMessage])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'regionInstanceGroupListWarning' smart constructor.
data RegionInstanceGroupListWarning =
  RegionInstanceGroupListWarning'
    { _riglwData :: !(Maybe [RegionInstanceGroupListWarningDataItem])
    , _riglwCode :: !(Maybe RegionInstanceGroupListWarningCode)
    , _riglwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'riglwData'
--
-- * 'riglwCode'
--
-- * 'riglwMessage'
regionInstanceGroupListWarning
    :: RegionInstanceGroupListWarning
regionInstanceGroupListWarning =
  RegionInstanceGroupListWarning'
    {_riglwData = Nothing, _riglwCode = Nothing, _riglwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
riglwData :: Lens' RegionInstanceGroupListWarning [RegionInstanceGroupListWarningDataItem]
riglwData
  = lens _riglwData (\ s a -> s{_riglwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
riglwCode :: Lens' RegionInstanceGroupListWarning (Maybe RegionInstanceGroupListWarningCode)
riglwCode
  = lens _riglwCode (\ s a -> s{_riglwCode = a})

-- | [Output Only] A human-readable description of the warning code.
riglwMessage :: Lens' RegionInstanceGroupListWarning (Maybe Text)
riglwMessage
  = lens _riglwMessage (\ s a -> s{_riglwMessage = a})

instance FromJSON RegionInstanceGroupListWarning
         where
        parseJSON
          = withObject "RegionInstanceGroupListWarning"
              (\ o ->
                 RegionInstanceGroupListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON RegionInstanceGroupListWarning where
        toJSON RegionInstanceGroupListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _riglwData,
                  ("code" .=) <$> _riglwCode,
                  ("message" .=) <$> _riglwMessage])

-- | An access configuration attached to an instance\'s network interface.
-- Only one access config per instance is supported.
--
-- /See:/ 'accessConfig' smart constructor.
data AccessConfig =
  AccessConfig'
    { _acNetworkTier :: !(Maybe AccessConfigNetworkTier)
    , _acExternalIPv6 :: !(Maybe Text)
    , _acSetPublicPtr :: !(Maybe Bool)
    , _acKind :: !Text
    , _acExternalIPv6PrefixLength :: !(Maybe (Textual Int32))
    , _acName :: !(Maybe Text)
    , _acNATIP :: !(Maybe Text)
    , _acPublicPtrDomainName :: !(Maybe Text)
    , _acType :: !AccessConfigType
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AccessConfig' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'acNetworkTier'
--
-- * 'acExternalIPv6'
--
-- * 'acSetPublicPtr'
--
-- * 'acKind'
--
-- * 'acExternalIPv6PrefixLength'
--
-- * 'acName'
--
-- * 'acNATIP'
--
-- * 'acPublicPtrDomainName'
--
-- * 'acType'
accessConfig
    :: AccessConfig
accessConfig =
  AccessConfig'
    { _acNetworkTier = Nothing
    , _acExternalIPv6 = Nothing
    , _acSetPublicPtr = Nothing
    , _acKind = "compute#accessConfig"
    , _acExternalIPv6PrefixLength = Nothing
    , _acName = Nothing
    , _acNATIP = Nothing
    , _acPublicPtrDomainName = Nothing
    , _acType = OneToOneNAT
    }


-- | This signifies the networking tier used for configuring this access
-- configuration and can only take the following values: PREMIUM, STANDARD.
-- If an AccessConfig is specified without a valid external IP address, an
-- ephemeral IP will be created with this networkTier. If an AccessConfig
-- with a valid external IP address is specified, it must match that of the
-- networkTier associated with the Address resource owning that IP.
acNetworkTier :: Lens' AccessConfig (Maybe AccessConfigNetworkTier)
acNetworkTier
  = lens _acNetworkTier
      (\ s a -> s{_acNetworkTier = a})

-- | [Output Only] The first IPv6 address of the external IPv6 range
-- associated with this instance, prefix length is stored in
-- externalIpv6PrefixLength in ipv6AccessConfig. The field is output only,
-- an IPv6 address from a subnetwork associated with the instance will be
-- allocated dynamically.
acExternalIPv6 :: Lens' AccessConfig (Maybe Text)
acExternalIPv6
  = lens _acExternalIPv6
      (\ s a -> s{_acExternalIPv6 = a})

-- | Specifies whether a public DNS \'PTR\' record should be created to map
-- the external IP address of the instance to a DNS domain name.
acSetPublicPtr :: Lens' AccessConfig (Maybe Bool)
acSetPublicPtr
  = lens _acSetPublicPtr
      (\ s a -> s{_acSetPublicPtr = a})

-- | [Output Only] Type of the resource. Always compute#accessConfig for
-- access configs.
acKind :: Lens' AccessConfig Text
acKind = lens _acKind (\ s a -> s{_acKind = a})

-- | [Output Only] The prefix length of the external IPv6 range.
acExternalIPv6PrefixLength :: Lens' AccessConfig (Maybe Int32)
acExternalIPv6PrefixLength
  = lens _acExternalIPv6PrefixLength
      (\ s a -> s{_acExternalIPv6PrefixLength = a})
      . mapping _Coerce

-- | The name of this access configuration. The default and recommended name
-- is External NAT, but you can use any arbitrary string, such as My
-- external IP or Network Access.
acName :: Lens' AccessConfig (Maybe Text)
acName = lens _acName (\ s a -> s{_acName = a})

-- | An external IP address associated with this instance. Specify an unused
-- static external IP address available to the project or leave this field
-- undefined to use an IP from a shared ephemeral IP address pool. If you
-- specify a static external IP address, it must live in the same region as
-- the zone of the instance.
acNATIP :: Lens' AccessConfig (Maybe Text)
acNATIP = lens _acNATIP (\ s a -> s{_acNATIP = a})

-- | The DNS domain name for the public PTR record. You can set this field
-- only if the \`setPublicPtr\` field is enabled.
acPublicPtrDomainName :: Lens' AccessConfig (Maybe Text)
acPublicPtrDomainName
  = lens _acPublicPtrDomainName
      (\ s a -> s{_acPublicPtrDomainName = a})

-- | The type of configuration. The default and only option is
-- ONE_TO_ONE_NAT.
acType :: Lens' AccessConfig AccessConfigType
acType = lens _acType (\ s a -> s{_acType = a})

instance FromJSON AccessConfig where
        parseJSON
          = withObject "AccessConfig"
              (\ o ->
                 AccessConfig' <$>
                   (o .:? "networkTier") <*> (o .:? "externalIpv6") <*>
                     (o .:? "setPublicPtr")
                     <*> (o .:? "kind" .!= "compute#accessConfig")
                     <*> (o .:? "externalIpv6PrefixLength")
                     <*> (o .:? "name")
                     <*> (o .:? "natIP")
                     <*> (o .:? "publicPtrDomainName")
                     <*> (o .:? "type" .!= OneToOneNAT))

instance ToJSON AccessConfig where
        toJSON AccessConfig'{..}
          = object
              (catMaybes
                 [("networkTier" .=) <$> _acNetworkTier,
                  ("externalIpv6" .=) <$> _acExternalIPv6,
                  ("setPublicPtr" .=) <$> _acSetPublicPtr,
                  Just ("kind" .= _acKind),
                  ("externalIpv6PrefixLength" .=) <$>
                    _acExternalIPv6PrefixLength,
                  ("name" .=) <$> _acName, ("natIP" .=) <$> _acNATIP,
                  ("publicPtrDomainName" .=) <$>
                    _acPublicPtrDomainName,
                  Just ("type" .= _acType)])

-- | Specifies what kind of log the caller must write
--
-- /See:/ 'logConfig' smart constructor.
data LogConfig =
  LogConfig'
    { _lcCloudAudit :: !(Maybe LogConfigCloudAuditOptions)
    , _lcDataAccess :: !(Maybe LogConfigDataAccessOptions)
    , _lcCounter :: !(Maybe LogConfigCounterOptions)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'LogConfig' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'lcCloudAudit'
--
-- * 'lcDataAccess'
--
-- * 'lcCounter'
logConfig
    :: LogConfig
logConfig =
  LogConfig'
    {_lcCloudAudit = Nothing, _lcDataAccess = Nothing, _lcCounter = Nothing}


-- | Cloud audit options.
lcCloudAudit :: Lens' LogConfig (Maybe LogConfigCloudAuditOptions)
lcCloudAudit
  = lens _lcCloudAudit (\ s a -> s{_lcCloudAudit = a})

-- | Data access options.
lcDataAccess :: Lens' LogConfig (Maybe LogConfigDataAccessOptions)
lcDataAccess
  = lens _lcDataAccess (\ s a -> s{_lcDataAccess = a})

-- | Counter options.
lcCounter :: Lens' LogConfig (Maybe LogConfigCounterOptions)
lcCounter
  = lens _lcCounter (\ s a -> s{_lcCounter = a})

instance FromJSON LogConfig where
        parseJSON
          = withObject "LogConfig"
              (\ o ->
                 LogConfig' <$>
                   (o .:? "cloudAudit") <*> (o .:? "dataAccess") <*>
                     (o .:? "counter"))

instance ToJSON LogConfig where
        toJSON LogConfig'{..}
          = object
              (catMaybes
                 [("cloudAudit" .=) <$> _lcCloudAudit,
                  ("dataAccess" .=) <$> _lcDataAccess,
                  ("counter" .=) <$> _lcCounter])

--
-- /See:/ 'targetGrpcProxyListWarningDataItem' smart constructor.
data TargetGrpcProxyListWarningDataItem =
  TargetGrpcProxyListWarningDataItem'
    { _tgplwdiValue :: !(Maybe Text)
    , _tgplwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetGrpcProxyListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tgplwdiValue'
--
-- * 'tgplwdiKey'
targetGrpcProxyListWarningDataItem
    :: TargetGrpcProxyListWarningDataItem
targetGrpcProxyListWarningDataItem =
  TargetGrpcProxyListWarningDataItem'
    {_tgplwdiValue = Nothing, _tgplwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
tgplwdiValue :: Lens' TargetGrpcProxyListWarningDataItem (Maybe Text)
tgplwdiValue
  = lens _tgplwdiValue (\ s a -> s{_tgplwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
tgplwdiKey :: Lens' TargetGrpcProxyListWarningDataItem (Maybe Text)
tgplwdiKey
  = lens _tgplwdiKey (\ s a -> s{_tgplwdiKey = a})

instance FromJSON TargetGrpcProxyListWarningDataItem
         where
        parseJSON
          = withObject "TargetGrpcProxyListWarningDataItem"
              (\ o ->
                 TargetGrpcProxyListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON TargetGrpcProxyListWarningDataItem
         where
        toJSON TargetGrpcProxyListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _tgplwdiValue,
                  ("key" .=) <$> _tgplwdiKey])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'zoneListWarning' smart constructor.
data ZoneListWarning =
  ZoneListWarning'
    { _zlwData :: !(Maybe [ZoneListWarningDataItem])
    , _zlwCode :: !(Maybe ZoneListWarningCode)
    , _zlwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ZoneListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'zlwData'
--
-- * 'zlwCode'
--
-- * 'zlwMessage'
zoneListWarning
    :: ZoneListWarning
zoneListWarning =
  ZoneListWarning'
    {_zlwData = Nothing, _zlwCode = Nothing, _zlwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
zlwData :: Lens' ZoneListWarning [ZoneListWarningDataItem]
zlwData
  = lens _zlwData (\ s a -> s{_zlwData = a}) . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
zlwCode :: Lens' ZoneListWarning (Maybe ZoneListWarningCode)
zlwCode = lens _zlwCode (\ s a -> s{_zlwCode = a})

-- | [Output Only] A human-readable description of the warning code.
zlwMessage :: Lens' ZoneListWarning (Maybe Text)
zlwMessage
  = lens _zlwMessage (\ s a -> s{_zlwMessage = a})

instance FromJSON ZoneListWarning where
        parseJSON
          = withObject "ZoneListWarning"
              (\ o ->
                 ZoneListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON ZoneListWarning where
        toJSON ZoneListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _zlwData, ("code" .=) <$> _zlwCode,
                  ("message" .=) <$> _zlwMessage])

-- | Configuration of logging on a NAT.
--
-- /See:/ 'routerNATLogConfig' smart constructor.
data RouterNATLogConfig =
  RouterNATLogConfig'
    { _rnatlcEnable :: !(Maybe Bool)
    , _rnatlcFilter :: !(Maybe RouterNATLogConfigFilter)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RouterNATLogConfig' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rnatlcEnable'
--
-- * 'rnatlcFilter'
routerNATLogConfig
    :: RouterNATLogConfig
routerNATLogConfig =
  RouterNATLogConfig' {_rnatlcEnable = Nothing, _rnatlcFilter = Nothing}


-- | Indicates whether or not to export logs. This is false by default.
rnatlcEnable :: Lens' RouterNATLogConfig (Maybe Bool)
rnatlcEnable
  = lens _rnatlcEnable (\ s a -> s{_rnatlcEnable = a})

-- | Specify the desired filtering of logs on this NAT. If unspecified, logs
-- are exported for all connections handled by this NAT. This option can
-- take one of the following values: - ERRORS_ONLY: Export logs only for
-- connection failures. - TRANSLATIONS_ONLY: Export logs only for
-- successful connections. - ALL: Export logs for all connections,
-- successful and unsuccessful.
rnatlcFilter :: Lens' RouterNATLogConfig (Maybe RouterNATLogConfigFilter)
rnatlcFilter
  = lens _rnatlcFilter (\ s a -> s{_rnatlcFilter = a})

instance FromJSON RouterNATLogConfig where
        parseJSON
          = withObject "RouterNATLogConfig"
              (\ o ->
                 RouterNATLogConfig' <$>
                   (o .:? "enable") <*> (o .:? "filter"))

instance ToJSON RouterNATLogConfig where
        toJSON RouterNATLogConfig'{..}
          = object
              (catMaybes
                 [("enable" .=) <$> _rnatlcEnable,
                  ("filter" .=) <$> _rnatlcFilter])

--
-- /See:/ 'managedInstanceLastAttemptErrorsErrorsItem' smart constructor.
data ManagedInstanceLastAttemptErrorsErrorsItem =
  ManagedInstanceLastAttemptErrorsErrorsItem'
    { _milaeeiLocation :: !(Maybe Text)
    , _milaeeiCode :: !(Maybe Text)
    , _milaeeiMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ManagedInstanceLastAttemptErrorsErrorsItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'milaeeiLocation'
--
-- * 'milaeeiCode'
--
-- * 'milaeeiMessage'
managedInstanceLastAttemptErrorsErrorsItem
    :: ManagedInstanceLastAttemptErrorsErrorsItem
managedInstanceLastAttemptErrorsErrorsItem =
  ManagedInstanceLastAttemptErrorsErrorsItem'
    { _milaeeiLocation = Nothing
    , _milaeeiCode = Nothing
    , _milaeeiMessage = Nothing
    }


-- | [Output Only] Indicates the field in the request that caused the error.
-- This property is optional.
milaeeiLocation :: Lens' ManagedInstanceLastAttemptErrorsErrorsItem (Maybe Text)
milaeeiLocation
  = lens _milaeeiLocation
      (\ s a -> s{_milaeeiLocation = a})

-- | [Output Only] The error type identifier for this error.
milaeeiCode :: Lens' ManagedInstanceLastAttemptErrorsErrorsItem (Maybe Text)
milaeeiCode
  = lens _milaeeiCode (\ s a -> s{_milaeeiCode = a})

-- | [Output Only] An optional, human-readable error message.
milaeeiMessage :: Lens' ManagedInstanceLastAttemptErrorsErrorsItem (Maybe Text)
milaeeiMessage
  = lens _milaeeiMessage
      (\ s a -> s{_milaeeiMessage = a})

instance FromJSON
           ManagedInstanceLastAttemptErrorsErrorsItem
         where
        parseJSON
          = withObject
              "ManagedInstanceLastAttemptErrorsErrorsItem"
              (\ o ->
                 ManagedInstanceLastAttemptErrorsErrorsItem' <$>
                   (o .:? "location") <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON
           ManagedInstanceLastAttemptErrorsErrorsItem
         where
        toJSON
          ManagedInstanceLastAttemptErrorsErrorsItem'{..}
          = object
              (catMaybes
                 [("location" .=) <$> _milaeeiLocation,
                  ("code" .=) <$> _milaeeiCode,
                  ("message" .=) <$> _milaeeiMessage])

--
-- /See:/ 'instancesScopedListWarningDataItem' smart constructor.
data InstancesScopedListWarningDataItem =
  InstancesScopedListWarningDataItem'
    { _islwdiValue :: !(Maybe Text)
    , _islwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstancesScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'islwdiValue'
--
-- * 'islwdiKey'
instancesScopedListWarningDataItem
    :: InstancesScopedListWarningDataItem
instancesScopedListWarningDataItem =
  InstancesScopedListWarningDataItem'
    {_islwdiValue = Nothing, _islwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
islwdiValue :: Lens' InstancesScopedListWarningDataItem (Maybe Text)
islwdiValue
  = lens _islwdiValue (\ s a -> s{_islwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
islwdiKey :: Lens' InstancesScopedListWarningDataItem (Maybe Text)
islwdiKey
  = lens _islwdiKey (\ s a -> s{_islwdiKey = a})

instance FromJSON InstancesScopedListWarningDataItem
         where
        parseJSON
          = withObject "InstancesScopedListWarningDataItem"
              (\ o ->
                 InstancesScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON InstancesScopedListWarningDataItem
         where
        toJSON InstancesScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _islwdiValue,
                  ("key" .=) <$> _islwdiKey])

--
-- /See:/ 'packetMirroringNetworkInfo' smart constructor.
data PacketMirroringNetworkInfo =
  PacketMirroringNetworkInfo'
    { _pmniURL :: !(Maybe Text)
    , _pmniCanonicalURL :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PacketMirroringNetworkInfo' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pmniURL'
--
-- * 'pmniCanonicalURL'
packetMirroringNetworkInfo
    :: PacketMirroringNetworkInfo
packetMirroringNetworkInfo =
  PacketMirroringNetworkInfo' {_pmniURL = Nothing, _pmniCanonicalURL = Nothing}


-- | URL of the network resource.
pmniURL :: Lens' PacketMirroringNetworkInfo (Maybe Text)
pmniURL = lens _pmniURL (\ s a -> s{_pmniURL = a})

-- | [Output Only] Unique identifier for the network; defined by the server.
pmniCanonicalURL :: Lens' PacketMirroringNetworkInfo (Maybe Text)
pmniCanonicalURL
  = lens _pmniCanonicalURL
      (\ s a -> s{_pmniCanonicalURL = a})

instance FromJSON PacketMirroringNetworkInfo where
        parseJSON
          = withObject "PacketMirroringNetworkInfo"
              (\ o ->
                 PacketMirroringNetworkInfo' <$>
                   (o .:? "url") <*> (o .:? "canonicalUrl"))

instance ToJSON PacketMirroringNetworkInfo where
        toJSON PacketMirroringNetworkInfo'{..}
          = object
              (catMaybes
                 [("url" .=) <$> _pmniURL,
                  ("canonicalUrl" .=) <$> _pmniCanonicalURL])

-- | Labels to apply to this snapshot. These can be later modified by the
-- setLabels method. Label values may be empty.
--
-- /See:/ 'snapshotLabels' smart constructor.
newtype SnapshotLabels =
  SnapshotLabels'
    { _slAddtional :: HashMap Text Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SnapshotLabels' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'slAddtional'
snapshotLabels
    :: HashMap Text Text -- ^ 'slAddtional'
    -> SnapshotLabels
snapshotLabels pSlAddtional_ =
  SnapshotLabels' {_slAddtional = _Coerce # pSlAddtional_}


slAddtional :: Lens' SnapshotLabels (HashMap Text Text)
slAddtional
  = lens _slAddtional (\ s a -> s{_slAddtional = a}) .
      _Coerce

instance FromJSON SnapshotLabels where
        parseJSON
          = withObject "SnapshotLabels"
              (\ o -> SnapshotLabels' <$> (parseJSONObject o))

instance ToJSON SnapshotLabels where
        toJSON = toJSON . _slAddtional

--
-- /See:/ 'managedInstanceInstanceHealth' smart constructor.
data ManagedInstanceInstanceHealth =
  ManagedInstanceInstanceHealth'
    { _miihHealthCheck :: !(Maybe Text)
    , _miihDetailedHealthState :: !(Maybe ManagedInstanceInstanceHealthDetailedHealthState)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ManagedInstanceInstanceHealth' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'miihHealthCheck'
--
-- * 'miihDetailedHealthState'
managedInstanceInstanceHealth
    :: ManagedInstanceInstanceHealth
managedInstanceInstanceHealth =
  ManagedInstanceInstanceHealth'
    {_miihHealthCheck = Nothing, _miihDetailedHealthState = Nothing}


-- | [Output Only] The URL for the health check that verifies whether the
-- instance is healthy.
miihHealthCheck :: Lens' ManagedInstanceInstanceHealth (Maybe Text)
miihHealthCheck
  = lens _miihHealthCheck
      (\ s a -> s{_miihHealthCheck = a})

-- | [Output Only] The current detailed instance health state.
miihDetailedHealthState :: Lens' ManagedInstanceInstanceHealth (Maybe ManagedInstanceInstanceHealthDetailedHealthState)
miihDetailedHealthState
  = lens _miihDetailedHealthState
      (\ s a -> s{_miihDetailedHealthState = a})

instance FromJSON ManagedInstanceInstanceHealth where
        parseJSON
          = withObject "ManagedInstanceInstanceHealth"
              (\ o ->
                 ManagedInstanceInstanceHealth' <$>
                   (o .:? "healthCheck") <*>
                     (o .:? "detailedHealthState"))

instance ToJSON ManagedInstanceInstanceHealth where
        toJSON ManagedInstanceInstanceHealth'{..}
          = object
              (catMaybes
                 [("healthCheck" .=) <$> _miihHealthCheck,
                  ("detailedHealthState" .=) <$>
                    _miihDetailedHealthState])

--
-- /See:/ 'backendServicesScopedListWarningDataItem' smart constructor.
data BackendServicesScopedListWarningDataItem =
  BackendServicesScopedListWarningDataItem'
    { _bsslwdiValue :: !(Maybe Text)
    , _bsslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendServicesScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bsslwdiValue'
--
-- * 'bsslwdiKey'
backendServicesScopedListWarningDataItem
    :: BackendServicesScopedListWarningDataItem
backendServicesScopedListWarningDataItem =
  BackendServicesScopedListWarningDataItem'
    {_bsslwdiValue = Nothing, _bsslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
bsslwdiValue :: Lens' BackendServicesScopedListWarningDataItem (Maybe Text)
bsslwdiValue
  = lens _bsslwdiValue (\ s a -> s{_bsslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
bsslwdiKey :: Lens' BackendServicesScopedListWarningDataItem (Maybe Text)
bsslwdiKey
  = lens _bsslwdiKey (\ s a -> s{_bsslwdiKey = a})

instance FromJSON
           BackendServicesScopedListWarningDataItem
         where
        parseJSON
          = withObject
              "BackendServicesScopedListWarningDataItem"
              (\ o ->
                 BackendServicesScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           BackendServicesScopedListWarningDataItem
         where
        toJSON BackendServicesScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _bsslwdiValue,
                  ("key" .=) <$> _bsslwdiKey])

--
-- /See:/ 'packetMirroringAggregatedListWarningDataItem' smart constructor.
data PacketMirroringAggregatedListWarningDataItem =
  PacketMirroringAggregatedListWarningDataItem'
    { _pmalwdiValue :: !(Maybe Text)
    , _pmalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PacketMirroringAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pmalwdiValue'
--
-- * 'pmalwdiKey'
packetMirroringAggregatedListWarningDataItem
    :: PacketMirroringAggregatedListWarningDataItem
packetMirroringAggregatedListWarningDataItem =
  PacketMirroringAggregatedListWarningDataItem'
    {_pmalwdiValue = Nothing, _pmalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
pmalwdiValue :: Lens' PacketMirroringAggregatedListWarningDataItem (Maybe Text)
pmalwdiValue
  = lens _pmalwdiValue (\ s a -> s{_pmalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
pmalwdiKey :: Lens' PacketMirroringAggregatedListWarningDataItem (Maybe Text)
pmalwdiKey
  = lens _pmalwdiKey (\ s a -> s{_pmalwdiKey = a})

instance FromJSON
           PacketMirroringAggregatedListWarningDataItem
         where
        parseJSON
          = withObject
              "PacketMirroringAggregatedListWarningDataItem"
              (\ o ->
                 PacketMirroringAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           PacketMirroringAggregatedListWarningDataItem
         where
        toJSON
          PacketMirroringAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _pmalwdiValue,
                  ("key" .=) <$> _pmalwdiKey])

-- | A list of NodeTemplatesScopedList resources.
--
-- /See:/ 'nodeTemplateAggregatedListItems' smart constructor.
newtype NodeTemplateAggregatedListItems =
  NodeTemplateAggregatedListItems'
    { _ntaliAddtional :: HashMap Text NodeTemplatesScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeTemplateAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ntaliAddtional'
nodeTemplateAggregatedListItems
    :: HashMap Text NodeTemplatesScopedList -- ^ 'ntaliAddtional'
    -> NodeTemplateAggregatedListItems
nodeTemplateAggregatedListItems pNtaliAddtional_ =
  NodeTemplateAggregatedListItems'
    {_ntaliAddtional = _Coerce # pNtaliAddtional_}


-- | [Output Only] Name of the scope containing this set of node templates.
ntaliAddtional :: Lens' NodeTemplateAggregatedListItems (HashMap Text NodeTemplatesScopedList)
ntaliAddtional
  = lens _ntaliAddtional
      (\ s a -> s{_ntaliAddtional = a})
      . _Coerce

instance FromJSON NodeTemplateAggregatedListItems
         where
        parseJSON
          = withObject "NodeTemplateAggregatedListItems"
              (\ o ->
                 NodeTemplateAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON NodeTemplateAggregatedListItems where
        toJSON = toJSON . _ntaliAddtional

--
-- /See:/ 'healthChecksAggregatedListWarningDataItem' smart constructor.
data HealthChecksAggregatedListWarningDataItem =
  HealthChecksAggregatedListWarningDataItem'
    { _hcalwdiValue :: !(Maybe Text)
    , _hcalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HealthChecksAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hcalwdiValue'
--
-- * 'hcalwdiKey'
healthChecksAggregatedListWarningDataItem
    :: HealthChecksAggregatedListWarningDataItem
healthChecksAggregatedListWarningDataItem =
  HealthChecksAggregatedListWarningDataItem'
    {_hcalwdiValue = Nothing, _hcalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
hcalwdiValue :: Lens' HealthChecksAggregatedListWarningDataItem (Maybe Text)
hcalwdiValue
  = lens _hcalwdiValue (\ s a -> s{_hcalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
hcalwdiKey :: Lens' HealthChecksAggregatedListWarningDataItem (Maybe Text)
hcalwdiKey
  = lens _hcalwdiKey (\ s a -> s{_hcalwdiKey = a})

instance FromJSON
           HealthChecksAggregatedListWarningDataItem
         where
        parseJSON
          = withObject
              "HealthChecksAggregatedListWarningDataItem"
              (\ o ->
                 HealthChecksAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           HealthChecksAggregatedListWarningDataItem
         where
        toJSON HealthChecksAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _hcalwdiValue,
                  ("key" .=) <$> _hcalwdiKey])

-- | RegionInstanceGroupManagers.deletePerInstanceConfigs
--
-- /See:/ 'regionInstanceGroupManagerDeleteInstanceConfigReq' smart constructor.
newtype RegionInstanceGroupManagerDeleteInstanceConfigReq =
  RegionInstanceGroupManagerDeleteInstanceConfigReq'
    { _rigmdicrNames :: Maybe [Text]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupManagerDeleteInstanceConfigReq' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rigmdicrNames'
regionInstanceGroupManagerDeleteInstanceConfigReq
    :: RegionInstanceGroupManagerDeleteInstanceConfigReq
regionInstanceGroupManagerDeleteInstanceConfigReq =
  RegionInstanceGroupManagerDeleteInstanceConfigReq' {_rigmdicrNames = Nothing}


-- | The list of instance names for which we want to delete per-instance
-- configs on this managed instance group.
rigmdicrNames :: Lens' RegionInstanceGroupManagerDeleteInstanceConfigReq [Text]
rigmdicrNames
  = lens _rigmdicrNames
      (\ s a -> s{_rigmdicrNames = a})
      . _Default
      . _Coerce

instance FromJSON
           RegionInstanceGroupManagerDeleteInstanceConfigReq
         where
        parseJSON
          = withObject
              "RegionInstanceGroupManagerDeleteInstanceConfigReq"
              (\ o ->
                 RegionInstanceGroupManagerDeleteInstanceConfigReq'
                   <$> (o .:? "names" .!= mempty))

instance ToJSON
           RegionInstanceGroupManagerDeleteInstanceConfigReq
         where
        toJSON
          RegionInstanceGroupManagerDeleteInstanceConfigReq'{..}
          = object
              (catMaybes [("names" .=) <$> _rigmdicrNames])

-- | InstanceGroupManagers.applyUpdatesToInstances
--
-- /See:/ 'instanceGroupManagersApplyUpdatesRequest' smart constructor.
data InstanceGroupManagersApplyUpdatesRequest =
  InstanceGroupManagersApplyUpdatesRequest'
    { _igmaurAllInstances :: !(Maybe Bool)
    , _igmaurMostDisruptiveAllowedAction :: !(Maybe InstanceGroupManagersApplyUpdatesRequestMostDisruptiveAllowedAction)
    , _igmaurInstances :: !(Maybe [Text])
    , _igmaurMinimalAction :: !(Maybe InstanceGroupManagersApplyUpdatesRequestMinimalAction)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagersApplyUpdatesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmaurAllInstances'
--
-- * 'igmaurMostDisruptiveAllowedAction'
--
-- * 'igmaurInstances'
--
-- * 'igmaurMinimalAction'
instanceGroupManagersApplyUpdatesRequest
    :: InstanceGroupManagersApplyUpdatesRequest
instanceGroupManagersApplyUpdatesRequest =
  InstanceGroupManagersApplyUpdatesRequest'
    { _igmaurAllInstances = Nothing
    , _igmaurMostDisruptiveAllowedAction = Nothing
    , _igmaurInstances = Nothing
    , _igmaurMinimalAction = Nothing
    }


-- | Flag to update all instances instead of specified list of ?instances?.
-- If the flag is set to true then the instances may not be specified in
-- the request.
igmaurAllInstances :: Lens' InstanceGroupManagersApplyUpdatesRequest (Maybe Bool)
igmaurAllInstances
  = lens _igmaurAllInstances
      (\ s a -> s{_igmaurAllInstances = a})

-- | The most disruptive action that you want to perform on each instance
-- during the update: - REPLACE: Delete the instance and create it again. -
-- RESTART: Stop the instance and start it again. - REFRESH: Do not stop
-- the instance. - NONE: Do not disrupt the instance at all. By default,
-- the most disruptive allowed action is REPLACE. If your update requires a
-- more disruptive action than you set with this flag, the update request
-- will fail.
igmaurMostDisruptiveAllowedAction :: Lens' InstanceGroupManagersApplyUpdatesRequest (Maybe InstanceGroupManagersApplyUpdatesRequestMostDisruptiveAllowedAction)
igmaurMostDisruptiveAllowedAction
  = lens _igmaurMostDisruptiveAllowedAction
      (\ s a -> s{_igmaurMostDisruptiveAllowedAction = a})

-- | The list of URLs of one or more instances for which you want to apply
-- updates. Each URL can be a full URL or a partial URL, such as
-- zones\/[ZONE]\/instances\/[INSTANCE_NAME].
igmaurInstances :: Lens' InstanceGroupManagersApplyUpdatesRequest [Text]
igmaurInstances
  = lens _igmaurInstances
      (\ s a -> s{_igmaurInstances = a})
      . _Default
      . _Coerce

-- | The minimal action that you want to perform on each instance during the
-- update: - REPLACE: At minimum, delete the instance and create it again.
-- - RESTART: Stop the instance and start it again. - REFRESH: Do not stop
-- the instance. - NONE: Do not disrupt the instance at all. By default,
-- the minimum action is NONE. If your update requires a more disruptive
-- action than you set with this flag, the necessary action is performed to
-- execute the update.
igmaurMinimalAction :: Lens' InstanceGroupManagersApplyUpdatesRequest (Maybe InstanceGroupManagersApplyUpdatesRequestMinimalAction)
igmaurMinimalAction
  = lens _igmaurMinimalAction
      (\ s a -> s{_igmaurMinimalAction = a})

instance FromJSON
           InstanceGroupManagersApplyUpdatesRequest
         where
        parseJSON
          = withObject
              "InstanceGroupManagersApplyUpdatesRequest"
              (\ o ->
                 InstanceGroupManagersApplyUpdatesRequest' <$>
                   (o .:? "allInstances") <*>
                     (o .:? "mostDisruptiveAllowedAction")
                     <*> (o .:? "instances" .!= mempty)
                     <*> (o .:? "minimalAction"))

instance ToJSON
           InstanceGroupManagersApplyUpdatesRequest
         where
        toJSON InstanceGroupManagersApplyUpdatesRequest'{..}
          = object
              (catMaybes
                 [("allInstances" .=) <$> _igmaurAllInstances,
                  ("mostDisruptiveAllowedAction" .=) <$>
                    _igmaurMostDisruptiveAllowedAction,
                  ("instances" .=) <$> _igmaurInstances,
                  ("minimalAction" .=) <$> _igmaurMinimalAction])

-- | Represents a Backend Service resource. A backend service defines how
-- Google Cloud load balancers distribute traffic. The backend service
-- configuration contains a set of values, such as the protocol used to
-- connect to backends, various distribution and session settings, health
-- checks, and timeouts. These settings provide fine-grained control over
-- how your load balancer behaves. Most of the settings have default values
-- that allow for easy configuration if you need to get started quickly.
-- Backend services in Google Compute Engine can be either regionally or
-- globally scoped. *
-- [Global](\/compute\/docs\/reference\/rest\/{$api_version}\/backendServices)
-- *
-- [Regional](\/compute\/docs\/reference\/rest\/{$api_version}\/regionBackendServices)
-- For more information, see Backend Services. (== resource_for
-- {$api_version}.backendService ==)
--
-- /See:/ 'backendService' smart constructor.
data BackendService =
  BackendService'
    { _bsSessionAffinity :: !(Maybe BackendServiceSessionAffinity)
    , _bsFailoverPolicy :: !(Maybe BackendServiceFailoverPolicy)
    , _bsBackends :: !(Maybe [Backend])
    , _bsLocalityLbPolicy :: !(Maybe BackendServiceLocalityLbPolicy)
    , _bsAffinityCookieTtlSec :: !(Maybe (Textual Int32))
    , _bsConsistentHash :: !(Maybe ConsistentHashLoadBalancerSettings)
    , _bsIap :: !(Maybe BackendServiceIAP)
    , _bsLoadBalancingScheme :: !(Maybe BackendServiceLoadBalancingScheme)
    , _bsKind :: !Text
    , _bsEnableCDN :: !(Maybe Bool)
    , _bsCircuitBreakers :: !(Maybe CircuitBreakers)
    , _bsFingerprint :: !(Maybe Bytes)
    , _bsSecuritySettings :: !(Maybe SecuritySettings)
    , _bsOutlierDetection :: !(Maybe OutlierDetection)
    , _bsNetwork :: !(Maybe Text)
    , _bsProtocol :: !(Maybe BackendServiceProtocol)
    , _bsCustomRequestHeaders :: !(Maybe [Text])
    , _bsSecurityPolicy :: !(Maybe Text)
    , _bsCdnPolicy :: !(Maybe BackendServiceCdnPolicy)
    , _bsCustomResponseHeaders :: !(Maybe [Text])
    , _bsSelfLink :: !(Maybe Text)
    , _bsName :: !(Maybe Text)
    , _bsCreationTimestamp :: !(Maybe Text)
    , _bsId :: !(Maybe (Textual Word64))
    , _bsRegion :: !(Maybe Text)
    , _bsMaxStreamDuration :: !(Maybe Duration)
    , _bsConnectionDraining :: !(Maybe ConnectionDraining)
    , _bsTimeoutSec :: !(Maybe (Textual Int32))
    , _bsLogConfig :: !(Maybe BackendServiceLogConfig)
    , _bsDescription :: !(Maybe Text)
    , _bsPortName :: !(Maybe Text)
    , _bsHealthChecks :: !(Maybe [Text])
    , _bsPort :: !(Maybe (Textual Int32))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendService' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bsSessionAffinity'
--
-- * 'bsFailoverPolicy'
--
-- * 'bsBackends'
--
-- * 'bsLocalityLbPolicy'
--
-- * 'bsAffinityCookieTtlSec'
--
-- * 'bsConsistentHash'
--
-- * 'bsIap'
--
-- * 'bsLoadBalancingScheme'
--
-- * 'bsKind'
--
-- * 'bsEnableCDN'
--
-- * 'bsCircuitBreakers'
--
-- * 'bsFingerprint'
--
-- * 'bsSecuritySettings'
--
-- * 'bsOutlierDetection'
--
-- * 'bsNetwork'
--
-- * 'bsProtocol'
--
-- * 'bsCustomRequestHeaders'
--
-- * 'bsSecurityPolicy'
--
-- * 'bsCdnPolicy'
--
-- * 'bsCustomResponseHeaders'
--
-- * 'bsSelfLink'
--
-- * 'bsName'
--
-- * 'bsCreationTimestamp'
--
-- * 'bsId'
--
-- * 'bsRegion'
--
-- * 'bsMaxStreamDuration'
--
-- * 'bsConnectionDraining'
--
-- * 'bsTimeoutSec'
--
-- * 'bsLogConfig'
--
-- * 'bsDescription'
--
-- * 'bsPortName'
--
-- * 'bsHealthChecks'
--
-- * 'bsPort'
backendService
    :: BackendService
backendService =
  BackendService'
    { _bsSessionAffinity = Nothing
    , _bsFailoverPolicy = Nothing
    , _bsBackends = Nothing
    , _bsLocalityLbPolicy = Nothing
    , _bsAffinityCookieTtlSec = Nothing
    , _bsConsistentHash = Nothing
    , _bsIap = Nothing
    , _bsLoadBalancingScheme = Nothing
    , _bsKind = "compute#backendService"
    , _bsEnableCDN = Nothing
    , _bsCircuitBreakers = Nothing
    , _bsFingerprint = Nothing
    , _bsSecuritySettings = Nothing
    , _bsOutlierDetection = Nothing
    , _bsNetwork = Nothing
    , _bsProtocol = Nothing
    , _bsCustomRequestHeaders = Nothing
    , _bsSecurityPolicy = Nothing
    , _bsCdnPolicy = Nothing
    , _bsCustomResponseHeaders = Nothing
    , _bsSelfLink = Nothing
    , _bsName = Nothing
    , _bsCreationTimestamp = Nothing
    , _bsId = Nothing
    , _bsRegion = Nothing
    , _bsMaxStreamDuration = Nothing
    , _bsConnectionDraining = Nothing
    , _bsTimeoutSec = Nothing
    , _bsLogConfig = Nothing
    , _bsDescription = Nothing
    , _bsPortName = Nothing
    , _bsHealthChecks = Nothing
    , _bsPort = Nothing
    }


-- | Type of session affinity to use. The default is NONE. When the
-- loadBalancingScheme is EXTERNAL: * For Network Load Balancing, the
-- possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or
-- CLIENT_IP_PORT_PROTO. * For all other load balancers that use
-- loadBalancingScheme=EXTERNAL, the possible values are NONE, CLIENT_IP,
-- or GENERATED_COOKIE. * You can use GENERATED_COOKIE if the protocol is
-- HTTP, HTTP2, or HTTPS. When the loadBalancingScheme is INTERNAL,
-- possible values are NONE, CLIENT_IP, CLIENT_IP_PROTO, or
-- CLIENT_IP_PORT_PROTO. When the loadBalancingScheme is
-- INTERNAL_SELF_MANAGED, or INTERNAL_MANAGED, possible values are NONE,
-- CLIENT_IP, GENERATED_COOKIE, HEADER_FIELD, or HTTP_COOKIE. Not supported
-- when the backend service is referenced by a URL map that is bound to
-- target gRPC proxy that has validateForProxyless field set to true.
bsSessionAffinity :: Lens' BackendService (Maybe BackendServiceSessionAffinity)
bsSessionAffinity
  = lens _bsSessionAffinity
      (\ s a -> s{_bsSessionAffinity = a})

-- | Applicable only to Failover for Internal TCP\/UDP Load Balancing and
-- Network Load Balancing. Requires at least one backend instance group to
-- be defined as a backup (failover) backend.
bsFailoverPolicy :: Lens' BackendService (Maybe BackendServiceFailoverPolicy)
bsFailoverPolicy
  = lens _bsFailoverPolicy
      (\ s a -> s{_bsFailoverPolicy = a})

-- | The list of backends that serve this BackendService.
bsBackends :: Lens' BackendService [Backend]
bsBackends
  = lens _bsBackends (\ s a -> s{_bsBackends = a}) .
      _Default
      . _Coerce

-- | The load balancing algorithm used within the scope of the locality. The
-- possible values are: - ROUND_ROBIN: This is a simple policy in which
-- each healthy backend is selected in round robin order. This is the
-- default. - LEAST_REQUEST: An O(1) algorithm which selects two random
-- healthy hosts and picks the host which has fewer active requests. -
-- RING_HASH: The ring\/modulo hash load balancer implements consistent
-- hashing to backends. The algorithm has the property that the
-- addition\/removal of a host from a set of N hosts only affects 1\/N of
-- the requests. - RANDOM: The load balancer selects a random healthy host.
-- - ORIGINAL_DESTINATION: Backend host is selected based on the client
-- connection metadata, i.e., connections are opened to the same address as
-- the destination address of the incoming connection before the connection
-- was redirected to the load balancer. - MAGLEV: used as a drop in
-- replacement for the ring hash load balancer. Maglev is not as stable as
-- ring hash but has faster table lookup build times and host selection
-- times. For more information about Maglev, see
-- https:\/\/ai.google\/research\/pubs\/pub44824 This field is applicable
-- to either: - A regional backend service with the service_protocol set to
-- HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to
-- INTERNAL_MANAGED. - A global backend service with the
-- load_balancing_scheme set to INTERNAL_SELF_MANAGED. If sessionAffinity
-- is not NONE, and this field is not set to MAGLEV or RING_HASH, session
-- affinity settings will not take effect. Only the default ROUND_ROBIN
-- policy is supported when the backend service is referenced by a URL map
-- that is bound to target gRPC proxy that has validateForProxyless field
-- set to true.
bsLocalityLbPolicy :: Lens' BackendService (Maybe BackendServiceLocalityLbPolicy)
bsLocalityLbPolicy
  = lens _bsLocalityLbPolicy
      (\ s a -> s{_bsLocalityLbPolicy = a})

-- | Lifetime of cookies in seconds. Only applicable if the
-- loadBalancingScheme is EXTERNAL, INTERNAL_SELF_MANAGED, or
-- INTERNAL_MANAGED, the protocol is HTTP or HTTPS, and the sessionAffinity
-- is GENERATED_COOKIE, or HTTP_COOKIE. If set to 0, the cookie is
-- non-persistent and lasts only until the end of the browser session (or
-- equivalent). The maximum allowed value is one day (86,400). Not
-- supported when the backend service is referenced by a URL map that is
-- bound to target gRPC proxy that has validateForProxyless field set to
-- true.
bsAffinityCookieTtlSec :: Lens' BackendService (Maybe Int32)
bsAffinityCookieTtlSec
  = lens _bsAffinityCookieTtlSec
      (\ s a -> s{_bsAffinityCookieTtlSec = a})
      . mapping _Coerce

-- | Consistent Hash-based load balancing can be used to provide soft session
-- affinity based on HTTP headers, cookies or other properties. This load
-- balancing policy is applicable only for HTTP connections. The affinity
-- to a particular destination host will be lost when one or more hosts are
-- added\/removed from the destination service. This field specifies
-- parameters that control consistent hashing. This field is only
-- applicable when localityLbPolicy is set to MAGLEV or RING_HASH. This
-- field is applicable to either: - A regional backend service with the
-- service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme
-- set to INTERNAL_MANAGED. - A global backend service with the
-- load_balancing_scheme set to INTERNAL_SELF_MANAGED. Not supported when
-- the backend service is referenced by a URL map that is bound to target
-- gRPC proxy that has validateForProxyless field set to true.
bsConsistentHash :: Lens' BackendService (Maybe ConsistentHashLoadBalancerSettings)
bsConsistentHash
  = lens _bsConsistentHash
      (\ s a -> s{_bsConsistentHash = a})

-- | The configurations for Identity-Aware Proxy on this resource. Not
-- available for Internal TCP\/UDP Load Balancing and Network Load
-- Balancing.
bsIap :: Lens' BackendService (Maybe BackendServiceIAP)
bsIap = lens _bsIap (\ s a -> s{_bsIap = a})

-- | Specifies the load balancer type. Choose EXTERNAL for external HTTP(S),
-- SSL Proxy, TCP Proxy and Network Load Balancing. Choose INTERNAL for
-- Internal TCP\/UDP Load Balancing. Choose INTERNAL_MANAGED for Internal
-- HTTP(S) Load Balancing. INTERNAL_SELF_MANAGED for Traffic Director. A
-- backend service created for one type of load balancer cannot be used
-- with another. For more information, refer to Choosing a load balancer.
bsLoadBalancingScheme :: Lens' BackendService (Maybe BackendServiceLoadBalancingScheme)
bsLoadBalancingScheme
  = lens _bsLoadBalancingScheme
      (\ s a -> s{_bsLoadBalancingScheme = a})

-- | [Output Only] Type of resource. Always compute#backendService for
-- backend services.
bsKind :: Lens' BackendService Text
bsKind = lens _bsKind (\ s a -> s{_bsKind = a})

-- | If true, enables Cloud CDN for the backend service. Only applicable if
-- the loadBalancingScheme is EXTERNAL and the protocol is HTTP or HTTPS.
bsEnableCDN :: Lens' BackendService (Maybe Bool)
bsEnableCDN
  = lens _bsEnableCDN (\ s a -> s{_bsEnableCDN = a})

bsCircuitBreakers :: Lens' BackendService (Maybe CircuitBreakers)
bsCircuitBreakers
  = lens _bsCircuitBreakers
      (\ s a -> s{_bsCircuitBreakers = a})

-- | Fingerprint of this resource. A hash of the contents stored in this
-- object. This field is used in optimistic locking. This field will be
-- ignored when inserting a BackendService. An up-to-date fingerprint must
-- be provided in order to update the BackendService, otherwise the request
-- will fail with error 412 conditionNotMet. To see the latest fingerprint,
-- make a get() request to retrieve a BackendService.
bsFingerprint :: Lens' BackendService (Maybe ByteString)
bsFingerprint
  = lens _bsFingerprint
      (\ s a -> s{_bsFingerprint = a})
      . mapping _Bytes

-- | This field specifies the security policy that applies to this backend
-- service. This field is applicable to either: - A regional backend
-- service with the service_protocol set to HTTP, HTTPS, or HTTP2, and
-- load_balancing_scheme set to INTERNAL_MANAGED. - A global backend
-- service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
bsSecuritySettings :: Lens' BackendService (Maybe SecuritySettings)
bsSecuritySettings
  = lens _bsSecuritySettings
      (\ s a -> s{_bsSecuritySettings = a})

-- | Settings controlling the eviction of unhealthy hosts from the load
-- balancing pool for the backend service. If not set, this feature is
-- considered disabled. This field is applicable to either: - A regional
-- backend service with the service_protocol set to HTTP, HTTPS, or HTTP2,
-- and load_balancing_scheme set to INTERNAL_MANAGED. - A global backend
-- service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED. Not
-- supported when the backend service is referenced by a URL map that is
-- bound to target gRPC proxy that has validateForProxyless field set to
-- true.
bsOutlierDetection :: Lens' BackendService (Maybe OutlierDetection)
bsOutlierDetection
  = lens _bsOutlierDetection
      (\ s a -> s{_bsOutlierDetection = a})

-- | The URL of the network to which this backend service belongs. This field
-- can only be specified when the load balancing scheme is set to INTERNAL.
bsNetwork :: Lens' BackendService (Maybe Text)
bsNetwork
  = lens _bsNetwork (\ s a -> s{_bsNetwork = a})

-- | The protocol this BackendService uses to communicate with backends.
-- Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC. depending
-- on the chosen load balancer or Traffic Director configuration. Refer to
-- the documentation for the load balancer or for Traffic Director for more
-- information. Must be set to GRPC when the backend service is referenced
-- by a URL map that is bound to target gRPC proxy.
bsProtocol :: Lens' BackendService (Maybe BackendServiceProtocol)
bsProtocol
  = lens _bsProtocol (\ s a -> s{_bsProtocol = a})

-- | Headers that the HTTP\/S load balancer should add to proxied requests.
bsCustomRequestHeaders :: Lens' BackendService [Text]
bsCustomRequestHeaders
  = lens _bsCustomRequestHeaders
      (\ s a -> s{_bsCustomRequestHeaders = a})
      . _Default
      . _Coerce

-- | [Output Only] The resource URL for the security policy associated with
-- this backend service.
bsSecurityPolicy :: Lens' BackendService (Maybe Text)
bsSecurityPolicy
  = lens _bsSecurityPolicy
      (\ s a -> s{_bsSecurityPolicy = a})

-- | Cloud CDN configuration for this BackendService. Only available for
-- external HTTP(S) Load Balancing.
bsCdnPolicy :: Lens' BackendService (Maybe BackendServiceCdnPolicy)
bsCdnPolicy
  = lens _bsCdnPolicy (\ s a -> s{_bsCdnPolicy = a})

-- | Headers that the HTTP\/S load balancer should add to proxied responses.
bsCustomResponseHeaders :: Lens' BackendService [Text]
bsCustomResponseHeaders
  = lens _bsCustomResponseHeaders
      (\ s a -> s{_bsCustomResponseHeaders = a})
      . _Default
      . _Coerce

-- | [Output Only] Server-defined URL for the resource.
bsSelfLink :: Lens' BackendService (Maybe Text)
bsSelfLink
  = lens _bsSelfLink (\ s a -> s{_bsSelfLink = a})

-- | Name of the resource. Provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
bsName :: Lens' BackendService (Maybe Text)
bsName = lens _bsName (\ s a -> s{_bsName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
bsCreationTimestamp :: Lens' BackendService (Maybe Text)
bsCreationTimestamp
  = lens _bsCreationTimestamp
      (\ s a -> s{_bsCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
bsId :: Lens' BackendService (Maybe Word64)
bsId
  = lens _bsId (\ s a -> s{_bsId = a}) .
      mapping _Coerce

-- | [Output Only] URL of the region where the regional backend service
-- resides. This field is not applicable to global backend services. You
-- must specify this field as part of the HTTP request URL. It is not
-- settable as a field in the request body.
bsRegion :: Lens' BackendService (Maybe Text)
bsRegion = lens _bsRegion (\ s a -> s{_bsRegion = a})

-- | Specifies the default maximum duration (timeout) for streams to this
-- service. Duration is computed from the beginning of the stream until the
-- response has been completely processed, including all retries. A stream
-- that does not complete in this duration is closed. If not specified,
-- there will be no timeout limit, i.e. the maximum duration is infinite.
-- This value can be overridden in the PathMatcher configuration of the
-- UrlMap that references this backend service. This field is only allowed
-- when the loadBalancingScheme of the backend service is
-- INTERNAL_SELF_MANAGED.
bsMaxStreamDuration :: Lens' BackendService (Maybe Duration)
bsMaxStreamDuration
  = lens _bsMaxStreamDuration
      (\ s a -> s{_bsMaxStreamDuration = a})

bsConnectionDraining :: Lens' BackendService (Maybe ConnectionDraining)
bsConnectionDraining
  = lens _bsConnectionDraining
      (\ s a -> s{_bsConnectionDraining = a})

-- | Not supported when the backend service is referenced by a URL map that
-- is bound to target gRPC proxy that has validateForProxyless field set to
-- true. Instead, use maxStreamDuration.
bsTimeoutSec :: Lens' BackendService (Maybe Int32)
bsTimeoutSec
  = lens _bsTimeoutSec (\ s a -> s{_bsTimeoutSec = a})
      . mapping _Coerce

-- | This field denotes the logging options for the load balancer traffic
-- served by this backend service. If logging is enabled, logs will be
-- exported to Stackdriver.
bsLogConfig :: Lens' BackendService (Maybe BackendServiceLogConfig)
bsLogConfig
  = lens _bsLogConfig (\ s a -> s{_bsLogConfig = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource.
bsDescription :: Lens' BackendService (Maybe Text)
bsDescription
  = lens _bsDescription
      (\ s a -> s{_bsDescription = a})

-- | A named port on a backend instance group representing the port for
-- communication to the backend VMs in that group. Required when the
-- loadBalancingScheme is EXTERNAL (except Network Load Balancing),
-- INTERNAL_MANAGED, or INTERNAL_SELF_MANAGED and the backends are instance
-- groups. The named port must be defined on each backend instance group.
-- This parameter has no meaning if the backends are NEGs. Backend services
-- for Internal TCP\/UDP Load Balancing and Network Load Balancing require
-- you omit port_name.
bsPortName :: Lens' BackendService (Maybe Text)
bsPortName
  = lens _bsPortName (\ s a -> s{_bsPortName = a})

-- | The list of URLs to the healthChecks, httpHealthChecks (legacy), or
-- httpsHealthChecks (legacy) resource for health checking this backend
-- service. Not all backend services support legacy health checks. See Load
-- balancer guide. Currently, at most one health check can be specified for
-- each backend service. Backend services with instance group or zonal NEG
-- backends must have a health check. Backend services with internet or
-- serverless NEG backends must not have a health check.
bsHealthChecks :: Lens' BackendService [Text]
bsHealthChecks
  = lens _bsHealthChecks
      (\ s a -> s{_bsHealthChecks = a})
      . _Default
      . _Coerce

-- | Deprecated in favor of portName. The TCP port to connect on the backend.
-- The default value is 80. Backend services for Internal TCP\/UDP Load
-- Balancing and Network Load Balancing require you omit port.
bsPort :: Lens' BackendService (Maybe Int32)
bsPort
  = lens _bsPort (\ s a -> s{_bsPort = a}) .
      mapping _Coerce

instance FromJSON BackendService where
        parseJSON
          = withObject "BackendService"
              (\ o ->
                 BackendService' <$>
                   (o .:? "sessionAffinity") <*>
                     (o .:? "failoverPolicy")
                     <*> (o .:? "backends" .!= mempty)
                     <*> (o .:? "localityLbPolicy")
                     <*> (o .:? "affinityCookieTtlSec")
                     <*> (o .:? "consistentHash")
                     <*> (o .:? "iap")
                     <*> (o .:? "loadBalancingScheme")
                     <*> (o .:? "kind" .!= "compute#backendService")
                     <*> (o .:? "enableCDN")
                     <*> (o .:? "circuitBreakers")
                     <*> (o .:? "fingerprint")
                     <*> (o .:? "securitySettings")
                     <*> (o .:? "outlierDetection")
                     <*> (o .:? "network")
                     <*> (o .:? "protocol")
                     <*> (o .:? "customRequestHeaders" .!= mempty)
                     <*> (o .:? "securityPolicy")
                     <*> (o .:? "cdnPolicy")
                     <*> (o .:? "customResponseHeaders" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "region")
                     <*> (o .:? "maxStreamDuration")
                     <*> (o .:? "connectionDraining")
                     <*> (o .:? "timeoutSec")
                     <*> (o .:? "logConfig")
                     <*> (o .:? "description")
                     <*> (o .:? "portName")
                     <*> (o .:? "healthChecks" .!= mempty)
                     <*> (o .:? "port"))

instance ToJSON BackendService where
        toJSON BackendService'{..}
          = object
              (catMaybes
                 [("sessionAffinity" .=) <$> _bsSessionAffinity,
                  ("failoverPolicy" .=) <$> _bsFailoverPolicy,
                  ("backends" .=) <$> _bsBackends,
                  ("localityLbPolicy" .=) <$> _bsLocalityLbPolicy,
                  ("affinityCookieTtlSec" .=) <$>
                    _bsAffinityCookieTtlSec,
                  ("consistentHash" .=) <$> _bsConsistentHash,
                  ("iap" .=) <$> _bsIap,
                  ("loadBalancingScheme" .=) <$>
                    _bsLoadBalancingScheme,
                  Just ("kind" .= _bsKind),
                  ("enableCDN" .=) <$> _bsEnableCDN,
                  ("circuitBreakers" .=) <$> _bsCircuitBreakers,
                  ("fingerprint" .=) <$> _bsFingerprint,
                  ("securitySettings" .=) <$> _bsSecuritySettings,
                  ("outlierDetection" .=) <$> _bsOutlierDetection,
                  ("network" .=) <$> _bsNetwork,
                  ("protocol" .=) <$> _bsProtocol,
                  ("customRequestHeaders" .=) <$>
                    _bsCustomRequestHeaders,
                  ("securityPolicy" .=) <$> _bsSecurityPolicy,
                  ("cdnPolicy" .=) <$> _bsCdnPolicy,
                  ("customResponseHeaders" .=) <$>
                    _bsCustomResponseHeaders,
                  ("selfLink" .=) <$> _bsSelfLink,
                  ("name" .=) <$> _bsName,
                  ("creationTimestamp" .=) <$> _bsCreationTimestamp,
                  ("id" .=) <$> _bsId, ("region" .=) <$> _bsRegion,
                  ("maxStreamDuration" .=) <$> _bsMaxStreamDuration,
                  ("connectionDraining" .=) <$> _bsConnectionDraining,
                  ("timeoutSec" .=) <$> _bsTimeoutSec,
                  ("logConfig" .=) <$> _bsLogConfig,
                  ("description" .=) <$> _bsDescription,
                  ("portName" .=) <$> _bsPortName,
                  ("healthChecks" .=) <$> _bsHealthChecks,
                  ("port" .=) <$> _bsPort])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'instanceListWarning' smart constructor.
data InstanceListWarning =
  InstanceListWarning'
    { _insData :: !(Maybe [InstanceListWarningDataItem])
    , _insCode :: !(Maybe InstanceListWarningCode)
    , _insMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'insData'
--
-- * 'insCode'
--
-- * 'insMessage'
instanceListWarning
    :: InstanceListWarning
instanceListWarning =
  InstanceListWarning'
    {_insData = Nothing, _insCode = Nothing, _insMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
insData :: Lens' InstanceListWarning [InstanceListWarningDataItem]
insData
  = lens _insData (\ s a -> s{_insData = a}) . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
insCode :: Lens' InstanceListWarning (Maybe InstanceListWarningCode)
insCode = lens _insCode (\ s a -> s{_insCode = a})

-- | [Output Only] A human-readable description of the warning code.
insMessage :: Lens' InstanceListWarning (Maybe Text)
insMessage
  = lens _insMessage (\ s a -> s{_insMessage = a})

instance FromJSON InstanceListWarning where
        parseJSON
          = withObject "InstanceListWarning"
              (\ o ->
                 InstanceListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON InstanceListWarning where
        toJSON InstanceListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _insData, ("code" .=) <$> _insCode,
                  ("message" .=) <$> _insMessage])

--
-- /See:/ 'instanceMoveRequest' smart constructor.
data InstanceMoveRequest =
  InstanceMoveRequest'
    { _imrTargetInstance :: !(Maybe Text)
    , _imrDestinationZone :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceMoveRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'imrTargetInstance'
--
-- * 'imrDestinationZone'
instanceMoveRequest
    :: InstanceMoveRequest
instanceMoveRequest =
  InstanceMoveRequest'
    {_imrTargetInstance = Nothing, _imrDestinationZone = Nothing}


-- | The URL of the target instance to move. This can be a full or partial
-- URL. For example, the following are all valid URLs to an instance: -
-- https:\/\/www.googleapis.com\/compute\/v1\/projects\/project\/zones\/zone\/instances\/instance
-- - projects\/project\/zones\/zone\/instances\/instance -
-- zones\/zone\/instances\/instance
imrTargetInstance :: Lens' InstanceMoveRequest (Maybe Text)
imrTargetInstance
  = lens _imrTargetInstance
      (\ s a -> s{_imrTargetInstance = a})

-- | The URL of the destination zone to move the instance. This can be a full
-- or partial URL. For example, the following are all valid URLs to a zone:
-- -
-- https:\/\/www.googleapis.com\/compute\/v1\/projects\/project\/zones\/zone
-- - projects\/project\/zones\/zone - zones\/zone
imrDestinationZone :: Lens' InstanceMoveRequest (Maybe Text)
imrDestinationZone
  = lens _imrDestinationZone
      (\ s a -> s{_imrDestinationZone = a})

instance FromJSON InstanceMoveRequest where
        parseJSON
          = withObject "InstanceMoveRequest"
              (\ o ->
                 InstanceMoveRequest' <$>
                   (o .:? "targetInstance") <*>
                     (o .:? "destinationZone"))

instance ToJSON InstanceMoveRequest where
        toJSON InstanceMoveRequest'{..}
          = object
              (catMaybes
                 [("targetInstance" .=) <$> _imrTargetInstance,
                  ("destinationZone" .=) <$> _imrDestinationZone])

--
-- /See:/ 'instanceManagedByIgmErrorInstanceActionDetails' smart constructor.
data InstanceManagedByIgmErrorInstanceActionDetails =
  InstanceManagedByIgmErrorInstanceActionDetails'
    { _imbieiadAction :: !(Maybe InstanceManagedByIgmErrorInstanceActionDetailsAction)
    , _imbieiadVersion :: !(Maybe ManagedInstanceVersion)
    , _imbieiadInstance :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceManagedByIgmErrorInstanceActionDetails' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'imbieiadAction'
--
-- * 'imbieiadVersion'
--
-- * 'imbieiadInstance'
instanceManagedByIgmErrorInstanceActionDetails
    :: InstanceManagedByIgmErrorInstanceActionDetails
instanceManagedByIgmErrorInstanceActionDetails =
  InstanceManagedByIgmErrorInstanceActionDetails'
    { _imbieiadAction = Nothing
    , _imbieiadVersion = Nothing
    , _imbieiadInstance = Nothing
    }


-- | [Output Only] Action that managed instance group was executing on the
-- instance when the error occurred. Possible values:
imbieiadAction :: Lens' InstanceManagedByIgmErrorInstanceActionDetails (Maybe InstanceManagedByIgmErrorInstanceActionDetailsAction)
imbieiadAction
  = lens _imbieiadAction
      (\ s a -> s{_imbieiadAction = a})

-- | [Output Only] Version this instance was created from, or was being
-- created from, but the creation failed. Corresponds to one of the
-- versions that were set on the Instance Group Manager resource at the
-- time this instance was being created.
imbieiadVersion :: Lens' InstanceManagedByIgmErrorInstanceActionDetails (Maybe ManagedInstanceVersion)
imbieiadVersion
  = lens _imbieiadVersion
      (\ s a -> s{_imbieiadVersion = a})

-- | [Output Only] The URL of the instance. The URL can be set even if the
-- instance has not yet been created.
imbieiadInstance :: Lens' InstanceManagedByIgmErrorInstanceActionDetails (Maybe Text)
imbieiadInstance
  = lens _imbieiadInstance
      (\ s a -> s{_imbieiadInstance = a})

instance FromJSON
           InstanceManagedByIgmErrorInstanceActionDetails
         where
        parseJSON
          = withObject
              "InstanceManagedByIgmErrorInstanceActionDetails"
              (\ o ->
                 InstanceManagedByIgmErrorInstanceActionDetails' <$>
                   (o .:? "action") <*> (o .:? "version") <*>
                     (o .:? "instance"))

instance ToJSON
           InstanceManagedByIgmErrorInstanceActionDetails
         where
        toJSON
          InstanceManagedByIgmErrorInstanceActionDetails'{..}
          = object
              (catMaybes
                 [("action" .=) <$> _imbieiadAction,
                  ("version" .=) <$> _imbieiadVersion,
                  ("instance" .=) <$> _imbieiadInstance])

--
-- /See:/ 'regionTargetHTTPSProxiesSetSSLCertificatesRequest' smart constructor.
newtype RegionTargetHTTPSProxiesSetSSLCertificatesRequest =
  RegionTargetHTTPSProxiesSetSSLCertificatesRequest'
    { _rthpsscrSSLCertificates :: Maybe [Text]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionTargetHTTPSProxiesSetSSLCertificatesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rthpsscrSSLCertificates'
regionTargetHTTPSProxiesSetSSLCertificatesRequest
    :: RegionTargetHTTPSProxiesSetSSLCertificatesRequest
regionTargetHTTPSProxiesSetSSLCertificatesRequest =
  RegionTargetHTTPSProxiesSetSSLCertificatesRequest'
    {_rthpsscrSSLCertificates = Nothing}


-- | New set of SslCertificate resources to associate with this
-- TargetHttpsProxy resource. Currently exactly one SslCertificate resource
-- must be specified.
rthpsscrSSLCertificates :: Lens' RegionTargetHTTPSProxiesSetSSLCertificatesRequest [Text]
rthpsscrSSLCertificates
  = lens _rthpsscrSSLCertificates
      (\ s a -> s{_rthpsscrSSLCertificates = a})
      . _Default
      . _Coerce

instance FromJSON
           RegionTargetHTTPSProxiesSetSSLCertificatesRequest
         where
        parseJSON
          = withObject
              "RegionTargetHTTPSProxiesSetSSLCertificatesRequest"
              (\ o ->
                 RegionTargetHTTPSProxiesSetSSLCertificatesRequest'
                   <$> (o .:? "sslCertificates" .!= mempty))

instance ToJSON
           RegionTargetHTTPSProxiesSetSSLCertificatesRequest
         where
        toJSON
          RegionTargetHTTPSProxiesSetSSLCertificatesRequest'{..}
          = object
              (catMaybes
                 [("sslCertificates" .=) <$>
                    _rthpsscrSSLCertificates])

-- | Describing the ARP neighbor entries seen on this link
--
-- /See:/ 'interconnectDiagnosticsARPEntry' smart constructor.
data InterconnectDiagnosticsARPEntry =
  InterconnectDiagnosticsARPEntry'
    { _idarpeIPAddress :: !(Maybe Text)
    , _idarpeMACAddress :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectDiagnosticsARPEntry' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'idarpeIPAddress'
--
-- * 'idarpeMACAddress'
interconnectDiagnosticsARPEntry
    :: InterconnectDiagnosticsARPEntry
interconnectDiagnosticsARPEntry =
  InterconnectDiagnosticsARPEntry'
    {_idarpeIPAddress = Nothing, _idarpeMACAddress = Nothing}


-- | The IP address of this ARP neighbor.
idarpeIPAddress :: Lens' InterconnectDiagnosticsARPEntry (Maybe Text)
idarpeIPAddress
  = lens _idarpeIPAddress
      (\ s a -> s{_idarpeIPAddress = a})

-- | The MAC address of this ARP neighbor.
idarpeMACAddress :: Lens' InterconnectDiagnosticsARPEntry (Maybe Text)
idarpeMACAddress
  = lens _idarpeMACAddress
      (\ s a -> s{_idarpeMACAddress = a})

instance FromJSON InterconnectDiagnosticsARPEntry
         where
        parseJSON
          = withObject "InterconnectDiagnosticsARPEntry"
              (\ o ->
                 InterconnectDiagnosticsARPEntry' <$>
                   (o .:? "ipAddress") <*> (o .:? "macAddress"))

instance ToJSON InterconnectDiagnosticsARPEntry where
        toJSON InterconnectDiagnosticsARPEntry'{..}
          = object
              (catMaybes
                 [("ipAddress" .=) <$> _idarpeIPAddress,
                  ("macAddress" .=) <$> _idarpeMACAddress])

-- | A shielded Instance identity entry.
--
-- /See:/ 'shieldedInstanceIdentity' smart constructor.
data ShieldedInstanceIdentity =
  ShieldedInstanceIdentity'
    { _siiSigningKey :: !(Maybe ShieldedInstanceIdentityEntry)
    , _siiKind :: !Text
    , _siiEncryptionKey :: !(Maybe ShieldedInstanceIdentityEntry)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'ShieldedInstanceIdentity' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'siiSigningKey'
--
-- * 'siiKind'
--
-- * 'siiEncryptionKey'
shieldedInstanceIdentity
    :: ShieldedInstanceIdentity
shieldedInstanceIdentity =
  ShieldedInstanceIdentity'
    { _siiSigningKey = Nothing
    , _siiKind = "compute#shieldedInstanceIdentity"
    , _siiEncryptionKey = Nothing
    }


-- | An Attestation Key (AK) made by the RSA 2048 algorithm issued to the
-- Shielded Instance\'s vTPM.
siiSigningKey :: Lens' ShieldedInstanceIdentity (Maybe ShieldedInstanceIdentityEntry)
siiSigningKey
  = lens _siiSigningKey
      (\ s a -> s{_siiSigningKey = a})

-- | [Output Only] Type of the resource. Always
-- compute#shieldedInstanceIdentity for shielded Instance identity entry.
siiKind :: Lens' ShieldedInstanceIdentity Text
siiKind = lens _siiKind (\ s a -> s{_siiKind = a})

-- | An Endorsement Key (EK) made by the RSA 2048 algorithm issued to the
-- Shielded Instance\'s vTPM.
siiEncryptionKey :: Lens' ShieldedInstanceIdentity (Maybe ShieldedInstanceIdentityEntry)
siiEncryptionKey
  = lens _siiEncryptionKey
      (\ s a -> s{_siiEncryptionKey = a})

instance FromJSON ShieldedInstanceIdentity where
        parseJSON
          = withObject "ShieldedInstanceIdentity"
              (\ o ->
                 ShieldedInstanceIdentity' <$>
                   (o .:? "signingKey") <*>
                     (o .:? "kind" .!= "compute#shieldedInstanceIdentity")
                     <*> (o .:? "encryptionKey"))

instance ToJSON ShieldedInstanceIdentity where
        toJSON ShieldedInstanceIdentity'{..}
          = object
              (catMaybes
                 [("signingKey" .=) <$> _siiSigningKey,
                  Just ("kind" .= _siiKind),
                  ("encryptionKey" .=) <$> _siiEncryptionKey])

-- | [Output only] Detailed statuses of the domains specified for managed
-- certificate resource.
--
-- /See:/ 'sslCertificateManagedSSLCertificateDomainStatus' smart constructor.
newtype SSLCertificateManagedSSLCertificateDomainStatus =
  SSLCertificateManagedSSLCertificateDomainStatus'
    { _scmscdsAddtional :: HashMap Text SSLCertificateManagedSSLCertificateDomainStatusAdditional
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'SSLCertificateManagedSSLCertificateDomainStatus' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'scmscdsAddtional'
sslCertificateManagedSSLCertificateDomainStatus
    :: HashMap Text SSLCertificateManagedSSLCertificateDomainStatusAdditional -- ^ 'scmscdsAddtional'
    -> SSLCertificateManagedSSLCertificateDomainStatus
sslCertificateManagedSSLCertificateDomainStatus pScmscdsAddtional_ =
  SSLCertificateManagedSSLCertificateDomainStatus'
    {_scmscdsAddtional = _Coerce # pScmscdsAddtional_}


scmscdsAddtional :: Lens' SSLCertificateManagedSSLCertificateDomainStatus (HashMap Text SSLCertificateManagedSSLCertificateDomainStatusAdditional)
scmscdsAddtional
  = lens _scmscdsAddtional
      (\ s a -> s{_scmscdsAddtional = a})
      . _Coerce

instance FromJSON
           SSLCertificateManagedSSLCertificateDomainStatus
         where
        parseJSON
          = withObject
              "SSLCertificateManagedSSLCertificateDomainStatus"
              (\ o ->
                 SSLCertificateManagedSSLCertificateDomainStatus' <$>
                   (parseJSONObject o))

instance ToJSON
           SSLCertificateManagedSSLCertificateDomainStatus
         where
        toJSON = toJSON . _scmscdsAddtional

-- | Contains a list of Commitment resources.
--
-- /See:/ 'commitmentList' smart constructor.
data CommitmentList =
  CommitmentList'
    { _clNextPageToken :: !(Maybe Text)
    , _clKind :: !Text
    , _clItems :: !(Maybe [Commitment])
    , _clSelfLink :: !(Maybe Text)
    , _clWarning :: !(Maybe CommitmentListWarning)
    , _clId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'CommitmentList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'clNextPageToken'
--
-- * 'clKind'
--
-- * 'clItems'
--
-- * 'clSelfLink'
--
-- * 'clWarning'
--
-- * 'clId'
commitmentList
    :: CommitmentList
commitmentList =
  CommitmentList'
    { _clNextPageToken = Nothing
    , _clKind = "compute#commitmentList"
    , _clItems = Nothing
    , _clSelfLink = Nothing
    , _clWarning = Nothing
    , _clId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
clNextPageToken :: Lens' CommitmentList (Maybe Text)
clNextPageToken
  = lens _clNextPageToken
      (\ s a -> s{_clNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#commitmentList for lists
-- of commitments.
clKind :: Lens' CommitmentList Text
clKind = lens _clKind (\ s a -> s{_clKind = a})

-- | A list of Commitment resources.
clItems :: Lens' CommitmentList [Commitment]
clItems
  = lens _clItems (\ s a -> s{_clItems = a}) . _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
clSelfLink :: Lens' CommitmentList (Maybe Text)
clSelfLink
  = lens _clSelfLink (\ s a -> s{_clSelfLink = a})

-- | [Output Only] Informational warning message.
clWarning :: Lens' CommitmentList (Maybe CommitmentListWarning)
clWarning
  = lens _clWarning (\ s a -> s{_clWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
clId :: Lens' CommitmentList (Maybe Text)
clId = lens _clId (\ s a -> s{_clId = a})

instance FromJSON CommitmentList where
        parseJSON
          = withObject "CommitmentList"
              (\ o ->
                 CommitmentList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#commitmentList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON CommitmentList where
        toJSON CommitmentList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _clNextPageToken,
                  Just ("kind" .= _clKind), ("items" .=) <$> _clItems,
                  ("selfLink" .=) <$> _clSelfLink,
                  ("warning" .=) <$> _clWarning, ("id" .=) <$> _clId])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'packetMirroringListWarning' smart constructor.
data PacketMirroringListWarning =
  PacketMirroringListWarning'
    { _pmlwData :: !(Maybe [PacketMirroringListWarningDataItem])
    , _pmlwCode :: !(Maybe PacketMirroringListWarningCode)
    , _pmlwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PacketMirroringListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pmlwData'
--
-- * 'pmlwCode'
--
-- * 'pmlwMessage'
packetMirroringListWarning
    :: PacketMirroringListWarning
packetMirroringListWarning =
  PacketMirroringListWarning'
    {_pmlwData = Nothing, _pmlwCode = Nothing, _pmlwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
pmlwData :: Lens' PacketMirroringListWarning [PacketMirroringListWarningDataItem]
pmlwData
  = lens _pmlwData (\ s a -> s{_pmlwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
pmlwCode :: Lens' PacketMirroringListWarning (Maybe PacketMirroringListWarningCode)
pmlwCode = lens _pmlwCode (\ s a -> s{_pmlwCode = a})

-- | [Output Only] A human-readable description of the warning code.
pmlwMessage :: Lens' PacketMirroringListWarning (Maybe Text)
pmlwMessage
  = lens _pmlwMessage (\ s a -> s{_pmlwMessage = a})

instance FromJSON PacketMirroringListWarning where
        parseJSON
          = withObject "PacketMirroringListWarning"
              (\ o ->
                 PacketMirroringListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON PacketMirroringListWarning where
        toJSON PacketMirroringListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _pmlwData,
                  ("code" .=) <$> _pmlwCode,
                  ("message" .=) <$> _pmlwMessage])

--
-- /See:/ 'firewallPolicyRuleMatcherLayer4Config' smart constructor.
data FirewallPolicyRuleMatcherLayer4Config =
  FirewallPolicyRuleMatcherLayer4Config'
    { _fprmlcIPProtocol :: !(Maybe Text)
    , _fprmlcPorts :: !(Maybe [Text])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'FirewallPolicyRuleMatcherLayer4Config' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'fprmlcIPProtocol'
--
-- * 'fprmlcPorts'
firewallPolicyRuleMatcherLayer4Config
    :: FirewallPolicyRuleMatcherLayer4Config
firewallPolicyRuleMatcherLayer4Config =
  FirewallPolicyRuleMatcherLayer4Config'
    {_fprmlcIPProtocol = Nothing, _fprmlcPorts = Nothing}


-- | The IP protocol to which this rule applies. The protocol type is
-- required when creating a firewall rule. This value can either be one of
-- the following well known protocol strings (tcp, udp, icmp, esp, ah,
-- ipip, sctp), or the IP protocol number.
fprmlcIPProtocol :: Lens' FirewallPolicyRuleMatcherLayer4Config (Maybe Text)
fprmlcIPProtocol
  = lens _fprmlcIPProtocol
      (\ s a -> s{_fprmlcIPProtocol = a})

-- | An optional list of ports to which this rule applies. This field is only
-- applicable for UDP or TCP protocol. Each entry must be either an integer
-- or a range. If not specified, this rule applies to connections through
-- any port. Example inputs include: [\"22\"], [\"80\",\"443\"], and
-- [\"12345-12349\"].
fprmlcPorts :: Lens' FirewallPolicyRuleMatcherLayer4Config [Text]
fprmlcPorts
  = lens _fprmlcPorts (\ s a -> s{_fprmlcPorts = a}) .
      _Default
      . _Coerce

instance FromJSON
           FirewallPolicyRuleMatcherLayer4Config
         where
        parseJSON
          = withObject "FirewallPolicyRuleMatcherLayer4Config"
              (\ o ->
                 FirewallPolicyRuleMatcherLayer4Config' <$>
                   (o .:? "ipProtocol") <*> (o .:? "ports" .!= mempty))

instance ToJSON FirewallPolicyRuleMatcherLayer4Config
         where
        toJSON FirewallPolicyRuleMatcherLayer4Config'{..}
          = object
              (catMaybes
                 [("ipProtocol" .=) <$> _fprmlcIPProtocol,
                  ("ports" .=) <$> _fprmlcPorts])

-- | InstanceGroupManagers.createInstances
--
-- /See:/ 'instanceGroupManagersCreateInstancesRequest' smart constructor.
newtype InstanceGroupManagersCreateInstancesRequest =
  InstanceGroupManagersCreateInstancesRequest'
    { _igmcirInstances :: Maybe [PerInstanceConfig]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagersCreateInstancesRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmcirInstances'
instanceGroupManagersCreateInstancesRequest
    :: InstanceGroupManagersCreateInstancesRequest
instanceGroupManagersCreateInstancesRequest =
  InstanceGroupManagersCreateInstancesRequest' {_igmcirInstances = Nothing}


-- | [Required] List of specifications of per-instance configs.
igmcirInstances :: Lens' InstanceGroupManagersCreateInstancesRequest [PerInstanceConfig]
igmcirInstances
  = lens _igmcirInstances
      (\ s a -> s{_igmcirInstances = a})
      . _Default
      . _Coerce

instance FromJSON
           InstanceGroupManagersCreateInstancesRequest
         where
        parseJSON
          = withObject
              "InstanceGroupManagersCreateInstancesRequest"
              (\ o ->
                 InstanceGroupManagersCreateInstancesRequest' <$>
                   (o .:? "instances" .!= mempty))

instance ToJSON
           InstanceGroupManagersCreateInstancesRequest
         where
        toJSON
          InstanceGroupManagersCreateInstancesRequest'{..}
          = object
              (catMaybes [("instances" .=) <$> _igmcirInstances])

--
-- /See:/ 'instancesSetLabelsRequestLabels' smart constructor.
newtype InstancesSetLabelsRequestLabels =
  InstancesSetLabelsRequestLabels'
    { _islrlAddtional :: HashMap Text Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstancesSetLabelsRequestLabels' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'islrlAddtional'
instancesSetLabelsRequestLabels
    :: HashMap Text Text -- ^ 'islrlAddtional'
    -> InstancesSetLabelsRequestLabels
instancesSetLabelsRequestLabels pIslrlAddtional_ =
  InstancesSetLabelsRequestLabels'
    {_islrlAddtional = _Coerce # pIslrlAddtional_}


islrlAddtional :: Lens' InstancesSetLabelsRequestLabels (HashMap Text Text)
islrlAddtional
  = lens _islrlAddtional
      (\ s a -> s{_islrlAddtional = a})
      . _Coerce

instance FromJSON InstancesSetLabelsRequestLabels
         where
        parseJSON
          = withObject "InstancesSetLabelsRequestLabels"
              (\ o ->
                 InstancesSetLabelsRequestLabels' <$>
                   (parseJSONObject o))

instance ToJSON InstancesSetLabelsRequestLabels where
        toJSON = toJSON . _islrlAddtional

--
-- /See:/ 'instanceGroupsScopedList' smart constructor.
data InstanceGroupsScopedList =
  InstanceGroupsScopedList'
    { _igslWarning :: !(Maybe InstanceGroupsScopedListWarning)
    , _igslInstanceGroups :: !(Maybe [InstanceGroup])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupsScopedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igslWarning'
--
-- * 'igslInstanceGroups'
instanceGroupsScopedList
    :: InstanceGroupsScopedList
instanceGroupsScopedList =
  InstanceGroupsScopedList'
    {_igslWarning = Nothing, _igslInstanceGroups = Nothing}


-- | [Output Only] An informational warning that replaces the list of
-- instance groups when the list is empty.
igslWarning :: Lens' InstanceGroupsScopedList (Maybe InstanceGroupsScopedListWarning)
igslWarning
  = lens _igslWarning (\ s a -> s{_igslWarning = a})

-- | [Output Only] The list of instance groups that are contained in this
-- scope.
igslInstanceGroups :: Lens' InstanceGroupsScopedList [InstanceGroup]
igslInstanceGroups
  = lens _igslInstanceGroups
      (\ s a -> s{_igslInstanceGroups = a})
      . _Default
      . _Coerce

instance FromJSON InstanceGroupsScopedList where
        parseJSON
          = withObject "InstanceGroupsScopedList"
              (\ o ->
                 InstanceGroupsScopedList' <$>
                   (o .:? "warning") <*>
                     (o .:? "instanceGroups" .!= mempty))

instance ToJSON InstanceGroupsScopedList where
        toJSON InstanceGroupsScopedList'{..}
          = object
              (catMaybes
                 [("warning" .=) <$> _igslWarning,
                  ("instanceGroups" .=) <$> _igslInstanceGroups])

--
-- /See:/ 'instancesStartWithEncryptionKeyRequest' smart constructor.
newtype InstancesStartWithEncryptionKeyRequest =
  InstancesStartWithEncryptionKeyRequest'
    { _iswekrDisks :: Maybe [CustomerEncryptionKeyProtectedDisk]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstancesStartWithEncryptionKeyRequest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'iswekrDisks'
instancesStartWithEncryptionKeyRequest
    :: InstancesStartWithEncryptionKeyRequest
instancesStartWithEncryptionKeyRequest =
  InstancesStartWithEncryptionKeyRequest' {_iswekrDisks = Nothing}


-- | Array of disks associated with this instance that are protected with a
-- customer-supplied encryption key. In order to start the instance, the
-- disk url and its corresponding key must be provided. If the disk is not
-- protected with a customer-supplied encryption key it should not be
-- specified.
iswekrDisks :: Lens' InstancesStartWithEncryptionKeyRequest [CustomerEncryptionKeyProtectedDisk]
iswekrDisks
  = lens _iswekrDisks (\ s a -> s{_iswekrDisks = a}) .
      _Default
      . _Coerce

instance FromJSON
           InstancesStartWithEncryptionKeyRequest
         where
        parseJSON
          = withObject "InstancesStartWithEncryptionKeyRequest"
              (\ o ->
                 InstancesStartWithEncryptionKeyRequest' <$>
                   (o .:? "disks" .!= mempty))

instance ToJSON
           InstancesStartWithEncryptionKeyRequest
         where
        toJSON InstancesStartWithEncryptionKeyRequest'{..}
          = object (catMaybes [("disks" .=) <$> _iswekrDisks])

--
-- /See:/ 'httpsHealthCheck' smart constructor.
data HTTPSHealthCheck =
  HTTPSHealthCheck'
    { _hhcResponse :: !(Maybe Text)
    , _hhcPortSpecification :: !(Maybe HTTPSHealthCheckPortSpecification)
    , _hhcRequestPath :: !(Maybe Text)
    , _hhcHost :: !(Maybe Text)
    , _hhcProxyHeader :: !(Maybe HTTPSHealthCheckProxyHeader)
    , _hhcPortName :: !(Maybe Text)
    , _hhcPort :: !(Maybe (Textual Int32))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HTTPSHealthCheck' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hhcResponse'
--
-- * 'hhcPortSpecification'
--
-- * 'hhcRequestPath'
--
-- * 'hhcHost'
--
-- * 'hhcProxyHeader'
--
-- * 'hhcPortName'
--
-- * 'hhcPort'
httpsHealthCheck
    :: HTTPSHealthCheck
httpsHealthCheck =
  HTTPSHealthCheck'
    { _hhcResponse = Nothing
    , _hhcPortSpecification = Nothing
    , _hhcRequestPath = Nothing
    , _hhcHost = Nothing
    , _hhcProxyHeader = Nothing
    , _hhcPortName = Nothing
    , _hhcPort = Nothing
    }


-- | The string to match anywhere in the first 1024 bytes of the response
-- body. If left empty (the default value), the status code determines
-- health. The response data can only be ASCII.
hhcResponse :: Lens' HTTPSHealthCheck (Maybe Text)
hhcResponse
  = lens _hhcResponse (\ s a -> s{_hhcResponse = a})

-- | Specifies how port is selected for health checking, can be one of
-- following values: USE_FIXED_PORT: The port number in port is used for
-- health checking. USE_NAMED_PORT: The portName is used for health
-- checking. USE_SERVING_PORT: For NetworkEndpointGroup, the port specified
-- for each network endpoint is used for health checking. For other
-- backends, the port or named port specified in the Backend Service is
-- used for health checking. If not specified, HTTPS health check follows
-- behavior specified in port and portName fields.
hhcPortSpecification :: Lens' HTTPSHealthCheck (Maybe HTTPSHealthCheckPortSpecification)
hhcPortSpecification
  = lens _hhcPortSpecification
      (\ s a -> s{_hhcPortSpecification = a})

-- | The request path of the HTTPS health check request. The default value is
-- \/.
hhcRequestPath :: Lens' HTTPSHealthCheck (Maybe Text)
hhcRequestPath
  = lens _hhcRequestPath
      (\ s a -> s{_hhcRequestPath = a})

-- | The value of the host header in the HTTPS health check request. If left
-- empty (default value), the IP on behalf of which this health check is
-- performed will be used.
hhcHost :: Lens' HTTPSHealthCheck (Maybe Text)
hhcHost = lens _hhcHost (\ s a -> s{_hhcHost = a})

-- | Specifies the type of proxy header to append before sending data to the
-- backend, either NONE or PROXY_V1. The default is NONE.
hhcProxyHeader :: Lens' HTTPSHealthCheck (Maybe HTTPSHealthCheckProxyHeader)
hhcProxyHeader
  = lens _hhcProxyHeader
      (\ s a -> s{_hhcProxyHeader = a})

-- | Port name as defined in InstanceGroup#NamedPort#name. If both port and
-- port_name are defined, port takes precedence.
hhcPortName :: Lens' HTTPSHealthCheck (Maybe Text)
hhcPortName
  = lens _hhcPortName (\ s a -> s{_hhcPortName = a})

-- | The TCP port number for the health check request. The default value is
-- 443. Valid values are 1 through 65535.
hhcPort :: Lens' HTTPSHealthCheck (Maybe Int32)
hhcPort
  = lens _hhcPort (\ s a -> s{_hhcPort = a}) .
      mapping _Coerce

instance FromJSON HTTPSHealthCheck where
        parseJSON
          = withObject "HTTPSHealthCheck"
              (\ o ->
                 HTTPSHealthCheck' <$>
                   (o .:? "response") <*> (o .:? "portSpecification")
                     <*> (o .:? "requestPath")
                     <*> (o .:? "host")
                     <*> (o .:? "proxyHeader")
                     <*> (o .:? "portName")
                     <*> (o .:? "port"))

instance ToJSON HTTPSHealthCheck where
        toJSON HTTPSHealthCheck'{..}
          = object
              (catMaybes
                 [("response" .=) <$> _hhcResponse,
                  ("portSpecification" .=) <$> _hhcPortSpecification,
                  ("requestPath" .=) <$> _hhcRequestPath,
                  ("host" .=) <$> _hhcHost,
                  ("proxyHeader" .=) <$> _hhcProxyHeader,
                  ("portName" .=) <$> _hhcPortName,
                  ("port" .=) <$> _hhcPort])

-- | The request and response header transformations that take effect before
-- the request is passed along to the selected backendService.
--
-- /See:/ 'hTTPHeaderAction' smart constructor.
data HTTPHeaderAction =
  HTTPHeaderAction'
    { _httphaResponseHeadersToAdd :: !(Maybe [HTTPHeaderOption])
    , _httphaRequestHeadersToRemove :: !(Maybe [Text])
    , _httphaRequestHeadersToAdd :: !(Maybe [HTTPHeaderOption])
    , _httphaResponseHeadersToRemove :: !(Maybe [Text])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HTTPHeaderAction' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'httphaResponseHeadersToAdd'
--
-- * 'httphaRequestHeadersToRemove'
--
-- * 'httphaRequestHeadersToAdd'
--
-- * 'httphaResponseHeadersToRemove'
hTTPHeaderAction
    :: HTTPHeaderAction
hTTPHeaderAction =
  HTTPHeaderAction'
    { _httphaResponseHeadersToAdd = Nothing
    , _httphaRequestHeadersToRemove = Nothing
    , _httphaRequestHeadersToAdd = Nothing
    , _httphaResponseHeadersToRemove = Nothing
    }


-- | Headers to add the response prior to sending the response back to the
-- client.
httphaResponseHeadersToAdd :: Lens' HTTPHeaderAction [HTTPHeaderOption]
httphaResponseHeadersToAdd
  = lens _httphaResponseHeadersToAdd
      (\ s a -> s{_httphaResponseHeadersToAdd = a})
      . _Default
      . _Coerce

-- | A list of header names for headers that need to be removed from the
-- request prior to forwarding the request to the backendService.
httphaRequestHeadersToRemove :: Lens' HTTPHeaderAction [Text]
httphaRequestHeadersToRemove
  = lens _httphaRequestHeadersToRemove
      (\ s a -> s{_httphaRequestHeadersToRemove = a})
      . _Default
      . _Coerce

-- | Headers to add to a matching request prior to forwarding the request to
-- the backendService.
httphaRequestHeadersToAdd :: Lens' HTTPHeaderAction [HTTPHeaderOption]
httphaRequestHeadersToAdd
  = lens _httphaRequestHeadersToAdd
      (\ s a -> s{_httphaRequestHeadersToAdd = a})
      . _Default
      . _Coerce

-- | A list of header names for headers that need to be removed from the
-- response prior to sending the response back to the client.
httphaResponseHeadersToRemove :: Lens' HTTPHeaderAction [Text]
httphaResponseHeadersToRemove
  = lens _httphaResponseHeadersToRemove
      (\ s a -> s{_httphaResponseHeadersToRemove = a})
      . _Default
      . _Coerce

instance FromJSON HTTPHeaderAction where
        parseJSON
          = withObject "HTTPHeaderAction"
              (\ o ->
                 HTTPHeaderAction' <$>
                   (o .:? "responseHeadersToAdd" .!= mempty) <*>
                     (o .:? "requestHeadersToRemove" .!= mempty)
                     <*> (o .:? "requestHeadersToAdd" .!= mempty)
                     <*> (o .:? "responseHeadersToRemove" .!= mempty))

instance ToJSON HTTPHeaderAction where
        toJSON HTTPHeaderAction'{..}
          = object
              (catMaybes
                 [("responseHeadersToAdd" .=) <$>
                    _httphaResponseHeadersToAdd,
                  ("requestHeadersToRemove" .=) <$>
                    _httphaRequestHeadersToRemove,
                  ("requestHeadersToAdd" .=) <$>
                    _httphaRequestHeadersToAdd,
                  ("responseHeadersToRemove" .=) <$>
                    _httphaResponseHeadersToRemove])

--
-- /See:/ 'targetGrpcProxyList' smart constructor.
data TargetGrpcProxyList =
  TargetGrpcProxyList'
    { _tgplNextPageToken :: !(Maybe Text)
    , _tgplKind :: !Text
    , _tgplItems :: !(Maybe [TargetGrpcProxy])
    , _tgplSelfLink :: !(Maybe Text)
    , _tgplWarning :: !(Maybe TargetGrpcProxyListWarning)
    , _tgplId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'TargetGrpcProxyList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tgplNextPageToken'
--
-- * 'tgplKind'
--
-- * 'tgplItems'
--
-- * 'tgplSelfLink'
--
-- * 'tgplWarning'
--
-- * 'tgplId'
targetGrpcProxyList
    :: TargetGrpcProxyList
targetGrpcProxyList =
  TargetGrpcProxyList'
    { _tgplNextPageToken = Nothing
    , _tgplKind = "compute#targetGrpcProxyList"
    , _tgplItems = Nothing
    , _tgplSelfLink = Nothing
    , _tgplWarning = Nothing
    , _tgplId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
tgplNextPageToken :: Lens' TargetGrpcProxyList (Maybe Text)
tgplNextPageToken
  = lens _tgplNextPageToken
      (\ s a -> s{_tgplNextPageToken = a})

-- | [Output Only] Type of the resource. Always compute#targetGrpcProxy for
-- target grpc proxies.
tgplKind :: Lens' TargetGrpcProxyList Text
tgplKind = lens _tgplKind (\ s a -> s{_tgplKind = a})

-- | A list of TargetGrpcProxy resources.
tgplItems :: Lens' TargetGrpcProxyList [TargetGrpcProxy]
tgplItems
  = lens _tgplItems (\ s a -> s{_tgplItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
tgplSelfLink :: Lens' TargetGrpcProxyList (Maybe Text)
tgplSelfLink
  = lens _tgplSelfLink (\ s a -> s{_tgplSelfLink = a})

-- | [Output Only] Informational warning message.
tgplWarning :: Lens' TargetGrpcProxyList (Maybe TargetGrpcProxyListWarning)
tgplWarning
  = lens _tgplWarning (\ s a -> s{_tgplWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
tgplId :: Lens' TargetGrpcProxyList (Maybe Text)
tgplId = lens _tgplId (\ s a -> s{_tgplId = a})

instance FromJSON TargetGrpcProxyList where
        parseJSON
          = withObject "TargetGrpcProxyList"
              (\ o ->
                 TargetGrpcProxyList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!= "compute#targetGrpcProxyList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON TargetGrpcProxyList where
        toJSON TargetGrpcProxyList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _tgplNextPageToken,
                  Just ("kind" .= _tgplKind),
                  ("items" .=) <$> _tgplItems,
                  ("selfLink" .=) <$> _tgplSelfLink,
                  ("warning" .=) <$> _tgplWarning,
                  ("id" .=) <$> _tgplId])

-- | [Output Only] Status information of existing scaling schedules.
--
-- /See:/ 'autoscalerScalingScheduleStatus' smart constructor.
newtype AutoscalerScalingScheduleStatus =
  AutoscalerScalingScheduleStatus'
    { _asssAddtional :: HashMap Text ScalingScheduleStatus
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AutoscalerScalingScheduleStatus' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'asssAddtional'
autoscalerScalingScheduleStatus
    :: HashMap Text ScalingScheduleStatus -- ^ 'asssAddtional'
    -> AutoscalerScalingScheduleStatus
autoscalerScalingScheduleStatus pAsssAddtional_ =
  AutoscalerScalingScheduleStatus' {_asssAddtional = _Coerce # pAsssAddtional_}


asssAddtional :: Lens' AutoscalerScalingScheduleStatus (HashMap Text ScalingScheduleStatus)
asssAddtional
  = lens _asssAddtional
      (\ s a -> s{_asssAddtional = a})
      . _Coerce

instance FromJSON AutoscalerScalingScheduleStatus
         where
        parseJSON
          = withObject "AutoscalerScalingScheduleStatus"
              (\ o ->
                 AutoscalerScalingScheduleStatus' <$>
                   (parseJSONObject o))

instance ToJSON AutoscalerScalingScheduleStatus where
        toJSON = toJSON . _asssAddtional

-- | A list of VpnTunnelsScopedList resources.
--
-- /See:/ 'vpnTunnelAggregatedListItems' smart constructor.
newtype VPNTunnelAggregatedListItems =
  VPNTunnelAggregatedListItems'
    { _vtaliAddtional :: HashMap Text VPNTunnelsScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNTunnelAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vtaliAddtional'
vpnTunnelAggregatedListItems
    :: HashMap Text VPNTunnelsScopedList -- ^ 'vtaliAddtional'
    -> VPNTunnelAggregatedListItems
vpnTunnelAggregatedListItems pVtaliAddtional_ =
  VPNTunnelAggregatedListItems' {_vtaliAddtional = _Coerce # pVtaliAddtional_}


-- | Name of the scope containing this set of VPN tunnels.
vtaliAddtional :: Lens' VPNTunnelAggregatedListItems (HashMap Text VPNTunnelsScopedList)
vtaliAddtional
  = lens _vtaliAddtional
      (\ s a -> s{_vtaliAddtional = a})
      . _Coerce

instance FromJSON VPNTunnelAggregatedListItems where
        parseJSON
          = withObject "VPNTunnelAggregatedListItems"
              (\ o ->
                 VPNTunnelAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON VPNTunnelAggregatedListItems where
        toJSON = toJSON . _vtaliAddtional

--
-- /See:/ 'instanceAggregatedListWarningDataItem' smart constructor.
data InstanceAggregatedListWarningDataItem =
  InstanceAggregatedListWarningDataItem'
    { _insValue :: !(Maybe Text)
    , _insKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'insValue'
--
-- * 'insKey'
instanceAggregatedListWarningDataItem
    :: InstanceAggregatedListWarningDataItem
instanceAggregatedListWarningDataItem =
  InstanceAggregatedListWarningDataItem'
    {_insValue = Nothing, _insKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
insValue :: Lens' InstanceAggregatedListWarningDataItem (Maybe Text)
insValue = lens _insValue (\ s a -> s{_insValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
insKey :: Lens' InstanceAggregatedListWarningDataItem (Maybe Text)
insKey = lens _insKey (\ s a -> s{_insKey = a})

instance FromJSON
           InstanceAggregatedListWarningDataItem
         where
        parseJSON
          = withObject "InstanceAggregatedListWarningDataItem"
              (\ o ->
                 InstanceAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON InstanceAggregatedListWarningDataItem
         where
        toJSON InstanceAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _insValue, ("key" .=) <$> _insKey])

-- | RegionInstanceGroupManagers.updatePerInstanceConfigs
--
-- /See:/ 'regionInstanceGroupManagerUpdateInstanceConfigReq' smart constructor.
newtype RegionInstanceGroupManagerUpdateInstanceConfigReq =
  RegionInstanceGroupManagerUpdateInstanceConfigReq'
    { _rigmuicrPerInstanceConfigs :: Maybe [PerInstanceConfig]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RegionInstanceGroupManagerUpdateInstanceConfigReq' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rigmuicrPerInstanceConfigs'
regionInstanceGroupManagerUpdateInstanceConfigReq
    :: RegionInstanceGroupManagerUpdateInstanceConfigReq
regionInstanceGroupManagerUpdateInstanceConfigReq =
  RegionInstanceGroupManagerUpdateInstanceConfigReq'
    {_rigmuicrPerInstanceConfigs = Nothing}


-- | The list of per-instance configs to insert or patch on this managed
-- instance group.
rigmuicrPerInstanceConfigs :: Lens' RegionInstanceGroupManagerUpdateInstanceConfigReq [PerInstanceConfig]
rigmuicrPerInstanceConfigs
  = lens _rigmuicrPerInstanceConfigs
      (\ s a -> s{_rigmuicrPerInstanceConfigs = a})
      . _Default
      . _Coerce

instance FromJSON
           RegionInstanceGroupManagerUpdateInstanceConfigReq
         where
        parseJSON
          = withObject
              "RegionInstanceGroupManagerUpdateInstanceConfigReq"
              (\ o ->
                 RegionInstanceGroupManagerUpdateInstanceConfigReq'
                   <$> (o .:? "perInstanceConfigs" .!= mempty))

instance ToJSON
           RegionInstanceGroupManagerUpdateInstanceConfigReq
         where
        toJSON
          RegionInstanceGroupManagerUpdateInstanceConfigReq'{..}
          = object
              (catMaybes
                 [("perInstanceConfigs" .=) <$>
                    _rigmuicrPerInstanceConfigs])

-- | A set of instance tags.
--
-- /See:/ 'tags' smart constructor.
data Tags =
  Tags'
    { _tFingerprint :: !(Maybe Bytes)
    , _tItems :: !(Maybe [Text])
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Tags' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'tFingerprint'
--
-- * 'tItems'
tags
    :: Tags
tags = Tags' {_tFingerprint = Nothing, _tItems = Nothing}


-- | Specifies a fingerprint for this request, which is essentially a hash of
-- the tags\' contents and used for optimistic locking. The fingerprint is
-- initially generated by Compute Engine and changes after every request to
-- modify or update tags. You must always provide an up-to-date fingerprint
-- hash in order to update or change tags. To see the latest fingerprint,
-- make get() request to the instance.
tFingerprint :: Lens' Tags (Maybe ByteString)
tFingerprint
  = lens _tFingerprint (\ s a -> s{_tFingerprint = a})
      . mapping _Bytes

-- | An array of tags. Each tag must be 1-63 characters long, and comply with
-- RFC1035.
tItems :: Lens' Tags [Text]
tItems
  = lens _tItems (\ s a -> s{_tItems = a}) . _Default .
      _Coerce

instance FromJSON Tags where
        parseJSON
          = withObject "Tags"
              (\ o ->
                 Tags' <$>
                   (o .:? "fingerprint") <*> (o .:? "items" .!= mempty))

instance ToJSON Tags where
        toJSON Tags'{..}
          = object
              (catMaybes
                 [("fingerprint" .=) <$> _tFingerprint,
                  ("items" .=) <$> _tItems])

--
-- /See:/ 'addressAggregatedList' smart constructor.
data AddressAggregatedList =
  AddressAggregatedList'
    { _addUnreachables :: !(Maybe [Text])
    , _addNextPageToken :: !(Maybe Text)
    , _addKind :: !Text
    , _addItems :: !(Maybe AddressAggregatedListItems)
    , _addSelfLink :: !(Maybe Text)
    , _addWarning :: !(Maybe AddressAggregatedListWarning)
    , _addId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AddressAggregatedList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'addUnreachables'
--
-- * 'addNextPageToken'
--
-- * 'addKind'
--
-- * 'addItems'
--
-- * 'addSelfLink'
--
-- * 'addWarning'
--
-- * 'addId'
addressAggregatedList
    :: AddressAggregatedList
addressAggregatedList =
  AddressAggregatedList'
    { _addUnreachables = Nothing
    , _addNextPageToken = Nothing
    , _addKind = "compute#addressAggregatedList"
    , _addItems = Nothing
    , _addSelfLink = Nothing
    , _addWarning = Nothing
    , _addId = Nothing
    }


-- | [Output Only] Unreachable resources.
addUnreachables :: Lens' AddressAggregatedList [Text]
addUnreachables
  = lens _addUnreachables
      (\ s a -> s{_addUnreachables = a})
      . _Default
      . _Coerce

-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
addNextPageToken :: Lens' AddressAggregatedList (Maybe Text)
addNextPageToken
  = lens _addNextPageToken
      (\ s a -> s{_addNextPageToken = a})

-- | [Output Only] Type of resource. Always compute#addressAggregatedList for
-- aggregated lists of addresses.
addKind :: Lens' AddressAggregatedList Text
addKind = lens _addKind (\ s a -> s{_addKind = a})

-- | A list of AddressesScopedList resources.
addItems :: Lens' AddressAggregatedList (Maybe AddressAggregatedListItems)
addItems = lens _addItems (\ s a -> s{_addItems = a})

-- | [Output Only] Server-defined URL for this resource.
addSelfLink :: Lens' AddressAggregatedList (Maybe Text)
addSelfLink
  = lens _addSelfLink (\ s a -> s{_addSelfLink = a})

-- | [Output Only] Informational warning message.
addWarning :: Lens' AddressAggregatedList (Maybe AddressAggregatedListWarning)
addWarning
  = lens _addWarning (\ s a -> s{_addWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
addId :: Lens' AddressAggregatedList (Maybe Text)
addId = lens _addId (\ s a -> s{_addId = a})

instance FromJSON AddressAggregatedList where
        parseJSON
          = withObject "AddressAggregatedList"
              (\ o ->
                 AddressAggregatedList' <$>
                   (o .:? "unreachables" .!= mempty) <*>
                     (o .:? "nextPageToken")
                     <*>
                     (o .:? "kind" .!= "compute#addressAggregatedList")
                     <*> (o .:? "items")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON AddressAggregatedList where
        toJSON AddressAggregatedList'{..}
          = object
              (catMaybes
                 [("unreachables" .=) <$> _addUnreachables,
                  ("nextPageToken" .=) <$> _addNextPageToken,
                  Just ("kind" .= _addKind),
                  ("items" .=) <$> _addItems,
                  ("selfLink" .=) <$> _addSelfLink,
                  ("warning" .=) <$> _addWarning,
                  ("id" .=) <$> _addId])

-- | Response to the list request, and contains a list of interconnect
-- attachments.
--
-- /See:/ 'interconnectAttachmentList' smart constructor.
data InterconnectAttachmentList =
  InterconnectAttachmentList'
    { _ialaNextPageToken :: !(Maybe Text)
    , _ialaKind :: !Text
    , _ialaItems :: !(Maybe [InterconnectAttachment])
    , _ialaSelfLink :: !(Maybe Text)
    , _ialaWarning :: !(Maybe InterconnectAttachmentListWarning)
    , _ialaId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InterconnectAttachmentList' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'ialaNextPageToken'
--
-- * 'ialaKind'
--
-- * 'ialaItems'
--
-- * 'ialaSelfLink'
--
-- * 'ialaWarning'
--
-- * 'ialaId'
interconnectAttachmentList
    :: InterconnectAttachmentList
interconnectAttachmentList =
  InterconnectAttachmentList'
    { _ialaNextPageToken = Nothing
    , _ialaKind = "compute#interconnectAttachmentList"
    , _ialaItems = Nothing
    , _ialaSelfLink = Nothing
    , _ialaWarning = Nothing
    , _ialaId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
ialaNextPageToken :: Lens' InterconnectAttachmentList (Maybe Text)
ialaNextPageToken
  = lens _ialaNextPageToken
      (\ s a -> s{_ialaNextPageToken = a})

-- | [Output Only] Type of resource. Always
-- compute#interconnectAttachmentList for lists of interconnect
-- attachments.
ialaKind :: Lens' InterconnectAttachmentList Text
ialaKind = lens _ialaKind (\ s a -> s{_ialaKind = a})

-- | A list of InterconnectAttachment resources.
ialaItems :: Lens' InterconnectAttachmentList [InterconnectAttachment]
ialaItems
  = lens _ialaItems (\ s a -> s{_ialaItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
ialaSelfLink :: Lens' InterconnectAttachmentList (Maybe Text)
ialaSelfLink
  = lens _ialaSelfLink (\ s a -> s{_ialaSelfLink = a})

-- | [Output Only] Informational warning message.
ialaWarning :: Lens' InterconnectAttachmentList (Maybe InterconnectAttachmentListWarning)
ialaWarning
  = lens _ialaWarning (\ s a -> s{_ialaWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
ialaId :: Lens' InterconnectAttachmentList (Maybe Text)
ialaId = lens _ialaId (\ s a -> s{_ialaId = a})

instance FromJSON InterconnectAttachmentList where
        parseJSON
          = withObject "InterconnectAttachmentList"
              (\ o ->
                 InterconnectAttachmentList' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "kind" .!=
                        "compute#interconnectAttachmentList")
                     <*> (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON InterconnectAttachmentList where
        toJSON InterconnectAttachmentList'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _ialaNextPageToken,
                  Just ("kind" .= _ialaKind),
                  ("items" .=) <$> _ialaItems,
                  ("selfLink" .=) <$> _ialaSelfLink,
                  ("warning" .=) <$> _ialaWarning,
                  ("id" .=) <$> _ialaId])

-- | Specify CDN TTLs for response error codes.
--
-- /See:/ 'backendBucketCdnPolicyNegativeCachingPolicy' smart constructor.
data BackendBucketCdnPolicyNegativeCachingPolicy =
  BackendBucketCdnPolicyNegativeCachingPolicy'
    { _bbcpncpTtl :: !(Maybe (Textual Int32))
    , _bbcpncpCode :: !(Maybe (Textual Int32))
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendBucketCdnPolicyNegativeCachingPolicy' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bbcpncpTtl'
--
-- * 'bbcpncpCode'
backendBucketCdnPolicyNegativeCachingPolicy
    :: BackendBucketCdnPolicyNegativeCachingPolicy
backendBucketCdnPolicyNegativeCachingPolicy =
  BackendBucketCdnPolicyNegativeCachingPolicy'
    {_bbcpncpTtl = Nothing, _bbcpncpCode = Nothing}


-- | The TTL (in seconds) for which to cache responses with the corresponding
-- status code. The maximum allowed value is 1800s (30 minutes), noting
-- that infrequently accessed objects may be evicted from the cache before
-- the defined TTL.
bbcpncpTtl :: Lens' BackendBucketCdnPolicyNegativeCachingPolicy (Maybe Int32)
bbcpncpTtl
  = lens _bbcpncpTtl (\ s a -> s{_bbcpncpTtl = a}) .
      mapping _Coerce

-- | The HTTP status code to define a TTL against. Only HTTP status codes
-- 300, 301, 302, 307, 308, 404, 405, 410, 421, 451 and 501 are can be
-- specified as values, and you cannot specify a status code more than
-- once.
bbcpncpCode :: Lens' BackendBucketCdnPolicyNegativeCachingPolicy (Maybe Int32)
bbcpncpCode
  = lens _bbcpncpCode (\ s a -> s{_bbcpncpCode = a}) .
      mapping _Coerce

instance FromJSON
           BackendBucketCdnPolicyNegativeCachingPolicy
         where
        parseJSON
          = withObject
              "BackendBucketCdnPolicyNegativeCachingPolicy"
              (\ o ->
                 BackendBucketCdnPolicyNegativeCachingPolicy' <$>
                   (o .:? "ttl") <*> (o .:? "code"))

instance ToJSON
           BackendBucketCdnPolicyNegativeCachingPolicy
         where
        toJSON
          BackendBucketCdnPolicyNegativeCachingPolicy'{..}
          = object
              (catMaybes
                 [("ttl" .=) <$> _bbcpncpTtl,
                  ("code" .=) <$> _bbcpncpCode])

--
-- /See:/ 'instanceGroupManagerStatusStateful' smart constructor.
data InstanceGroupManagerStatusStateful =
  InstanceGroupManagerStatusStateful'
    { _igmssHasStatefulConfig :: !(Maybe Bool)
    , _igmssPerInstanceConfigs :: !(Maybe InstanceGroupManagerStatusStatefulPerInstanceConfigs)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'InstanceGroupManagerStatusStateful' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'igmssHasStatefulConfig'
--
-- * 'igmssPerInstanceConfigs'
instanceGroupManagerStatusStateful
    :: InstanceGroupManagerStatusStateful
instanceGroupManagerStatusStateful =
  InstanceGroupManagerStatusStateful'
    {_igmssHasStatefulConfig = Nothing, _igmssPerInstanceConfigs = Nothing}


-- | [Output Only] A bit indicating whether the managed instance group has
-- stateful configuration, that is, if you have configured any items in a
-- stateful policy or in per-instance configs. The group might report that
-- it has no stateful config even when there is still some preserved state
-- on a managed instance, for example, if you have deleted all PICs but not
-- yet applied those deletions.
igmssHasStatefulConfig :: Lens' InstanceGroupManagerStatusStateful (Maybe Bool)
igmssHasStatefulConfig
  = lens _igmssHasStatefulConfig
      (\ s a -> s{_igmssHasStatefulConfig = a})

-- | [Output Only] Status of per-instance configs on the instance.
igmssPerInstanceConfigs :: Lens' InstanceGroupManagerStatusStateful (Maybe InstanceGroupManagerStatusStatefulPerInstanceConfigs)
igmssPerInstanceConfigs
  = lens _igmssPerInstanceConfigs
      (\ s a -> s{_igmssPerInstanceConfigs = a})

instance FromJSON InstanceGroupManagerStatusStateful
         where
        parseJSON
          = withObject "InstanceGroupManagerStatusStateful"
              (\ o ->
                 InstanceGroupManagerStatusStateful' <$>
                   (o .:? "hasStatefulConfig") <*>
                     (o .:? "perInstanceConfigs"))

instance ToJSON InstanceGroupManagerStatusStateful
         where
        toJSON InstanceGroupManagerStatusStateful'{..}
          = object
              (catMaybes
                 [("hasStatefulConfig" .=) <$>
                    _igmssHasStatefulConfig,
                  ("perInstanceConfigs" .=) <$>
                    _igmssPerInstanceConfigs])

--
-- /See:/ 'operationWarningsItem' smart constructor.
data OperationWarningsItem =
  OperationWarningsItem'
    { _owiData :: !(Maybe [OperationWarningsItemDataItem])
    , _owiCode :: !(Maybe OperationWarningsItemCode)
    , _owiMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'OperationWarningsItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'owiData'
--
-- * 'owiCode'
--
-- * 'owiMessage'
operationWarningsItem
    :: OperationWarningsItem
operationWarningsItem =
  OperationWarningsItem'
    {_owiData = Nothing, _owiCode = Nothing, _owiMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
owiData :: Lens' OperationWarningsItem [OperationWarningsItemDataItem]
owiData
  = lens _owiData (\ s a -> s{_owiData = a}) . _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
owiCode :: Lens' OperationWarningsItem (Maybe OperationWarningsItemCode)
owiCode = lens _owiCode (\ s a -> s{_owiCode = a})

-- | [Output Only] A human-readable description of the warning code.
owiMessage :: Lens' OperationWarningsItem (Maybe Text)
owiMessage
  = lens _owiMessage (\ s a -> s{_owiMessage = a})

instance FromJSON OperationWarningsItem where
        parseJSON
          = withObject "OperationWarningsItem"
              (\ o ->
                 OperationWarningsItem' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON OperationWarningsItem where
        toJSON OperationWarningsItem'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _owiData, ("code" .=) <$> _owiCode,
                  ("message" .=) <$> _owiMessage])

-- | Scaling schedules defined for an autoscaler. Multiple schedules can be
-- set on an autoscaler, and they can overlap. During overlapping periods
-- the greatest min_required_replicas of all scaling schedules is applied.
-- Up to 128 scaling schedules are allowed.
--
-- /See:/ 'autoscalingPolicyScalingSchedules' smart constructor.
newtype AutoscalingPolicyScalingSchedules =
  AutoscalingPolicyScalingSchedules'
    { _apssAddtional :: HashMap Text AutoscalingPolicyScalingSchedule
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'AutoscalingPolicyScalingSchedules' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'apssAddtional'
autoscalingPolicyScalingSchedules
    :: HashMap Text AutoscalingPolicyScalingSchedule -- ^ 'apssAddtional'
    -> AutoscalingPolicyScalingSchedules
autoscalingPolicyScalingSchedules pApssAddtional_ =
  AutoscalingPolicyScalingSchedules'
    {_apssAddtional = _Coerce # pApssAddtional_}


apssAddtional :: Lens' AutoscalingPolicyScalingSchedules (HashMap Text AutoscalingPolicyScalingSchedule)
apssAddtional
  = lens _apssAddtional
      (\ s a -> s{_apssAddtional = a})
      . _Coerce

instance FromJSON AutoscalingPolicyScalingSchedules
         where
        parseJSON
          = withObject "AutoscalingPolicyScalingSchedules"
              (\ o ->
                 AutoscalingPolicyScalingSchedules' <$>
                   (parseJSONObject o))

instance ToJSON AutoscalingPolicyScalingSchedules
         where
        toJSON = toJSON . _apssAddtional

--
-- /See:/ 'preConfiguredWafSet' smart constructor.
newtype PreConfiguredWafSet =
  PreConfiguredWafSet'
    { _pcwsExpressionSets :: Maybe [WafExpressionSet]
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PreConfiguredWafSet' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pcwsExpressionSets'
preConfiguredWafSet
    :: PreConfiguredWafSet
preConfiguredWafSet = PreConfiguredWafSet' {_pcwsExpressionSets = Nothing}


-- | List of entities that are currently supported for WAF rules.
pcwsExpressionSets :: Lens' PreConfiguredWafSet [WafExpressionSet]
pcwsExpressionSets
  = lens _pcwsExpressionSets
      (\ s a -> s{_pcwsExpressionSets = a})
      . _Default
      . _Coerce

instance FromJSON PreConfiguredWafSet where
        parseJSON
          = withObject "PreConfiguredWafSet"
              (\ o ->
                 PreConfiguredWafSet' <$>
                   (o .:? "expressionSets" .!= mempty))

instance ToJSON PreConfiguredWafSet where
        toJSON PreConfiguredWafSet'{..}
          = object
              (catMaybes
                 [("expressionSets" .=) <$> _pcwsExpressionSets])

-- | Associates \`members\` with a \`role\`.
--
-- /See:/ 'binding' smart constructor.
data Binding =
  Binding'
    { _bBindingId :: !(Maybe Text)
    , _bMembers :: !(Maybe [Text])
    , _bRole :: !(Maybe Text)
    , _bCondition :: !(Maybe Expr)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Binding' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bBindingId'
--
-- * 'bMembers'
--
-- * 'bRole'
--
-- * 'bCondition'
binding
    :: Binding
binding =
  Binding'
    { _bBindingId = Nothing
    , _bMembers = Nothing
    , _bRole = Nothing
    , _bCondition = Nothing
    }


-- |
bBindingId :: Lens' Binding (Maybe Text)
bBindingId
  = lens _bBindingId (\ s a -> s{_bBindingId = a})

-- | Specifies the identities requesting access for a Cloud Platform
-- resource. \`members\` can have the following values: * \`allUsers\`: A
-- special identifier that represents anyone who is on the internet; with
-- or without a Google account. * \`allAuthenticatedUsers\`: A special
-- identifier that represents anyone who is authenticated with a Google
-- account or a service account. * \`user:{emailid}\`: An email address
-- that represents a specific Google account. For example,
-- \`alice\'example.com\` . * \`serviceAccount:{emailid}\`: An email
-- address that represents a service account. For example,
-- \`my-other-app\'appspot.gserviceaccount.com\`. * \`group:{emailid}\`: An
-- email address that represents a Google group. For example,
-- \`admins\'example.com\`. * \`deleted:user:{emailid}?uid={uniqueid}\`: An
-- email address (plus unique identifier) representing a user that has been
-- recently deleted. For example,
-- \`alice\'example.com?uid=123456789012345678901\`. If the user is
-- recovered, this value reverts to \`user:{emailid}\` and the recovered
-- user retains the role in the binding. *
-- \`deleted:serviceAccount:{emailid}?uid={uniqueid}\`: An email address
-- (plus unique identifier) representing a service account that has been
-- recently deleted. For example,
-- \`my-other-app\'appspot.gserviceaccount.com?uid=123456789012345678901\`.
-- If the service account is undeleted, this value reverts to
-- \`serviceAccount:{emailid}\` and the undeleted service account retains
-- the role in the binding. * \`deleted:group:{emailid}?uid={uniqueid}\`:
-- An email address (plus unique identifier) representing a Google group
-- that has been recently deleted. For example,
-- \`admins\'example.com?uid=123456789012345678901\`. If the group is
-- recovered, this value reverts to \`group:{emailid}\` and the recovered
-- group retains the role in the binding. * \`domain:{domain}\`: The G
-- Suite domain (primary) that represents all the users of that domain. For
-- example, \`google.com\` or \`example.com\`.
bMembers :: Lens' Binding [Text]
bMembers
  = lens _bMembers (\ s a -> s{_bMembers = a}) .
      _Default
      . _Coerce

-- | Role that is assigned to \`members\`. For example, \`roles\/viewer\`,
-- \`roles\/editor\`, or \`roles\/owner\`.
bRole :: Lens' Binding (Maybe Text)
bRole = lens _bRole (\ s a -> s{_bRole = a})

-- | The condition that is associated with this binding. If the condition
-- evaluates to \`true\`, then this binding applies to the current request.
-- If the condition evaluates to \`false\`, then this binding does not
-- apply to the current request. However, a different role binding might
-- grant the same role to one or more of the members in this binding. To
-- learn which resources support conditions in their IAM policies, see the
-- [IAM
-- documentation](https:\/\/cloud.google.com\/iam\/help\/conditions\/resource-policies).
bCondition :: Lens' Binding (Maybe Expr)
bCondition
  = lens _bCondition (\ s a -> s{_bCondition = a})

instance FromJSON Binding where
        parseJSON
          = withObject "Binding"
              (\ o ->
                 Binding' <$>
                   (o .:? "bindingId") <*> (o .:? "members" .!= mempty)
                     <*> (o .:? "role")
                     <*> (o .:? "condition"))

instance ToJSON Binding where
        toJSON Binding'{..}
          = object
              (catMaybes
                 [("bindingId" .=) <$> _bBindingId,
                  ("members" .=) <$> _bMembers, ("role" .=) <$> _bRole,
                  ("condition" .=) <$> _bCondition])

-- | Message for the expected URL mappings.
--
-- /See:/ 'urlMapTest' smart constructor.
data URLMapTest =
  URLMapTest'
    { _umtExpectedOutputURL :: !(Maybe Text)
    , _umtExpectedRedirectResponseCode :: !(Maybe (Textual Int32))
    , _umtPath :: !(Maybe Text)
    , _umtService :: !(Maybe Text)
    , _umtHeaders :: !(Maybe [URLMapTestHeader])
    , _umtHost :: !(Maybe Text)
    , _umtDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'URLMapTest' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'umtExpectedOutputURL'
--
-- * 'umtExpectedRedirectResponseCode'
--
-- * 'umtPath'
--
-- * 'umtService'
--
-- * 'umtHeaders'
--
-- * 'umtHost'
--
-- * 'umtDescription'
urlMapTest
    :: URLMapTest
urlMapTest =
  URLMapTest'
    { _umtExpectedOutputURL = Nothing
    , _umtExpectedRedirectResponseCode = Nothing
    , _umtPath = Nothing
    , _umtService = Nothing
    , _umtHeaders = Nothing
    , _umtHost = Nothing
    , _umtDescription = Nothing
    }


-- | The expected output URL evaluated by load balancer containing the
-- scheme, host, path and query parameters. For rules that forward requests
-- to backends, the test passes only when expectedOutputUrl matches the
-- request forwarded by load balancer to backends. For rules with
-- urlRewrite, the test verifies that the forwarded request matches
-- hostRewrite and pathPrefixRewrite in the urlRewrite action. When service
-- is specified, expectedOutputUrl\`s scheme is ignored. For rules with
-- urlRedirect, the test passes only if expectedOutputUrl matches the URL
-- in the load balancer\'s redirect response. If urlRedirect specifies
-- https_redirect, the test passes only if the scheme in expectedOutputUrl
-- is also set to https. If urlRedirect specifies strip_query, the test
-- passes only if expectedOutputUrl does not contain any query parameters.
-- expectedOutputUrl is optional when service is specified.
umtExpectedOutputURL :: Lens' URLMapTest (Maybe Text)
umtExpectedOutputURL
  = lens _umtExpectedOutputURL
      (\ s a -> s{_umtExpectedOutputURL = a})

-- | For rules with urlRedirect, the test passes only if
-- expectedRedirectResponseCode matches the HTTP status code in load
-- balancer\'s redirect response. expectedRedirectResponseCode cannot be
-- set when service is set.
umtExpectedRedirectResponseCode :: Lens' URLMapTest (Maybe Int32)
umtExpectedRedirectResponseCode
  = lens _umtExpectedRedirectResponseCode
      (\ s a -> s{_umtExpectedRedirectResponseCode = a})
      . mapping _Coerce

-- | Path portion of the URL.
umtPath :: Lens' URLMapTest (Maybe Text)
umtPath = lens _umtPath (\ s a -> s{_umtPath = a})

-- | Expected BackendService or BackendBucket resource the given URL should
-- be mapped to. service cannot be set if expectedRedirectResponseCode is
-- set.
umtService :: Lens' URLMapTest (Maybe Text)
umtService
  = lens _umtService (\ s a -> s{_umtService = a})

-- | HTTP headers for this request. If headers contains a host header, then
-- host must also match the header value.
umtHeaders :: Lens' URLMapTest [URLMapTestHeader]
umtHeaders
  = lens _umtHeaders (\ s a -> s{_umtHeaders = a}) .
      _Default
      . _Coerce

-- | Host portion of the URL. If headers contains a host header, then host
-- must also match the header value.
umtHost :: Lens' URLMapTest (Maybe Text)
umtHost = lens _umtHost (\ s a -> s{_umtHost = a})

-- | Description of this test case.
umtDescription :: Lens' URLMapTest (Maybe Text)
umtDescription
  = lens _umtDescription
      (\ s a -> s{_umtDescription = a})

instance FromJSON URLMapTest where
        parseJSON
          = withObject "URLMapTest"
              (\ o ->
                 URLMapTest' <$>
                   (o .:? "expectedOutputUrl") <*>
                     (o .:? "expectedRedirectResponseCode")
                     <*> (o .:? "path")
                     <*> (o .:? "service")
                     <*> (o .:? "headers" .!= mempty)
                     <*> (o .:? "host")
                     <*> (o .:? "description"))

instance ToJSON URLMapTest where
        toJSON URLMapTest'{..}
          = object
              (catMaybes
                 [("expectedOutputUrl" .=) <$> _umtExpectedOutputURL,
                  ("expectedRedirectResponseCode" .=) <$>
                    _umtExpectedRedirectResponseCode,
                  ("path" .=) <$> _umtPath,
                  ("service" .=) <$> _umtService,
                  ("headers" .=) <$> _umtHeaders,
                  ("host" .=) <$> _umtHost,
                  ("description" .=) <$> _umtDescription])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'httpsHealthCheckListWarning' smart constructor.
data HTTPSHealthCheckListWarning =
  HTTPSHealthCheckListWarning'
    { _hhclwData :: !(Maybe [HTTPSHealthCheckListWarningDataItem])
    , _hhclwCode :: !(Maybe HTTPSHealthCheckListWarningCode)
    , _hhclwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'HTTPSHealthCheckListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'hhclwData'
--
-- * 'hhclwCode'
--
-- * 'hhclwMessage'
httpsHealthCheckListWarning
    :: HTTPSHealthCheckListWarning
httpsHealthCheckListWarning =
  HTTPSHealthCheckListWarning'
    {_hhclwData = Nothing, _hhclwCode = Nothing, _hhclwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
hhclwData :: Lens' HTTPSHealthCheckListWarning [HTTPSHealthCheckListWarningDataItem]
hhclwData
  = lens _hhclwData (\ s a -> s{_hhclwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
hhclwCode :: Lens' HTTPSHealthCheckListWarning (Maybe HTTPSHealthCheckListWarningCode)
hhclwCode
  = lens _hhclwCode (\ s a -> s{_hhclwCode = a})

-- | [Output Only] A human-readable description of the warning code.
hhclwMessage :: Lens' HTTPSHealthCheckListWarning (Maybe Text)
hhclwMessage
  = lens _hhclwMessage (\ s a -> s{_hhclwMessage = a})

instance FromJSON HTTPSHealthCheckListWarning where
        parseJSON
          = withObject "HTTPSHealthCheckListWarning"
              (\ o ->
                 HTTPSHealthCheckListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON HTTPSHealthCheckListWarning where
        toJSON HTTPSHealthCheckListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _hhclwData,
                  ("code" .=) <$> _hhclwCode,
                  ("message" .=) <$> _hhclwMessage])

-- | A list of NodeTypesScopedList resources.
--
-- /See:/ 'nodeTypeAggregatedListItems' smart constructor.
newtype NodeTypeAggregatedListItems =
  NodeTypeAggregatedListItems'
    { _nAddtional :: HashMap Text NodeTypesScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NodeTypeAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'nAddtional'
nodeTypeAggregatedListItems
    :: HashMap Text NodeTypesScopedList -- ^ 'nAddtional'
    -> NodeTypeAggregatedListItems
nodeTypeAggregatedListItems pNAddtional_ =
  NodeTypeAggregatedListItems' {_nAddtional = _Coerce # pNAddtional_}


-- | [Output Only] Name of the scope containing this set of node types.
nAddtional :: Lens' NodeTypeAggregatedListItems (HashMap Text NodeTypesScopedList)
nAddtional
  = lens _nAddtional (\ s a -> s{_nAddtional = a}) .
      _Coerce

instance FromJSON NodeTypeAggregatedListItems where
        parseJSON
          = withObject "NodeTypeAggregatedListItems"
              (\ o ->
                 NodeTypeAggregatedListItems' <$> (parseJSONObject o))

instance ToJSON NodeTypeAggregatedListItems where
        toJSON = toJSON . _nAddtional

--
-- /See:/ 'routersPreviewResponse' smart constructor.
newtype RoutersPreviewResponse =
  RoutersPreviewResponse'
    { _rprResource :: Maybe Router
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'RoutersPreviewResponse' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'rprResource'
routersPreviewResponse
    :: RoutersPreviewResponse
routersPreviewResponse = RoutersPreviewResponse' {_rprResource = Nothing}


-- | Preview of given router.
rprResource :: Lens' RoutersPreviewResponse (Maybe Router)
rprResource
  = lens _rprResource (\ s a -> s{_rprResource = a})

instance FromJSON RoutersPreviewResponse where
        parseJSON
          = withObject "RoutersPreviewResponse"
              (\ o ->
                 RoutersPreviewResponse' <$> (o .:? "resource"))

instance ToJSON RoutersPreviewResponse where
        toJSON RoutersPreviewResponse'{..}
          = object
              (catMaybes [("resource" .=) <$> _rprResource])

--
-- /See:/ 'licensesListResponse' smart constructor.
data LicensesListResponse =
  LicensesListResponse'
    { _llrNextPageToken :: !(Maybe Text)
    , _llrItems :: !(Maybe [License])
    , _llrSelfLink :: !(Maybe Text)
    , _llrWarning :: !(Maybe LicensesListResponseWarning)
    , _llrId :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'LicensesListResponse' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'llrNextPageToken'
--
-- * 'llrItems'
--
-- * 'llrSelfLink'
--
-- * 'llrWarning'
--
-- * 'llrId'
licensesListResponse
    :: LicensesListResponse
licensesListResponse =
  LicensesListResponse'
    { _llrNextPageToken = Nothing
    , _llrItems = Nothing
    , _llrSelfLink = Nothing
    , _llrWarning = Nothing
    , _llrId = Nothing
    }


-- | [Output Only] This token allows you to get the next page of results for
-- list requests. If the number of results is larger than maxResults, use
-- the nextPageToken as a value for the query parameter pageToken in the
-- next list request. Subsequent list requests will have their own
-- nextPageToken to continue paging through the results.
llrNextPageToken :: Lens' LicensesListResponse (Maybe Text)
llrNextPageToken
  = lens _llrNextPageToken
      (\ s a -> s{_llrNextPageToken = a})

-- | A list of License resources.
llrItems :: Lens' LicensesListResponse [License]
llrItems
  = lens _llrItems (\ s a -> s{_llrItems = a}) .
      _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
llrSelfLink :: Lens' LicensesListResponse (Maybe Text)
llrSelfLink
  = lens _llrSelfLink (\ s a -> s{_llrSelfLink = a})

-- | [Output Only] Informational warning message.
llrWarning :: Lens' LicensesListResponse (Maybe LicensesListResponseWarning)
llrWarning
  = lens _llrWarning (\ s a -> s{_llrWarning = a})

-- | [Output Only] Unique identifier for the resource; defined by the server.
llrId :: Lens' LicensesListResponse (Maybe Text)
llrId = lens _llrId (\ s a -> s{_llrId = a})

instance FromJSON LicensesListResponse where
        parseJSON
          = withObject "LicensesListResponse"
              (\ o ->
                 LicensesListResponse' <$>
                   (o .:? "nextPageToken") <*>
                     (o .:? "items" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "warning")
                     <*> (o .:? "id"))

instance ToJSON LicensesListResponse where
        toJSON LicensesListResponse'{..}
          = object
              (catMaybes
                 [("nextPageToken" .=) <$> _llrNextPageToken,
                  ("items" .=) <$> _llrItems,
                  ("selfLink" .=) <$> _llrSelfLink,
                  ("warning" .=) <$> _llrWarning,
                  ("id" .=) <$> _llrId])

--
-- /See:/ 'packetMirroringsScopedListWarningDataItem' smart constructor.
data PacketMirroringsScopedListWarningDataItem =
  PacketMirroringsScopedListWarningDataItem'
    { _pmslwdiValue :: !(Maybe Text)
    , _pmslwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PacketMirroringsScopedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pmslwdiValue'
--
-- * 'pmslwdiKey'
packetMirroringsScopedListWarningDataItem
    :: PacketMirroringsScopedListWarningDataItem
packetMirroringsScopedListWarningDataItem =
  PacketMirroringsScopedListWarningDataItem'
    {_pmslwdiValue = Nothing, _pmslwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
pmslwdiValue :: Lens' PacketMirroringsScopedListWarningDataItem (Maybe Text)
pmslwdiValue
  = lens _pmslwdiValue (\ s a -> s{_pmslwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
pmslwdiKey :: Lens' PacketMirroringsScopedListWarningDataItem (Maybe Text)
pmslwdiKey
  = lens _pmslwdiKey (\ s a -> s{_pmslwdiKey = a})

instance FromJSON
           PacketMirroringsScopedListWarningDataItem
         where
        parseJSON
          = withObject
              "PacketMirroringsScopedListWarningDataItem"
              (\ o ->
                 PacketMirroringsScopedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           PacketMirroringsScopedListWarningDataItem
         where
        toJSON PacketMirroringsScopedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _pmslwdiValue,
                  ("key" .=) <$> _pmslwdiKey])

--
-- /See:/ 'backendServiceAggregatedListWarningDataItem' smart constructor.
data BackendServiceAggregatedListWarningDataItem =
  BackendServiceAggregatedListWarningDataItem'
    { _bsalwdiValue :: !(Maybe Text)
    , _bsalwdiKey :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendServiceAggregatedListWarningDataItem' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bsalwdiValue'
--
-- * 'bsalwdiKey'
backendServiceAggregatedListWarningDataItem
    :: BackendServiceAggregatedListWarningDataItem
backendServiceAggregatedListWarningDataItem =
  BackendServiceAggregatedListWarningDataItem'
    {_bsalwdiValue = Nothing, _bsalwdiKey = Nothing}


-- | [Output Only] A warning data value corresponding to the key.
bsalwdiValue :: Lens' BackendServiceAggregatedListWarningDataItem (Maybe Text)
bsalwdiValue
  = lens _bsalwdiValue (\ s a -> s{_bsalwdiValue = a})

-- | [Output Only] A key that provides more detail on the warning being
-- returned. For example, for warnings where there are no results in a list
-- request for a particular zone, this key might be scope and the key value
-- might be the zone name. Other examples might be a key indicating a
-- deprecated resource and a suggested replacement, or a warning about
-- invalid network settings (for example, if an instance attempts to
-- perform IP forwarding but is not enabled for IP forwarding).
bsalwdiKey :: Lens' BackendServiceAggregatedListWarningDataItem (Maybe Text)
bsalwdiKey
  = lens _bsalwdiKey (\ s a -> s{_bsalwdiKey = a})

instance FromJSON
           BackendServiceAggregatedListWarningDataItem
         where
        parseJSON
          = withObject
              "BackendServiceAggregatedListWarningDataItem"
              (\ o ->
                 BackendServiceAggregatedListWarningDataItem' <$>
                   (o .:? "value") <*> (o .:? "key"))

instance ToJSON
           BackendServiceAggregatedListWarningDataItem
         where
        toJSON
          BackendServiceAggregatedListWarningDataItem'{..}
          = object
              (catMaybes
                 [("value" .=) <$> _bsalwdiValue,
                  ("key" .=) <$> _bsalwdiKey])

-- | Represents an Instance resource. An instance is a virtual machine that
-- is hosted on Google Cloud Platform. For more information, read Virtual
-- Machine Instances. (== resource_for {$api_version}.instances ==)
--
-- /See:/ 'instance'' smart constructor.
data Instance =
  Instance'
    { _i1AdvancedMachineFeatures :: !(Maybe AdvancedMachineFeatures)
    , _i1SatisfiesPzs :: !(Maybe Bool)
    , _i1Status :: !(Maybe InstanceStatus)
    , _i1LastStopTimestamp :: !(Maybe Text)
    , _i1ServiceAccounts :: !(Maybe [ServiceAccount])
    , _i1LastSuspendedTimestamp :: !(Maybe Text)
    , _i1DeletionProtection :: !(Maybe Bool)
    , _i1Hostname :: !(Maybe Text)
    , _i1ReservationAffinity :: !(Maybe ReservationAffinity)
    , _i1DisplayDevice :: !(Maybe DisplayDevice)
    , _i1NetworkInterfaces :: !(Maybe [NetworkInterface])
    , _i1ShieldedInstanceIntegrityPolicy :: !(Maybe ShieldedInstanceIntegrityPolicy)
    , _i1Kind :: !Text
    , _i1Fingerprint :: !(Maybe Bytes)
    , _i1Zone :: !(Maybe Text)
    , _i1ConfidentialInstanceConfig :: !(Maybe ConfidentialInstanceConfig)
    , _i1CPUPlatform :: !(Maybe Text)
    , _i1ResourcePolicies :: !(Maybe [Text])
    , _i1SelfLink :: !(Maybe Text)
    , _i1GuestAccelerators :: !(Maybe [AcceleratorConfig])
    , _i1LastStartTimestamp :: !(Maybe Text)
    , _i1Name :: !(Maybe Text)
    , _i1StatusMessage :: !(Maybe Text)
    , _i1CreationTimestamp :: !(Maybe Text)
    , _i1MachineType :: !(Maybe Text)
    , _i1Metadata :: !(Maybe Metadata)
    , _i1ShieldedInstanceConfig :: !(Maybe ShieldedInstanceConfig)
    , _i1Id :: !(Maybe (Textual Word64))
    , _i1Labels :: !(Maybe InstanceLabels)
    , _i1StartRestricted :: !(Maybe Bool)
    , _i1Scheduling :: !(Maybe Scheduling)
    , _i1MinCPUPlatform :: !(Maybe Text)
    , _i1Disks :: !(Maybe [AttachedDisk])
    , _i1CanIPForward :: !(Maybe Bool)
    , _i1LabelFingerprint :: !(Maybe Bytes)
    , _i1Description :: !(Maybe Text)
    , _i1Tags :: !(Maybe Tags)
    , _i1PrivateIPv6GoogleAccess :: !(Maybe InstancePrivateIPv6GoogleAccess)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'Instance' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'i1AdvancedMachineFeatures'
--
-- * 'i1SatisfiesPzs'
--
-- * 'i1Status'
--
-- * 'i1LastStopTimestamp'
--
-- * 'i1ServiceAccounts'
--
-- * 'i1LastSuspendedTimestamp'
--
-- * 'i1DeletionProtection'
--
-- * 'i1Hostname'
--
-- * 'i1ReservationAffinity'
--
-- * 'i1DisplayDevice'
--
-- * 'i1NetworkInterfaces'
--
-- * 'i1ShieldedInstanceIntegrityPolicy'
--
-- * 'i1Kind'
--
-- * 'i1Fingerprint'
--
-- * 'i1Zone'
--
-- * 'i1ConfidentialInstanceConfig'
--
-- * 'i1CPUPlatform'
--
-- * 'i1ResourcePolicies'
--
-- * 'i1SelfLink'
--
-- * 'i1GuestAccelerators'
--
-- * 'i1LastStartTimestamp'
--
-- * 'i1Name'
--
-- * 'i1StatusMessage'
--
-- * 'i1CreationTimestamp'
--
-- * 'i1MachineType'
--
-- * 'i1Metadata'
--
-- * 'i1ShieldedInstanceConfig'
--
-- * 'i1Id'
--
-- * 'i1Labels'
--
-- * 'i1StartRestricted'
--
-- * 'i1Scheduling'
--
-- * 'i1MinCPUPlatform'
--
-- * 'i1Disks'
--
-- * 'i1CanIPForward'
--
-- * 'i1LabelFingerprint'
--
-- * 'i1Description'
--
-- * 'i1Tags'
--
-- * 'i1PrivateIPv6GoogleAccess'
instance'
    :: Instance
instance' =
  Instance'
    { _i1AdvancedMachineFeatures = Nothing
    , _i1SatisfiesPzs = Nothing
    , _i1Status = Nothing
    , _i1LastStopTimestamp = Nothing
    , _i1ServiceAccounts = Nothing
    , _i1LastSuspendedTimestamp = Nothing
    , _i1DeletionProtection = Nothing
    , _i1Hostname = Nothing
    , _i1ReservationAffinity = Nothing
    , _i1DisplayDevice = Nothing
    , _i1NetworkInterfaces = Nothing
    , _i1ShieldedInstanceIntegrityPolicy = Nothing
    , _i1Kind = "compute#instance"
    , _i1Fingerprint = Nothing
    , _i1Zone = Nothing
    , _i1ConfidentialInstanceConfig = Nothing
    , _i1CPUPlatform = Nothing
    , _i1ResourcePolicies = Nothing
    , _i1SelfLink = Nothing
    , _i1GuestAccelerators = Nothing
    , _i1LastStartTimestamp = Nothing
    , _i1Name = Nothing
    , _i1StatusMessage = Nothing
    , _i1CreationTimestamp = Nothing
    , _i1MachineType = Nothing
    , _i1Metadata = Nothing
    , _i1ShieldedInstanceConfig = Nothing
    , _i1Id = Nothing
    , _i1Labels = Nothing
    , _i1StartRestricted = Nothing
    , _i1Scheduling = Nothing
    , _i1MinCPUPlatform = Nothing
    , _i1Disks = Nothing
    , _i1CanIPForward = Nothing
    , _i1LabelFingerprint = Nothing
    , _i1Description = Nothing
    , _i1Tags = Nothing
    , _i1PrivateIPv6GoogleAccess = Nothing
    }


-- | Controls for advanced machine-related behavior features.
i1AdvancedMachineFeatures :: Lens' Instance (Maybe AdvancedMachineFeatures)
i1AdvancedMachineFeatures
  = lens _i1AdvancedMachineFeatures
      (\ s a -> s{_i1AdvancedMachineFeatures = a})

-- | [Output Only] Reserved for future use.
i1SatisfiesPzs :: Lens' Instance (Maybe Bool)
i1SatisfiesPzs
  = lens _i1SatisfiesPzs
      (\ s a -> s{_i1SatisfiesPzs = a})

-- | [Output Only] The status of the instance. One of the following values:
-- PROVISIONING, STAGING, RUNNING, STOPPING, SUSPENDING, SUSPENDED,
-- REPAIRING, and TERMINATED. For more information about the status of the
-- instance, see Instance life cycle.
i1Status :: Lens' Instance (Maybe InstanceStatus)
i1Status = lens _i1Status (\ s a -> s{_i1Status = a})

-- | [Output Only] Last stop timestamp in RFC3339 text format.
i1LastStopTimestamp :: Lens' Instance (Maybe Text)
i1LastStopTimestamp
  = lens _i1LastStopTimestamp
      (\ s a -> s{_i1LastStopTimestamp = a})

-- | A list of service accounts, with their specified scopes, authorized for
-- this instance. Only one service account per VM instance is supported.
-- Service accounts generate access tokens that can be accessed through the
-- metadata server and used to authenticate applications on the instance.
-- See Service Accounts for more information.
i1ServiceAccounts :: Lens' Instance [ServiceAccount]
i1ServiceAccounts
  = lens _i1ServiceAccounts
      (\ s a -> s{_i1ServiceAccounts = a})
      . _Default
      . _Coerce

-- | [Output Only] Last suspended timestamp in RFC3339 text format.
i1LastSuspendedTimestamp :: Lens' Instance (Maybe Text)
i1LastSuspendedTimestamp
  = lens _i1LastSuspendedTimestamp
      (\ s a -> s{_i1LastSuspendedTimestamp = a})

-- | Whether the resource should be protected against deletion.
i1DeletionProtection :: Lens' Instance (Maybe Bool)
i1DeletionProtection
  = lens _i1DeletionProtection
      (\ s a -> s{_i1DeletionProtection = a})

-- | Specifies the hostname of the instance. The specified hostname must be
-- RFC1035 compliant. If hostname is not specified, the default hostname is
-- [INSTANCE_NAME].c.[PROJECT_ID].internal when using the global DNS, and
-- [INSTANCE_NAME].[ZONE].c.[PROJECT_ID].internal when using zonal DNS.
i1Hostname :: Lens' Instance (Maybe Text)
i1Hostname
  = lens _i1Hostname (\ s a -> s{_i1Hostname = a})

-- | Specifies the reservations that this instance can consume from.
i1ReservationAffinity :: Lens' Instance (Maybe ReservationAffinity)
i1ReservationAffinity
  = lens _i1ReservationAffinity
      (\ s a -> s{_i1ReservationAffinity = a})

-- | Enables display device for the instance.
i1DisplayDevice :: Lens' Instance (Maybe DisplayDevice)
i1DisplayDevice
  = lens _i1DisplayDevice
      (\ s a -> s{_i1DisplayDevice = a})

-- | An array of network configurations for this instance. These specify how
-- interfaces are configured to interact with other network services, such
-- as connecting to the internet. Multiple interfaces are supported per
-- instance.
i1NetworkInterfaces :: Lens' Instance [NetworkInterface]
i1NetworkInterfaces
  = lens _i1NetworkInterfaces
      (\ s a -> s{_i1NetworkInterfaces = a})
      . _Default
      . _Coerce

i1ShieldedInstanceIntegrityPolicy :: Lens' Instance (Maybe ShieldedInstanceIntegrityPolicy)
i1ShieldedInstanceIntegrityPolicy
  = lens _i1ShieldedInstanceIntegrityPolicy
      (\ s a -> s{_i1ShieldedInstanceIntegrityPolicy = a})

-- | [Output Only] Type of the resource. Always compute#instance for
-- instances.
i1Kind :: Lens' Instance Text
i1Kind = lens _i1Kind (\ s a -> s{_i1Kind = a})

-- | Specifies a fingerprint for this resource, which is essentially a hash
-- of the instance\'s contents and used for optimistic locking. The
-- fingerprint is initially generated by Compute Engine and changes after
-- every request to modify or update the instance. You must always provide
-- an up-to-date fingerprint hash in order to update the instance. To see
-- the latest fingerprint, make get() request to the instance.
i1Fingerprint :: Lens' Instance (Maybe ByteString)
i1Fingerprint
  = lens _i1Fingerprint
      (\ s a -> s{_i1Fingerprint = a})
      . mapping _Bytes

-- | [Output Only] URL of the zone where the instance resides. You must
-- specify this field as part of the HTTP request URL. It is not settable
-- as a field in the request body.
i1Zone :: Lens' Instance (Maybe Text)
i1Zone = lens _i1Zone (\ s a -> s{_i1Zone = a})

i1ConfidentialInstanceConfig :: Lens' Instance (Maybe ConfidentialInstanceConfig)
i1ConfidentialInstanceConfig
  = lens _i1ConfidentialInstanceConfig
      (\ s a -> s{_i1ConfidentialInstanceConfig = a})

-- | [Output Only] The CPU platform used by this instance.
i1CPUPlatform :: Lens' Instance (Maybe Text)
i1CPUPlatform
  = lens _i1CPUPlatform
      (\ s a -> s{_i1CPUPlatform = a})

-- | Resource policies applied to this instance.
i1ResourcePolicies :: Lens' Instance [Text]
i1ResourcePolicies
  = lens _i1ResourcePolicies
      (\ s a -> s{_i1ResourcePolicies = a})
      . _Default
      . _Coerce

-- | [Output Only] Server-defined URL for this resource.
i1SelfLink :: Lens' Instance (Maybe Text)
i1SelfLink
  = lens _i1SelfLink (\ s a -> s{_i1SelfLink = a})

-- | A list of the type and count of accelerator cards attached to the
-- instance.
i1GuestAccelerators :: Lens' Instance [AcceleratorConfig]
i1GuestAccelerators
  = lens _i1GuestAccelerators
      (\ s a -> s{_i1GuestAccelerators = a})
      . _Default
      . _Coerce

-- | [Output Only] Last start timestamp in RFC3339 text format.
i1LastStartTimestamp :: Lens' Instance (Maybe Text)
i1LastStartTimestamp
  = lens _i1LastStartTimestamp
      (\ s a -> s{_i1LastStartTimestamp = a})

-- | The name of the resource, provided by the client when initially creating
-- the resource. The resource name must be 1-63 characters long, and comply
-- with RFC1035. Specifically, the name must be 1-63 characters long and
-- match the regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means
-- the first character must be a lowercase letter, and all following
-- characters must be a dash, lowercase letter, or digit, except the last
-- character, which cannot be a dash.
i1Name :: Lens' Instance (Maybe Text)
i1Name = lens _i1Name (\ s a -> s{_i1Name = a})

-- | [Output Only] An optional, human-readable explanation of the status.
i1StatusMessage :: Lens' Instance (Maybe Text)
i1StatusMessage
  = lens _i1StatusMessage
      (\ s a -> s{_i1StatusMessage = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
i1CreationTimestamp :: Lens' Instance (Maybe Text)
i1CreationTimestamp
  = lens _i1CreationTimestamp
      (\ s a -> s{_i1CreationTimestamp = a})

-- | Full or partial URL of the machine type resource to use for this
-- instance, in the format: zones\/zone\/machineTypes\/machine-type. This
-- is provided by the client when the instance is created. For example, the
-- following is a valid partial url to a predefined machine type:
-- zones\/us-central1-f\/machineTypes\/n1-standard-1 To create a custom
-- machine type, provide a URL to a machine type in the following format,
-- where CPUS is 1 or an even number up to 32 (2, 4, 6, ... 24, etc), and
-- MEMORY is the total memory for this instance. Memory must be a multiple
-- of 256 MB and must be supplied in MB (e.g. 5 GB of memory is 5120 MB):
-- zones\/zone\/machineTypes\/custom-CPUS-MEMORY For example:
-- zones\/us-central1-f\/machineTypes\/custom-4-5120 For a full list of
-- restrictions, read the Specifications for custom machine types.
i1MachineType :: Lens' Instance (Maybe Text)
i1MachineType
  = lens _i1MachineType
      (\ s a -> s{_i1MachineType = a})

-- | The metadata key\/value pairs assigned to this instance. This includes
-- custom metadata and predefined keys.
i1Metadata :: Lens' Instance (Maybe Metadata)
i1Metadata
  = lens _i1Metadata (\ s a -> s{_i1Metadata = a})

i1ShieldedInstanceConfig :: Lens' Instance (Maybe ShieldedInstanceConfig)
i1ShieldedInstanceConfig
  = lens _i1ShieldedInstanceConfig
      (\ s a -> s{_i1ShieldedInstanceConfig = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
i1Id :: Lens' Instance (Maybe Word64)
i1Id
  = lens _i1Id (\ s a -> s{_i1Id = a}) .
      mapping _Coerce

-- | Labels to apply to this instance. These can be later modified by the
-- setLabels method.
i1Labels :: Lens' Instance (Maybe InstanceLabels)
i1Labels = lens _i1Labels (\ s a -> s{_i1Labels = a})

-- | [Output Only] Whether a VM has been restricted for start because Compute
-- Engine has detected suspicious activity.
i1StartRestricted :: Lens' Instance (Maybe Bool)
i1StartRestricted
  = lens _i1StartRestricted
      (\ s a -> s{_i1StartRestricted = a})

-- | Sets the scheduling options for this instance.
i1Scheduling :: Lens' Instance (Maybe Scheduling)
i1Scheduling
  = lens _i1Scheduling (\ s a -> s{_i1Scheduling = a})

-- | Specifies a minimum CPU platform for the VM instance. Applicable values
-- are the friendly names of CPU platforms, such as minCpuPlatform: \"Intel
-- Haswell\" or minCpuPlatform: \"Intel Sandy Bridge\".
i1MinCPUPlatform :: Lens' Instance (Maybe Text)
i1MinCPUPlatform
  = lens _i1MinCPUPlatform
      (\ s a -> s{_i1MinCPUPlatform = a})

-- | Array of disks associated with this instance. Persistent disks must be
-- created before you can assign them.
i1Disks :: Lens' Instance [AttachedDisk]
i1Disks
  = lens _i1Disks (\ s a -> s{_i1Disks = a}) . _Default
      . _Coerce

-- | Allows this instance to send and receive packets with non-matching
-- destination or source IPs. This is required if you plan to use this
-- instance to forward routes. For more information, see Enabling IP
-- Forwarding.
i1CanIPForward :: Lens' Instance (Maybe Bool)
i1CanIPForward
  = lens _i1CanIPForward
      (\ s a -> s{_i1CanIPForward = a})

-- | A fingerprint for this request, which is essentially a hash of the
-- label\'s contents and used for optimistic locking. The fingerprint is
-- initially generated by Compute Engine and changes after every request to
-- modify or update labels. You must always provide an up-to-date
-- fingerprint hash in order to update or change labels. To see the latest
-- fingerprint, make get() request to the instance.
i1LabelFingerprint :: Lens' Instance (Maybe ByteString)
i1LabelFingerprint
  = lens _i1LabelFingerprint
      (\ s a -> s{_i1LabelFingerprint = a})
      . mapping _Bytes

-- | An optional description of this resource. Provide this property when you
-- create the resource.
i1Description :: Lens' Instance (Maybe Text)
i1Description
  = lens _i1Description
      (\ s a -> s{_i1Description = a})

-- | Tags to apply to this instance. Tags are used to identify valid sources
-- or targets for network firewalls and are specified by the client during
-- instance creation. The tags can be later modified by the setTags method.
-- Each tag within the list must comply with RFC1035. Multiple tags can be
-- specified via the \'tags.items\' field.
i1Tags :: Lens' Instance (Maybe Tags)
i1Tags = lens _i1Tags (\ s a -> s{_i1Tags = a})

-- | The private IPv6 google access type for the VM. If not specified, use
-- INHERIT_FROM_SUBNETWORK as default.
i1PrivateIPv6GoogleAccess :: Lens' Instance (Maybe InstancePrivateIPv6GoogleAccess)
i1PrivateIPv6GoogleAccess
  = lens _i1PrivateIPv6GoogleAccess
      (\ s a -> s{_i1PrivateIPv6GoogleAccess = a})

instance FromJSON Instance where
        parseJSON
          = withObject "Instance"
              (\ o ->
                 Instance' <$>
                   (o .:? "advancedMachineFeatures") <*>
                     (o .:? "satisfiesPzs")
                     <*> (o .:? "status")
                     <*> (o .:? "lastStopTimestamp")
                     <*> (o .:? "serviceAccounts" .!= mempty)
                     <*> (o .:? "lastSuspendedTimestamp")
                     <*> (o .:? "deletionProtection")
                     <*> (o .:? "hostname")
                     <*> (o .:? "reservationAffinity")
                     <*> (o .:? "displayDevice")
                     <*> (o .:? "networkInterfaces" .!= mempty)
                     <*> (o .:? "shieldedInstanceIntegrityPolicy")
                     <*> (o .:? "kind" .!= "compute#instance")
                     <*> (o .:? "fingerprint")
                     <*> (o .:? "zone")
                     <*> (o .:? "confidentialInstanceConfig")
                     <*> (o .:? "cpuPlatform")
                     <*> (o .:? "resourcePolicies" .!= mempty)
                     <*> (o .:? "selfLink")
                     <*> (o .:? "guestAccelerators" .!= mempty)
                     <*> (o .:? "lastStartTimestamp")
                     <*> (o .:? "name")
                     <*> (o .:? "statusMessage")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "machineType")
                     <*> (o .:? "metadata")
                     <*> (o .:? "shieldedInstanceConfig")
                     <*> (o .:? "id")
                     <*> (o .:? "labels")
                     <*> (o .:? "startRestricted")
                     <*> (o .:? "scheduling")
                     <*> (o .:? "minCpuPlatform")
                     <*> (o .:? "disks" .!= mempty)
                     <*> (o .:? "canIpForward")
                     <*> (o .:? "labelFingerprint")
                     <*> (o .:? "description")
                     <*> (o .:? "tags")
                     <*> (o .:? "privateIpv6GoogleAccess"))

instance ToJSON Instance where
        toJSON Instance'{..}
          = object
              (catMaybes
                 [("advancedMachineFeatures" .=) <$>
                    _i1AdvancedMachineFeatures,
                  ("satisfiesPzs" .=) <$> _i1SatisfiesPzs,
                  ("status" .=) <$> _i1Status,
                  ("lastStopTimestamp" .=) <$> _i1LastStopTimestamp,
                  ("serviceAccounts" .=) <$> _i1ServiceAccounts,
                  ("lastSuspendedTimestamp" .=) <$>
                    _i1LastSuspendedTimestamp,
                  ("deletionProtection" .=) <$> _i1DeletionProtection,
                  ("hostname" .=) <$> _i1Hostname,
                  ("reservationAffinity" .=) <$>
                    _i1ReservationAffinity,
                  ("displayDevice" .=) <$> _i1DisplayDevice,
                  ("networkInterfaces" .=) <$> _i1NetworkInterfaces,
                  ("shieldedInstanceIntegrityPolicy" .=) <$>
                    _i1ShieldedInstanceIntegrityPolicy,
                  Just ("kind" .= _i1Kind),
                  ("fingerprint" .=) <$> _i1Fingerprint,
                  ("zone" .=) <$> _i1Zone,
                  ("confidentialInstanceConfig" .=) <$>
                    _i1ConfidentialInstanceConfig,
                  ("cpuPlatform" .=) <$> _i1CPUPlatform,
                  ("resourcePolicies" .=) <$> _i1ResourcePolicies,
                  ("selfLink" .=) <$> _i1SelfLink,
                  ("guestAccelerators" .=) <$> _i1GuestAccelerators,
                  ("lastStartTimestamp" .=) <$> _i1LastStartTimestamp,
                  ("name" .=) <$> _i1Name,
                  ("statusMessage" .=) <$> _i1StatusMessage,
                  ("creationTimestamp" .=) <$> _i1CreationTimestamp,
                  ("machineType" .=) <$> _i1MachineType,
                  ("metadata" .=) <$> _i1Metadata,
                  ("shieldedInstanceConfig" .=) <$>
                    _i1ShieldedInstanceConfig,
                  ("id" .=) <$> _i1Id, ("labels" .=) <$> _i1Labels,
                  ("startRestricted" .=) <$> _i1StartRestricted,
                  ("scheduling" .=) <$> _i1Scheduling,
                  ("minCpuPlatform" .=) <$> _i1MinCPUPlatform,
                  ("disks" .=) <$> _i1Disks,
                  ("canIpForward" .=) <$> _i1CanIPForward,
                  ("labelFingerprint" .=) <$> _i1LabelFingerprint,
                  ("description" .=) <$> _i1Description,
                  ("tags" .=) <$> _i1Tags,
                  ("privateIpv6GoogleAccess" .=) <$>
                    _i1PrivateIPv6GoogleAccess])

-- | Metadata defined as annotations on the network endpoint.
--
-- /See:/ 'networkEndpointAnnotations' smart constructor.
newtype NetworkEndpointAnnotations =
  NetworkEndpointAnnotations'
    { _neaAddtional :: HashMap Text Text
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'NetworkEndpointAnnotations' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'neaAddtional'
networkEndpointAnnotations
    :: HashMap Text Text -- ^ 'neaAddtional'
    -> NetworkEndpointAnnotations
networkEndpointAnnotations pNeaAddtional_ =
  NetworkEndpointAnnotations' {_neaAddtional = _Coerce # pNeaAddtional_}


neaAddtional :: Lens' NetworkEndpointAnnotations (HashMap Text Text)
neaAddtional
  = lens _neaAddtional (\ s a -> s{_neaAddtional = a})
      . _Coerce

instance FromJSON NetworkEndpointAnnotations where
        parseJSON
          = withObject "NetworkEndpointAnnotations"
              (\ o ->
                 NetworkEndpointAnnotations' <$> (parseJSONObject o))

instance ToJSON NetworkEndpointAnnotations where
        toJSON = toJSON . _neaAddtional

-- | A matcher for the path portion of the URL. The BackendService from the
-- longest-matched rule will serve the URL. If no rule was matched, the
-- default service will be used.
--
-- /See:/ 'pathMatcher' smart constructor.
data PathMatcher =
  PathMatcher'
    { _pmDefaultRouteAction :: !(Maybe HTTPRouteAction)
    , _pmDefaultURLRedirect :: !(Maybe HTTPRedirectAction)
    , _pmDefaultService :: !(Maybe Text)
    , _pmHeaderAction :: !(Maybe HTTPHeaderAction)
    , _pmRouteRules :: !(Maybe [HTTPRouteRule])
    , _pmName :: !(Maybe Text)
    , _pmPathRules :: !(Maybe [PathRule])
    , _pmDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PathMatcher' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pmDefaultRouteAction'
--
-- * 'pmDefaultURLRedirect'
--
-- * 'pmDefaultService'
--
-- * 'pmHeaderAction'
--
-- * 'pmRouteRules'
--
-- * 'pmName'
--
-- * 'pmPathRules'
--
-- * 'pmDescription'
pathMatcher
    :: PathMatcher
pathMatcher =
  PathMatcher'
    { _pmDefaultRouteAction = Nothing
    , _pmDefaultURLRedirect = Nothing
    , _pmDefaultService = Nothing
    , _pmHeaderAction = Nothing
    , _pmRouteRules = Nothing
    , _pmName = Nothing
    , _pmPathRules = Nothing
    , _pmDescription = Nothing
    }


-- | defaultRouteAction takes effect when none of the pathRules or routeRules
-- match. The load balancer performs advanced routing actions like URL
-- rewrites, header transformations, etc. prior to forwarding the request
-- to the selected backend. If defaultRouteAction specifies any
-- weightedBackendServices, defaultService must not be set. Conversely if
-- defaultService is set, defaultRouteAction cannot contain any
-- weightedBackendServices. Only one of defaultRouteAction or
-- defaultUrlRedirect must be set. UrlMaps for external HTTP(S) load
-- balancers support only the urlRewrite action within a pathMatcher\'s
-- defaultRouteAction.
pmDefaultRouteAction :: Lens' PathMatcher (Maybe HTTPRouteAction)
pmDefaultRouteAction
  = lens _pmDefaultRouteAction
      (\ s a -> s{_pmDefaultRouteAction = a})

-- | When none of the specified pathRules or routeRules match, the request is
-- redirected to a URL specified by defaultUrlRedirect. If
-- defaultUrlRedirect is specified, defaultService or defaultRouteAction
-- must not be set. Not supported when the URL map is bound to target gRPC
-- proxy.
pmDefaultURLRedirect :: Lens' PathMatcher (Maybe HTTPRedirectAction)
pmDefaultURLRedirect
  = lens _pmDefaultURLRedirect
      (\ s a -> s{_pmDefaultURLRedirect = a})

-- | The full or partial URL to the BackendService resource. This will be
-- used if none of the pathRules or routeRules defined by this PathMatcher
-- are matched. For example, the following are all valid URLs to a
-- BackendService resource: -
-- https:\/\/www.googleapis.com\/compute\/v1\/projects\/project\/global\/backendServices\/backendService
-- -
-- compute\/v1\/projects\/project\/global\/backendServices\/backendService
-- - global\/backendServices\/backendService If defaultRouteAction is
-- additionally specified, advanced routing actions like URL Rewrites, etc.
-- take effect prior to sending the request to the backend. However, if
-- defaultService is specified, defaultRouteAction cannot contain any
-- weightedBackendServices. Conversely, if defaultRouteAction specifies any
-- weightedBackendServices, defaultService must not be specified. Only one
-- of defaultService, defaultUrlRedirect or
-- defaultRouteAction.weightedBackendService must be set. Authorization
-- requires one or more of the following Google IAM permissions on the
-- specified resource default_service: - compute.backendBuckets.use -
-- compute.backendServices.use
pmDefaultService :: Lens' PathMatcher (Maybe Text)
pmDefaultService
  = lens _pmDefaultService
      (\ s a -> s{_pmDefaultService = a})

-- | Specifies changes to request and response headers that need to take
-- effect for the selected backendService. HeaderAction specified here are
-- applied after the matching HttpRouteRule HeaderAction and before the
-- HeaderAction in the UrlMap Note that headerAction is not supported for
-- Loadbalancers that have their loadBalancingScheme set to EXTERNAL. Not
-- supported when the URL map is bound to target gRPC proxy that has
-- validateForProxyless field set to true.
pmHeaderAction :: Lens' PathMatcher (Maybe HTTPHeaderAction)
pmHeaderAction
  = lens _pmHeaderAction
      (\ s a -> s{_pmHeaderAction = a})

-- | The list of HTTP route rules. Use this list instead of pathRules when
-- advanced route matching and routing actions are desired. routeRules are
-- evaluated in order of priority, from the lowest to highest number.
-- Within a given pathMatcher, you can set only one of pathRules or
-- routeRules.
pmRouteRules :: Lens' PathMatcher [HTTPRouteRule]
pmRouteRules
  = lens _pmRouteRules (\ s a -> s{_pmRouteRules = a})
      . _Default
      . _Coerce

-- | The name to which this PathMatcher is referred by the HostRule.
pmName :: Lens' PathMatcher (Maybe Text)
pmName = lens _pmName (\ s a -> s{_pmName = a})

-- | The list of path rules. Use this list instead of routeRules when routing
-- based on simple path matching is all that\'s required. The order by
-- which path rules are specified does not matter. Matches are always done
-- on the longest-path-first basis. For example: a pathRule with a path
-- \/a\/b\/c\/* will match before \/a\/b\/* irrespective of the order in
-- which those paths appear in this list. Within a given pathMatcher, only
-- one of pathRules or routeRules must be set.
pmPathRules :: Lens' PathMatcher [PathRule]
pmPathRules
  = lens _pmPathRules (\ s a -> s{_pmPathRules = a}) .
      _Default
      . _Coerce

-- | An optional description of this resource. Provide this property when you
-- create the resource.
pmDescription :: Lens' PathMatcher (Maybe Text)
pmDescription
  = lens _pmDescription
      (\ s a -> s{_pmDescription = a})

instance FromJSON PathMatcher where
        parseJSON
          = withObject "PathMatcher"
              (\ o ->
                 PathMatcher' <$>
                   (o .:? "defaultRouteAction") <*>
                     (o .:? "defaultUrlRedirect")
                     <*> (o .:? "defaultService")
                     <*> (o .:? "headerAction")
                     <*> (o .:? "routeRules" .!= mempty)
                     <*> (o .:? "name")
                     <*> (o .:? "pathRules" .!= mempty)
                     <*> (o .:? "description"))

instance ToJSON PathMatcher where
        toJSON PathMatcher'{..}
          = object
              (catMaybes
                 [("defaultRouteAction" .=) <$> _pmDefaultRouteAction,
                  ("defaultUrlRedirect" .=) <$> _pmDefaultURLRedirect,
                  ("defaultService" .=) <$> _pmDefaultService,
                  ("headerAction" .=) <$> _pmHeaderAction,
                  ("routeRules" .=) <$> _pmRouteRules,
                  ("name" .=) <$> _pmName,
                  ("pathRules" .=) <$> _pmPathRules,
                  ("description" .=) <$> _pmDescription])

-- | Represents a Packet Mirroring resource. Packet Mirroring clones the
-- traffic of specified instances in your Virtual Private Cloud (VPC)
-- network and forwards it to a collector destination, such as an instance
-- group of an internal TCP\/UDP load balancer, for analysis or
-- examination. For more information about setting up Packet Mirroring, see
-- Using Packet Mirroring. (== resource_for {$api_version}.packetMirrorings
-- ==)
--
-- /See:/ 'packetMirroring' smart constructor.
data PacketMirroring =
  PacketMirroring'
    { _pacPriority :: !(Maybe (Textual Word32))
    , _pacKind :: !Text
    , _pacNetwork :: !(Maybe PacketMirroringNetworkInfo)
    , _pacMirroredResources :: !(Maybe PacketMirroringMirroredResourceInfo)
    , _pacEnable :: !(Maybe PacketMirroringEnable)
    , _pacCollectorIlb :: !(Maybe PacketMirroringForwardingRuleInfo)
    , _pacSelfLink :: !(Maybe Text)
    , _pacName :: !(Maybe Text)
    , _pacCreationTimestamp :: !(Maybe Text)
    , _pacId :: !(Maybe (Textual Word64))
    , _pacFilter :: !(Maybe PacketMirroringFilter)
    , _pacRegion :: !(Maybe Text)
    , _pacDescription :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'PacketMirroring' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'pacPriority'
--
-- * 'pacKind'
--
-- * 'pacNetwork'
--
-- * 'pacMirroredResources'
--
-- * 'pacEnable'
--
-- * 'pacCollectorIlb'
--
-- * 'pacSelfLink'
--
-- * 'pacName'
--
-- * 'pacCreationTimestamp'
--
-- * 'pacId'
--
-- * 'pacFilter'
--
-- * 'pacRegion'
--
-- * 'pacDescription'
packetMirroring
    :: PacketMirroring
packetMirroring =
  PacketMirroring'
    { _pacPriority = Nothing
    , _pacKind = "compute#packetMirroring"
    , _pacNetwork = Nothing
    , _pacMirroredResources = Nothing
    , _pacEnable = Nothing
    , _pacCollectorIlb = Nothing
    , _pacSelfLink = Nothing
    , _pacName = Nothing
    , _pacCreationTimestamp = Nothing
    , _pacId = Nothing
    , _pacFilter = Nothing
    , _pacRegion = Nothing
    , _pacDescription = Nothing
    }


-- | The priority of applying this configuration. Priority is used to break
-- ties in cases where there is more than one matching rule. In the case of
-- two rules that apply for a given Instance, the one with the
-- lowest-numbered priority value wins. Default value is 1000. Valid range
-- is 0 through 65535.
pacPriority :: Lens' PacketMirroring (Maybe Word32)
pacPriority
  = lens _pacPriority (\ s a -> s{_pacPriority = a}) .
      mapping _Coerce

-- | [Output Only] Type of the resource. Always compute#packetMirroring for
-- packet mirrorings.
pacKind :: Lens' PacketMirroring Text
pacKind = lens _pacKind (\ s a -> s{_pacKind = a})

-- | Specifies the mirrored VPC network. Only packets in this network will be
-- mirrored. All mirrored VMs should have a NIC in the given network. All
-- mirrored subnetworks should belong to the given network.
pacNetwork :: Lens' PacketMirroring (Maybe PacketMirroringNetworkInfo)
pacNetwork
  = lens _pacNetwork (\ s a -> s{_pacNetwork = a})

-- | PacketMirroring mirroredResourceInfos. MirroredResourceInfo specifies a
-- set of mirrored VM instances, subnetworks and\/or tags for which traffic
-- from\/to all VM instances will be mirrored.
pacMirroredResources :: Lens' PacketMirroring (Maybe PacketMirroringMirroredResourceInfo)
pacMirroredResources
  = lens _pacMirroredResources
      (\ s a -> s{_pacMirroredResources = a})

-- | Indicates whether or not this packet mirroring takes effect. If set to
-- FALSE, this packet mirroring policy will not be enforced on the network.
-- The default is TRUE.
pacEnable :: Lens' PacketMirroring (Maybe PacketMirroringEnable)
pacEnable
  = lens _pacEnable (\ s a -> s{_pacEnable = a})

-- | The Forwarding Rule resource of type loadBalancingScheme=INTERNAL that
-- will be used as collector for mirrored traffic. The specified forwarding
-- rule must have isMirroringCollector set to true.
pacCollectorIlb :: Lens' PacketMirroring (Maybe PacketMirroringForwardingRuleInfo)
pacCollectorIlb
  = lens _pacCollectorIlb
      (\ s a -> s{_pacCollectorIlb = a})

-- | [Output Only] Server-defined URL for the resource.
pacSelfLink :: Lens' PacketMirroring (Maybe Text)
pacSelfLink
  = lens _pacSelfLink (\ s a -> s{_pacSelfLink = a})

-- | Name of the resource; provided by the client when the resource is
-- created. The name must be 1-63 characters long, and comply with RFC1035.
-- Specifically, the name must be 1-63 characters long and match the
-- regular expression \`[a-z]([-a-z0-9]*[a-z0-9])?\` which means the first
-- character must be a lowercase letter, and all following characters must
-- be a dash, lowercase letter, or digit, except the last character, which
-- cannot be a dash.
pacName :: Lens' PacketMirroring (Maybe Text)
pacName = lens _pacName (\ s a -> s{_pacName = a})

-- | [Output Only] Creation timestamp in RFC3339 text format.
pacCreationTimestamp :: Lens' PacketMirroring (Maybe Text)
pacCreationTimestamp
  = lens _pacCreationTimestamp
      (\ s a -> s{_pacCreationTimestamp = a})

-- | [Output Only] The unique identifier for the resource. This identifier is
-- defined by the server.
pacId :: Lens' PacketMirroring (Maybe Word64)
pacId
  = lens _pacId (\ s a -> s{_pacId = a}) .
      mapping _Coerce

-- | Filter for mirrored traffic. If unspecified, all traffic is mirrored.
pacFilter :: Lens' PacketMirroring (Maybe PacketMirroringFilter)
pacFilter
  = lens _pacFilter (\ s a -> s{_pacFilter = a})

-- | [Output Only] URI of the region where the packetMirroring resides.
pacRegion :: Lens' PacketMirroring (Maybe Text)
pacRegion
  = lens _pacRegion (\ s a -> s{_pacRegion = a})

-- | An optional description of this resource. Provide this property when you
-- create the resource.
pacDescription :: Lens' PacketMirroring (Maybe Text)
pacDescription
  = lens _pacDescription
      (\ s a -> s{_pacDescription = a})

instance FromJSON PacketMirroring where
        parseJSON
          = withObject "PacketMirroring"
              (\ o ->
                 PacketMirroring' <$>
                   (o .:? "priority") <*>
                     (o .:? "kind" .!= "compute#packetMirroring")
                     <*> (o .:? "network")
                     <*> (o .:? "mirroredResources")
                     <*> (o .:? "enable")
                     <*> (o .:? "collectorIlb")
                     <*> (o .:? "selfLink")
                     <*> (o .:? "name")
                     <*> (o .:? "creationTimestamp")
                     <*> (o .:? "id")
                     <*> (o .:? "filter")
                     <*> (o .:? "region")
                     <*> (o .:? "description"))

instance ToJSON PacketMirroring where
        toJSON PacketMirroring'{..}
          = object
              (catMaybes
                 [("priority" .=) <$> _pacPriority,
                  Just ("kind" .= _pacKind),
                  ("network" .=) <$> _pacNetwork,
                  ("mirroredResources" .=) <$> _pacMirroredResources,
                  ("enable" .=) <$> _pacEnable,
                  ("collectorIlb" .=) <$> _pacCollectorIlb,
                  ("selfLink" .=) <$> _pacSelfLink,
                  ("name" .=) <$> _pacName,
                  ("creationTimestamp" .=) <$> _pacCreationTimestamp,
                  ("id" .=) <$> _pacId, ("filter" .=) <$> _pacFilter,
                  ("region" .=) <$> _pacRegion,
                  ("description" .=) <$> _pacDescription])

-- | [Output Only] Informational warning message.
--
-- /See:/ 'backendServiceListWarning' smart constructor.
data BackendServiceListWarning =
  BackendServiceListWarning'
    { _bslwData :: !(Maybe [BackendServiceListWarningDataItem])
    , _bslwCode :: !(Maybe BackendServiceListWarningCode)
    , _bslwMessage :: !(Maybe Text)
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'BackendServiceListWarning' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'bslwData'
--
-- * 'bslwCode'
--
-- * 'bslwMessage'
backendServiceListWarning
    :: BackendServiceListWarning
backendServiceListWarning =
  BackendServiceListWarning'
    {_bslwData = Nothing, _bslwCode = Nothing, _bslwMessage = Nothing}


-- | [Output Only] Metadata about this warning in key: value format. For
-- example: \"data\": [ { \"key\": \"scope\", \"value\":
-- \"zones\/us-east1-d\" }
bslwData :: Lens' BackendServiceListWarning [BackendServiceListWarningDataItem]
bslwData
  = lens _bslwData (\ s a -> s{_bslwData = a}) .
      _Default
      . _Coerce

-- | [Output Only] A warning code, if applicable. For example, Compute Engine
-- returns NO_RESULTS_ON_PAGE if there are no results in the response.
bslwCode :: Lens' BackendServiceListWarning (Maybe BackendServiceListWarningCode)
bslwCode = lens _bslwCode (\ s a -> s{_bslwCode = a})

-- | [Output Only] A human-readable description of the warning code.
bslwMessage :: Lens' BackendServiceListWarning (Maybe Text)
bslwMessage
  = lens _bslwMessage (\ s a -> s{_bslwMessage = a})

instance FromJSON BackendServiceListWarning where
        parseJSON
          = withObject "BackendServiceListWarning"
              (\ o ->
                 BackendServiceListWarning' <$>
                   (o .:? "data" .!= mempty) <*> (o .:? "code") <*>
                     (o .:? "message"))

instance ToJSON BackendServiceListWarning where
        toJSON BackendServiceListWarning'{..}
          = object
              (catMaybes
                 [("data" .=) <$> _bslwData,
                  ("code" .=) <$> _bslwCode,
                  ("message" .=) <$> _bslwMessage])

-- | A list of VpnGateway resources.
--
-- /See:/ 'vpnGatewayAggregatedListItems' smart constructor.
newtype VPNGatewayAggregatedListItems =
  VPNGatewayAggregatedListItems'
    { _vgaliAddtional :: HashMap Text VPNGatewaysScopedList
    }
  deriving (Eq, Show, Data, Typeable, Generic)


-- | Creates a value of 'VPNGatewayAggregatedListItems' with the minimum fields required to make a request.
--
-- Use one of the following lenses to modify other fields as desired:
--
-- * 'vgaliAddtional'
vpnGatewayAggregatedListItems
    :: HashMap Text VPNGatewaysScopedList -- ^ 'vgaliAddtional'
    -> VPNGatewayAggregatedListItems
vpnGatewayAggregatedListItems pVgaliAddtional_ =
  VPNGatewayAggregatedListItems' {_vgaliAddtional = _Coerce # pVgaliAddtional_}


-- | [Output Only] Name of the scope containing this set of VPN gateways.
vgaliAddtional :: Lens' VPNGatewayAggregatedListItems (HashMap Text VPNGatewaysScopedList)
vgaliAddtional
  = lens _vgaliAddtional
      (\ s a -> s{_vgaliAddtional = a})
      . _Coerce

instance FromJSON VPNGatewayAggregatedListItems where
        parseJSON
          = withObject "VPNGatewayAggregatedListItems"
              (\ o ->
                 VPNGatewayAggregatedListItems' <$>
                   (parseJSONObject o))

instance ToJSON VPNGatewayAggregatedListItems where
        toJSON = toJSON . _vgaliAddtional
