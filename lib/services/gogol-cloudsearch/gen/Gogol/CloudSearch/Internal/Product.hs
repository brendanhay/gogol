{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE PatternSynonyms #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE StrictData #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# OPTIONS_GHC -fno-warn-duplicate-exports #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-binds #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-- |
-- Module      : Gogol.CloudSearch.Internal.Product
-- Copyright   : (c) 2015-2022 Brendan Hay
-- License     : Mozilla Public License, v. 2.0.
-- Maintainer  : Brendan Hay <brendan.g.hay+gogol@gmail.com>
-- Stability   : auto-generated
-- Portability : non-portable (GHC extensions)
module Gogol.CloudSearch.Internal.Product
  ( -- * AbuseReportingConfig
    AbuseReportingConfig (..),
    newAbuseReportingConfig,

    -- * AckInfo
    AckInfo (..),
    newAckInfo,

    -- * AclFixRequest
    AclFixRequest (..),
    newAclFixRequest,

    -- * AclFixStatus
    AclFixStatus (..),
    newAclFixStatus,

    -- * AclInfo
    AclInfo (..),
    newAclInfo,

    -- * ActionParameter
    ActionParameter (..),
    newActionParameter,

    -- * AddonComposeUiActionMarkup
    AddonComposeUiActionMarkup (..),
    newAddonComposeUiActionMarkup,

    -- * AffectedMembership
    AffectedMembership (..),
    newAffectedMembership,

    -- * AllAuthenticatedUsersProto
    AllAuthenticatedUsersProto (..),
    newAllAuthenticatedUsersProto,

    -- * Annotation
    Annotation (..),
    newAnnotation,

    -- * AppId
    AppId (..),
    newAppId,

    -- * AppsDynamiteSharedActivityFeedAnnotationData
    AppsDynamiteSharedActivityFeedAnnotationData (..),
    newAppsDynamiteSharedActivityFeedAnnotationData,

    -- * AppsDynamiteSharedActivityFeedAnnotationDataUserInfo
    AppsDynamiteSharedActivityFeedAnnotationDataUserInfo (..),
    newAppsDynamiteSharedActivityFeedAnnotationDataUserInfo,

    -- * AppsDynamiteSharedAppProfile
    AppsDynamiteSharedAppProfile (..),
    newAppsDynamiteSharedAppProfile,

    -- * AppsDynamiteSharedAssistantAnnotationData
    AppsDynamiteSharedAssistantAnnotationData (..),
    newAppsDynamiteSharedAssistantAnnotationData,

    -- * AppsDynamiteSharedAssistantDebugContext
    AppsDynamiteSharedAssistantDebugContext (..),
    newAppsDynamiteSharedAssistantDebugContext,

    -- * AppsDynamiteSharedAssistantFeedbackContext
    AppsDynamiteSharedAssistantFeedbackContext (..),
    newAppsDynamiteSharedAssistantFeedbackContext,

    -- * AppsDynamiteSharedAssistantFeedbackContextFeedbackChip
    AppsDynamiteSharedAssistantFeedbackContextFeedbackChip (..),
    newAppsDynamiteSharedAssistantFeedbackContextFeedbackChip,

    -- * AppsDynamiteSharedAssistantSessionContext
    AppsDynamiteSharedAssistantSessionContext (..),
    newAppsDynamiteSharedAssistantSessionContext,

    -- * AppsDynamiteSharedAssistantSuggestion
    AppsDynamiteSharedAssistantSuggestion (..),
    newAppsDynamiteSharedAssistantSuggestion,

    -- * AppsDynamiteSharedAssistantUnfulfillableRequest
    AppsDynamiteSharedAssistantUnfulfillableRequest (..),
    newAppsDynamiteSharedAssistantUnfulfillableRequest,

    -- * AppsDynamiteSharedAvatarInfo
    AppsDynamiteSharedAvatarInfo (..),
    newAppsDynamiteSharedAvatarInfo,

    -- * AppsDynamiteSharedBackendUploadMetadata
    AppsDynamiteSharedBackendUploadMetadata (..),
    newAppsDynamiteSharedBackendUploadMetadata,

    -- * AppsDynamiteSharedCalendarEventAnnotationData
    AppsDynamiteSharedCalendarEventAnnotationData (..),
    newAppsDynamiteSharedCalendarEventAnnotationData,

    -- * AppsDynamiteSharedCalendarEventAnnotationDataCalendarEvent
    AppsDynamiteSharedCalendarEventAnnotationDataCalendarEvent (..),
    newAppsDynamiteSharedCalendarEventAnnotationDataCalendarEvent,

    -- * AppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime
    AppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime (..),
    newAppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime,

    -- * AppsDynamiteSharedCalendarEventAnnotationDataEventCreation
    AppsDynamiteSharedCalendarEventAnnotationDataEventCreation (..),
    newAppsDynamiteSharedCalendarEventAnnotationDataEventCreation,

    -- * AppsDynamiteSharedCallAnnotationData
    AppsDynamiteSharedCallAnnotationData (..),
    newAppsDynamiteSharedCallAnnotationData,

    -- * AppsDynamiteSharedCallMetadata
    AppsDynamiteSharedCallMetadata (..),
    newAppsDynamiteSharedCallMetadata,

    -- * AppsDynamiteSharedCardClickSuggestion
    AppsDynamiteSharedCardClickSuggestion (..),
    newAppsDynamiteSharedCardClickSuggestion,

    -- * AppsDynamiteSharedChatItem
    AppsDynamiteSharedChatItem (..),
    newAppsDynamiteSharedChatItem,

    -- * AppsDynamiteSharedChatItemActivityInfo
    AppsDynamiteSharedChatItemActivityInfo (..),
    newAppsDynamiteSharedChatItemActivityInfo,

    -- * AppsDynamiteSharedChatItemActivityInfoFeedItemNudge
    AppsDynamiteSharedChatItemActivityInfoFeedItemNudge (..),
    newAppsDynamiteSharedChatItemActivityInfoFeedItemNudge,

    -- * AppsDynamiteSharedChatItemActivityInfoFeedItemReactions
    AppsDynamiteSharedChatItemActivityInfoFeedItemReactions (..),
    newAppsDynamiteSharedChatItemActivityInfoFeedItemReactions,

    -- * AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReply
    AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReply (..),
    newAppsDynamiteSharedChatItemActivityInfoFeedItemThreadReply,

    -- * AppsDynamiteSharedChatItemActivityInfoFeedItemUserMention
    AppsDynamiteSharedChatItemActivityInfoFeedItemUserMention (..),
    newAppsDynamiteSharedChatItemActivityInfoFeedItemUserMention,

    -- * AppsDynamiteSharedChatItemGroupInfo
    AppsDynamiteSharedChatItemGroupInfo (..),
    newAppsDynamiteSharedChatItemGroupInfo,

    -- * AppsDynamiteSharedContentReportType
    AppsDynamiteSharedContentReportType (..),
    newAppsDynamiteSharedContentReportType,

    -- * AppsDynamiteSharedCustomEmoji
    AppsDynamiteSharedCustomEmoji (..),
    newAppsDynamiteSharedCustomEmoji,

    -- * AppsDynamiteSharedDimension
    AppsDynamiteSharedDimension (..),
    newAppsDynamiteSharedDimension,

    -- * AppsDynamiteSharedDlpMetricsMetadata
    AppsDynamiteSharedDlpMetricsMetadata (..),
    newAppsDynamiteSharedDlpMetricsMetadata,

    -- * AppsDynamiteSharedDocument
    AppsDynamiteSharedDocument (..),
    newAppsDynamiteSharedDocument,

    -- * AppsDynamiteSharedEmoji
    AppsDynamiteSharedEmoji (..),
    newAppsDynamiteSharedEmoji,

    -- * AppsDynamiteSharedFindDocumentSuggestion
    AppsDynamiteSharedFindDocumentSuggestion (..),
    newAppsDynamiteSharedFindDocumentSuggestion,

    -- * AppsDynamiteSharedGroupDetails
    AppsDynamiteSharedGroupDetails (..),
    newAppsDynamiteSharedGroupDetails,

    -- * AppsDynamiteSharedGroupVisibility
    AppsDynamiteSharedGroupVisibility (..),
    newAppsDynamiteSharedGroupVisibility,

    -- * AppsDynamiteSharedJustification
    AppsDynamiteSharedJustification (..),
    newAppsDynamiteSharedJustification,

    -- * AppsDynamiteSharedJustificationPerson
    AppsDynamiteSharedJustificationPerson (..),
    newAppsDynamiteSharedJustificationPerson,

    -- * AppsDynamiteSharedMeetMetadata
    AppsDynamiteSharedMeetMetadata (..),
    newAppsDynamiteSharedMeetMetadata,

    -- * AppsDynamiteSharedMessageComponentSearchInfo
    AppsDynamiteSharedMessageComponentSearchInfo (..),
    newAppsDynamiteSharedMessageComponentSearchInfo,

    -- * AppsDynamiteSharedMessageInfo
    AppsDynamiteSharedMessageInfo (..),
    newAppsDynamiteSharedMessageInfo,

    -- * AppsDynamiteSharedMessageIntegrationPayload
    AppsDynamiteSharedMessageIntegrationPayload (..),
    newAppsDynamiteSharedMessageIntegrationPayload,

    -- * AppsDynamiteSharedOrganizationInfo
    AppsDynamiteSharedOrganizationInfo (..),
    newAppsDynamiteSharedOrganizationInfo,

    -- * AppsDynamiteSharedOrganizationInfoConsumerInfo
    AppsDynamiteSharedOrganizationInfoConsumerInfo (..),
    newAppsDynamiteSharedOrganizationInfoConsumerInfo,

    -- * AppsDynamiteSharedOrganizationInfoCustomerInfo
    AppsDynamiteSharedOrganizationInfoCustomerInfo (..),
    newAppsDynamiteSharedOrganizationInfoCustomerInfo,

    -- * AppsDynamiteSharedOriginAppSuggestion
    AppsDynamiteSharedOriginAppSuggestion (..),
    newAppsDynamiteSharedOriginAppSuggestion,

    -- * AppsDynamiteSharedPhoneNumber
    AppsDynamiteSharedPhoneNumber (..),
    newAppsDynamiteSharedPhoneNumber,

    -- * AppsDynamiteSharedReaction
    AppsDynamiteSharedReaction (..),
    newAppsDynamiteSharedReaction,

    -- * AppsDynamiteSharedRetentionSettings
    AppsDynamiteSharedRetentionSettings (..),
    newAppsDynamiteSharedRetentionSettings,

    -- * AppsDynamiteSharedSegmentedMembershipCount
    AppsDynamiteSharedSegmentedMembershipCount (..),
    newAppsDynamiteSharedSegmentedMembershipCount,

    -- * AppsDynamiteSharedSegmentedMembershipCounts
    AppsDynamiteSharedSegmentedMembershipCounts (..),
    newAppsDynamiteSharedSegmentedMembershipCounts,

    -- * AppsDynamiteSharedSpaceInfo
    AppsDynamiteSharedSpaceInfo (..),
    newAppsDynamiteSharedSpaceInfo,

    -- * AppsDynamiteSharedTasksAnnotationData
    AppsDynamiteSharedTasksAnnotationData (..),
    newAppsDynamiteSharedTasksAnnotationData,

    -- * AppsDynamiteSharedTasksAnnotationDataAssigneeChange
    AppsDynamiteSharedTasksAnnotationDataAssigneeChange (..),
    newAppsDynamiteSharedTasksAnnotationDataAssigneeChange,

    -- * AppsDynamiteSharedTasksAnnotationDataCompletionChange
    AppsDynamiteSharedTasksAnnotationDataCompletionChange (..),
    newAppsDynamiteSharedTasksAnnotationDataCompletionChange,

    -- * AppsDynamiteSharedTasksAnnotationDataCreation
    AppsDynamiteSharedTasksAnnotationDataCreation (..),
    newAppsDynamiteSharedTasksAnnotationDataCreation,

    -- * AppsDynamiteSharedTasksAnnotationDataDeletionChange
    AppsDynamiteSharedTasksAnnotationDataDeletionChange (..),
    newAppsDynamiteSharedTasksAnnotationDataDeletionChange,

    -- * AppsDynamiteSharedTasksAnnotationDataTaskProperties
    AppsDynamiteSharedTasksAnnotationDataTaskProperties (..),
    newAppsDynamiteSharedTasksAnnotationDataTaskProperties,

    -- * AppsDynamiteSharedTasksAnnotationDataUserDefinedMessage
    AppsDynamiteSharedTasksAnnotationDataUserDefinedMessage (..),
    newAppsDynamiteSharedTasksAnnotationDataUserDefinedMessage,

    -- * AppsDynamiteSharedTasksMessageIntegrationPayload
    AppsDynamiteSharedTasksMessageIntegrationPayload (..),
    newAppsDynamiteSharedTasksMessageIntegrationPayload,

    -- * AppsDynamiteSharedTextSegment
    AppsDynamiteSharedTextSegment (..),
    newAppsDynamiteSharedTextSegment,

    -- * AppsDynamiteSharedTextSegmentsWithDescription
    AppsDynamiteSharedTextSegmentsWithDescription (..),
    newAppsDynamiteSharedTextSegmentsWithDescription,

    -- * AppsDynamiteSharedTextWithDescription
    AppsDynamiteSharedTextWithDescription (..),
    newAppsDynamiteSharedTextWithDescription,

    -- * AppsDynamiteSharedUserBlockRelationship
    AppsDynamiteSharedUserBlockRelationship (..),
    newAppsDynamiteSharedUserBlockRelationship,

    -- * AppsDynamiteSharedVideoReference
    AppsDynamiteSharedVideoReference (..),
    newAppsDynamiteSharedVideoReference,

    -- * AppsDynamiteStorageAction
    AppsDynamiteStorageAction (..),
    newAppsDynamiteStorageAction,

    -- * AppsDynamiteStorageActionActionParameter
    AppsDynamiteStorageActionActionParameter (..),
    newAppsDynamiteStorageActionActionParameter,

    -- * AppsDynamiteStorageBorderStyle
    AppsDynamiteStorageBorderStyle (..),
    newAppsDynamiteStorageBorderStyle,

    -- * AppsDynamiteStorageButton
    AppsDynamiteStorageButton (..),
    newAppsDynamiteStorageButton,

    -- * AppsDynamiteStorageButtonList
    AppsDynamiteStorageButtonList (..),
    newAppsDynamiteStorageButtonList,

    -- * AppsDynamiteStorageCard
    AppsDynamiteStorageCard (..),
    newAppsDynamiteStorageCard,

    -- * AppsDynamiteStorageCardCardAction
    AppsDynamiteStorageCardCardAction (..),
    newAppsDynamiteStorageCardCardAction,

    -- * AppsDynamiteStorageCardCardHeader
    AppsDynamiteStorageCardCardHeader (..),
    newAppsDynamiteStorageCardCardHeader,

    -- * AppsDynamiteStorageCardSection
    AppsDynamiteStorageCardSection (..),
    newAppsDynamiteStorageCardSection,

    -- * AppsDynamiteStorageColumns
    AppsDynamiteStorageColumns (..),
    newAppsDynamiteStorageColumns,

    -- * AppsDynamiteStorageColumnsColumn
    AppsDynamiteStorageColumnsColumn (..),
    newAppsDynamiteStorageColumnsColumn,

    -- * AppsDynamiteStorageColumnsColumnWidgets
    AppsDynamiteStorageColumnsColumnWidgets (..),
    newAppsDynamiteStorageColumnsColumnWidgets,

    -- * AppsDynamiteStorageDateTimePicker
    AppsDynamiteStorageDateTimePicker (..),
    newAppsDynamiteStorageDateTimePicker,

    -- * AppsDynamiteStorageDecoratedText
    AppsDynamiteStorageDecoratedText (..),
    newAppsDynamiteStorageDecoratedText,

    -- * AppsDynamiteStorageDecoratedTextSwitchControl
    AppsDynamiteStorageDecoratedTextSwitchControl (..),
    newAppsDynamiteStorageDecoratedTextSwitchControl,

    -- * AppsDynamiteStorageDivider
    AppsDynamiteStorageDivider (..),
    newAppsDynamiteStorageDivider,

    -- * AppsDynamiteStorageGrid
    AppsDynamiteStorageGrid (..),
    newAppsDynamiteStorageGrid,

    -- * AppsDynamiteStorageGridGridItem
    AppsDynamiteStorageGridGridItem (..),
    newAppsDynamiteStorageGridGridItem,

    -- * AppsDynamiteStorageIcon
    AppsDynamiteStorageIcon (..),
    newAppsDynamiteStorageIcon,

    -- * AppsDynamiteStorageImage
    AppsDynamiteStorageImage (..),
    newAppsDynamiteStorageImage,

    -- * AppsDynamiteStorageImageComponent
    AppsDynamiteStorageImageComponent (..),
    newAppsDynamiteStorageImageComponent,

    -- * AppsDynamiteStorageImageCropStyle
    AppsDynamiteStorageImageCropStyle (..),
    newAppsDynamiteStorageImageCropStyle,

    -- * AppsDynamiteStorageMaterialIcon
    AppsDynamiteStorageMaterialIcon (..),
    newAppsDynamiteStorageMaterialIcon,

    -- * AppsDynamiteStorageOnClick
    AppsDynamiteStorageOnClick (..),
    newAppsDynamiteStorageOnClick,

    -- * AppsDynamiteStorageOpenLink
    AppsDynamiteStorageOpenLink (..),
    newAppsDynamiteStorageOpenLink,

    -- * AppsDynamiteStorageOpenLinkAppUri
    AppsDynamiteStorageOpenLinkAppUri (..),
    newAppsDynamiteStorageOpenLinkAppUri,

    -- * AppsDynamiteStorageOpenLinkAppUriIntent
    AppsDynamiteStorageOpenLinkAppUriIntent (..),
    newAppsDynamiteStorageOpenLinkAppUriIntent,

    -- * AppsDynamiteStorageOpenLinkAppUriIntentExtraData
    AppsDynamiteStorageOpenLinkAppUriIntentExtraData (..),
    newAppsDynamiteStorageOpenLinkAppUriIntentExtraData,

    -- * AppsDynamiteStorageSelectionInput
    AppsDynamiteStorageSelectionInput (..),
    newAppsDynamiteStorageSelectionInput,

    -- * AppsDynamiteStorageSelectionInputSelectionItem
    AppsDynamiteStorageSelectionInputSelectionItem (..),
    newAppsDynamiteStorageSelectionInputSelectionItem,

    -- * AppsDynamiteStorageSuggestions
    AppsDynamiteStorageSuggestions (..),
    newAppsDynamiteStorageSuggestions,

    -- * AppsDynamiteStorageSuggestionsSuggestionItem
    AppsDynamiteStorageSuggestionsSuggestionItem (..),
    newAppsDynamiteStorageSuggestionsSuggestionItem,

    -- * AppsDynamiteStorageTextInput
    AppsDynamiteStorageTextInput (..),
    newAppsDynamiteStorageTextInput,

    -- * AppsDynamiteStorageTextParagraph
    AppsDynamiteStorageTextParagraph (..),
    newAppsDynamiteStorageTextParagraph,

    -- * AppsDynamiteStorageWidget
    AppsDynamiteStorageWidget (..),
    newAppsDynamiteStorageWidget,

    -- * AppsDynamiteV1ApiCompatV1Action
    AppsDynamiteV1ApiCompatV1Action (..),
    newAppsDynamiteV1ApiCompatV1Action,

    -- * AppsDynamiteV1ApiCompatV1ActionConfirm
    AppsDynamiteV1ApiCompatV1ActionConfirm (..),
    newAppsDynamiteV1ApiCompatV1ActionConfirm,

    -- * AppsDynamiteV1ApiCompatV1Attachment
    AppsDynamiteV1ApiCompatV1Attachment (..),
    newAppsDynamiteV1ApiCompatV1Attachment,

    -- * AppsDynamiteV1ApiCompatV1Field
    AppsDynamiteV1ApiCompatV1Field (..),
    newAppsDynamiteV1ApiCompatV1Field,

    -- * AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkup
    AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkup (..),
    newAppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkup,

    -- * AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkupAddonAttachment
    AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkupAddonAttachment (..),
    newAppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkupAddonAttachment,

    -- * AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkup
    AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkup (..),
    newAppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkup,

    -- * AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup
    AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup (..),
    newAppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup,

    -- * AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupError
    AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupError (..),
    newAppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupError,

    -- * AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupParameter
    AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupParameter (..),
    newAppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupParameter,

    -- * AppsExtensionsMarkupCalendarClientActionMarkupEditAttendeesActionMarkup
    AppsExtensionsMarkupCalendarClientActionMarkupEditAttendeesActionMarkup (..),
    newAppsExtensionsMarkupCalendarClientActionMarkupEditAttendeesActionMarkup,

    -- * AppsExtensionsMarkupCalendarClientActionMarkupEditConferenceDataActionMarkup
    AppsExtensionsMarkupCalendarClientActionMarkupEditConferenceDataActionMarkup (..),
    newAppsExtensionsMarkupCalendarClientActionMarkupEditConferenceDataActionMarkup,

    -- * Attachment
    Attachment (..),
    newAttachment,

    -- * Attribute
    Attribute (..),
    newAttribute,

    -- * AttributeRemoved
    AttributeRemoved (..),
    newAttributeRemoved,

    -- * AttributeSet
    AttributeSet (..),
    newAttributeSet,

    -- * Attributes
    Attributes (..),
    newAttributes,

    -- * AuditLoggingSettings
    AuditLoggingSettings (..),
    newAuditLoggingSettings,

    -- * AuthorizedItemId
    AuthorizedItemId (..),
    newAuthorizedItemId,

    -- * AutoComplete
    AutoComplete (..),
    newAutoComplete,

    -- * AutoCompleteItem
    AutoCompleteItem (..),
    newAutoCompleteItem,

    -- * BabelMessageProps
    BabelMessageProps (..),
    newBabelMessageProps,

    -- * BabelPlaceholderMetadata
    BabelPlaceholderMetadata (..),
    newBabelPlaceholderMetadata,

    -- * BooleanOperatorOptions
    BooleanOperatorOptions (..),
    newBooleanOperatorOptions,

    -- * BooleanPropertyOptions
    BooleanPropertyOptions (..),
    newBooleanPropertyOptions,

    -- * BorderStyle
    BorderStyle (..),
    newBorderStyle,

    -- * BotInfo
    BotInfo (..),
    newBotInfo,

    -- * BotResponse
    BotResponse (..),
    newBotResponse,

    -- * BroadcastAccess
    BroadcastAccess (..),
    newBroadcastAccess,

    -- * BroadcastSessionInfo
    BroadcastSessionInfo (..),
    newBroadcastSessionInfo,

    -- * BroadcastStats
    BroadcastStats (..),
    newBroadcastStats,

    -- * Button
    Button (..),
    newButton,

    -- * CalendarClientActionMarkup
    CalendarClientActionMarkup (..),
    newCalendarClientActionMarkup,

    -- * CallInfo
    CallInfo (..),
    newCallInfo,

    -- * CallSettings
    CallSettings (..),
    newCallSettings,

    -- * CapTokenHolderProto
    CapTokenHolderProto (..),
    newCapTokenHolderProto,

    -- * Card
    Card (..),
    newCard,

    -- * CardAction
    CardAction (..),
    newCardAction,

    -- * CardCapabilityMetadata
    CardCapabilityMetadata (..),
    newCardCapabilityMetadata,

    -- * CardHeader
    CardHeader (..),
    newCardHeader,

    -- * CaribouAttributeValue
    CaribouAttributeValue (..),
    newCaribouAttributeValue,

    -- * ChatClientActionMarkup
    ChatClientActionMarkup (..),
    newChatClientActionMarkup,

    -- * ChatConserverDynamitePlaceholderMetadata
    ChatConserverDynamitePlaceholderMetadata (..),
    newChatConserverDynamitePlaceholderMetadata,

    -- * ChatConserverDynamitePlaceholderMetadataAttachmentMetadata
    ChatConserverDynamitePlaceholderMetadataAttachmentMetadata (..),
    newChatConserverDynamitePlaceholderMetadataAttachmentMetadata,

    -- * ChatConserverDynamitePlaceholderMetadataBotMessageMetadata
    ChatConserverDynamitePlaceholderMetadataBotMessageMetadata (..),
    newChatConserverDynamitePlaceholderMetadataBotMessageMetadata,

    -- * ChatConserverDynamitePlaceholderMetadataCalendarEventMetadata
    ChatConserverDynamitePlaceholderMetadataCalendarEventMetadata (..),
    newChatConserverDynamitePlaceholderMetadataCalendarEventMetadata,

    -- * ChatConserverDynamitePlaceholderMetadataDeleteMetadata
    ChatConserverDynamitePlaceholderMetadataDeleteMetadata (..),
    newChatConserverDynamitePlaceholderMetadataDeleteMetadata,

    -- * ChatConserverDynamitePlaceholderMetadataEditMetadata
    ChatConserverDynamitePlaceholderMetadataEditMetadata (..),
    newChatConserverDynamitePlaceholderMetadataEditMetadata,

    -- * ChatConserverDynamitePlaceholderMetadataTasksMetadata
    ChatConserverDynamitePlaceholderMetadataTasksMetadata (..),
    newChatConserverDynamitePlaceholderMetadataTasksMetadata,

    -- * ChatConserverDynamitePlaceholderMetadataVideoCallMetadata
    ChatConserverDynamitePlaceholderMetadataVideoCallMetadata (..),
    newChatConserverDynamitePlaceholderMetadataVideoCallMetadata,

    -- * ChatConserverMessageContent
    ChatConserverMessageContent (..),
    newChatConserverMessageContent,

    -- * ChatContentExtension
    ChatContentExtension (..),
    newChatContentExtension,

    -- * ChatProto
    ChatProto (..),
    newChatProto,

    -- * CheckAccessResponse
    CheckAccessResponse (..),
    newCheckAccessResponse,

    -- * CircleProto
    CircleProto (..),
    newCircleProto,

    -- * ClientContext
    ClientContext (..),
    newClientContext,

    -- * CloudPrincipalProto
    CloudPrincipalProto (..),
    newCloudPrincipalProto,

    -- * ClusterInfo
    ClusterInfo (..),
    newClusterInfo,

    -- * CoActivity
    CoActivity (..),
    newCoActivity,

    -- * Collaboration
    Collaboration (..),
    newCollaboration,

    -- * Color
    Color (..),
    newColor,

    -- * CommunalLabelTag
    CommunalLabelTag (..),
    newCommunalLabelTag,

    -- * CompositeFilter
    CompositeFilter (..),
    newCompositeFilter,

    -- * ConsentedAppUnfurlMetadata
    ConsentedAppUnfurlMetadata (..),
    newConsentedAppUnfurlMetadata,

    -- * ContactGroupProto
    ContactGroupProto (..),
    newContactGroupProto,

    -- * ContentReport
    ContentReport (..),
    newContentReport,

    -- * ContentReportJustification
    ContentReportJustification (..),
    newContentReportJustification,

    -- * ContentReportSummary
    ContentReportSummary (..),
    newContentReportSummary,

    -- * ContextAttribute
    ContextAttribute (..),
    newContextAttribute,

    -- * ContextualAddOnMarkup
    ContextualAddOnMarkup (..),
    newContextualAddOnMarkup,

    -- * CseInfo
    CseInfo (..),
    newCseInfo,

    -- * CustomEmojiMetadata
    CustomEmojiMetadata (..),
    newCustomEmojiMetadata,

    -- * CustomFunctionReturnValueMarkup
    CustomFunctionReturnValueMarkup (..),
    newCustomFunctionReturnValueMarkup,

    -- * CustomerId
    CustomerId (..),
    newCustomerId,

    -- * CustomerIndexStats
    CustomerIndexStats (..),
    newCustomerIndexStats,

    -- * CustomerQueryStats
    CustomerQueryStats (..),
    newCustomerQueryStats,

    -- * CustomerSearchApplicationStats
    CustomerSearchApplicationStats (..),
    newCustomerSearchApplicationStats,

    -- * CustomerSessionStats
    CustomerSessionStats (..),
    newCustomerSessionStats,

    -- * CustomerSettings
    CustomerSettings (..),
    newCustomerSettings,

    -- * CustomerUserStats
    CustomerUserStats (..),
    newCustomerUserStats,

    -- * DataLossPreventionMetadata
    DataLossPreventionMetadata (..),
    newDataLossPreventionMetadata,

    -- * DataSource
    DataSource (..),
    newDataSource,

    -- * DataSourceIndexStats
    DataSourceIndexStats (..),
    newDataSourceIndexStats,

    -- * DataSourceRestriction
    DataSourceRestriction (..),
    newDataSourceRestriction,

    -- * Date
    Date (..),
    newDate,

    -- * DateOperatorOptions
    DateOperatorOptions (..),
    newDateOperatorOptions,

    -- * DatePropertyOptions
    DatePropertyOptions (..),
    newDatePropertyOptions,

    -- * DateTimePicker
    DateTimePicker (..),
    newDateTimePicker,

    -- * DateValues
    DateValues (..),
    newDateValues,

    -- * DebugOptions
    DebugOptions (..),
    newDebugOptions,

    -- * DeepLinkData
    DeepLinkData (..),
    newDeepLinkData,

    -- * DeleteMetadata
    DeleteMetadata (..),
    newDeleteMetadata,

    -- * DeleteQueueItemsRequest
    DeleteQueueItemsRequest (..),
    newDeleteQueueItemsRequest,

    -- * DeliveryMedium
    DeliveryMedium (..),
    newDeliveryMedium,

    -- * DisplayedProperty
    DisplayedProperty (..),
    newDisplayedProperty,

    -- * Divider
    Divider (..),
    newDivider,

    -- * DlpAction
    DlpAction (..),
    newDlpAction,

    -- * DlpScanSummary
    DlpScanSummary (..),
    newDlpScanSummary,

    -- * DmId
    DmId (..),
    newDmId,

    -- * DocumentInfo
    DocumentInfo (..),
    newDocumentInfo,

    -- * DoubleOperatorOptions
    DoubleOperatorOptions (..),
    newDoubleOperatorOptions,

    -- * DoublePropertyOptions
    DoublePropertyOptions (..),
    newDoublePropertyOptions,

    -- * DoubleValues
    DoubleValues (..),
    newDoubleValues,

    -- * DriveClientActionMarkup
    DriveClientActionMarkup (..),
    newDriveClientActionMarkup,

    -- * DriveFollowUpRestrict
    DriveFollowUpRestrict (..),
    newDriveFollowUpRestrict,

    -- * DriveLocationRestrict
    DriveLocationRestrict (..),
    newDriveLocationRestrict,

    -- * DriveMetadata
    DriveMetadata (..),
    newDriveMetadata,

    -- * DriveMimeTypeRestrict
    DriveMimeTypeRestrict (..),
    newDriveMimeTypeRestrict,

    -- * DriveTimeSpanRestrict
    DriveTimeSpanRestrict (..),
    newDriveTimeSpanRestrict,

    -- * DynamiteMessagesScoringInfo
    DynamiteMessagesScoringInfo (..),
    newDynamiteMessagesScoringInfo,

    -- * DynamiteSpacesScoringInfo
    DynamiteSpacesScoringInfo (..),
    newDynamiteSpacesScoringInfo,

    -- * EditMetadata
    EditMetadata (..),
    newEditMetadata,

    -- * EditorClientActionMarkup
    EditorClientActionMarkup (..),
    newEditorClientActionMarkup,

    -- * EmailAddress
    EmailAddress (..),
    newEmailAddress,

    -- * EmailOwnerProto
    EmailOwnerProto (..),
    newEmailOwnerProto,

    -- * EmbedClientItem
    EmbedClientItem (..),
    newEmbedClientItem,

    -- * EnumOperatorOptions
    EnumOperatorOptions (..),
    newEnumOperatorOptions,

    -- * EnumPropertyOptions
    EnumPropertyOptions (..),
    newEnumPropertyOptions,

    -- * EnumValuePair
    EnumValuePair (..),
    newEnumValuePair,

    -- * EnumValues
    EnumValues (..),
    newEnumValues,

    -- * ErrorInfo
    ErrorInfo (..),
    newErrorInfo,

    -- * ErrorMessage
    ErrorMessage (..),
    newErrorMessage,

    -- * EventAnnotation
    EventAnnotation (..),
    newEventAnnotation,

    -- * EventProto
    EventProto (..),
    newEventProto,

    -- * FacetBucket
    FacetBucket (..),
    newFacetBucket,

    -- * FacetOptions
    FacetOptions (..),
    newFacetOptions,

    -- * FacetResult
    FacetResult (..),
    newFacetResult,

    -- * FieldViolation
    FieldViolation (..),
    newFieldViolation,

    -- * Filter
    Filter (..),
    newFilter,

    -- * FilterCreated
    FilterCreated (..),
    newFilterCreated,

    -- * FilterDeleted
    FilterDeleted (..),
    newFilterDeleted,

    -- * FilterOptions
    FilterOptions (..),
    newFilterOptions,

    -- * FilterUpdate
    FilterUpdate (..),
    newFilterUpdate,

    -- * FixedFooter
    FixedFooter (..),
    newFixedFooter,

    -- * Folder
    Folder (..),
    newFolder,

    -- * FolderAttribute
    FolderAttribute (..),
    newFolderAttribute,

    -- * FormAction
    FormAction (..),
    newFormAction,

    -- * FormatMetadata
    FormatMetadata (..),
    newFormatMetadata,

    -- * Formatting
    Formatting (..),
    newFormatting,

    -- * FreshnessOptions
    FreshnessOptions (..),
    newFreshnessOptions,

    -- * FuseboxItem
    FuseboxItem (..),
    newFuseboxItem,

    -- * FuseboxItemThreadMatchInfo
    FuseboxItemThreadMatchInfo (..),
    newFuseboxItemThreadMatchInfo,

    -- * FuseboxPrefUpdatePreState
    FuseboxPrefUpdatePreState (..),
    newFuseboxPrefUpdatePreState,

    -- * GSuitePrincipal
    GSuitePrincipal (..),
    newGSuitePrincipal,

    -- * GaiaGroupProto
    GaiaGroupProto (..),
    newGaiaGroupProto,

    -- * GaiaUserProto
    GaiaUserProto (..),
    newGaiaUserProto,

    -- * GatewayAccess
    GatewayAccess (..),
    newGatewayAccess,

    -- * GatewaySipAccess
    GatewaySipAccess (..),
    newGatewaySipAccess,

    -- * GetCustomerIndexStatsResponse
    GetCustomerIndexStatsResponse (..),
    newGetCustomerIndexStatsResponse,

    -- * GetCustomerQueryStatsResponse
    GetCustomerQueryStatsResponse (..),
    newGetCustomerQueryStatsResponse,

    -- * GetCustomerSearchApplicationStatsResponse
    GetCustomerSearchApplicationStatsResponse (..),
    newGetCustomerSearchApplicationStatsResponse,

    -- * GetCustomerSessionStatsResponse
    GetCustomerSessionStatsResponse (..),
    newGetCustomerSessionStatsResponse,

    -- * GetCustomerUserStatsResponse
    GetCustomerUserStatsResponse (..),
    newGetCustomerUserStatsResponse,

    -- * GetDataSourceIndexStatsResponse
    GetDataSourceIndexStatsResponse (..),
    newGetDataSourceIndexStatsResponse,

    -- * GetSearchApplicationQueryStatsResponse
    GetSearchApplicationQueryStatsResponse (..),
    newGetSearchApplicationQueryStatsResponse,

    -- * GetSearchApplicationSessionStatsResponse
    GetSearchApplicationSessionStatsResponse (..),
    newGetSearchApplicationSessionStatsResponse,

    -- * GetSearchApplicationUserStatsResponse
    GetSearchApplicationUserStatsResponse (..),
    newGetSearchApplicationUserStatsResponse,

    -- * GmailClientActionMarkup
    GmailClientActionMarkup (..),
    newGmailClientActionMarkup,

    -- * GoogleChatV1ContextualAddOnMarkup
    GoogleChatV1ContextualAddOnMarkup (..),
    newGoogleChatV1ContextualAddOnMarkup,

    -- * GoogleChatV1ContextualAddOnMarkupCard
    GoogleChatV1ContextualAddOnMarkupCard (..),
    newGoogleChatV1ContextualAddOnMarkupCard,

    -- * GoogleChatV1ContextualAddOnMarkupCardCardAction
    GoogleChatV1ContextualAddOnMarkupCardCardAction (..),
    newGoogleChatV1ContextualAddOnMarkupCardCardAction,

    -- * GoogleChatV1ContextualAddOnMarkupCardCardHeader
    GoogleChatV1ContextualAddOnMarkupCardCardHeader (..),
    newGoogleChatV1ContextualAddOnMarkupCardCardHeader,

    -- * GoogleChatV1ContextualAddOnMarkupCardSection
    GoogleChatV1ContextualAddOnMarkupCardSection (..),
    newGoogleChatV1ContextualAddOnMarkupCardSection,

    -- * GoogleChatV1WidgetMarkup
    GoogleChatV1WidgetMarkup (..),
    newGoogleChatV1WidgetMarkup,

    -- * GoogleChatV1WidgetMarkupButton
    GoogleChatV1WidgetMarkupButton (..),
    newGoogleChatV1WidgetMarkupButton,

    -- * GoogleChatV1WidgetMarkupFormAction
    GoogleChatV1WidgetMarkupFormAction (..),
    newGoogleChatV1WidgetMarkupFormAction,

    -- * GoogleChatV1WidgetMarkupFormActionActionParameter
    GoogleChatV1WidgetMarkupFormActionActionParameter (..),
    newGoogleChatV1WidgetMarkupFormActionActionParameter,

    -- * GoogleChatV1WidgetMarkupImage
    GoogleChatV1WidgetMarkupImage (..),
    newGoogleChatV1WidgetMarkupImage,

    -- * GoogleChatV1WidgetMarkupImageButton
    GoogleChatV1WidgetMarkupImageButton (..),
    newGoogleChatV1WidgetMarkupImageButton,

    -- * GoogleChatV1WidgetMarkupKeyValue
    GoogleChatV1WidgetMarkupKeyValue (..),
    newGoogleChatV1WidgetMarkupKeyValue,

    -- * GoogleChatV1WidgetMarkupOnClick
    GoogleChatV1WidgetMarkupOnClick (..),
    newGoogleChatV1WidgetMarkupOnClick,

    -- * GoogleChatV1WidgetMarkupOpenLink
    GoogleChatV1WidgetMarkupOpenLink (..),
    newGoogleChatV1WidgetMarkupOpenLink,

    -- * GoogleChatV1WidgetMarkupTextButton
    GoogleChatV1WidgetMarkupTextButton (..),
    newGoogleChatV1WidgetMarkupTextButton,

    -- * GoogleChatV1WidgetMarkupTextParagraph
    GoogleChatV1WidgetMarkupTextParagraph (..),
    newGoogleChatV1WidgetMarkupTextParagraph,

    -- * GoogleDocsMetadata
    GoogleDocsMetadata (..),
    newGoogleDocsMetadata,

    -- * GoogleDocsResultInfo
    GoogleDocsResultInfo (..),
    newGoogleDocsResultInfo,

    -- * Grid
    Grid (..),
    newGrid,

    -- * GridItem
    GridItem (..),
    newGridItem,

    -- * GroupDetailsUpdatedMetadata
    GroupDetailsUpdatedMetadata (..),
    newGroupDetailsUpdatedMetadata,

    -- * GroupId
    GroupId (..),
    newGroupId,

    -- * GroupLinkSharingModificationEvent
    GroupLinkSharingModificationEvent (..),
    newGroupLinkSharingModificationEvent,

    -- * GroupRetentionSettingsUpdatedMetaData
    GroupRetentionSettingsUpdatedMetaData (..),
    newGroupRetentionSettingsUpdatedMetaData,

    -- * GsuiteIntegrationMetadata
    GsuiteIntegrationMetadata (..),
    newGsuiteIntegrationMetadata,

    -- * HangoutEvent
    HangoutEvent (..),
    newHangoutEvent,

    -- * HangoutVideoEventMetadata
    HangoutVideoEventMetadata (..),
    newHangoutVideoEventMetadata,

    -- * HashtagData
    HashtagData (..),
    newHashtagData,

    -- * History
    History (..),
    newHistory,

    -- * HistoryRecord
    HistoryRecord (..),
    newHistoryRecord,

    -- * HostAppActionMarkup
    HostAppActionMarkup (..),
    newHostAppActionMarkup,

    -- * HostProto
    HostProto (..),
    newHostProto,

    -- * HtmlOperatorOptions
    HtmlOperatorOptions (..),
    newHtmlOperatorOptions,

    -- * HtmlPropertyOptions
    HtmlPropertyOptions (..),
    newHtmlPropertyOptions,

    -- * HtmlValues
    HtmlValues (..),
    newHtmlValues,

    -- * IconImage
    IconImage (..),
    newIconImage,

    -- * Id
    Id (..),
    newId,

    -- * Image
    Image (..),
    newImage,

    -- * ImageButton
    ImageButton (..),
    newImageButton,

    -- * ImageComponent
    ImageComponent (..),
    newImageComponent,

    -- * ImageCropStyle
    ImageCropStyle (..),
    newImageCropStyle,

    -- * ImageKeyValue
    ImageKeyValue (..),
    newImageKeyValue,

    -- * ImapSessionContext
    ImapSessionContext (..),
    newImapSessionContext,

    -- * ImapSyncDelete
    ImapSyncDelete (..),
    newImapSyncDelete,

    -- * ImapUidsReassign
    ImapUidsReassign (..),
    newImapUidsReassign,

    -- * ImapUpdate
    ImapUpdate (..),
    newImapUpdate,

    -- * ImapsyncFolderAttributeFolderMessage
    ImapsyncFolderAttributeFolderMessage (..),
    newImapsyncFolderAttributeFolderMessage,

    -- * ImapsyncFolderAttributeFolderMessageFlags
    ImapsyncFolderAttributeFolderMessageFlags (..),
    newImapsyncFolderAttributeFolderMessageFlags,

    -- * IncomingWebhookChangedMetadata
    IncomingWebhookChangedMetadata (..),
    newIncomingWebhookChangedMetadata,

    -- * IndexItemOptions
    IndexItemOptions (..),
    newIndexItemOptions,

    -- * IndexItemRequest
    IndexItemRequest (..),
    newIndexItemRequest,

    -- * InitializeCustomerRequest
    InitializeCustomerRequest (..),
    newInitializeCustomerRequest,

    -- * InsertContent
    InsertContent (..),
    newInsertContent,

    -- * IntegerFacetingOptions
    IntegerFacetingOptions (..),
    newIntegerFacetingOptions,

    -- * IntegerOperatorOptions
    IntegerOperatorOptions (..),
    newIntegerOperatorOptions,

    -- * IntegerPropertyOptions
    IntegerPropertyOptions (..),
    newIntegerPropertyOptions,

    -- * IntegerValues
    IntegerValues (..),
    newIntegerValues,

    -- * IntegrationConfigMutation
    IntegrationConfigMutation (..),
    newIntegrationConfigMutation,

    -- * IntegrationConfigUpdatedMetadata
    IntegrationConfigUpdatedMetadata (..),
    newIntegrationConfigUpdatedMetadata,

    -- * Interaction
    Interaction (..),
    newInteraction,

    -- * InteractionData
    InteractionData (..),
    newInteractionData,

    -- * InviteAcceptedEvent
    InviteAcceptedEvent (..),
    newInviteAcceptedEvent,

    -- * InviteeInfo
    InviteeInfo (..),
    newInviteeInfo,

    -- * Item
    Item (..),
    newItem,

    -- * ItemAcl
    ItemAcl (..),
    newItemAcl,

    -- * ItemContent
    ItemContent (..),
    newItemContent,

    -- * ItemCountByStatus
    ItemCountByStatus (..),
    newItemCountByStatus,

    -- * ItemMetadata
    ItemMetadata (..),
    newItemMetadata,

    -- * ItemParts
    ItemParts (..),
    newItemParts,

    -- * ItemStatus
    ItemStatus (..),
    newItemStatus,

    -- * ItemStructuredData
    ItemStructuredData (..),
    newItemStructuredData,

    -- * ItemThread
    ItemThread (..),
    newItemThread,

    -- * JobsettedServerSpec
    JobsettedServerSpec (..),
    newJobsettedServerSpec,

    -- * KeyValue
    KeyValue (..),
    newKeyValue,

    -- * LabelAdded
    LabelAdded (..),
    newLabelAdded,

    -- * LabelCreated
    LabelCreated (..),
    newLabelCreated,

    -- * LabelDeleted
    LabelDeleted (..),
    newLabelDeleted,

    -- * LabelRemoved
    LabelRemoved (..),
    newLabelRemoved,

    -- * LabelRenamed
    LabelRenamed (..),
    newLabelRenamed,

    -- * LabelUpdate
    LabelUpdate (..),
    newLabelUpdate,

    -- * LabelUpdated
    LabelUpdated (..),
    newLabelUpdated,

    -- * Labels
    Labels (..),
    newLabels,

    -- * LanguageConfig
    LanguageConfig (..),
    newLanguageConfig,

    -- * LdapGroupProto
    LdapGroupProto (..),
    newLdapGroupProto,

    -- * LdapUserProto
    LdapUserProto (..),
    newLdapUserProto,

    -- * LegacyUploadMetadata
    LegacyUploadMetadata (..),
    newLegacyUploadMetadata,

    -- * LinkData
    LinkData (..),
    newLinkData,

    -- * ListDataSourceResponse
    ListDataSourceResponse (..),
    newListDataSourceResponse,

    -- * ListItemNamesForUnmappedIdentityResponse
    ListItemNamesForUnmappedIdentityResponse (..),
    newListItemNamesForUnmappedIdentityResponse,

    -- * ListItemsResponse
    ListItemsResponse (..),
    newListItemsResponse,

    -- * ListOperationsResponse
    ListOperationsResponse (..),
    newListOperationsResponse,

    -- * ListQuerySourcesResponse
    ListQuerySourcesResponse (..),
    newListQuerySourcesResponse,

    -- * ListSearchApplicationsResponse
    ListSearchApplicationsResponse (..),
    newListSearchApplicationsResponse,

    -- * ListUnmappedIdentitiesResponse
    ListUnmappedIdentitiesResponse (..),
    newListUnmappedIdentitiesResponse,

    -- * MatchInfo
    MatchInfo (..),
    newMatchInfo,

    -- * MatchRange
    MatchRange (..),
    newMatchRange,

    -- * MdbGroupProto
    MdbGroupProto (..),
    newMdbGroupProto,

    -- * MdbUserProto
    MdbUserProto (..),
    newMdbUserProto,

    -- * Media
    Media (..),
    newMedia,

    -- * MeetingSpace
    MeetingSpace (..),
    newMeetingSpace,

    -- * Member
    Member (..),
    newMember,

    -- * MemberId
    MemberId (..),
    newMemberId,

    -- * MembershipChangeEvent
    MembershipChangeEvent (..),
    newMembershipChangeEvent,

    -- * MembershipChangedMetadata
    MembershipChangedMetadata (..),
    newMembershipChangedMetadata,

    -- * Menu
    Menu (..),
    newMenu,

    -- * MenuItem
    MenuItem (..),
    newMenuItem,

    -- * Message
    Message (..),
    newMessage,

    -- * MessageAdded
    MessageAdded (..),
    newMessageAdded,

    -- * MessageAttributes
    MessageAttributes (..),
    newMessageAttributes,

    -- * MessageDeleted
    MessageDeleted (..),
    newMessageDeleted,

    -- * MessageId
    MessageId (..),
    newMessageId,

    -- * MessageInfo
    MessageInfo (..),
    newMessageInfo,

    -- * MessageParentId
    MessageParentId (..),
    newMessageParentId,

    -- * MessageProps
    MessageProps (..),
    newMessageProps,

    -- * MessageSet
    MessageSet (..),
    newMessageSet,

    -- * Metadata
    Metadata (..),
    newMetadata,

    -- * Metaline
    Metaline (..),
    newMetaline,

    -- * MultiKey
    MultiKey (..),
    newMultiKey,

    -- * Name
    Name (..),
    newName,

    -- * NamedProperty
    NamedProperty (..),
    newNamedProperty,

    -- * OAuthConsumerProto
    OAuthConsumerProto (..),
    newOAuthConsumerProto,

    -- * ObjectDefinition
    ObjectDefinition (..),
    newObjectDefinition,

    -- * ObjectDisplayOptions
    ObjectDisplayOptions (..),
    newObjectDisplayOptions,

    -- * ObjectOptions
    ObjectOptions (..),
    newObjectOptions,

    -- * ObjectPropertyOptions
    ObjectPropertyOptions (..),
    newObjectPropertyOptions,

    -- * ObjectValues
    ObjectValues (..),
    newObjectValues,

    -- * OnClick
    OnClick (..),
    newOnClick,

    -- * OpenCreatedDraftActionMarkup
    OpenCreatedDraftActionMarkup (..),
    newOpenCreatedDraftActionMarkup,

    -- * OpenLink
    OpenLink (..),
    newOpenLink,

    -- * Operation
    Operation (..),
    newOperation,

    -- * Operation_Metadata
    Operation_Metadata (..),
    newOperation_Metadata,

    -- * Operation_Response
    Operation_Response (..),
    newOperation_Response,

    -- * OsVersion
    OsVersion (..),
    newOsVersion,

    -- * OtrChatMessageEvent
    OtrChatMessageEvent (..),
    newOtrChatMessageEvent,

    -- * OtrModificationEvent
    OtrModificationEvent (..),
    newOtrModificationEvent,

    -- * PackagingServiceClient
    PackagingServiceClient (..),
    newPackagingServiceClient,

    -- * PaygateInfo
    PaygateInfo (..),
    newPaygateInfo,

    -- * PeopleSuggestion
    PeopleSuggestion (..),
    newPeopleSuggestion,

    -- * Person
    Person (..),
    newPerson,

    -- * PersonalLabelTag
    PersonalLabelTag (..),
    newPersonalLabelTag,

    -- * PhoneAccess
    PhoneAccess (..),
    newPhoneAccess,

    -- * PhoneNumber
    PhoneNumber (..),
    newPhoneNumber,

    -- * Photo
    Photo (..),
    newPhoto,

    -- * PinnedItemId
    PinnedItemId (..),
    newPinnedItemId,

    -- * PollItemsRequest
    PollItemsRequest (..),
    newPollItemsRequest,

    -- * PollItemsResponse
    PollItemsResponse (..),
    newPollItemsResponse,

    -- * PossiblyTrimmedModel
    PossiblyTrimmedModel (..),
    newPossiblyTrimmedModel,

    -- * PostiniUserProto
    PostiniUserProto (..),
    newPostiniUserProto,

    -- * PreState
    PreState (..),
    newPreState,

    -- * PrefDeleted
    PrefDeleted (..),
    newPrefDeleted,

    -- * PrefUpdate
    PrefUpdate (..),
    newPrefUpdate,

    -- * PrefWritten
    PrefWritten (..),
    newPrefWritten,

    -- * Presenter
    Presenter (..),
    newPresenter,

    -- * Principal
    Principal (..),
    newPrincipal,

    -- * PrincipalProto
    PrincipalProto (..),
    newPrincipalProto,

    -- * PrivateMessageInfo
    PrivateMessageInfo (..),
    newPrivateMessageInfo,

    -- * ProcessingError
    ProcessingError (..),
    newProcessingError,

    -- * PropertyDefinition
    PropertyDefinition (..),
    newPropertyDefinition,

    -- * PropertyDisplayOptions
    PropertyDisplayOptions (..),
    newPropertyDisplayOptions,

    -- * Provenance
    Provenance (..),
    newProvenance,

    -- * PushItem
    PushItem (..),
    newPushItem,

    -- * PushItemRequest
    PushItemRequest (..),
    newPushItemRequest,

    -- * QueryCountByStatus
    QueryCountByStatus (..),
    newQueryCountByStatus,

    -- * QueryInterpretation
    QueryInterpretation (..),
    newQueryInterpretation,

    -- * QueryInterpretationConfig
    QueryInterpretationConfig (..),
    newQueryInterpretationConfig,

    -- * QueryInterpretationOptions
    QueryInterpretationOptions (..),
    newQueryInterpretationOptions,

    -- * QueryItem
    QueryItem (..),
    newQueryItem,

    -- * QueryOperator
    QueryOperator (..),
    newQueryOperator,

    -- * QuerySource
    QuerySource (..),
    newQuerySource,

    -- * QuerySuggestion
    QuerySuggestion (..),
    newQuerySuggestion,

    -- * QuotedMessageMetadata
    QuotedMessageMetadata (..),
    newQuotedMessageMetadata,

    -- * Rank
    Rank (..),
    newRank,

    -- * RbacRoleProto
    RbacRoleProto (..),
    newRbacRoleProto,

    -- * RbacSubjectProto
    RbacSubjectProto (..),
    newRbacSubjectProto,

    -- * ReactionInfo
    ReactionInfo (..),
    newReactionInfo,

    -- * ReadReceiptsSettingsUpdatedMetadata
    ReadReceiptsSettingsUpdatedMetadata (..),
    newReadReceiptsSettingsUpdatedMetadata,

    -- * Recipient
    Recipient (..),
    newRecipient,

    -- * RecordingEvent
    RecordingEvent (..),
    newRecordingEvent,

    -- * RecordingInfo
    RecordingInfo (..),
    newRecordingInfo,

    -- * RecordingSessionInfo
    RecordingSessionInfo (..),
    newRecordingSessionInfo,

    -- * Reference
    Reference (..),
    newReference,

    -- * References
    References (..),
    newReferences,

    -- * RenameEvent
    RenameEvent (..),
    newRenameEvent,

    -- * RepositoryError
    RepositoryError (..),
    newRepositoryError,

    -- * RequestFileScope
    RequestFileScope (..),
    newRequestFileScope,

    -- * RequestFileScopeForActiveDocument
    RequestFileScopeForActiveDocument (..),
    newRequestFileScopeForActiveDocument,

    -- * RequestOptions
    RequestOptions (..),
    newRequestOptions,

    -- * RequiredMessageFeaturesMetadata
    RequiredMessageFeaturesMetadata (..),
    newRequiredMessageFeaturesMetadata,

    -- * ResetSearchApplicationRequest
    ResetSearchApplicationRequest (..),
    newResetSearchApplicationRequest,

    -- * ResourceRoleProto
    ResourceRoleProto (..),
    newResourceRoleProto,

    -- * ResponseDebugInfo
    ResponseDebugInfo (..),
    newResponseDebugInfo,

    -- * RestrictItem
    RestrictItem (..),
    newRestrictItem,

    -- * ResultCounts
    ResultCounts (..),
    newResultCounts,

    -- * ResultDebugInfo
    ResultDebugInfo (..),
    newResultDebugInfo,

    -- * ResultDisplayField
    ResultDisplayField (..),
    newResultDisplayField,

    -- * ResultDisplayLine
    ResultDisplayLine (..),
    newResultDisplayLine,

    -- * ResultDisplayMetadata
    ResultDisplayMetadata (..),
    newResultDisplayMetadata,

    -- * RetrievalImportance
    RetrievalImportance (..),
    newRetrievalImportance,

    -- * RoomRenameMetadata
    RoomRenameMetadata (..),
    newRoomRenameMetadata,

    -- * RoomUpdatedMetadata
    RoomUpdatedMetadata (..),
    newRoomUpdatedMetadata,

    -- * Roster
    Roster (..),
    newRoster,

    -- * RosterId
    RosterId (..),
    newRosterId,

    -- * RpcOptions
    RpcOptions (..),
    newRpcOptions,

    -- * SafeUrlProto
    SafeUrlProto (..),
    newSafeUrlProto,

    -- * Schema
    Schema (..),
    newSchema,

    -- * ScoringConfig
    ScoringConfig (..),
    newScoringConfig,

    -- * SearchApplication
    SearchApplication (..),
    newSearchApplication,

    -- * SearchApplicationQueryStats
    SearchApplicationQueryStats (..),
    newSearchApplicationQueryStats,

    -- * SearchApplicationSessionStats
    SearchApplicationSessionStats (..),
    newSearchApplicationSessionStats,

    -- * SearchApplicationUserStats
    SearchApplicationUserStats (..),
    newSearchApplicationUserStats,

    -- * SearchItemsByViewUrlRequest
    SearchItemsByViewUrlRequest (..),
    newSearchItemsByViewUrlRequest,

    -- * SearchItemsByViewUrlResponse
    SearchItemsByViewUrlResponse (..),
    newSearchItemsByViewUrlResponse,

    -- * SearchQualityMetadata
    SearchQualityMetadata (..),
    newSearchQualityMetadata,

    -- * SearchRequest
    SearchRequest (..),
    newSearchRequest,

    -- * SearchResponse
    SearchResponse (..),
    newSearchResponse,

    -- * SearchResult
    SearchResult (..),
    newSearchResult,

    -- * Section
    Section (..),
    newSection,

    -- * Segment
    Segment (..),
    newSegment,

    -- * SelectionControl
    SelectionControl (..),
    newSelectionControl,

    -- * SelectionItem
    SelectionItem (..),
    newSelectionItem,

    -- * SessionContext
    SessionContext (..),
    newSessionContext,

    -- * SessionEvent
    SessionEvent (..),
    newSessionEvent,

    -- * SessionStateInfo
    SessionStateInfo (..),
    newSessionStateInfo,

    -- * Settings
    Settings (..),
    newSettings,

    -- * ShareScope
    ShareScope (..),
    newShareScope,

    -- * SheetsClientActionMarkup
    SheetsClientActionMarkup (..),
    newSheetsClientActionMarkup,

    -- * SigningKeyPossessorProto
    SigningKeyPossessorProto (..),
    newSigningKeyPossessorProto,

    -- * SimpleSecretHolderProto
    SimpleSecretHolderProto (..),
    newSimpleSecretHolderProto,

    -- * SimpleSecretLabelProto
    SimpleSecretLabelProto (..),
    newSimpleSecretLabelProto,

    -- * SlashCommandMetadata
    SlashCommandMetadata (..),
    newSlashCommandMetadata,

    -- * Snippet
    Snippet (..),
    newSnippet,

    -- * SocialCommonAttachmentAttachment
    SocialCommonAttachmentAttachment (..),
    newSocialCommonAttachmentAttachment,

    -- * SocialGraphNodeProto
    SocialGraphNodeProto (..),
    newSocialGraphNodeProto,

    -- * SortOptions
    SortOptions (..),
    newSortOptions,

    -- * Source
    Source (..),
    newSource,

    -- * SourceConfig
    SourceConfig (..),
    newSourceConfig,

    -- * SourceCrowdingConfig
    SourceCrowdingConfig (..),
    newSourceCrowdingConfig,

    -- * SourceResultCount
    SourceResultCount (..),
    newSourceResultCount,

    -- * SourceScoringConfig
    SourceScoringConfig (..),
    newSourceScoringConfig,

    -- * SpaceId
    SpaceId (..),
    newSpaceId,

    -- * SpellResult
    SpellResult (..),
    newSpellResult,

    -- * SquareProto
    SquareProto (..),
    newSquareProto,

    -- * StartUploadItemRequest
    StartUploadItemRequest (..),
    newStartUploadItemRequest,

    -- * Status
    Status (..),
    newStatus,

    -- * Status_DetailsItem
    Status_DetailsItem (..),
    newStatus_DetailsItem,

    -- * StoredParticipantId
    StoredParticipantId (..),
    newStoredParticipantId,

    -- * StreamViewerStats
    StreamViewerStats (..),
    newStreamViewerStats,

    -- * StreamingSessionInfo
    StreamingSessionInfo (..),
    newStreamingSessionInfo,

    -- * StructuredDataObject
    StructuredDataObject (..),
    newStructuredDataObject,

    -- * StructuredResult
    StructuredResult (..),
    newStructuredResult,

    -- * SuggestRequest
    SuggestRequest (..),
    newSuggestRequest,

    -- * SuggestResponse
    SuggestResponse (..),
    newSuggestResponse,

    -- * SuggestResult
    SuggestResult (..),
    newSuggestResult,

    -- * SupportUrls
    SupportUrls (..),
    newSupportUrls,

    -- * SwitchWidget
    SwitchWidget (..),
    newSwitchWidget,

    -- * TaskActionMarkup
    TaskActionMarkup (..),
    newTaskActionMarkup,

    -- * TextButton
    TextButton (..),
    newTextButton,

    -- * TextField
    TextField (..),
    newTextField,

    -- * TextKeyValue
    TextKeyValue (..),
    newTextKeyValue,

    -- * TextOperatorOptions
    TextOperatorOptions (..),
    newTextOperatorOptions,

    -- * TextParagraph
    TextParagraph (..),
    newTextParagraph,

    -- * TextPropertyOptions
    TextPropertyOptions (..),
    newTextPropertyOptions,

    -- * TextValues
    TextValues (..),
    newTextValues,

    -- * ThreadKeySet
    ThreadKeySet (..),
    newThreadKeySet,

    -- * ThreadUpdate
    ThreadUpdate (..),
    newThreadUpdate,

    -- * TimestampOperatorOptions
    TimestampOperatorOptions (..),
    newTimestampOperatorOptions,

    -- * TimestampPropertyOptions
    TimestampPropertyOptions (..),
    newTimestampPropertyOptions,

    -- * TimestampValues
    TimestampValues (..),
    newTimestampValues,

    -- * TombstoneMetadata
    TombstoneMetadata (..),
    newTombstoneMetadata,

    -- * Toolbar
    Toolbar (..),
    newToolbar,

    -- * TopicId
    TopicId (..),
    newTopicId,

    -- * TopicState
    TopicState (..),
    newTopicState,

    -- * TopicState_LabelIdMessageCount
    TopicState_LabelIdMessageCount (..),
    newTopicState_LabelIdMessageCount,

    -- * TopicStateUpdate
    TopicStateUpdate (..),
    newTopicStateUpdate,

    -- * TransactionContext
    TransactionContext (..),
    newTransactionContext,

    -- * TransactionDebugInfo
    TransactionDebugInfo (..),
    newTransactionDebugInfo,

    -- * TranscriptionSessionInfo
    TranscriptionSessionInfo (..),
    newTranscriptionSessionInfo,

    -- * TransientData
    TransientData (..),
    newTransientData,

    -- * Trigger
    Trigger (..),
    newTrigger,

    -- * TriggerAction
    TriggerAction (..),
    newTriggerAction,

    -- * TriggerKey
    TriggerKey (..),
    newTriggerKey,

    -- * Triggers
    Triggers (..),
    newTriggers,

    -- * TrustedResourceUrlProto
    TrustedResourceUrlProto (..),
    newTrustedResourceUrlProto,

    -- * TypeInfo
    TypeInfo (..),
    newTypeInfo,

    -- * UniversalPhoneAccess
    UniversalPhoneAccess (..),
    newUniversalPhoneAccess,

    -- * UnmappedIdentity
    UnmappedIdentity (..),
    newUnmappedIdentity,

    -- * UnreserveItemsRequest
    UnreserveItemsRequest (..),
    newUnreserveItemsRequest,

    -- * UpdateBccRecipients
    UpdateBccRecipients (..),
    newUpdateBccRecipients,

    -- * UpdateBody
    UpdateBody (..),
    newUpdateBody,

    -- * UpdateCcRecipients
    UpdateCcRecipients (..),
    newUpdateCcRecipients,

    -- * UpdateDataSourceRequest
    UpdateDataSourceRequest (..),
    newUpdateDataSourceRequest,

    -- * UpdateDraftActionMarkup
    UpdateDraftActionMarkup (..),
    newUpdateDraftActionMarkup,

    -- * UpdateSchemaRequest
    UpdateSchemaRequest (..),
    newUpdateSchemaRequest,

    -- * UpdateSubject
    UpdateSubject (..),
    newUpdateSubject,

    -- * UpdateToRecipients
    UpdateToRecipients (..),
    newUpdateToRecipients,

    -- * UploadItemRef
    UploadItemRef (..),
    newUploadItemRef,

    -- * UploadMetadata
    UploadMetadata (..),
    newUploadMetadata,

    -- * UrlMetadata
    UrlMetadata (..),
    newUrlMetadata,

    -- * User
    User (..),
    newUser,

    -- * UserDisplayInfo
    UserDisplayInfo (..),
    newUserDisplayInfo,

    -- * UserId
    UserId (..),
    newUserId,

    -- * UserInfo
    UserInfo (..),
    newUserInfo,

    -- * UserMentionData
    UserMentionData (..),
    newUserMentionData,

    -- * UserMentionMetadata
    UserMentionMetadata (..),
    newUserMentionMetadata,

    -- * VPCSettings
    VPCSettings (..),
    newVPCSettings,

    -- * Value
    Value (..),
    newValue,

    -- * ValueFilter
    ValueFilter (..),
    newValueFilter,

    -- * VideoCallMetadata
    VideoCallMetadata (..),
    newVideoCallMetadata,

    -- * VideoInfo
    VideoInfo (..),
    newVideoInfo,

    -- * VoicePhoneNumber
    VoicePhoneNumber (..),
    newVoicePhoneNumber,

    -- * VoicePhoneNumberI18nData
    VoicePhoneNumberI18nData (..),
    newVoicePhoneNumberI18nData,

    -- * WhiteboardInfo
    WhiteboardInfo (..),
    newWhiteboardInfo,

    -- * WidgetMarkup
    WidgetMarkup (..),
    newWidgetMarkup,

    -- * WonderCardDelete
    WonderCardDelete (..),
    newWonderCardDelete,

    -- * WonderCardDelete_MessageMappings
    WonderCardDelete_MessageMappings (..),
    newWonderCardDelete_MessageMappings,

    -- * WonderMessageMapping
    WonderMessageMapping (..),
    newWonderMessageMapping,

    -- * WrappedResourceKey
    WrappedResourceKey (..),
    newWrappedResourceKey,

    -- * YouTubeBroadcastSessionInfo
    YouTubeBroadcastSessionInfo (..),
    newYouTubeBroadcastSessionInfo,

    -- * YouTubeBroadcastStats
    YouTubeBroadcastStats (..),
    newYouTubeBroadcastStats,

    -- * YouTubeLiveBroadcastEvent
    YouTubeLiveBroadcastEvent (..),
    newYouTubeLiveBroadcastEvent,

    -- * YoutubeMetadata
    YoutubeMetadata (..),
    newYoutubeMetadata,

    -- * YoutubeUserProto
    YoutubeUserProto (..),
    newYoutubeUserProto,

    -- * ZwiebackSessionProto
    ZwiebackSessionProto (..),
    newZwiebackSessionProto,
  )
where

import Gogol.CloudSearch.Internal.Sum
import qualified Gogol.Prelude as Core

-- | Abuse reporting configuration outlining what is supported in this conference.
--
-- /See:/ 'newAbuseReportingConfig' smart constructor.
data AbuseReportingConfig = AbuseReportingConfig
  { -- | Whether the current call may include video recordings in its abuse reports.
    recordingAllowed :: (Core.Maybe Core.Bool),
    -- | Whether the current call may include user generated content (chat, polls, Q&A...) in its abuse reports.
    writtenUgcAllowed :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AbuseReportingConfig' with the minimum fields required to make a request.
newAbuseReportingConfig ::
  AbuseReportingConfig
newAbuseReportingConfig =
  AbuseReportingConfig
    { recordingAllowed = Core.Nothing,
      writtenUgcAllowed = Core.Nothing
    }

instance Core.FromJSON AbuseReportingConfig where
  parseJSON =
    Core.withObject
      "AbuseReportingConfig"
      ( \o ->
          AbuseReportingConfig
            Core.<$> (o Core..:? "recordingAllowed")
            Core.<*> (o Core..:? "writtenUgcAllowed")
      )

instance Core.ToJSON AbuseReportingConfig where
  toJSON AbuseReportingConfig {..} =
    Core.object
      ( Core.catMaybes
          [ ("recordingAllowed" Core..=)
              Core.<$> recordingAllowed,
            ("writtenUgcAllowed" Core..=)
              Core.<$> writtenUgcAllowed
          ]
      )

-- | Information about how devices in a meeting have acked for a session\/operation.
--
-- /See:/ 'newAckInfo' smart constructor.
data AckInfo = AckInfo
  { -- | Output only. Number of meeting devices that have not acked yet.
    unackedDeviceCount :: (Core.Maybe Core.Int32),
    -- | Output only. IDs of meeting devices (at most ten are provided) that have not acked yet.
    unackedDeviceIds :: (Core.Maybe [Core.Text])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AckInfo' with the minimum fields required to make a request.
newAckInfo ::
  AckInfo
newAckInfo =
  AckInfo {unackedDeviceCount = Core.Nothing, unackedDeviceIds = Core.Nothing}

instance Core.FromJSON AckInfo where
  parseJSON =
    Core.withObject
      "AckInfo"
      ( \o ->
          AckInfo
            Core.<$> (o Core..:? "unackedDeviceCount")
            Core.<*> (o Core..:? "unackedDeviceIds")
      )

instance Core.ToJSON AckInfo where
  toJSON AckInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("unackedDeviceCount" Core..=)
              Core.<$> unackedDeviceCount,
            ("unackedDeviceIds" Core..=)
              Core.<$> unackedDeviceIds
          ]
      )

-- | The request set by clients to instruct Backend how the user intend to fix the ACL. Technically it\'s not a request to ACL Fixer, because Backend uses \/DriveService.Share to modify Drive ACLs.
--
-- /See:/ 'newAclFixRequest' smart constructor.
data AclFixRequest = AclFixRequest
  { -- | For Spaces messages: This field is ignored. For DMs messages: The list of email addresses that should be added to the Drive item\'s ACL. In general, the list should not be empty when the boolean \"should/fix\" field is set; otherwise, the list should be empty. During transition - when clients do not specify this field but the \"should/fix\" is true, we follow the legacy behavior: share to all users in the DM regardless of emails. This behavior is being phased out.
    recipientEmails :: (Core.Maybe [Core.Text]),
    -- |
    role' :: (Core.Maybe AclFixRequest_Role),
    -- | Whether to attempt to fix the ACL by adding the room or DM members to the Drive file\'s ACL.
    shouldFix :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AclFixRequest' with the minimum fields required to make a request.
newAclFixRequest ::
  AclFixRequest
newAclFixRequest =
  AclFixRequest
    { recipientEmails = Core.Nothing,
      role' = Core.Nothing,
      shouldFix = Core.Nothing
    }

instance Core.FromJSON AclFixRequest where
  parseJSON =
    Core.withObject
      "AclFixRequest"
      ( \o ->
          AclFixRequest
            Core.<$> (o Core..:? "recipientEmails")
            Core.<*> (o Core..:? "role")
            Core.<*> (o Core..:? "shouldFix")
      )

instance Core.ToJSON AclFixRequest where
  toJSON AclFixRequest {..} =
    Core.object
      ( Core.catMaybes
          [ ("recipientEmails" Core..=)
              Core.<$> recipientEmails,
            ("role" Core..=) Core.<$> role',
            ("shouldFix" Core..=) Core.<$> shouldFix
          ]
      )

-- | The message reconstructed based on information in the response of \/PermissionFixOptionsService.Query (or the Apiary API that wraps it). Indicates the ability of the requester to change the access to the Drive file for the room roster or the DM members. Used in GetMessagePreviewMetadataResponse only.
--
-- /See:/ 'newAclFixStatus' smart constructor.
data AclFixStatus = AclFixStatus
  { -- |
    fixability :: (Core.Maybe AclFixStatus_Fixability),
    -- | List of recipient email addresses for which access can be granted. This field contains the same email addresses from the GetMessagePreviewMetadata request if all recipients can be successfully added to the ACL as determined by Drive ACL Fixer. For now, the field is non-empty if and only if the \"fixability\" value is \"CAN_FIX\".
    fixableEmailAddress :: (Core.Maybe [Core.Text]),
    -- | List of recipient email addresses for which an out-of-domain-sharing warning must be shown, stating that these email addresses are not in the Google Apps organization that the requested item belong to. Empty if all recipients are in the same Google Apps organization.
    outOfDomainWarningEmailAddress :: (Core.Maybe [Core.Text])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AclFixStatus' with the minimum fields required to make a request.
newAclFixStatus ::
  AclFixStatus
newAclFixStatus =
  AclFixStatus
    { fixability = Core.Nothing,
      fixableEmailAddress = Core.Nothing,
      outOfDomainWarningEmailAddress = Core.Nothing
    }

instance Core.FromJSON AclFixStatus where
  parseJSON =
    Core.withObject
      "AclFixStatus"
      ( \o ->
          AclFixStatus
            Core.<$> (o Core..:? "fixability")
            Core.<*> (o Core..:? "fixableEmailAddress")
            Core.<*> (o Core..:? "outOfDomainWarningEmailAddress")
      )

instance Core.ToJSON AclFixStatus where
  toJSON AclFixStatus {..} =
    Core.object
      ( Core.catMaybes
          [ ("fixability" Core..=) Core.<$> fixability,
            ("fixableEmailAddress" Core..=)
              Core.<$> fixableEmailAddress,
            ("outOfDomainWarningEmailAddress" Core..=)
              Core.<$> outOfDomainWarningEmailAddress
          ]
      )

-- | Next tag: 4
--
-- /See:/ 'newAclInfo' smart constructor.
data AclInfo = AclInfo
  { -- | Number of groups which have at least read access to the document.
    groupsCount :: (Core.Maybe Core.Int32),
    -- | The scope to which the content was shared.
    scope :: (Core.Maybe AclInfo_Scope),
    -- | Number of users which have at least read access to the document.
    usersCount :: (Core.Maybe Core.Int32)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AclInfo' with the minimum fields required to make a request.
newAclInfo ::
  AclInfo
newAclInfo =
  AclInfo
    { groupsCount = Core.Nothing,
      scope = Core.Nothing,
      usersCount = Core.Nothing
    }

instance Core.FromJSON AclInfo where
  parseJSON =
    Core.withObject
      "AclInfo"
      ( \o ->
          AclInfo
            Core.<$> (o Core..:? "groupsCount")
            Core.<*> (o Core..:? "scope")
            Core.<*> (o Core..:? "usersCount")
      )

instance Core.ToJSON AclInfo where
  toJSON AclInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("groupsCount" Core..=) Core.<$> groupsCount,
            ("scope" Core..=) Core.<$> scope,
            ("usersCount" Core..=) Core.<$> usersCount
          ]
      )

-- | List of string parameters that developers can specify when the above action method (in apps script) is invoked. An example use case is for 3 snooze buttons: snooze now, snooze 1 day, snooze next week. Developers can have action method = snooze() and pass the snooze type and snooze time in list of string parameters.
--
-- /See:/ 'newActionParameter' smart constructor.
data ActionParameter = ActionParameter
  { -- |
    key :: (Core.Maybe Core.Text),
    -- |
    value :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ActionParameter' with the minimum fields required to make a request.
newActionParameter ::
  ActionParameter
newActionParameter = ActionParameter {key = Core.Nothing, value = Core.Nothing}

instance Core.FromJSON ActionParameter where
  parseJSON =
    Core.withObject
      "ActionParameter"
      ( \o ->
          ActionParameter
            Core.<$> (o Core..:? "key") Core.<*> (o Core..:? "value")
      )

instance Core.ToJSON ActionParameter where
  toJSON ActionParameter {..} =
    Core.object
      ( Core.catMaybes
          [ ("key" Core..=) Core.<$> key,
            ("value" Core..=) Core.<$> value
          ]
      )

--
-- /See:/ 'newAddonComposeUiActionMarkup' smart constructor.
newtype AddonComposeUiActionMarkup = AddonComposeUiActionMarkup
  { -- |
    type' :: (Core.Maybe AddonComposeUiActionMarkup_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AddonComposeUiActionMarkup' with the minimum fields required to make a request.
newAddonComposeUiActionMarkup ::
  AddonComposeUiActionMarkup
newAddonComposeUiActionMarkup =
  AddonComposeUiActionMarkup {type' = Core.Nothing}

instance Core.FromJSON AddonComposeUiActionMarkup where
  parseJSON =
    Core.withObject
      "AddonComposeUiActionMarkup"
      ( \o ->
          AddonComposeUiActionMarkup
            Core.<$> (o Core..:? "type")
      )

instance Core.ToJSON AddonComposeUiActionMarkup where
  toJSON AddonComposeUiActionMarkup {..} =
    Core.object
      (Core.catMaybes [("type" Core..=) Core.<$> type'])

-- | Earlier we used to populate just the affected/members list and inferred the new membership state (roles didn\'t exist back then) from the Type. go\/dynamite-finra required backend to know the previous membership state to reconstruct membership history. The proper solution involved cleaning up up Type enum, but it was used in many, many places. This was added as a stop-gap solution to unblock FINRA without breaking everything. Later role update and target audience update started relying on this to communicate information to clients about what transition happened. So this is now required to be populated and should be in sync with affected/members for new messages.
--
-- /See:/ 'newAffectedMembership' smart constructor.
data AffectedMembership = AffectedMembership
  { -- |
    affectedMember :: (Core.Maybe MemberId),
    -- |
    priorMembershipRole :: (Core.Maybe AffectedMembership_PriorMembershipRole),
    -- |
    priorMembershipState :: (Core.Maybe AffectedMembership_PriorMembershipState),
    -- |
    targetMembershipRole :: (Core.Maybe AffectedMembership_TargetMembershipRole)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AffectedMembership' with the minimum fields required to make a request.
newAffectedMembership ::
  AffectedMembership
newAffectedMembership =
  AffectedMembership
    { affectedMember = Core.Nothing,
      priorMembershipRole = Core.Nothing,
      priorMembershipState = Core.Nothing,
      targetMembershipRole = Core.Nothing
    }

instance Core.FromJSON AffectedMembership where
  parseJSON =
    Core.withObject
      "AffectedMembership"
      ( \o ->
          AffectedMembership
            Core.<$> (o Core..:? "affectedMember")
            Core.<*> (o Core..:? "priorMembershipRole")
            Core.<*> (o Core..:? "priorMembershipState")
            Core.<*> (o Core..:? "targetMembershipRole")
      )

instance Core.ToJSON AffectedMembership where
  toJSON AffectedMembership {..} =
    Core.object
      ( Core.catMaybes
          [ ("affectedMember" Core..=) Core.<$> affectedMember,
            ("priorMembershipRole" Core..=)
              Core.<$> priorMembershipRole,
            ("priorMembershipState" Core..=)
              Core.<$> priorMembershipState,
            ("targetMembershipRole" Core..=)
              Core.<$> targetMembershipRole
          ]
      )

-- | Represents a principal who has authenticated as any kind of user which the application understands. This is typically used for \"wiki-like\" security, where anyone is allowed access so long as they can be held accountable for that access. Since the purpose is knowing whom to blame, it is up to the application to decide what kinds of users it knows how to blame. For example, an application might choose to include GAIA users in \"all authenticated users\", but not include MDB users. Nothing here.
--
-- /See:/ 'newAllAuthenticatedUsersProto' smart constructor.
data AllAuthenticatedUsersProto = AllAuthenticatedUsersProto
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AllAuthenticatedUsersProto' with the minimum fields required to make a request.
newAllAuthenticatedUsersProto ::
  AllAuthenticatedUsersProto
newAllAuthenticatedUsersProto = AllAuthenticatedUsersProto

instance Core.FromJSON AllAuthenticatedUsersProto where
  parseJSON =
    Core.withObject
      "AllAuthenticatedUsersProto"
      (\o -> Core.pure AllAuthenticatedUsersProto)

instance Core.ToJSON AllAuthenticatedUsersProto where
  toJSON = Core.const Core.emptyObject

-- | NOTE WHEN ADDING NEW PROTO FIELDS: Be sure to add datapol annotations to new fields with potential PII, so they get scrubbed when logging protos for errors. NEXT TAG: 32
--
-- /See:/ 'newAnnotation' smart constructor.
data Annotation = Annotation
  { -- |
    babelPlaceholderMetadata :: (Core.Maybe BabelPlaceholderMetadata),
    -- | LINT.ThenChange(\/\/depot\/google3\/java\/com\/google\/apps\/dynamite\/v1\/backend\/action\/common\/SystemMessageHelper.java)
    cardCapabilityMetadata :: (Core.Maybe CardCapabilityMetadata),
    -- | Whether the annotation should be rendered as a preview chip. If this is missing or unspecified, fallback to should/not/render on the metadata.
    chipRenderType :: (Core.Maybe Annotation_ChipRenderType),
    -- | Contains additional metadata that further enhances the annotation when it is returned as part of search response. For example, this can be used to define how the annotation matches the search. Information can be used to highlight in rendering search results. The following are the different annotation text fields that can be highlighted by this field: 1. DriveMetadata.title 2. UploadMetadata.content_name 3. GsuiteIntegrationMetadata.TasksMessageIntegrationRenderData.title 4. GsuiteIntegrationMetadata.CalendarEventAnnotationData.title
    componentSearchInfo :: (Core.Maybe AppsDynamiteSharedMessageComponentSearchInfo),
    -- |
    consentedAppUnfurlMetadata :: (Core.Maybe ConsentedAppUnfurlMetadata),
    -- |
    customEmojiMetadata :: (Core.Maybe CustomEmojiMetadata),
    -- |
    dataLossPreventionMetadata :: (Core.Maybe DataLossPreventionMetadata),
    -- | Chip annotations
    driveMetadata :: (Core.Maybe DriveMetadata),
    -- |
    formatMetadata :: (Core.Maybe FormatMetadata),
    -- |
    groupRetentionSettingsUpdated :: (Core.Maybe GroupRetentionSettingsUpdatedMetaData),
    -- | Metadata for 1P integrations like tasks, calendar. These are supported only through integration server as 1P integrations use the integration API (which in turn uses backend API with special permissions) to post messages. Clients should never set this. LINT.IfChange
    gsuiteIntegrationMetadata :: (Core.Maybe GsuiteIntegrationMetadata),
    -- |
    incomingWebhookChangedMetadata :: (Core.Maybe IncomingWebhookChangedMetadata),
    -- | The inline render format of this annotation. go\/drive-smart-chips-chat-v2.
    inlineRenderFormat :: (Core.Maybe Annotation_InlineRenderFormat),
    -- | LINT.ThenChange(\/\/depot\/google3\/java\/com\/google\/apps\/dynamite\/v1\/backend\/action\/common\/SystemMessageHelper.java)
    integrationConfigUpdated :: (Core.Maybe IntegrationConfigUpdatedMetadata),
    -- | Additional interaction data for this annotation.
    interactionData :: (Core.Maybe InteractionData),
    -- | Length of the text/body substring beginning from start/index the Annotation corresponds to.
    length :: (Core.Maybe Core.Int32),
    -- | -   A client-assigned ID for this annotation. This is helpful in matching the back-filled annotations to the original annotations on client side, without having to re-parse the message. There is no guarantee an annotation has a local_id, it\'s a purely client used and controlled field with no guarantee of uniqueness.
    localId :: (Core.Maybe Core.Text),
    -- | Metadata for system messages. Clients should never set this. LINT.IfChange
    membershipChanged :: (Core.Maybe MembershipChangedMetadata),
    -- |
    readReceiptsSettingsMetadata :: (Core.Maybe ReadReceiptsSettingsUpdatedMetadata),
    -- | Metadata that defines all of the required features that must be rendered in the message. Clients can use this to see whether they support the entire message, or show a fallback chip otherwise. See go\/message-quoting-client-to-server for details. LINT.ThenChange( \/\/depot\/google3\/java\/com\/google\/apps\/dynamite\/v1\/allshared\/parser\/AnnotationSanitizer.java, \/\/depot\/google3\/java\/com\/google\/apps\/dynamite\/v1\/backend\/action\/common\/SystemMessageHelper.java, \/\/depot\/google3\/java\/com\/google\/caribou\/eli\/mediation\/chat\/AnnotationConverter.java )
    requiredMessageFeaturesMetadata :: (Core.Maybe RequiredMessageFeaturesMetadata),
    -- |
    roomUpdated :: (Core.Maybe RoomUpdatedMetadata),
    -- | Whether or not the annotation is invalidated by the server. Example of situations for invalidation include: when the URL is malformed, or when Drive item ID is rejected by Drive Service.
    serverInvalidated :: (Core.Maybe Core.Bool),
    -- |
    slashCommandMetadata :: (Core.Maybe SlashCommandMetadata),
    -- | Start index (0-indexed) of the Message text the Annotation corresponds to, inclusive.
    startIndex :: (Core.Maybe Core.Int32),
    -- | Type of the Annotation.
    type' :: (Core.Maybe Annotation_Type),
    -- | -   A unique server-assigned ID for this annotation. This is helpful in matching annotation objects when fetched from service. All uploads should have a unique/id after the message they are attached to is successfully sent. Url annotations that originally were uploads (i.e. policy violations) will have a unique/id after the message they are attached to is successfully sent. No other url annotations should have a unique/id. All drive annotations should have a unique/id after the message they are attached to is successfully sent.
    uniqueId :: (Core.Maybe Core.Text),
    -- |
    uploadMetadata :: (Core.Maybe UploadMetadata),
    -- |
    urlMetadata :: (Core.Maybe UrlMetadata),
    -- | Metadata that clients can set for annotations. LINT.IfChange In-text annotations
    userMentionMetadata :: (Core.Maybe UserMentionMetadata),
    -- |
    videoCallMetadata :: (Core.Maybe VideoCallMetadata),
    -- |
    youtubeMetadata :: (Core.Maybe YoutubeMetadata)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Annotation' with the minimum fields required to make a request.
newAnnotation ::
  Annotation
newAnnotation =
  Annotation
    { babelPlaceholderMetadata = Core.Nothing,
      cardCapabilityMetadata = Core.Nothing,
      chipRenderType = Core.Nothing,
      componentSearchInfo = Core.Nothing,
      consentedAppUnfurlMetadata = Core.Nothing,
      customEmojiMetadata = Core.Nothing,
      dataLossPreventionMetadata = Core.Nothing,
      driveMetadata = Core.Nothing,
      formatMetadata = Core.Nothing,
      groupRetentionSettingsUpdated = Core.Nothing,
      gsuiteIntegrationMetadata = Core.Nothing,
      incomingWebhookChangedMetadata = Core.Nothing,
      inlineRenderFormat = Core.Nothing,
      integrationConfigUpdated = Core.Nothing,
      interactionData = Core.Nothing,
      length = Core.Nothing,
      localId = Core.Nothing,
      membershipChanged = Core.Nothing,
      readReceiptsSettingsMetadata = Core.Nothing,
      requiredMessageFeaturesMetadata = Core.Nothing,
      roomUpdated = Core.Nothing,
      serverInvalidated = Core.Nothing,
      slashCommandMetadata = Core.Nothing,
      startIndex = Core.Nothing,
      type' = Core.Nothing,
      uniqueId = Core.Nothing,
      uploadMetadata = Core.Nothing,
      urlMetadata = Core.Nothing,
      userMentionMetadata = Core.Nothing,
      videoCallMetadata = Core.Nothing,
      youtubeMetadata = Core.Nothing
    }

instance Core.FromJSON Annotation where
  parseJSON =
    Core.withObject
      "Annotation"
      ( \o ->
          Annotation
            Core.<$> (o Core..:? "babelPlaceholderMetadata")
            Core.<*> (o Core..:? "cardCapabilityMetadata")
            Core.<*> (o Core..:? "chipRenderType")
            Core.<*> (o Core..:? "componentSearchInfo")
            Core.<*> (o Core..:? "consentedAppUnfurlMetadata")
            Core.<*> (o Core..:? "customEmojiMetadata")
            Core.<*> (o Core..:? "dataLossPreventionMetadata")
            Core.<*> (o Core..:? "driveMetadata")
            Core.<*> (o Core..:? "formatMetadata")
            Core.<*> (o Core..:? "groupRetentionSettingsUpdated")
            Core.<*> (o Core..:? "gsuiteIntegrationMetadata")
            Core.<*> (o Core..:? "incomingWebhookChangedMetadata")
            Core.<*> (o Core..:? "inlineRenderFormat")
            Core.<*> (o Core..:? "integrationConfigUpdated")
            Core.<*> (o Core..:? "interactionData")
            Core.<*> (o Core..:? "length")
            Core.<*> (o Core..:? "localId")
            Core.<*> (o Core..:? "membershipChanged")
            Core.<*> (o Core..:? "readReceiptsSettingsMetadata")
            Core.<*> (o Core..:? "requiredMessageFeaturesMetadata")
            Core.<*> (o Core..:? "roomUpdated")
            Core.<*> (o Core..:? "serverInvalidated")
            Core.<*> (o Core..:? "slashCommandMetadata")
            Core.<*> (o Core..:? "startIndex")
            Core.<*> (o Core..:? "type")
            Core.<*> (o Core..:? "uniqueId")
            Core.<*> (o Core..:? "uploadMetadata")
            Core.<*> (o Core..:? "urlMetadata")
            Core.<*> (o Core..:? "userMentionMetadata")
            Core.<*> (o Core..:? "videoCallMetadata")
            Core.<*> (o Core..:? "youtubeMetadata")
      )

instance Core.ToJSON Annotation where
  toJSON Annotation {..} =
    Core.object
      ( Core.catMaybes
          [ ("babelPlaceholderMetadata" Core..=)
              Core.<$> babelPlaceholderMetadata,
            ("cardCapabilityMetadata" Core..=)
              Core.<$> cardCapabilityMetadata,
            ("chipRenderType" Core..=) Core.<$> chipRenderType,
            ("componentSearchInfo" Core..=)
              Core.<$> componentSearchInfo,
            ("consentedAppUnfurlMetadata" Core..=)
              Core.<$> consentedAppUnfurlMetadata,
            ("customEmojiMetadata" Core..=)
              Core.<$> customEmojiMetadata,
            ("dataLossPreventionMetadata" Core..=)
              Core.<$> dataLossPreventionMetadata,
            ("driveMetadata" Core..=) Core.<$> driveMetadata,
            ("formatMetadata" Core..=) Core.<$> formatMetadata,
            ("groupRetentionSettingsUpdated" Core..=)
              Core.<$> groupRetentionSettingsUpdated,
            ("gsuiteIntegrationMetadata" Core..=)
              Core.<$> gsuiteIntegrationMetadata,
            ("incomingWebhookChangedMetadata" Core..=)
              Core.<$> incomingWebhookChangedMetadata,
            ("inlineRenderFormat" Core..=)
              Core.<$> inlineRenderFormat,
            ("integrationConfigUpdated" Core..=)
              Core.<$> integrationConfigUpdated,
            ("interactionData" Core..=) Core.<$> interactionData,
            ("length" Core..=) Core.<$> length,
            ("localId" Core..=) Core.<$> localId,
            ("membershipChanged" Core..=)
              Core.<$> membershipChanged,
            ("readReceiptsSettingsMetadata" Core..=)
              Core.<$> readReceiptsSettingsMetadata,
            ("requiredMessageFeaturesMetadata" Core..=)
              Core.<$> requiredMessageFeaturesMetadata,
            ("roomUpdated" Core..=) Core.<$> roomUpdated,
            ("serverInvalidated" Core..=)
              Core.<$> serverInvalidated,
            ("slashCommandMetadata" Core..=)
              Core.<$> slashCommandMetadata,
            ("startIndex" Core..=) Core.<$> startIndex,
            ("type" Core..=) Core.<$> type',
            ("uniqueId" Core..=) Core.<$> uniqueId,
            ("uploadMetadata" Core..=) Core.<$> uploadMetadata,
            ("urlMetadata" Core..=) Core.<$> urlMetadata,
            ("userMentionMetadata" Core..=)
              Core.<$> userMentionMetadata,
            ("videoCallMetadata" Core..=)
              Core.<$> videoCallMetadata,
            ("youtubeMetadata" Core..=)
              Core.<$> youtubeMetadata
          ]
      )

-- | Identifier of an App.
--
-- /See:/ 'newAppId' smart constructor.
data AppId = AppId
  { -- | Enum indicating the type of App this is.
    appType :: (Core.Maybe AppId_AppType),
    -- | Enum indicating which 1P App this is when app/type is GSUITE/APP. Determined & set by the 1P API as a convenience for all users of this identifier(Eg. clients, chime, backend etc.) to map to 1P properties.
    gsuiteAppType :: (Core.Maybe AppId_GsuiteAppType),
    -- | Numeric identifier of the App. Set to Project number for 1\/3P Apps. For Webhook, this is WebhookId. Determined & set by the 1P API from App credentials on the side channel.
    id :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppId' with the minimum fields required to make a request.
newAppId ::
  AppId
newAppId =
  AppId
    { appType = Core.Nothing,
      gsuiteAppType = Core.Nothing,
      id = Core.Nothing
    }

instance Core.FromJSON AppId where
  parseJSON =
    Core.withObject
      "AppId"
      ( \o ->
          AppId
            Core.<$> (o Core..:? "appType")
            Core.<*> (o Core..:? "gsuiteAppType")
            Core.<*> (o Core..:? "id" Core.<&> Core.fmap Core.fromAsText)
      )

instance Core.ToJSON AppId where
  toJSON AppId {..} =
    Core.object
      ( Core.catMaybes
          [ ("appType" Core..=) Core.<$> appType,
            ("gsuiteAppType" Core..=) Core.<$> gsuiteAppType,
            ("id" Core..=) Core.. Core.AsText Core.<$> id
          ]
      )

-- | Next Id: 7
--
-- /See:/ 'newAppsDynamiteSharedActivityFeedAnnotationData' smart constructor.
data AppsDynamiteSharedActivityFeedAnnotationData = AppsDynamiteSharedActivityFeedAnnotationData
  { -- | Timestamp of when the Activity Feed message that contains this annotation was created. This is roughly when the activity happened, such as when a reaction happened, but will have at least some small delay, since the Activity Feed message is created asynchronously after. This timestamp should only be used for display when the activity create time is not available in the Chat UI, like the time of a reaction.
    activityFeedMessageCreateTime :: (Core.Maybe Core.DateTime),
    -- | Unique id of the Activity Feed message used by clients to implement click-to-source. This is the same messageId as the top-level id field for the Activity Feed item.
    activityFeedMessageId :: (Core.Maybe MessageId),
    -- |
    chatItem :: (Core.Maybe AppsDynamiteSharedChatItem),
    -- | Only populated on read path and should not be persisted in storage.
    sharedUserInfo :: (Core.Maybe UserInfo),
    -- | Use shared/user/info instead.
    userInfo :: (Core.Maybe AppsDynamiteSharedActivityFeedAnnotationDataUserInfo)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedActivityFeedAnnotationData' with the minimum fields required to make a request.
newAppsDynamiteSharedActivityFeedAnnotationData ::
  AppsDynamiteSharedActivityFeedAnnotationData
newAppsDynamiteSharedActivityFeedAnnotationData =
  AppsDynamiteSharedActivityFeedAnnotationData
    { activityFeedMessageCreateTime = Core.Nothing,
      activityFeedMessageId = Core.Nothing,
      chatItem = Core.Nothing,
      sharedUserInfo = Core.Nothing,
      userInfo = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedActivityFeedAnnotationData
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedActivityFeedAnnotationData"
      ( \o ->
          AppsDynamiteSharedActivityFeedAnnotationData
            Core.<$> (o Core..:? "activityFeedMessageCreateTime")
            Core.<*> (o Core..:? "activityFeedMessageId")
            Core.<*> (o Core..:? "chatItem")
            Core.<*> (o Core..:? "sharedUserInfo")
            Core.<*> (o Core..:? "userInfo")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedActivityFeedAnnotationData
  where
  toJSON
    AppsDynamiteSharedActivityFeedAnnotationData {..} =
      Core.object
        ( Core.catMaybes
            [ ("activityFeedMessageCreateTime" Core..=)
                Core.<$> activityFeedMessageCreateTime,
              ("activityFeedMessageId" Core..=)
                Core.<$> activityFeedMessageId,
              ("chatItem" Core..=) Core.<$> chatItem,
              ("sharedUserInfo" Core..=) Core.<$> sharedUserInfo,
              ("userInfo" Core..=) Core.<$> userInfo
            ]
        )

-- | UserId of the AF item updater to show and the updater count to show.
--
-- /See:/ 'newAppsDynamiteSharedActivityFeedAnnotationDataUserInfo' smart constructor.
data AppsDynamiteSharedActivityFeedAnnotationDataUserInfo = AppsDynamiteSharedActivityFeedAnnotationDataUserInfo
  { -- | Describes how updater/count/to_show should be used.
    updaterCountDisplayType ::
      ( Core.Maybe
          AppsDynamiteSharedActivityFeedAnnotationDataUserInfo_UpdaterCountDisplayType
      ),
    -- | The number of updaters for clients to show, currently set to the total number of updaters minus the one set in updater/to/show.
    updaterCountToShow :: (Core.Maybe Core.Int32),
    -- | The updater for clients to show.
    updaterToShow :: (Core.Maybe UserId)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedActivityFeedAnnotationDataUserInfo' with the minimum fields required to make a request.
newAppsDynamiteSharedActivityFeedAnnotationDataUserInfo ::
  AppsDynamiteSharedActivityFeedAnnotationDataUserInfo
newAppsDynamiteSharedActivityFeedAnnotationDataUserInfo =
  AppsDynamiteSharedActivityFeedAnnotationDataUserInfo
    { updaterCountDisplayType = Core.Nothing,
      updaterCountToShow = Core.Nothing,
      updaterToShow = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedActivityFeedAnnotationDataUserInfo
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedActivityFeedAnnotationDataUserInfo"
      ( \o ->
          AppsDynamiteSharedActivityFeedAnnotationDataUserInfo
            Core.<$> (o Core..:? "updaterCountDisplayType")
              Core.<*> (o Core..:? "updaterCountToShow")
              Core.<*> (o Core..:? "updaterToShow")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedActivityFeedAnnotationDataUserInfo
  where
  toJSON
    AppsDynamiteSharedActivityFeedAnnotationDataUserInfo {..} =
      Core.object
        ( Core.catMaybes
            [ ("updaterCountDisplayType" Core..=)
                Core.<$> updaterCountDisplayType,
              ("updaterCountToShow" Core..=)
                Core.<$> updaterCountToShow,
              ("updaterToShow" Core..=) Core.<$> updaterToShow
            ]
        )

-- | Optional field for apps overriding display info
--
-- /See:/ 'newAppsDynamiteSharedAppProfile' smart constructor.
data AppsDynamiteSharedAppProfile = AppsDynamiteSharedAppProfile
  { -- | Displayed user avatar emoji.
    avatarEmoji :: (Core.Maybe Core.Text),
    -- | Displayed user avatar url.
    avatarUrl :: (Core.Maybe Core.Text),
    -- | Displayed user name.
    name :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedAppProfile' with the minimum fields required to make a request.
newAppsDynamiteSharedAppProfile ::
  AppsDynamiteSharedAppProfile
newAppsDynamiteSharedAppProfile =
  AppsDynamiteSharedAppProfile
    { avatarEmoji = Core.Nothing,
      avatarUrl = Core.Nothing,
      name = Core.Nothing
    }

instance Core.FromJSON AppsDynamiteSharedAppProfile where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedAppProfile"
      ( \o ->
          AppsDynamiteSharedAppProfile
            Core.<$> (o Core..:? "avatarEmoji")
            Core.<*> (o Core..:? "avatarUrl")
            Core.<*> (o Core..:? "name")
      )

instance Core.ToJSON AppsDynamiteSharedAppProfile where
  toJSON AppsDynamiteSharedAppProfile {..} =
    Core.object
      ( Core.catMaybes
          [ ("avatarEmoji" Core..=) Core.<$> avatarEmoji,
            ("avatarUrl" Core..=) Core.<$> avatarUrl,
            ("name" Core..=) Core.<$> name
          ]
      )

-- | This is the internal version of the API proto at google3\/google\/chat\/v1\/gsuite/message/integration.proto Data used to render Assistant suggestions. See go\/bullseye-rendering.
--
-- /See:/ 'newAppsDynamiteSharedAssistantAnnotationData' smart constructor.
data AppsDynamiteSharedAssistantAnnotationData = AppsDynamiteSharedAssistantAnnotationData
  { -- | The suggestion to render in the card.
    suggestion :: (Core.Maybe AppsDynamiteSharedAssistantSuggestion),
    -- | Set when the initial query was unfulfillable. Only an on-demand unfulfillable query will result in a response (not a proactive query). 1. On-demand: user explicitly invokes the bot 2. Proactive: bot makes proactive suggestion (when available) by listening to all user messages.
    unfulfillable :: (Core.Maybe AppsDynamiteSharedAssistantUnfulfillableRequest)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedAssistantAnnotationData' with the minimum fields required to make a request.
newAppsDynamiteSharedAssistantAnnotationData ::
  AppsDynamiteSharedAssistantAnnotationData
newAppsDynamiteSharedAssistantAnnotationData =
  AppsDynamiteSharedAssistantAnnotationData
    { suggestion = Core.Nothing,
      unfulfillable = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedAssistantAnnotationData
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedAssistantAnnotationData"
      ( \o ->
          AppsDynamiteSharedAssistantAnnotationData
            Core.<$> (o Core..:? "suggestion")
            Core.<*> (o Core..:? "unfulfillable")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedAssistantAnnotationData
  where
  toJSON AppsDynamiteSharedAssistantAnnotationData {..} =
    Core.object
      ( Core.catMaybes
          [ ("suggestion" Core..=) Core.<$> suggestion,
            ("unfulfillable" Core..=) Core.<$> unfulfillable
          ]
      )

-- | Represents info regarding suggestion debug information.
--
-- /See:/ 'newAppsDynamiteSharedAssistantDebugContext' smart constructor.
newtype AppsDynamiteSharedAssistantDebugContext = AppsDynamiteSharedAssistantDebugContext
  { -- | The query that triggered the resulting suggestion.
    query :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedAssistantDebugContext' with the minimum fields required to make a request.
newAppsDynamiteSharedAssistantDebugContext ::
  AppsDynamiteSharedAssistantDebugContext
newAppsDynamiteSharedAssistantDebugContext =
  AppsDynamiteSharedAssistantDebugContext {query = Core.Nothing}

instance
  Core.FromJSON
    AppsDynamiteSharedAssistantDebugContext
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedAssistantDebugContext"
      ( \o ->
          AppsDynamiteSharedAssistantDebugContext
            Core.<$> (o Core..:? "query")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedAssistantDebugContext
  where
  toJSON AppsDynamiteSharedAssistantDebugContext {..} =
    Core.object
      (Core.catMaybes [("query" Core..=) Core.<$> query])

-- | Data needed to render feedback on the Assistant card
--
-- /See:/ 'newAppsDynamiteSharedAssistantFeedbackContext' smart constructor.
data AppsDynamiteSharedAssistantFeedbackContext = AppsDynamiteSharedAssistantFeedbackContext
  { -- | Specifies a list of feedback chips to show
    feedbackChips ::
      ( Core.Maybe
          [AppsDynamiteSharedAssistantFeedbackContextFeedbackChip]
      ),
    -- | Whether the thumbs feedback is provided
    thumbsFeedback ::
      ( Core.Maybe
          AppsDynamiteSharedAssistantFeedbackContext_ThumbsFeedback
      )
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedAssistantFeedbackContext' with the minimum fields required to make a request.
newAppsDynamiteSharedAssistantFeedbackContext ::
  AppsDynamiteSharedAssistantFeedbackContext
newAppsDynamiteSharedAssistantFeedbackContext =
  AppsDynamiteSharedAssistantFeedbackContext
    { feedbackChips = Core.Nothing,
      thumbsFeedback = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedAssistantFeedbackContext
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedAssistantFeedbackContext"
      ( \o ->
          AppsDynamiteSharedAssistantFeedbackContext
            Core.<$> (o Core..:? "feedbackChips")
            Core.<*> (o Core..:? "thumbsFeedback")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedAssistantFeedbackContext
  where
  toJSON AppsDynamiteSharedAssistantFeedbackContext {..} =
    Core.object
      ( Core.catMaybes
          [ ("feedbackChips" Core..=) Core.<$> feedbackChips,
            ("thumbsFeedback" Core..=) Core.<$> thumbsFeedback
          ]
      )

-- | Suggestion chips for users to indicate positive or negative feedback
--
-- /See:/ 'newAppsDynamiteSharedAssistantFeedbackContextFeedbackChip' smart constructor.
data AppsDynamiteSharedAssistantFeedbackContextFeedbackChip = AppsDynamiteSharedAssistantFeedbackContextFeedbackChip
  { -- | What type of chip to display
    feedbackChipType ::
      ( Core.Maybe
          AppsDynamiteSharedAssistantFeedbackContextFeedbackChip_FeedbackChipType
      ),
    -- | Whether the chip has been selected
    state ::
      ( Core.Maybe
          AppsDynamiteSharedAssistantFeedbackContextFeedbackChip_State
      )
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedAssistantFeedbackContextFeedbackChip' with the minimum fields required to make a request.
newAppsDynamiteSharedAssistantFeedbackContextFeedbackChip ::
  AppsDynamiteSharedAssistantFeedbackContextFeedbackChip
newAppsDynamiteSharedAssistantFeedbackContextFeedbackChip =
  AppsDynamiteSharedAssistantFeedbackContextFeedbackChip
    { feedbackChipType = Core.Nothing,
      state = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedAssistantFeedbackContextFeedbackChip
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedAssistantFeedbackContextFeedbackChip"
      ( \o ->
          AppsDynamiteSharedAssistantFeedbackContextFeedbackChip
            Core.<$> (o Core..:? "feedbackChipType")
              Core.<*> (o Core..:? "state")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedAssistantFeedbackContextFeedbackChip
  where
  toJSON
    AppsDynamiteSharedAssistantFeedbackContextFeedbackChip {..} =
      Core.object
        ( Core.catMaybes
            [ ("feedbackChipType" Core..=)
                Core.<$> feedbackChipType,
              ("state" Core..=) Core.<$> state
            ]
        )

-- | Session context specific for Assistant suggestions.
--
-- /See:/ 'newAppsDynamiteSharedAssistantSessionContext' smart constructor.
newtype AppsDynamiteSharedAssistantSessionContext = AppsDynamiteSharedAssistantSessionContext
  { -- | Unique identifier populated by the contextual request handler for each vertical (Ex: File Suggestions, Smart Scheduling, etc.) that can be used to track sessions end-to-end. May span multiple users (sender-specific).
    contextualSessionId :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedAssistantSessionContext' with the minimum fields required to make a request.
newAppsDynamiteSharedAssistantSessionContext ::
  AppsDynamiteSharedAssistantSessionContext
newAppsDynamiteSharedAssistantSessionContext =
  AppsDynamiteSharedAssistantSessionContext {contextualSessionId = Core.Nothing}

instance
  Core.FromJSON
    AppsDynamiteSharedAssistantSessionContext
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedAssistantSessionContext"
      ( \o ->
          AppsDynamiteSharedAssistantSessionContext
            Core.<$> (o Core..:? "contextualSessionId")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedAssistantSessionContext
  where
  toJSON AppsDynamiteSharedAssistantSessionContext {..} =
    Core.object
      ( Core.catMaybes
          [ ("contextualSessionId" Core..=)
              Core.<$> contextualSessionId
          ]
      )

-- | Data for an Assistant suggestion.
--
-- /See:/ 'newAppsDynamiteSharedAssistantSuggestion' smart constructor.
data AppsDynamiteSharedAssistantSuggestion = AppsDynamiteSharedAssistantSuggestion
  { -- | Info regarding suggestion debug information.
    debugContext :: (Core.Maybe AppsDynamiteSharedAssistantDebugContext),
    -- | Data for rendering feedback.
    feedbackContext :: (Core.Maybe AppsDynamiteSharedAssistantFeedbackContext),
    -- | Suggestion type that suggests documents (docs, slides, sheets).
    findDocumentSuggestion :: (Core.Maybe AppsDynamiteSharedFindDocumentSuggestion),
    -- | String representation of the suggestions provided.
    serializedSuggestions :: (Core.Maybe Core.Text),
    -- | Session context specific to the Assistant suggestion.
    sessionContext :: (Core.Maybe AppsDynamiteSharedAssistantSessionContext)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedAssistantSuggestion' with the minimum fields required to make a request.
newAppsDynamiteSharedAssistantSuggestion ::
  AppsDynamiteSharedAssistantSuggestion
newAppsDynamiteSharedAssistantSuggestion =
  AppsDynamiteSharedAssistantSuggestion
    { debugContext = Core.Nothing,
      feedbackContext = Core.Nothing,
      findDocumentSuggestion = Core.Nothing,
      serializedSuggestions = Core.Nothing,
      sessionContext = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedAssistantSuggestion
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedAssistantSuggestion"
      ( \o ->
          AppsDynamiteSharedAssistantSuggestion
            Core.<$> (o Core..:? "debugContext")
            Core.<*> (o Core..:? "feedbackContext")
            Core.<*> (o Core..:? "findDocumentSuggestion")
            Core.<*> (o Core..:? "serializedSuggestions")
            Core.<*> (o Core..:? "sessionContext")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedAssistantSuggestion
  where
  toJSON AppsDynamiteSharedAssistantSuggestion {..} =
    Core.object
      ( Core.catMaybes
          [ ("debugContext" Core..=) Core.<$> debugContext,
            ("feedbackContext" Core..=) Core.<$> feedbackContext,
            ("findDocumentSuggestion" Core..=)
              Core.<$> findDocumentSuggestion,
            ("serializedSuggestions" Core..=)
              Core.<$> serializedSuggestions,
            ("sessionContext" Core..=) Core.<$> sessionContext
          ]
      )

-- | Data for a response to an unfulfillable request.
--
-- /See:/ 'newAppsDynamiteSharedAssistantUnfulfillableRequest' smart constructor.
data AppsDynamiteSharedAssistantUnfulfillableRequest = AppsDynamiteSharedAssistantUnfulfillableRequest
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedAssistantUnfulfillableRequest' with the minimum fields required to make a request.
newAppsDynamiteSharedAssistantUnfulfillableRequest ::
  AppsDynamiteSharedAssistantUnfulfillableRequest
newAppsDynamiteSharedAssistantUnfulfillableRequest =
  AppsDynamiteSharedAssistantUnfulfillableRequest

instance
  Core.FromJSON
    AppsDynamiteSharedAssistantUnfulfillableRequest
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedAssistantUnfulfillableRequest"
      ( \o ->
          Core.pure
            AppsDynamiteSharedAssistantUnfulfillableRequest
      )

instance
  Core.ToJSON
    AppsDynamiteSharedAssistantUnfulfillableRequest
  where
  toJSON = Core.const Core.emptyObject

--
-- /See:/ 'newAppsDynamiteSharedAvatarInfo' smart constructor.
newtype AppsDynamiteSharedAvatarInfo = AppsDynamiteSharedAvatarInfo
  { -- |
    emoji :: (Core.Maybe AppsDynamiteSharedEmoji)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedAvatarInfo' with the minimum fields required to make a request.
newAppsDynamiteSharedAvatarInfo ::
  AppsDynamiteSharedAvatarInfo
newAppsDynamiteSharedAvatarInfo =
  AppsDynamiteSharedAvatarInfo {emoji = Core.Nothing}

instance Core.FromJSON AppsDynamiteSharedAvatarInfo where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedAvatarInfo"
      ( \o ->
          AppsDynamiteSharedAvatarInfo
            Core.<$> (o Core..:? "emoji")
      )

instance Core.ToJSON AppsDynamiteSharedAvatarInfo where
  toJSON AppsDynamiteSharedAvatarInfo {..} =
    Core.object
      (Core.catMaybes [("emoji" Core..=) Core.<$> emoji])

-- | Metadata used only in Dynamite backend for uploaded attachments.
--
-- /See:/ 'newAppsDynamiteSharedBackendUploadMetadata' smart constructor.
data AppsDynamiteSharedBackendUploadMetadata = AppsDynamiteSharedBackendUploadMetadata
  { -- | Blobstore path for the uploaded attachment
    blobPath :: (Core.Maybe Core.Text),
    -- | The original file name for the content, not the full path.
    contentName :: (Core.Maybe Core.Text),
    -- | Scotty reported content size by default. http:\/\/google3\/uploader\/agent\/scotty_agent.proto?l=101&rcl=140889785
    contentSize :: (Core.Maybe Core.Int64),
    -- | Type is from Scotty\'s best/guess by default: http:\/\/google3\/uploader\/agent\/scotty/agent.proto?l=51&rcl=140889785
    contentType :: (Core.Maybe Core.Text),
    -- | The results of the Data Loss Prevention (DLP) scan of the attachment. DEPRECATED: use dlp/scan/summary instead.
    dlpScanOutcome :: (Core.Maybe AppsDynamiteSharedBackendUploadMetadata_DlpScanOutcome),
    -- | Summary of a Data Loss Prevention (DLP) scan of the attachment. Attachments are evaluated in the backend when they are uploaded.
    dlpScanSummary :: (Core.Maybe DlpScanSummary),
    -- | GroupId to which this attachment is uploaded.
    groupId :: (Core.Maybe GroupId),
    -- | If the uploaded file is a video that has been transcoded on the client side Next tag: 18
    isClientSideTranscodedVideo :: (Core.Maybe Core.Bool),
    -- | Original dimension of the content. Only set for image attachments.
    originalDimension :: (Core.Maybe AppsDynamiteSharedDimension),
    -- | The message id of a quote reply referencing this attachment. When present, this attachment has been quoted in a reply message. Normally, the attachment is fetched through the message id in the blob/path, but in the case of a quote reply, the blob/path would contain the quoted message id. Thus this message id field is needed to fetch the quote reply message instead. This field is conditionally populated at read time for quotes and never persisted in storage. See go\/message-quoting-attachments for more context.
    quoteReplyMessageId :: (Core.Maybe MessageId),
    -- | The SHA256 hash of the attachment bytes.
    sha256 :: (Core.Maybe Core.Base64),
    -- | User IP address at upload time. Ex. \"123.1.2.3\". Used by Ares abuse scanning.
    uploadIp :: (Core.Maybe Core.Text),
    -- | Timestamp of when user finished uploading the content.
    uploadTimestampUsec :: (Core.Maybe Core.Int64),
    -- | VideoID of the video attachments. This ID shall meets the Youtube ID format of 16 hex characters. For example, \'4c14b8825af6059b\' is a valid ID.
    videoId :: (Core.Maybe Core.Text),
    -- | Full Blobstore ID for the video thumbnail.
    videoThumbnailBlobId :: (Core.Maybe Core.Text),
    -- | Result for a virus scan.
    virusScanResult ::
      ( Core.Maybe
          AppsDynamiteSharedBackendUploadMetadata_VirusScanResult
      )
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedBackendUploadMetadata' with the minimum fields required to make a request.
newAppsDynamiteSharedBackendUploadMetadata ::
  AppsDynamiteSharedBackendUploadMetadata
newAppsDynamiteSharedBackendUploadMetadata =
  AppsDynamiteSharedBackendUploadMetadata
    { blobPath = Core.Nothing,
      contentName = Core.Nothing,
      contentSize = Core.Nothing,
      contentType = Core.Nothing,
      dlpScanOutcome = Core.Nothing,
      dlpScanSummary = Core.Nothing,
      groupId = Core.Nothing,
      isClientSideTranscodedVideo = Core.Nothing,
      originalDimension = Core.Nothing,
      quoteReplyMessageId = Core.Nothing,
      sha256 = Core.Nothing,
      uploadIp = Core.Nothing,
      uploadTimestampUsec = Core.Nothing,
      videoId = Core.Nothing,
      videoThumbnailBlobId = Core.Nothing,
      virusScanResult = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedBackendUploadMetadata
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedBackendUploadMetadata"
      ( \o ->
          AppsDynamiteSharedBackendUploadMetadata
            Core.<$> (o Core..:? "blobPath")
            Core.<*> (o Core..:? "contentName")
            Core.<*> ( o Core..:? "contentSize"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "contentType")
            Core.<*> (o Core..:? "dlpScanOutcome")
            Core.<*> (o Core..:? "dlpScanSummary")
            Core.<*> (o Core..:? "groupId")
            Core.<*> (o Core..:? "isClientSideTranscodedVideo")
            Core.<*> (o Core..:? "originalDimension")
            Core.<*> (o Core..:? "quoteReplyMessageId")
            Core.<*> (o Core..:? "sha256")
            Core.<*> (o Core..:? "uploadIp")
            Core.<*> ( o Core..:? "uploadTimestampUsec"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "videoId")
            Core.<*> (o Core..:? "videoThumbnailBlobId")
            Core.<*> (o Core..:? "virusScanResult")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedBackendUploadMetadata
  where
  toJSON AppsDynamiteSharedBackendUploadMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("blobPath" Core..=) Core.<$> blobPath,
            ("contentName" Core..=) Core.<$> contentName,
            ("contentSize" Core..=) Core.. Core.AsText
              Core.<$> contentSize,
            ("contentType" Core..=) Core.<$> contentType,
            ("dlpScanOutcome" Core..=) Core.<$> dlpScanOutcome,
            ("dlpScanSummary" Core..=) Core.<$> dlpScanSummary,
            ("groupId" Core..=) Core.<$> groupId,
            ("isClientSideTranscodedVideo" Core..=)
              Core.<$> isClientSideTranscodedVideo,
            ("originalDimension" Core..=)
              Core.<$> originalDimension,
            ("quoteReplyMessageId" Core..=)
              Core.<$> quoteReplyMessageId,
            ("sha256" Core..=) Core.<$> sha256,
            ("uploadIp" Core..=) Core.<$> uploadIp,
            ("uploadTimestampUsec" Core..=) Core.. Core.AsText
              Core.<$> uploadTimestampUsec,
            ("videoId" Core..=) Core.<$> videoId,
            ("videoThumbnailBlobId" Core..=)
              Core.<$> videoThumbnailBlobId,
            ("virusScanResult" Core..=)
              Core.<$> virusScanResult
          ]
      )

--
-- /See:/ 'newAppsDynamiteSharedCalendarEventAnnotationData' smart constructor.
data AppsDynamiteSharedCalendarEventAnnotationData = AppsDynamiteSharedCalendarEventAnnotationData
  { -- |
    calendarEvent ::
      ( Core.Maybe
          AppsDynamiteSharedCalendarEventAnnotationDataCalendarEvent
      ),
    -- | Notification about the creation of an event.
    eventCreation ::
      ( Core.Maybe
          AppsDynamiteSharedCalendarEventAnnotationDataEventCreation
      )
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedCalendarEventAnnotationData' with the minimum fields required to make a request.
newAppsDynamiteSharedCalendarEventAnnotationData ::
  AppsDynamiteSharedCalendarEventAnnotationData
newAppsDynamiteSharedCalendarEventAnnotationData =
  AppsDynamiteSharedCalendarEventAnnotationData
    { calendarEvent = Core.Nothing,
      eventCreation = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedCalendarEventAnnotationData
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedCalendarEventAnnotationData"
      ( \o ->
          AppsDynamiteSharedCalendarEventAnnotationData
            Core.<$> (o Core..:? "calendarEvent")
              Core.<*> (o Core..:? "eventCreation")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedCalendarEventAnnotationData
  where
  toJSON
    AppsDynamiteSharedCalendarEventAnnotationData {..} =
      Core.object
        ( Core.catMaybes
            [ ("calendarEvent" Core..=) Core.<$> calendarEvent,
              ("eventCreation" Core..=) Core.<$> eventCreation
            ]
        )

--
-- /See:/ 'newAppsDynamiteSharedCalendarEventAnnotationDataCalendarEvent' smart constructor.
data AppsDynamiteSharedCalendarEventAnnotationDataCalendarEvent = AppsDynamiteSharedCalendarEventAnnotationDataCalendarEvent
  { -- | The end time of the event.
    endTime ::
      ( Core.Maybe
          AppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime
      ),
    -- | ID of the event.
    eventId :: (Core.Maybe Core.Text),
    -- | The start time of the event.
    startTime ::
      ( Core.Maybe
          AppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime
      ),
    -- | Title of the event (at the time the message was generated).
    title :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedCalendarEventAnnotationDataCalendarEvent' with the minimum fields required to make a request.
newAppsDynamiteSharedCalendarEventAnnotationDataCalendarEvent ::
  AppsDynamiteSharedCalendarEventAnnotationDataCalendarEvent
newAppsDynamiteSharedCalendarEventAnnotationDataCalendarEvent =
  AppsDynamiteSharedCalendarEventAnnotationDataCalendarEvent
    { endTime = Core.Nothing,
      eventId = Core.Nothing,
      startTime = Core.Nothing,
      title = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedCalendarEventAnnotationDataCalendarEvent
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedCalendarEventAnnotationDataCalendarEvent"
      ( \o ->
          AppsDynamiteSharedCalendarEventAnnotationDataCalendarEvent
            Core.<$> (o Core..:? "endTime")
              Core.<*> (o Core..:? "eventId")
              Core.<*> (o Core..:? "startTime")
              Core.<*> (o Core..:? "title")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedCalendarEventAnnotationDataCalendarEvent
  where
  toJSON
    AppsDynamiteSharedCalendarEventAnnotationDataCalendarEvent {..} =
      Core.object
        ( Core.catMaybes
            [ ("endTime" Core..=) Core.<$> endTime,
              ("eventId" Core..=) Core.<$> eventId,
              ("startTime" Core..=) Core.<$> startTime,
              ("title" Core..=) Core.<$> title
            ]
        )

--
-- /See:/ 'newAppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime' smart constructor.
data AppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime = AppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime
  { -- | All day event.
    allDay :: (Core.Maybe Date),
    -- | Non all day event.
    timed :: (Core.Maybe Core.DateTime)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime' with the minimum fields required to make a request.
newAppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime ::
  AppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime
newAppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime =
  AppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime
    { allDay = Core.Nothing,
      timed = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime"
      ( \o ->
          AppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime
            Core.<$> (o Core..:? "allDay") Core.<*> (o Core..:? "timed")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime
  where
  toJSON
    AppsDynamiteSharedCalendarEventAnnotationDataCalendarEventTime {..} =
      Core.object
        ( Core.catMaybes
            [ ("allDay" Core..=) Core.<$> allDay,
              ("timed" Core..=) Core.<$> timed
            ]
        )

-- | Creation of an event (no extra data for now).
--
-- /See:/ 'newAppsDynamiteSharedCalendarEventAnnotationDataEventCreation' smart constructor.
data AppsDynamiteSharedCalendarEventAnnotationDataEventCreation = AppsDynamiteSharedCalendarEventAnnotationDataEventCreation
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedCalendarEventAnnotationDataEventCreation' with the minimum fields required to make a request.
newAppsDynamiteSharedCalendarEventAnnotationDataEventCreation ::
  AppsDynamiteSharedCalendarEventAnnotationDataEventCreation
newAppsDynamiteSharedCalendarEventAnnotationDataEventCreation =
  AppsDynamiteSharedCalendarEventAnnotationDataEventCreation

instance
  Core.FromJSON
    AppsDynamiteSharedCalendarEventAnnotationDataEventCreation
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedCalendarEventAnnotationDataEventCreation"
      ( \o ->
          Core.pure
            AppsDynamiteSharedCalendarEventAnnotationDataEventCreation
      )

instance
  Core.ToJSON
    AppsDynamiteSharedCalendarEventAnnotationDataEventCreation
  where
  toJSON = Core.const Core.emptyObject

-- | Data used to render Meet or Google Voice chips in Chat. See go\/dynamite-calling-artifacts-in-chat.
--
-- /See:/ 'newAppsDynamiteSharedCallAnnotationData' smart constructor.
data AppsDynamiteSharedCallAnnotationData = AppsDynamiteSharedCallAnnotationData
  { -- | Timestamp when the call ended. Used to render the call ended system message.
    callEndedTimestamp :: (Core.Maybe Core.DateTime),
    -- | Required. Call metadata required to create the call artifacts. For now, the metadata contains only the call id to identify the call. This field allows additional data (e.g. voice call type) to be added if needed in the future.
    callMetadata :: (Core.Maybe AppsDynamiteSharedCallMetadata),
    -- | Required. Indicates the call status for the space. Used to determine the chip\'s state.
    callStatus :: (Core.Maybe AppsDynamiteSharedCallAnnotationData_CallStatus)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedCallAnnotationData' with the minimum fields required to make a request.
newAppsDynamiteSharedCallAnnotationData ::
  AppsDynamiteSharedCallAnnotationData
newAppsDynamiteSharedCallAnnotationData =
  AppsDynamiteSharedCallAnnotationData
    { callEndedTimestamp = Core.Nothing,
      callMetadata = Core.Nothing,
      callStatus = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedCallAnnotationData
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedCallAnnotationData"
      ( \o ->
          AppsDynamiteSharedCallAnnotationData
            Core.<$> (o Core..:? "callEndedTimestamp")
            Core.<*> (o Core..:? "callMetadata")
            Core.<*> (o Core..:? "callStatus")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedCallAnnotationData
  where
  toJSON AppsDynamiteSharedCallAnnotationData {..} =
    Core.object
      ( Core.catMaybes
          [ ("callEndedTimestamp" Core..=)
              Core.<$> callEndedTimestamp,
            ("callMetadata" Core..=) Core.<$> callMetadata,
            ("callStatus" Core..=) Core.<$> callStatus
          ]
      )

-- | Metadata required to generate call artifacts. This can either be the metadata for a Meet or, in the future, Google Voice call.
--
-- /See:/ 'newAppsDynamiteSharedCallMetadata' smart constructor.
newtype AppsDynamiteSharedCallMetadata = AppsDynamiteSharedCallMetadata
  { -- | Metadata specific for the Meet call.
    meetMetadata :: (Core.Maybe AppsDynamiteSharedMeetMetadata)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedCallMetadata' with the minimum fields required to make a request.
newAppsDynamiteSharedCallMetadata ::
  AppsDynamiteSharedCallMetadata
newAppsDynamiteSharedCallMetadata =
  AppsDynamiteSharedCallMetadata {meetMetadata = Core.Nothing}

instance Core.FromJSON AppsDynamiteSharedCallMetadata where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedCallMetadata"
      ( \o ->
          AppsDynamiteSharedCallMetadata
            Core.<$> (o Core..:? "meetMetadata")
      )

instance Core.ToJSON AppsDynamiteSharedCallMetadata where
  toJSON AppsDynamiteSharedCallMetadata {..} =
    Core.object
      ( Core.catMaybes
          [("meetMetadata" Core..=) Core.<$> meetMetadata]
      )

-- | Card click which identifies one suggestion provided by the app\/bot.
--
-- /See:/ 'newAppsDynamiteSharedCardClickSuggestion' smart constructor.
data AppsDynamiteSharedCardClickSuggestion = AppsDynamiteSharedCardClickSuggestion
  { -- | Identify the button\/action that created the suggestion. A simple example would be a card button within the stream, or the id which can identify a specific suggestion.
    actionId :: (Core.Maybe Core.Text),
    -- | The message_id for the message that was posted by the app\/bot.
    suggestionMessageId :: (Core.Maybe MessageId)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedCardClickSuggestion' with the minimum fields required to make a request.
newAppsDynamiteSharedCardClickSuggestion ::
  AppsDynamiteSharedCardClickSuggestion
newAppsDynamiteSharedCardClickSuggestion =
  AppsDynamiteSharedCardClickSuggestion
    { actionId = Core.Nothing,
      suggestionMessageId = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedCardClickSuggestion
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedCardClickSuggestion"
      ( \o ->
          AppsDynamiteSharedCardClickSuggestion
            Core.<$> (o Core..:? "actionId")
            Core.<*> (o Core..:? "suggestionMessageId")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedCardClickSuggestion
  where
  toJSON AppsDynamiteSharedCardClickSuggestion {..} =
    Core.object
      ( Core.catMaybes
          [ ("actionId" Core..=) Core.<$> actionId,
            ("suggestionMessageId" Core..=)
              Core.<$> suggestionMessageId
          ]
      )

-- | Next Id: 5
--
-- /See:/ 'newAppsDynamiteSharedChatItem' smart constructor.
data AppsDynamiteSharedChatItem = AppsDynamiteSharedChatItem
  { -- | Information needed to render the specific type of feed item.
    activityInfo :: (Core.Maybe [AppsDynamiteSharedChatItemActivityInfo]),
    -- | Only populated on read path and should not be persisted in storage.
    groupInfo :: (Core.Maybe AppsDynamiteSharedChatItemGroupInfo),
    -- | Additional information about the original chat message that isn\'t captured in the top-level message proto.
    messageInfo :: (Core.Maybe AppsDynamiteSharedMessageInfo)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedChatItem' with the minimum fields required to make a request.
newAppsDynamiteSharedChatItem ::
  AppsDynamiteSharedChatItem
newAppsDynamiteSharedChatItem =
  AppsDynamiteSharedChatItem
    { activityInfo = Core.Nothing,
      groupInfo = Core.Nothing,
      messageInfo = Core.Nothing
    }

instance Core.FromJSON AppsDynamiteSharedChatItem where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedChatItem"
      ( \o ->
          AppsDynamiteSharedChatItem
            Core.<$> (o Core..:? "activityInfo")
            Core.<*> (o Core..:? "groupInfo")
            Core.<*> (o Core..:? "messageInfo")
      )

instance Core.ToJSON AppsDynamiteSharedChatItem where
  toJSON AppsDynamiteSharedChatItem {..} =
    Core.object
      ( Core.catMaybes
          [ ("activityInfo" Core..=) Core.<$> activityInfo,
            ("groupInfo" Core..=) Core.<$> groupInfo,
            ("messageInfo" Core..=) Core.<$> messageInfo
          ]
      )

--
-- /See:/ 'newAppsDynamiteSharedChatItemActivityInfo' smart constructor.
data AppsDynamiteSharedChatItemActivityInfo = AppsDynamiteSharedChatItemActivityInfo
  { -- |
    feedItemNudge :: (Core.Maybe AppsDynamiteSharedChatItemActivityInfoFeedItemNudge),
    -- |
    feedItemReactions ::
      ( Core.Maybe
          AppsDynamiteSharedChatItemActivityInfoFeedItemReactions
      ),
    -- |
    feedItemThreadReply ::
      ( Core.Maybe
          AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReply
      ),
    -- |
    feedItemUserMention ::
      ( Core.Maybe
          AppsDynamiteSharedChatItemActivityInfoFeedItemUserMention
      )
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedChatItemActivityInfo' with the minimum fields required to make a request.
newAppsDynamiteSharedChatItemActivityInfo ::
  AppsDynamiteSharedChatItemActivityInfo
newAppsDynamiteSharedChatItemActivityInfo =
  AppsDynamiteSharedChatItemActivityInfo
    { feedItemNudge = Core.Nothing,
      feedItemReactions = Core.Nothing,
      feedItemThreadReply = Core.Nothing,
      feedItemUserMention = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedChatItemActivityInfo
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedChatItemActivityInfo"
      ( \o ->
          AppsDynamiteSharedChatItemActivityInfo
            Core.<$> (o Core..:? "feedItemNudge")
            Core.<*> (o Core..:? "feedItemReactions")
            Core.<*> (o Core..:? "feedItemThreadReply")
            Core.<*> (o Core..:? "feedItemUserMention")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedChatItemActivityInfo
  where
  toJSON AppsDynamiteSharedChatItemActivityInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("feedItemNudge" Core..=) Core.<$> feedItemNudge,
            ("feedItemReactions" Core..=)
              Core.<$> feedItemReactions,
            ("feedItemThreadReply" Core..=)
              Core.<$> feedItemThreadReply,
            ("feedItemUserMention" Core..=)
              Core.<$> feedItemUserMention
          ]
      )

-- | Existence of this attribute indicates that the AF item is for a message nudge item.
--
-- /See:/ 'newAppsDynamiteSharedChatItemActivityInfoFeedItemNudge' smart constructor.
newtype AppsDynamiteSharedChatItemActivityInfoFeedItemNudge = AppsDynamiteSharedChatItemActivityInfoFeedItemNudge
  { -- | Nudge type of the nudge feed item.
    nudgeType ::
      ( Core.Maybe
          AppsDynamiteSharedChatItemActivityInfoFeedItemNudge_NudgeType
      )
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedChatItemActivityInfoFeedItemNudge' with the minimum fields required to make a request.
newAppsDynamiteSharedChatItemActivityInfoFeedItemNudge ::
  AppsDynamiteSharedChatItemActivityInfoFeedItemNudge
newAppsDynamiteSharedChatItemActivityInfoFeedItemNudge =
  AppsDynamiteSharedChatItemActivityInfoFeedItemNudge {nudgeType = Core.Nothing}

instance
  Core.FromJSON
    AppsDynamiteSharedChatItemActivityInfoFeedItemNudge
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedChatItemActivityInfoFeedItemNudge"
      ( \o ->
          AppsDynamiteSharedChatItemActivityInfoFeedItemNudge
            Core.<$> (o Core..:? "nudgeType")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedChatItemActivityInfoFeedItemNudge
  where
  toJSON
    AppsDynamiteSharedChatItemActivityInfoFeedItemNudge {..} =
      Core.object
        ( Core.catMaybes
            [("nudgeType" Core..=) Core.<$> nudgeType]
        )

-- | Existence of this attribute indicates that the AF item is for message reactions, but it is intentionally left empty since the list of reactions can be found in the top-level Message.Reactions.
--
-- /See:/ 'newAppsDynamiteSharedChatItemActivityInfoFeedItemReactions' smart constructor.
data AppsDynamiteSharedChatItemActivityInfoFeedItemReactions = AppsDynamiteSharedChatItemActivityInfoFeedItemReactions
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedChatItemActivityInfoFeedItemReactions' with the minimum fields required to make a request.
newAppsDynamiteSharedChatItemActivityInfoFeedItemReactions ::
  AppsDynamiteSharedChatItemActivityInfoFeedItemReactions
newAppsDynamiteSharedChatItemActivityInfoFeedItemReactions =
  AppsDynamiteSharedChatItemActivityInfoFeedItemReactions

instance
  Core.FromJSON
    AppsDynamiteSharedChatItemActivityInfoFeedItemReactions
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedChatItemActivityInfoFeedItemReactions"
      ( \o ->
          Core.pure
            AppsDynamiteSharedChatItemActivityInfoFeedItemReactions
      )

instance
  Core.ToJSON
    AppsDynamiteSharedChatItemActivityInfoFeedItemReactions
  where
  toJSON = Core.const Core.emptyObject

-- | Existence of this attribute indicates that the AF item is for thread reply.
--
-- /See:/ 'newAppsDynamiteSharedChatItemActivityInfoFeedItemThreadReply' smart constructor.
newtype AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReply = AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReply
  { -- | Reply type of the thread reply feed item. The field is not persisted in storage. It\'s populated when constructing Activity Feed payload.
    replyType ::
      ( Core.Maybe
          AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReply_ReplyType
      )
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReply' with the minimum fields required to make a request.
newAppsDynamiteSharedChatItemActivityInfoFeedItemThreadReply ::
  AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReply
newAppsDynamiteSharedChatItemActivityInfoFeedItemThreadReply =
  AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReply
    { replyType = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReply
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReply"
      ( \o ->
          AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReply
            Core.<$> (o Core..:? "replyType")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReply
  where
  toJSON
    AppsDynamiteSharedChatItemActivityInfoFeedItemThreadReply {..} =
      Core.object
        ( Core.catMaybes
            [("replyType" Core..=) Core.<$> replyType]
        )

-- | Existence of this attribute indicates that the AF item is for a user mention item.
--
-- /See:/ 'newAppsDynamiteSharedChatItemActivityInfoFeedItemUserMention' smart constructor.
newtype AppsDynamiteSharedChatItemActivityInfoFeedItemUserMention = AppsDynamiteSharedChatItemActivityInfoFeedItemUserMention
  { -- | User mention type
    type' ::
      ( Core.Maybe
          AppsDynamiteSharedChatItemActivityInfoFeedItemUserMention_Type
      )
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedChatItemActivityInfoFeedItemUserMention' with the minimum fields required to make a request.
newAppsDynamiteSharedChatItemActivityInfoFeedItemUserMention ::
  AppsDynamiteSharedChatItemActivityInfoFeedItemUserMention
newAppsDynamiteSharedChatItemActivityInfoFeedItemUserMention =
  AppsDynamiteSharedChatItemActivityInfoFeedItemUserMention
    { type' = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedChatItemActivityInfoFeedItemUserMention
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedChatItemActivityInfoFeedItemUserMention"
      ( \o ->
          AppsDynamiteSharedChatItemActivityInfoFeedItemUserMention
            Core.<$> (o Core..:? "type")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedChatItemActivityInfoFeedItemUserMention
  where
  toJSON
    AppsDynamiteSharedChatItemActivityInfoFeedItemUserMention {..} =
      Core.object
        (Core.catMaybes [("type" Core..=) Core.<$> type'])

-- | Information about the space that the item originated from. This will be used to display Activity Feed items from rooms, and only contain the necessary information, such as the space name and group attributes. NEXT TAG: 6
--
-- /See:/ 'newAppsDynamiteSharedChatItemGroupInfo' smart constructor.
data AppsDynamiteSharedChatItemGroupInfo = AppsDynamiteSharedChatItemGroupInfo
  { -- | This is needed to determine what type of group the source message came from to support click-to-source.
    attributeCheckerGroupType ::
      ( Core.Maybe
          AppsDynamiteSharedChatItemGroupInfo_AttributeCheckerGroupType
      ),
    -- |
    groupName :: (Core.Maybe Core.Text),
    -- | Timestamp of when the group containing the message has been read by the user.
    groupReadTimeUsec :: (Core.Maybe Core.Int64),
    -- | Indicates whether the group has inline replies enabled. If enabled, clients will render the space with inline replies.
    inlineThreadingEnabled :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedChatItemGroupInfo' with the minimum fields required to make a request.
newAppsDynamiteSharedChatItemGroupInfo ::
  AppsDynamiteSharedChatItemGroupInfo
newAppsDynamiteSharedChatItemGroupInfo =
  AppsDynamiteSharedChatItemGroupInfo
    { attributeCheckerGroupType = Core.Nothing,
      groupName = Core.Nothing,
      groupReadTimeUsec = Core.Nothing,
      inlineThreadingEnabled = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedChatItemGroupInfo
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedChatItemGroupInfo"
      ( \o ->
          AppsDynamiteSharedChatItemGroupInfo
            Core.<$> (o Core..:? "attributeCheckerGroupType")
            Core.<*> (o Core..:? "groupName")
            Core.<*> ( o Core..:? "groupReadTimeUsec"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "inlineThreadingEnabled")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedChatItemGroupInfo
  where
  toJSON AppsDynamiteSharedChatItemGroupInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("attributeCheckerGroupType" Core..=)
              Core.<$> attributeCheckerGroupType,
            ("groupName" Core..=) Core.<$> groupName,
            ("groupReadTimeUsec" Core..=) Core.. Core.AsText
              Core.<$> groupReadTimeUsec,
            ("inlineThreadingEnabled" Core..=)
              Core.<$> inlineThreadingEnabled
          ]
      )

-- | Denotes a type of content report a user can send.
--
-- /See:/ 'newAppsDynamiteSharedContentReportType' smart constructor.
newtype AppsDynamiteSharedContentReportType = AppsDynamiteSharedContentReportType
  { -- | Required. Google-defined system violation, covering the most common violations.
    systemViolation :: (Core.Maybe AppsDynamiteSharedContentReportType_SystemViolation)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedContentReportType' with the minimum fields required to make a request.
newAppsDynamiteSharedContentReportType ::
  AppsDynamiteSharedContentReportType
newAppsDynamiteSharedContentReportType =
  AppsDynamiteSharedContentReportType {systemViolation = Core.Nothing}

instance
  Core.FromJSON
    AppsDynamiteSharedContentReportType
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedContentReportType"
      ( \o ->
          AppsDynamiteSharedContentReportType
            Core.<$> (o Core..:? "systemViolation")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedContentReportType
  where
  toJSON AppsDynamiteSharedContentReportType {..} =
    Core.object
      ( Core.catMaybes
          [ ("systemViolation" Core..=)
              Core.<$> systemViolation
          ]
      )

-- | Proto representation of a custom emoji. May be used in both APIs and in Spanner, but certain fields should be restricted to one or the other. See the per-field documentation for details. NEXT_TAG: 14
--
-- /See:/ 'newAppsDynamiteSharedCustomEmoji' smart constructor.
data AppsDynamiteSharedCustomEmoji = AppsDynamiteSharedCustomEmoji
  { -- | ID for the underlying image data in Blobstore. This field should /only/ be present in Spanner or within the server, but should not be exposed in public APIs.
    blobId :: (Core.Maybe Core.Text),
    -- | Content type of the file used to upload the emoji. Used for takeout. Written to Spanner when the emoji is created.
    contentType :: (Core.Maybe Core.Text),
    -- | Time when the Emoji was created, in microseconds. This field may be present in Spanner, within the server, or in public APIs.
    createTimeMicros :: (Core.Maybe Core.Int64),
    -- | This field should /never/ be persisted to Spanner.
    creatorUserId :: (Core.Maybe UserId),
    -- | Time when the emoji was deleted, in microseconds. This field may be present in Spanner, within the server, or in public APIs. Only present if the emoji has been deleted.
    deleteTimeMicros :: (Core.Maybe Core.Int64),
    -- | Output only. A short-lived URL clients can use for directly accessing a custom emoji image. This field is intended for API consumption, and should /never/ be persisted to Spanner.
    ephemeralUrl :: (Core.Maybe Core.Text),
    -- | This field should /never/ be persisted to Spanner.
    ownerCustomerId :: (Core.Maybe CustomerId),
    -- | Opaque token that clients use to construct the URL for accessing the custom emoji’s image data. This field is intended for API consumption, and should /never/ be persisted to Spanner.
    readToken :: (Core.Maybe Core.Text),
    -- | User-provided, human-readable ID for the custom emoji. Users are expected to observe this field in the UI instead of the UUID. This shortcode should be unique within an organization, but has no global uniqueness guarantees, unlike the UUID. This field should /never/ be persisted to Spanner.
    shortcode :: (Core.Maybe Core.Text),
    -- | Snapshot of the current state of the emoji, which may differ from the source-of-truth in the CustomEmojis table. This field should /never/ be persisted to Spanner.
    state :: (Core.Maybe AppsDynamiteSharedCustomEmoji_State),
    -- |
    updateTimeMicros :: (Core.Maybe Core.Int64),
    -- | Unique key for a custom emoji resource. Required. This field is /always/ populated.
    uuid :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedCustomEmoji' with the minimum fields required to make a request.
newAppsDynamiteSharedCustomEmoji ::
  AppsDynamiteSharedCustomEmoji
newAppsDynamiteSharedCustomEmoji =
  AppsDynamiteSharedCustomEmoji
    { blobId = Core.Nothing,
      contentType = Core.Nothing,
      createTimeMicros = Core.Nothing,
      creatorUserId = Core.Nothing,
      deleteTimeMicros = Core.Nothing,
      ephemeralUrl = Core.Nothing,
      ownerCustomerId = Core.Nothing,
      readToken = Core.Nothing,
      shortcode = Core.Nothing,
      state = Core.Nothing,
      updateTimeMicros = Core.Nothing,
      uuid = Core.Nothing
    }

instance Core.FromJSON AppsDynamiteSharedCustomEmoji where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedCustomEmoji"
      ( \o ->
          AppsDynamiteSharedCustomEmoji
            Core.<$> (o Core..:? "blobId")
            Core.<*> (o Core..:? "contentType")
            Core.<*> ( o Core..:? "createTimeMicros"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "creatorUserId")
            Core.<*> ( o Core..:? "deleteTimeMicros"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "ephemeralUrl")
            Core.<*> (o Core..:? "ownerCustomerId")
            Core.<*> (o Core..:? "readToken")
            Core.<*> (o Core..:? "shortcode")
            Core.<*> (o Core..:? "state")
            Core.<*> ( o Core..:? "updateTimeMicros"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "uuid")
      )

instance Core.ToJSON AppsDynamiteSharedCustomEmoji where
  toJSON AppsDynamiteSharedCustomEmoji {..} =
    Core.object
      ( Core.catMaybes
          [ ("blobId" Core..=) Core.<$> blobId,
            ("contentType" Core..=) Core.<$> contentType,
            ("createTimeMicros" Core..=) Core.. Core.AsText
              Core.<$> createTimeMicros,
            ("creatorUserId" Core..=) Core.<$> creatorUserId,
            ("deleteTimeMicros" Core..=) Core.. Core.AsText
              Core.<$> deleteTimeMicros,
            ("ephemeralUrl" Core..=) Core.<$> ephemeralUrl,
            ("ownerCustomerId" Core..=) Core.<$> ownerCustomerId,
            ("readToken" Core..=) Core.<$> readToken,
            ("shortcode" Core..=) Core.<$> shortcode,
            ("state" Core..=) Core.<$> state,
            ("updateTimeMicros" Core..=) Core.. Core.AsText
              Core.<$> updateTimeMicros,
            ("uuid" Core..=) Core.<$> uuid
          ]
      )

-- | Dimension for the uploaded attachments.
--
-- /See:/ 'newAppsDynamiteSharedDimension' smart constructor.
data AppsDynamiteSharedDimension = AppsDynamiteSharedDimension
  { -- |
    height :: (Core.Maybe Core.Int32),
    -- |
    width :: (Core.Maybe Core.Int32)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedDimension' with the minimum fields required to make a request.
newAppsDynamiteSharedDimension ::
  AppsDynamiteSharedDimension
newAppsDynamiteSharedDimension =
  AppsDynamiteSharedDimension {height = Core.Nothing, width = Core.Nothing}

instance Core.FromJSON AppsDynamiteSharedDimension where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedDimension"
      ( \o ->
          AppsDynamiteSharedDimension
            Core.<$> (o Core..:? "height") Core.<*> (o Core..:? "width")
      )

instance Core.ToJSON AppsDynamiteSharedDimension where
  toJSON AppsDynamiteSharedDimension {..} =
    Core.object
      ( Core.catMaybes
          [ ("height" Core..=) Core.<$> height,
            ("width" Core..=) Core.<$> width
          ]
      )

-- | LINT.IfChange
--
-- /See:/ 'newAppsDynamiteSharedDlpMetricsMetadata' smart constructor.
newtype AppsDynamiteSharedDlpMetricsMetadata = AppsDynamiteSharedDlpMetricsMetadata
  { -- | [required] Describes the DLP status of message send and attachment upload events.
    dlpStatus :: (Core.Maybe AppsDynamiteSharedDlpMetricsMetadata_DlpStatus)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedDlpMetricsMetadata' with the minimum fields required to make a request.
newAppsDynamiteSharedDlpMetricsMetadata ::
  AppsDynamiteSharedDlpMetricsMetadata
newAppsDynamiteSharedDlpMetricsMetadata =
  AppsDynamiteSharedDlpMetricsMetadata {dlpStatus = Core.Nothing}

instance
  Core.FromJSON
    AppsDynamiteSharedDlpMetricsMetadata
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedDlpMetricsMetadata"
      ( \o ->
          AppsDynamiteSharedDlpMetricsMetadata
            Core.<$> (o Core..:? "dlpStatus")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedDlpMetricsMetadata
  where
  toJSON AppsDynamiteSharedDlpMetricsMetadata {..} =
    Core.object
      ( Core.catMaybes
          [("dlpStatus" Core..=) Core.<$> dlpStatus]
      )

-- | Data for rendering a document.
--
-- /See:/ 'newAppsDynamiteSharedDocument' smart constructor.
data AppsDynamiteSharedDocument = AppsDynamiteSharedDocument
  { -- | Unique file ID.
    fileId :: (Core.Maybe Core.Text),
    -- | Justification to explain why this document is being suggested.
    justification :: (Core.Maybe AppsDynamiteSharedJustification),
    -- | Time the document was last modified.
    lastModifiedTime :: (Core.Maybe Core.DateTime),
    -- | Used to determine which icon to render (e.g. docs, slides, sheets)
    mimeType :: (Core.Maybe Core.Text),
    -- | Title of the document.
    title :: (Core.Maybe Core.Text),
    -- | URL of the document.
    url :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedDocument' with the minimum fields required to make a request.
newAppsDynamiteSharedDocument ::
  AppsDynamiteSharedDocument
newAppsDynamiteSharedDocument =
  AppsDynamiteSharedDocument
    { fileId = Core.Nothing,
      justification = Core.Nothing,
      lastModifiedTime = Core.Nothing,
      mimeType = Core.Nothing,
      title = Core.Nothing,
      url = Core.Nothing
    }

instance Core.FromJSON AppsDynamiteSharedDocument where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedDocument"
      ( \o ->
          AppsDynamiteSharedDocument
            Core.<$> (o Core..:? "fileId")
            Core.<*> (o Core..:? "justification")
            Core.<*> (o Core..:? "lastModifiedTime")
            Core.<*> (o Core..:? "mimeType")
            Core.<*> (o Core..:? "title")
            Core.<*> (o Core..:? "url")
      )

instance Core.ToJSON AppsDynamiteSharedDocument where
  toJSON AppsDynamiteSharedDocument {..} =
    Core.object
      ( Core.catMaybes
          [ ("fileId" Core..=) Core.<$> fileId,
            ("justification" Core..=) Core.<$> justification,
            ("lastModifiedTime" Core..=)
              Core.<$> lastModifiedTime,
            ("mimeType" Core..=) Core.<$> mimeType,
            ("title" Core..=) Core.<$> title,
            ("url" Core..=) Core.<$> url
          ]
      )

--
-- /See:/ 'newAppsDynamiteSharedEmoji' smart constructor.
data AppsDynamiteSharedEmoji = AppsDynamiteSharedEmoji
  { -- | A custom emoji.
    customEmoji :: (Core.Maybe AppsDynamiteSharedCustomEmoji),
    -- | A basic emoji represented by a unicode string.
    unicode :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedEmoji' with the minimum fields required to make a request.
newAppsDynamiteSharedEmoji ::
  AppsDynamiteSharedEmoji
newAppsDynamiteSharedEmoji =
  AppsDynamiteSharedEmoji {customEmoji = Core.Nothing, unicode = Core.Nothing}

instance Core.FromJSON AppsDynamiteSharedEmoji where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedEmoji"
      ( \o ->
          AppsDynamiteSharedEmoji
            Core.<$> (o Core..:? "customEmoji")
            Core.<*> (o Core..:? "unicode")
      )

instance Core.ToJSON AppsDynamiteSharedEmoji where
  toJSON AppsDynamiteSharedEmoji {..} =
    Core.object
      ( Core.catMaybes
          [ ("customEmoji" Core..=) Core.<$> customEmoji,
            ("unicode" Core..=) Core.<$> unicode
          ]
      )

-- | Data for a FindDocument suggestion type.
--
-- /See:/ 'newAppsDynamiteSharedFindDocumentSuggestion' smart constructor.
data AppsDynamiteSharedFindDocumentSuggestion = AppsDynamiteSharedFindDocumentSuggestion
  { -- | List of documents to render as suggestions.
    documentSuggestions :: (Core.Maybe [AppsDynamiteSharedDocument]),
    -- | Whether to show the action buttons in the card for the suggestions.
    showActionButtons :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedFindDocumentSuggestion' with the minimum fields required to make a request.
newAppsDynamiteSharedFindDocumentSuggestion ::
  AppsDynamiteSharedFindDocumentSuggestion
newAppsDynamiteSharedFindDocumentSuggestion =
  AppsDynamiteSharedFindDocumentSuggestion
    { documentSuggestions = Core.Nothing,
      showActionButtons = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedFindDocumentSuggestion
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedFindDocumentSuggestion"
      ( \o ->
          AppsDynamiteSharedFindDocumentSuggestion
            Core.<$> (o Core..:? "documentSuggestions")
            Core.<*> (o Core..:? "showActionButtons")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedFindDocumentSuggestion
  where
  toJSON AppsDynamiteSharedFindDocumentSuggestion {..} =
    Core.object
      ( Core.catMaybes
          [ ("documentSuggestions" Core..=)
              Core.<$> documentSuggestions,
            ("showActionButtons" Core..=)
              Core.<$> showActionButtons
          ]
      )

-- | NEXT TAG: 3 A GroupDetails proto will store the information pertaining to single Group.
--
-- /See:/ 'newAppsDynamiteSharedGroupDetails' smart constructor.
data AppsDynamiteSharedGroupDetails = AppsDynamiteSharedGroupDetails
  { -- | A simple text that describes the purpose of a single Group, the general theme of the topics to be posted and\/or the denominator of the Group participants.
    description :: (Core.Maybe Core.Text),
    -- | A simple text describing the rules and expectations from members when participating in conversation.
    guidelines :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedGroupDetails' with the minimum fields required to make a request.
newAppsDynamiteSharedGroupDetails ::
  AppsDynamiteSharedGroupDetails
newAppsDynamiteSharedGroupDetails =
  AppsDynamiteSharedGroupDetails
    { description = Core.Nothing,
      guidelines = Core.Nothing
    }

instance Core.FromJSON AppsDynamiteSharedGroupDetails where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedGroupDetails"
      ( \o ->
          AppsDynamiteSharedGroupDetails
            Core.<$> (o Core..:? "description")
            Core.<*> (o Core..:? "guidelines")
      )

instance Core.ToJSON AppsDynamiteSharedGroupDetails where
  toJSON AppsDynamiteSharedGroupDetails {..} =
    Core.object
      ( Core.catMaybes
          [ ("description" Core..=) Core.<$> description,
            ("guidelines" Core..=) Core.<$> guidelines
          ]
      )

--
-- /See:/ 'newAppsDynamiteSharedGroupVisibility' smart constructor.
newtype AppsDynamiteSharedGroupVisibility = AppsDynamiteSharedGroupVisibility
  { -- |
    state :: (Core.Maybe AppsDynamiteSharedGroupVisibility_State)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedGroupVisibility' with the minimum fields required to make a request.
newAppsDynamiteSharedGroupVisibility ::
  AppsDynamiteSharedGroupVisibility
newAppsDynamiteSharedGroupVisibility =
  AppsDynamiteSharedGroupVisibility {state = Core.Nothing}

instance
  Core.FromJSON
    AppsDynamiteSharedGroupVisibility
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedGroupVisibility"
      ( \o ->
          AppsDynamiteSharedGroupVisibility
            Core.<$> (o Core..:? "state")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedGroupVisibility
  where
  toJSON AppsDynamiteSharedGroupVisibility {..} =
    Core.object
      (Core.catMaybes [("state" Core..=) Core.<$> state])

-- | Data for rendering a justification for a document.
--
-- /See:/ 'newAppsDynamiteSharedJustification' smart constructor.
data AppsDynamiteSharedJustification = AppsDynamiteSharedJustification
  { -- | Time the action took place.
    actionTime :: (Core.Maybe Core.DateTime),
    -- | Type of action performed on the document.
    actionType :: (Core.Maybe AppsDynamiteSharedJustification_ActionType),
    -- | Owner of the document.
    documentOwner :: (Core.Maybe AppsDynamiteSharedJustificationPerson),
    -- | Words or phrases from the user\'s query that describes the document content. (Ex: Users query is \"Can you share the document about Bullseye?\" the extracted topic would be \"Bullseye\").
    topics :: (Core.Maybe [Core.Text])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedJustification' with the minimum fields required to make a request.
newAppsDynamiteSharedJustification ::
  AppsDynamiteSharedJustification
newAppsDynamiteSharedJustification =
  AppsDynamiteSharedJustification
    { actionTime = Core.Nothing,
      actionType = Core.Nothing,
      documentOwner = Core.Nothing,
      topics = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedJustification
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedJustification"
      ( \o ->
          AppsDynamiteSharedJustification
            Core.<$> (o Core..:? "actionTime")
            Core.<*> (o Core..:? "actionType")
            Core.<*> (o Core..:? "documentOwner")
            Core.<*> (o Core..:? "topics")
      )

instance Core.ToJSON AppsDynamiteSharedJustification where
  toJSON AppsDynamiteSharedJustification {..} =
    Core.object
      ( Core.catMaybes
          [ ("actionTime" Core..=) Core.<$> actionTime,
            ("actionType" Core..=) Core.<$> actionType,
            ("documentOwner" Core..=) Core.<$> documentOwner,
            ("topics" Core..=) Core.<$> topics
          ]
      )

-- | Data for rendering a person associated with a document.
--
-- /See:/ 'newAppsDynamiteSharedJustificationPerson' smart constructor.
data AppsDynamiteSharedJustificationPerson = AppsDynamiteSharedJustificationPerson
  { -- | Whether the person is the recipient of the suggestions.
    isRecipient :: (Core.Maybe Core.Bool),
    -- | Obfuscated user ID.
    user :: (Core.Maybe UserId)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedJustificationPerson' with the minimum fields required to make a request.
newAppsDynamiteSharedJustificationPerson ::
  AppsDynamiteSharedJustificationPerson
newAppsDynamiteSharedJustificationPerson =
  AppsDynamiteSharedJustificationPerson
    { isRecipient = Core.Nothing,
      user = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedJustificationPerson
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedJustificationPerson"
      ( \o ->
          AppsDynamiteSharedJustificationPerson
            Core.<$> (o Core..:? "isRecipient")
            Core.<*> (o Core..:? "user")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedJustificationPerson
  where
  toJSON AppsDynamiteSharedJustificationPerson {..} =
    Core.object
      ( Core.catMaybes
          [ ("isRecipient" Core..=) Core.<$> isRecipient,
            ("user" Core..=) Core.<$> user
          ]
      )

-- | Metadata specific for a Meet call that are required to generate call artifacts.
--
-- /See:/ 'newAppsDynamiteSharedMeetMetadata' smart constructor.
data AppsDynamiteSharedMeetMetadata = AppsDynamiteSharedMeetMetadata
  { -- | Required. A globally unique code (e.g. \"cxv-zbgj-wzw\") that points to a meeting space. Note: Meeting codes may be regenerated, which will cause old meeting codes to become invalid.
    meetingCode :: (Core.Maybe Core.Text),
    -- | Required. A URL, in the format \"https:\/\/meet.google.com\/*\" (e.g. https:\/\/meet.google.com\/cxv-zbgj-wzw), to identify and access the meeting space.
    meetingUrl :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedMeetMetadata' with the minimum fields required to make a request.
newAppsDynamiteSharedMeetMetadata ::
  AppsDynamiteSharedMeetMetadata
newAppsDynamiteSharedMeetMetadata =
  AppsDynamiteSharedMeetMetadata
    { meetingCode = Core.Nothing,
      meetingUrl = Core.Nothing
    }

instance Core.FromJSON AppsDynamiteSharedMeetMetadata where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedMeetMetadata"
      ( \o ->
          AppsDynamiteSharedMeetMetadata
            Core.<$> (o Core..:? "meetingCode")
            Core.<*> (o Core..:? "meetingUrl")
      )

instance Core.ToJSON AppsDynamiteSharedMeetMetadata where
  toJSON AppsDynamiteSharedMeetMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("meetingCode" Core..=) Core.<$> meetingCode,
            ("meetingUrl" Core..=) Core.<$> meetingUrl
          ]
      )

-- | Metadata used to describe search information in a specific component of a chat message, for example an annotation or an attachment.
--
-- /See:/ 'newAppsDynamiteSharedMessageComponentSearchInfo' smart constructor.
data AppsDynamiteSharedMessageComponentSearchInfo = AppsDynamiteSharedMessageComponentSearchInfo
  { -- | Whether the whole component matched the search.
    matchedSearch :: (Core.Maybe Core.Bool),
    -- | Backend should always set TextWithDescription.text_body based on the title (or its snippet) of the annotation or attachment.
    titleTextWithDescription :: (Core.Maybe AppsDynamiteSharedTextWithDescription)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedMessageComponentSearchInfo' with the minimum fields required to make a request.
newAppsDynamiteSharedMessageComponentSearchInfo ::
  AppsDynamiteSharedMessageComponentSearchInfo
newAppsDynamiteSharedMessageComponentSearchInfo =
  AppsDynamiteSharedMessageComponentSearchInfo
    { matchedSearch = Core.Nothing,
      titleTextWithDescription = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedMessageComponentSearchInfo
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedMessageComponentSearchInfo"
      ( \o ->
          AppsDynamiteSharedMessageComponentSearchInfo
            Core.<$> (o Core..:? "matchedSearch")
            Core.<*> (o Core..:? "titleTextWithDescription")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedMessageComponentSearchInfo
  where
  toJSON
    AppsDynamiteSharedMessageComponentSearchInfo {..} =
      Core.object
        ( Core.catMaybes
            [ ("matchedSearch" Core..=) Core.<$> matchedSearch,
              ("titleTextWithDescription" Core..=)
                Core.<$> titleTextWithDescription
            ]
        )

-- | Information that references a Dynamite chat message. This is only used for Activity Feed messages.
--
-- /See:/ 'newAppsDynamiteSharedMessageInfo' smart constructor.
data AppsDynamiteSharedMessageInfo = AppsDynamiteSharedMessageInfo
  { -- | Id of the source chat message. This is kept here because the top-level message ID to refers the AF message ID.
    messageId :: (Core.Maybe MessageId),
    -- | The type of the source chat message.
    messageType :: (Core.Maybe AppsDynamiteSharedMessageInfo_MessageType),
    -- | Timestamp of when the topic containing the message has been read by the user. This is populated if the message references an inline reply, in which case the space may be marked as read but the topic still has unread messages.
    topicReadTimeUsec :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedMessageInfo' with the minimum fields required to make a request.
newAppsDynamiteSharedMessageInfo ::
  AppsDynamiteSharedMessageInfo
newAppsDynamiteSharedMessageInfo =
  AppsDynamiteSharedMessageInfo
    { messageId = Core.Nothing,
      messageType = Core.Nothing,
      topicReadTimeUsec = Core.Nothing
    }

instance Core.FromJSON AppsDynamiteSharedMessageInfo where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedMessageInfo"
      ( \o ->
          AppsDynamiteSharedMessageInfo
            Core.<$> (o Core..:? "messageId")
            Core.<*> (o Core..:? "messageType")
            Core.<*> ( o Core..:? "topicReadTimeUsec"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON AppsDynamiteSharedMessageInfo where
  toJSON AppsDynamiteSharedMessageInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("messageId" Core..=) Core.<$> messageId,
            ("messageType" Core..=) Core.<$> messageType,
            ("topicReadTimeUsec" Core..=) Core.. Core.AsText
              Core.<$> topicReadTimeUsec
          ]
      )

-- | The payload(restricted to 1P applications) to be stored with a specific message.
--
-- /See:/ 'newAppsDynamiteSharedMessageIntegrationPayload' smart constructor.
data AppsDynamiteSharedMessageIntegrationPayload = AppsDynamiteSharedMessageIntegrationPayload
  { -- | Pantheon project number used to identify the calling app.
    projectNumber :: (Core.Maybe Core.Int64),
    -- |
    tasksMessageIntegrationPayload :: (Core.Maybe AppsDynamiteSharedTasksMessageIntegrationPayload),
    -- | An enum indicating which 1P application\'s payload this is. This field is required to add 1P payload.
    type' :: (Core.Maybe AppsDynamiteSharedMessageIntegrationPayload_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedMessageIntegrationPayload' with the minimum fields required to make a request.
newAppsDynamiteSharedMessageIntegrationPayload ::
  AppsDynamiteSharedMessageIntegrationPayload
newAppsDynamiteSharedMessageIntegrationPayload =
  AppsDynamiteSharedMessageIntegrationPayload
    { projectNumber = Core.Nothing,
      tasksMessageIntegrationPayload = Core.Nothing,
      type' = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedMessageIntegrationPayload
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedMessageIntegrationPayload"
      ( \o ->
          AppsDynamiteSharedMessageIntegrationPayload
            Core.<$> ( o Core..:? "projectNumber"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "tasksMessageIntegrationPayload")
            Core.<*> (o Core..:? "type")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedMessageIntegrationPayload
  where
  toJSON
    AppsDynamiteSharedMessageIntegrationPayload {..} =
      Core.object
        ( Core.catMaybes
            [ ("projectNumber" Core..=) Core.. Core.AsText
                Core.<$> projectNumber,
              ("tasksMessageIntegrationPayload" Core..=)
                Core.<$> tasksMessageIntegrationPayload,
              ("type" Core..=) Core.<$> type'
            ]
        )

-- | Contains info about the entity that something is, or is owned by.
--
-- /See:/ 'newAppsDynamiteSharedOrganizationInfo' smart constructor.
data AppsDynamiteSharedOrganizationInfo = AppsDynamiteSharedOrganizationInfo
  { -- |
    consumerInfo :: (Core.Maybe AppsDynamiteSharedOrganizationInfoConsumerInfo),
    -- |
    customerInfo :: (Core.Maybe AppsDynamiteSharedOrganizationInfoCustomerInfo)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedOrganizationInfo' with the minimum fields required to make a request.
newAppsDynamiteSharedOrganizationInfo ::
  AppsDynamiteSharedOrganizationInfo
newAppsDynamiteSharedOrganizationInfo =
  AppsDynamiteSharedOrganizationInfo
    { consumerInfo = Core.Nothing,
      customerInfo = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedOrganizationInfo
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedOrganizationInfo"
      ( \o ->
          AppsDynamiteSharedOrganizationInfo
            Core.<$> (o Core..:? "consumerInfo")
            Core.<*> (o Core..:? "customerInfo")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedOrganizationInfo
  where
  toJSON AppsDynamiteSharedOrganizationInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("consumerInfo" Core..=) Core.<$> consumerInfo,
            ("customerInfo" Core..=) Core.<$> customerInfo
          ]
      )

-- | Intentionally empty. Used to disambiguate consumer and customer use cases in oneof below.
--
-- /See:/ 'newAppsDynamiteSharedOrganizationInfoConsumerInfo' smart constructor.
data AppsDynamiteSharedOrganizationInfoConsumerInfo = AppsDynamiteSharedOrganizationInfoConsumerInfo
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedOrganizationInfoConsumerInfo' with the minimum fields required to make a request.
newAppsDynamiteSharedOrganizationInfoConsumerInfo ::
  AppsDynamiteSharedOrganizationInfoConsumerInfo
newAppsDynamiteSharedOrganizationInfoConsumerInfo =
  AppsDynamiteSharedOrganizationInfoConsumerInfo

instance
  Core.FromJSON
    AppsDynamiteSharedOrganizationInfoConsumerInfo
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedOrganizationInfoConsumerInfo"
      ( \o ->
          Core.pure
            AppsDynamiteSharedOrganizationInfoConsumerInfo
      )

instance
  Core.ToJSON
    AppsDynamiteSharedOrganizationInfoConsumerInfo
  where
  toJSON = Core.const Core.emptyObject

--
-- /See:/ 'newAppsDynamiteSharedOrganizationInfoCustomerInfo' smart constructor.
newtype AppsDynamiteSharedOrganizationInfoCustomerInfo = AppsDynamiteSharedOrganizationInfoCustomerInfo
  { -- |
    customerId :: (Core.Maybe CustomerId)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedOrganizationInfoCustomerInfo' with the minimum fields required to make a request.
newAppsDynamiteSharedOrganizationInfoCustomerInfo ::
  AppsDynamiteSharedOrganizationInfoCustomerInfo
newAppsDynamiteSharedOrganizationInfoCustomerInfo =
  AppsDynamiteSharedOrganizationInfoCustomerInfo {customerId = Core.Nothing}

instance
  Core.FromJSON
    AppsDynamiteSharedOrganizationInfoCustomerInfo
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedOrganizationInfoCustomerInfo"
      ( \o ->
          AppsDynamiteSharedOrganizationInfoCustomerInfo
            Core.<$> (o Core..:? "customerId")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedOrganizationInfoCustomerInfo
  where
  toJSON
    AppsDynamiteSharedOrganizationInfoCustomerInfo {..} =
      Core.object
        ( Core.catMaybes
            [("customerId" Core..=) Core.<$> customerId]
        )

-- | Stores the suggestion provided by apps\/bots.
--
-- /See:/ 'newAppsDynamiteSharedOriginAppSuggestion' smart constructor.
data AppsDynamiteSharedOriginAppSuggestion = AppsDynamiteSharedOriginAppSuggestion
  { -- |
    appId :: (Core.Maybe AppId),
    -- |
    cardClickSuggestion :: (Core.Maybe AppsDynamiteSharedCardClickSuggestion)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedOriginAppSuggestion' with the minimum fields required to make a request.
newAppsDynamiteSharedOriginAppSuggestion ::
  AppsDynamiteSharedOriginAppSuggestion
newAppsDynamiteSharedOriginAppSuggestion =
  AppsDynamiteSharedOriginAppSuggestion
    { appId = Core.Nothing,
      cardClickSuggestion = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedOriginAppSuggestion
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedOriginAppSuggestion"
      ( \o ->
          AppsDynamiteSharedOriginAppSuggestion
            Core.<$> (o Core..:? "appId")
            Core.<*> (o Core..:? "cardClickSuggestion")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedOriginAppSuggestion
  where
  toJSON AppsDynamiteSharedOriginAppSuggestion {..} =
    Core.object
      ( Core.catMaybes
          [ ("appId" Core..=) Core.<$> appId,
            ("cardClickSuggestion" Core..=)
              Core.<$> cardClickSuggestion
          ]
      )

--
-- /See:/ 'newAppsDynamiteSharedPhoneNumber' smart constructor.
data AppsDynamiteSharedPhoneNumber = AppsDynamiteSharedPhoneNumber
  { -- | The phone number type, e.g., work, mobile, etc.
    type' :: (Core.Maybe Core.Text),
    -- | The actual phone number.
    value :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedPhoneNumber' with the minimum fields required to make a request.
newAppsDynamiteSharedPhoneNumber ::
  AppsDynamiteSharedPhoneNumber
newAppsDynamiteSharedPhoneNumber =
  AppsDynamiteSharedPhoneNumber {type' = Core.Nothing, value = Core.Nothing}

instance Core.FromJSON AppsDynamiteSharedPhoneNumber where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedPhoneNumber"
      ( \o ->
          AppsDynamiteSharedPhoneNumber
            Core.<$> (o Core..:? "type") Core.<*> (o Core..:? "value")
      )

instance Core.ToJSON AppsDynamiteSharedPhoneNumber where
  toJSON AppsDynamiteSharedPhoneNumber {..} =
    Core.object
      ( Core.catMaybes
          [ ("type" Core..=) Core.<$> type',
            ("value" Core..=) Core.<$> value
          ]
      )

--
-- /See:/ 'newAppsDynamiteSharedReaction' smart constructor.
data AppsDynamiteSharedReaction = AppsDynamiteSharedReaction
  { -- | The total number of users who have reacted.
    count :: (Core.Maybe Core.Int32),
    -- | When the first emoji of this type was added.
    createTimestamp :: (Core.Maybe Core.Int64),
    -- | Whether the current user reacted using this emoji. Note: Unlike most properties of messages, this is different per-user.
    currentUserParticipated :: (Core.Maybe Core.Bool),
    -- |
    emoji :: (Core.Maybe AppsDynamiteSharedEmoji)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedReaction' with the minimum fields required to make a request.
newAppsDynamiteSharedReaction ::
  AppsDynamiteSharedReaction
newAppsDynamiteSharedReaction =
  AppsDynamiteSharedReaction
    { count = Core.Nothing,
      createTimestamp = Core.Nothing,
      currentUserParticipated = Core.Nothing,
      emoji = Core.Nothing
    }

instance Core.FromJSON AppsDynamiteSharedReaction where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedReaction"
      ( \o ->
          AppsDynamiteSharedReaction
            Core.<$> (o Core..:? "count")
            Core.<*> ( o Core..:? "createTimestamp"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "currentUserParticipated")
            Core.<*> (o Core..:? "emoji")
      )

instance Core.ToJSON AppsDynamiteSharedReaction where
  toJSON AppsDynamiteSharedReaction {..} =
    Core.object
      ( Core.catMaybes
          [ ("count" Core..=) Core.<$> count,
            ("createTimestamp" Core..=) Core.. Core.AsText
              Core.<$> createTimestamp,
            ("currentUserParticipated" Core..=)
              Core.<$> currentUserParticipated,
            ("emoji" Core..=) Core.<$> emoji
          ]
      )

-- | The settings of retention period of a message or topic.
--
-- /See:/ 'newAppsDynamiteSharedRetentionSettings' smart constructor.
data AppsDynamiteSharedRetentionSettings = AppsDynamiteSharedRetentionSettings
  { -- | The timestamp after which the message\/topic should be removed, in microseconds since the epoch, when state == EPHEMERAL/ONE/DAY. The value should not be set in other cases.
    expiryTimestamp :: (Core.Maybe Core.Int64),
    -- | The retention state.
    state :: (Core.Maybe AppsDynamiteSharedRetentionSettings_State)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedRetentionSettings' with the minimum fields required to make a request.
newAppsDynamiteSharedRetentionSettings ::
  AppsDynamiteSharedRetentionSettings
newAppsDynamiteSharedRetentionSettings =
  AppsDynamiteSharedRetentionSettings
    { expiryTimestamp = Core.Nothing,
      state = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedRetentionSettings
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedRetentionSettings"
      ( \o ->
          AppsDynamiteSharedRetentionSettings
            Core.<$> ( o Core..:? "expiryTimestamp"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "state")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedRetentionSettings
  where
  toJSON AppsDynamiteSharedRetentionSettings {..} =
    Core.object
      ( Core.catMaybes
          [ ("expiryTimestamp" Core..=) Core.. Core.AsText
              Core.<$> expiryTimestamp,
            ("state" Core..=) Core.<$> state
          ]
      )

-- | Contains info on membership count for member types: HUMAN/USER, APP/USER & ROSTER_MEMBER different states: INVITED, JOINED
--
-- /See:/ 'newAppsDynamiteSharedSegmentedMembershipCount' smart constructor.
data AppsDynamiteSharedSegmentedMembershipCount = AppsDynamiteSharedSegmentedMembershipCount
  { -- |
    memberType :: (Core.Maybe AppsDynamiteSharedSegmentedMembershipCount_MemberType),
    -- | count of members with given type and state
    membershipCount :: (Core.Maybe Core.Int32),
    -- |
    membershipState ::
      ( Core.Maybe
          AppsDynamiteSharedSegmentedMembershipCount_MembershipState
      )
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedSegmentedMembershipCount' with the minimum fields required to make a request.
newAppsDynamiteSharedSegmentedMembershipCount ::
  AppsDynamiteSharedSegmentedMembershipCount
newAppsDynamiteSharedSegmentedMembershipCount =
  AppsDynamiteSharedSegmentedMembershipCount
    { memberType = Core.Nothing,
      membershipCount = Core.Nothing,
      membershipState = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedSegmentedMembershipCount
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedSegmentedMembershipCount"
      ( \o ->
          AppsDynamiteSharedSegmentedMembershipCount
            Core.<$> (o Core..:? "memberType")
            Core.<*> (o Core..:? "membershipCount")
            Core.<*> (o Core..:? "membershipState")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedSegmentedMembershipCount
  where
  toJSON AppsDynamiteSharedSegmentedMembershipCount {..} =
    Core.object
      ( Core.catMaybes
          [ ("memberType" Core..=) Core.<$> memberType,
            ("membershipCount" Core..=) Core.<$> membershipCount,
            ("membershipState" Core..=)
              Core.<$> membershipState
          ]
      )

--
-- /See:/ 'newAppsDynamiteSharedSegmentedMembershipCounts' smart constructor.
newtype AppsDynamiteSharedSegmentedMembershipCounts = AppsDynamiteSharedSegmentedMembershipCounts
  { -- |
    value :: (Core.Maybe [AppsDynamiteSharedSegmentedMembershipCount])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedSegmentedMembershipCounts' with the minimum fields required to make a request.
newAppsDynamiteSharedSegmentedMembershipCounts ::
  AppsDynamiteSharedSegmentedMembershipCounts
newAppsDynamiteSharedSegmentedMembershipCounts =
  AppsDynamiteSharedSegmentedMembershipCounts {value = Core.Nothing}

instance
  Core.FromJSON
    AppsDynamiteSharedSegmentedMembershipCounts
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedSegmentedMembershipCounts"
      ( \o ->
          AppsDynamiteSharedSegmentedMembershipCounts
            Core.<$> (o Core..:? "value")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedSegmentedMembershipCounts
  where
  toJSON
    AppsDynamiteSharedSegmentedMembershipCounts {..} =
      Core.object
        (Core.catMaybes [("value" Core..=) Core.<$> value])

-- | Defines the representation of a single matching space.
--
-- /See:/ 'newAppsDynamiteSharedSpaceInfo' smart constructor.
data AppsDynamiteSharedSpaceInfo = AppsDynamiteSharedSpaceInfo
  { -- |
    avatarInfo :: (Core.Maybe AppsDynamiteSharedAvatarInfo),
    -- |
    avatarUrl :: (Core.Maybe Core.Text),
    -- |
    description :: (Core.Maybe Core.Text),
    -- |
    groupId :: (Core.Maybe GroupId),
    -- | The email address of the user that invited the calling user to the room, if available. This field will only be populated for direct invites, it will be empty if the user was indirectly invited to the group.
    inviterEmail :: (Core.Maybe Core.Text),
    -- | Whether this is a space that enables guest access
    isExternal :: (Core.Maybe Core.Bool),
    -- |
    name :: (Core.Maybe Core.Text),
    -- | Deprecated. Use segmented/membership/counts instead which also includes other counts such as rosters.
    numMembers :: (Core.Maybe Core.Int32),
    -- | Member counts object with types of members and their respective counts.
    segmentedMembershipCounts :: (Core.Maybe AppsDynamiteSharedSegmentedMembershipCounts),
    -- | searching user\'s membership state in this space
    userMembershipState :: (Core.Maybe AppsDynamiteSharedSpaceInfo_UserMembershipState)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedSpaceInfo' with the minimum fields required to make a request.
newAppsDynamiteSharedSpaceInfo ::
  AppsDynamiteSharedSpaceInfo
newAppsDynamiteSharedSpaceInfo =
  AppsDynamiteSharedSpaceInfo
    { avatarInfo = Core.Nothing,
      avatarUrl = Core.Nothing,
      description = Core.Nothing,
      groupId = Core.Nothing,
      inviterEmail = Core.Nothing,
      isExternal = Core.Nothing,
      name = Core.Nothing,
      numMembers = Core.Nothing,
      segmentedMembershipCounts = Core.Nothing,
      userMembershipState = Core.Nothing
    }

instance Core.FromJSON AppsDynamiteSharedSpaceInfo where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedSpaceInfo"
      ( \o ->
          AppsDynamiteSharedSpaceInfo
            Core.<$> (o Core..:? "avatarInfo")
            Core.<*> (o Core..:? "avatarUrl")
            Core.<*> (o Core..:? "description")
            Core.<*> (o Core..:? "groupId")
            Core.<*> (o Core..:? "inviterEmail")
            Core.<*> (o Core..:? "isExternal")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "numMembers")
            Core.<*> (o Core..:? "segmentedMembershipCounts")
            Core.<*> (o Core..:? "userMembershipState")
      )

instance Core.ToJSON AppsDynamiteSharedSpaceInfo where
  toJSON AppsDynamiteSharedSpaceInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("avatarInfo" Core..=) Core.<$> avatarInfo,
            ("avatarUrl" Core..=) Core.<$> avatarUrl,
            ("description" Core..=) Core.<$> description,
            ("groupId" Core..=) Core.<$> groupId,
            ("inviterEmail" Core..=) Core.<$> inviterEmail,
            ("isExternal" Core..=) Core.<$> isExternal,
            ("name" Core..=) Core.<$> name,
            ("numMembers" Core..=) Core.<$> numMembers,
            ("segmentedMembershipCounts" Core..=)
              Core.<$> segmentedMembershipCounts,
            ("userMembershipState" Core..=)
              Core.<$> userMembershipState
          ]
      )

-- | This is the internal version of the API proto at google3\/google\/chat\/v1\/gsuite/message/integration.proto
--
-- /See:/ 'newAppsDynamiteSharedTasksAnnotationData' smart constructor.
data AppsDynamiteSharedTasksAnnotationData = AppsDynamiteSharedTasksAnnotationData
  { -- |
    assigneeChange :: (Core.Maybe AppsDynamiteSharedTasksAnnotationDataAssigneeChange),
    -- |
    completionChange :: (Core.Maybe AppsDynamiteSharedTasksAnnotationDataCompletionChange),
    -- |
    creation :: (Core.Maybe AppsDynamiteSharedTasksAnnotationDataCreation),
    -- |
    deletionChange :: (Core.Maybe AppsDynamiteSharedTasksAnnotationDataDeletionChange),
    -- | ID of task. Will be used to create deep links to Tasks.
    taskId :: (Core.Maybe Core.Text),
    -- | Task properties after the update has been applied.
    taskProperties :: (Core.Maybe AppsDynamiteSharedTasksAnnotationDataTaskProperties),
    -- |
    userDefinedMessage ::
      ( Core.Maybe
          AppsDynamiteSharedTasksAnnotationDataUserDefinedMessage
      )
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedTasksAnnotationData' with the minimum fields required to make a request.
newAppsDynamiteSharedTasksAnnotationData ::
  AppsDynamiteSharedTasksAnnotationData
newAppsDynamiteSharedTasksAnnotationData =
  AppsDynamiteSharedTasksAnnotationData
    { assigneeChange = Core.Nothing,
      completionChange = Core.Nothing,
      creation = Core.Nothing,
      deletionChange = Core.Nothing,
      taskId = Core.Nothing,
      taskProperties = Core.Nothing,
      userDefinedMessage = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedTasksAnnotationData
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedTasksAnnotationData"
      ( \o ->
          AppsDynamiteSharedTasksAnnotationData
            Core.<$> (o Core..:? "assigneeChange")
            Core.<*> (o Core..:? "completionChange")
            Core.<*> (o Core..:? "creation")
            Core.<*> (o Core..:? "deletionChange")
            Core.<*> (o Core..:? "taskId")
            Core.<*> (o Core..:? "taskProperties")
            Core.<*> (o Core..:? "userDefinedMessage")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedTasksAnnotationData
  where
  toJSON AppsDynamiteSharedTasksAnnotationData {..} =
    Core.object
      ( Core.catMaybes
          [ ("assigneeChange" Core..=) Core.<$> assigneeChange,
            ("completionChange" Core..=)
              Core.<$> completionChange,
            ("creation" Core..=) Core.<$> creation,
            ("deletionChange" Core..=) Core.<$> deletionChange,
            ("taskId" Core..=) Core.<$> taskId,
            ("taskProperties" Core..=) Core.<$> taskProperties,
            ("userDefinedMessage" Core..=)
              Core.<$> userDefinedMessage
          ]
      )

--
-- /See:/ 'newAppsDynamiteSharedTasksAnnotationDataAssigneeChange' smart constructor.
newtype AppsDynamiteSharedTasksAnnotationDataAssigneeChange = AppsDynamiteSharedTasksAnnotationDataAssigneeChange
  { -- | Obfuscated user ID of previous assignee. Not set if the task was originally not assigned.
    oldAssignee :: (Core.Maybe UserId)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedTasksAnnotationDataAssigneeChange' with the minimum fields required to make a request.
newAppsDynamiteSharedTasksAnnotationDataAssigneeChange ::
  AppsDynamiteSharedTasksAnnotationDataAssigneeChange
newAppsDynamiteSharedTasksAnnotationDataAssigneeChange =
  AppsDynamiteSharedTasksAnnotationDataAssigneeChange
    { oldAssignee = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedTasksAnnotationDataAssigneeChange
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedTasksAnnotationDataAssigneeChange"
      ( \o ->
          AppsDynamiteSharedTasksAnnotationDataAssigneeChange
            Core.<$> (o Core..:? "oldAssignee")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedTasksAnnotationDataAssigneeChange
  where
  toJSON
    AppsDynamiteSharedTasksAnnotationDataAssigneeChange {..} =
      Core.object
        ( Core.catMaybes
            [("oldAssignee" Core..=) Core.<$> oldAssignee]
        )

--
-- /See:/ 'newAppsDynamiteSharedTasksAnnotationDataCompletionChange' smart constructor.
data AppsDynamiteSharedTasksAnnotationDataCompletionChange = AppsDynamiteSharedTasksAnnotationDataCompletionChange
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedTasksAnnotationDataCompletionChange' with the minimum fields required to make a request.
newAppsDynamiteSharedTasksAnnotationDataCompletionChange ::
  AppsDynamiteSharedTasksAnnotationDataCompletionChange
newAppsDynamiteSharedTasksAnnotationDataCompletionChange =
  AppsDynamiteSharedTasksAnnotationDataCompletionChange

instance
  Core.FromJSON
    AppsDynamiteSharedTasksAnnotationDataCompletionChange
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedTasksAnnotationDataCompletionChange"
      ( \o ->
          Core.pure
            AppsDynamiteSharedTasksAnnotationDataCompletionChange
      )

instance
  Core.ToJSON
    AppsDynamiteSharedTasksAnnotationDataCompletionChange
  where
  toJSON = Core.const Core.emptyObject

--
-- /See:/ 'newAppsDynamiteSharedTasksAnnotationDataCreation' smart constructor.
data AppsDynamiteSharedTasksAnnotationDataCreation = AppsDynamiteSharedTasksAnnotationDataCreation
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedTasksAnnotationDataCreation' with the minimum fields required to make a request.
newAppsDynamiteSharedTasksAnnotationDataCreation ::
  AppsDynamiteSharedTasksAnnotationDataCreation
newAppsDynamiteSharedTasksAnnotationDataCreation =
  AppsDynamiteSharedTasksAnnotationDataCreation

instance
  Core.FromJSON
    AppsDynamiteSharedTasksAnnotationDataCreation
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedTasksAnnotationDataCreation"
      ( \o ->
          Core.pure
            AppsDynamiteSharedTasksAnnotationDataCreation
      )

instance
  Core.ToJSON
    AppsDynamiteSharedTasksAnnotationDataCreation
  where
  toJSON = Core.const Core.emptyObject

--
-- /See:/ 'newAppsDynamiteSharedTasksAnnotationDataDeletionChange' smart constructor.
data AppsDynamiteSharedTasksAnnotationDataDeletionChange = AppsDynamiteSharedTasksAnnotationDataDeletionChange
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedTasksAnnotationDataDeletionChange' with the minimum fields required to make a request.
newAppsDynamiteSharedTasksAnnotationDataDeletionChange ::
  AppsDynamiteSharedTasksAnnotationDataDeletionChange
newAppsDynamiteSharedTasksAnnotationDataDeletionChange =
  AppsDynamiteSharedTasksAnnotationDataDeletionChange

instance
  Core.FromJSON
    AppsDynamiteSharedTasksAnnotationDataDeletionChange
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedTasksAnnotationDataDeletionChange"
      ( \o ->
          Core.pure
            AppsDynamiteSharedTasksAnnotationDataDeletionChange
      )

instance
  Core.ToJSON
    AppsDynamiteSharedTasksAnnotationDataDeletionChange
  where
  toJSON = Core.const Core.emptyObject

-- | All relevant task properties for a Chat message.
--
-- /See:/ 'newAppsDynamiteSharedTasksAnnotationDataTaskProperties' smart constructor.
data AppsDynamiteSharedTasksAnnotationDataTaskProperties = AppsDynamiteSharedTasksAnnotationDataTaskProperties
  { -- | Obfuscated user ID of new assignee. Not set if the task doesn\'t have an assignee.
    assignee :: (Core.Maybe UserId),
    -- | Whether the task is marked as completed.
    completed :: (Core.Maybe Core.Bool),
    -- | Whether the task is marked as deleted.
    deleted :: (Core.Maybe Core.Bool),
    -- | The description of the task. If Task original description\'s length is greater than 1024, then Task BE sends the truncated description to Dynamite Integration Server.
    description :: (Core.Maybe Core.Text),
    -- | Set if the task has a date but no time. Source of truth in Tasks BE: http:\/\/shortn\/_wyT7eB4Ixv
    startDate :: (Core.Maybe Date),
    -- | Set if the task has both a date and a time. Source of truth in Tasks BE: http:\/\/shortn\/_u6cr0F5ttE
    startTime :: (Core.Maybe Core.DateTime),
    -- | The title of the task.
    title :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedTasksAnnotationDataTaskProperties' with the minimum fields required to make a request.
newAppsDynamiteSharedTasksAnnotationDataTaskProperties ::
  AppsDynamiteSharedTasksAnnotationDataTaskProperties
newAppsDynamiteSharedTasksAnnotationDataTaskProperties =
  AppsDynamiteSharedTasksAnnotationDataTaskProperties
    { assignee = Core.Nothing,
      completed = Core.Nothing,
      deleted = Core.Nothing,
      description = Core.Nothing,
      startDate = Core.Nothing,
      startTime = Core.Nothing,
      title = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedTasksAnnotationDataTaskProperties
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedTasksAnnotationDataTaskProperties"
      ( \o ->
          AppsDynamiteSharedTasksAnnotationDataTaskProperties
            Core.<$> (o Core..:? "assignee")
              Core.<*> (o Core..:? "completed")
              Core.<*> (o Core..:? "deleted")
              Core.<*> (o Core..:? "description")
              Core.<*> (o Core..:? "startDate")
              Core.<*> (o Core..:? "startTime")
              Core.<*> (o Core..:? "title")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedTasksAnnotationDataTaskProperties
  where
  toJSON
    AppsDynamiteSharedTasksAnnotationDataTaskProperties {..} =
      Core.object
        ( Core.catMaybes
            [ ("assignee" Core..=) Core.<$> assignee,
              ("completed" Core..=) Core.<$> completed,
              ("deleted" Core..=) Core.<$> deleted,
              ("description" Core..=) Core.<$> description,
              ("startDate" Core..=) Core.<$> startDate,
              ("startTime" Core..=) Core.<$> startTime,
              ("title" Core..=) Core.<$> title
            ]
        )

-- | Used for task card attachments on custom user messages that should be kept as is without generating an i18n event message, e.g. the user starts a conversation from an existing task. IMPORTANT: please don\'t populate this field yet as it could break existing flows until it\'s implemented. See code at http:\/\/shortn\//CM74CdENMx used by http:\/\/shortn\//5o85POJY8Q.
--
-- /See:/ 'newAppsDynamiteSharedTasksAnnotationDataUserDefinedMessage' smart constructor.
data AppsDynamiteSharedTasksAnnotationDataUserDefinedMessage = AppsDynamiteSharedTasksAnnotationDataUserDefinedMessage
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedTasksAnnotationDataUserDefinedMessage' with the minimum fields required to make a request.
newAppsDynamiteSharedTasksAnnotationDataUserDefinedMessage ::
  AppsDynamiteSharedTasksAnnotationDataUserDefinedMessage
newAppsDynamiteSharedTasksAnnotationDataUserDefinedMessage =
  AppsDynamiteSharedTasksAnnotationDataUserDefinedMessage

instance
  Core.FromJSON
    AppsDynamiteSharedTasksAnnotationDataUserDefinedMessage
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedTasksAnnotationDataUserDefinedMessage"
      ( \o ->
          Core.pure
            AppsDynamiteSharedTasksAnnotationDataUserDefinedMessage
      )

instance
  Core.ToJSON
    AppsDynamiteSharedTasksAnnotationDataUserDefinedMessage
  where
  toJSON = Core.const Core.emptyObject

-- | A payload containing Tasks metadata for rendering a live card. Currently not used by the Tasks integration.
--
-- /See:/ 'newAppsDynamiteSharedTasksMessageIntegrationPayload' smart constructor.
data AppsDynamiteSharedTasksMessageIntegrationPayload = AppsDynamiteSharedTasksMessageIntegrationPayload
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedTasksMessageIntegrationPayload' with the minimum fields required to make a request.
newAppsDynamiteSharedTasksMessageIntegrationPayload ::
  AppsDynamiteSharedTasksMessageIntegrationPayload
newAppsDynamiteSharedTasksMessageIntegrationPayload =
  AppsDynamiteSharedTasksMessageIntegrationPayload

instance
  Core.FromJSON
    AppsDynamiteSharedTasksMessageIntegrationPayload
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedTasksMessageIntegrationPayload"
      ( \o ->
          Core.pure
            AppsDynamiteSharedTasksMessageIntegrationPayload
      )

instance
  Core.ToJSON
    AppsDynamiteSharedTasksMessageIntegrationPayload
  where
  toJSON = Core.const Core.emptyObject

-- | Defines a segment in a text.
--
-- /See:/ 'newAppsDynamiteSharedTextSegment' smart constructor.
data AppsDynamiteSharedTextSegment = AppsDynamiteSharedTextSegment
  { -- | Length of the segment in the text.
    length :: (Core.Maybe Core.Int32),
    -- | Start index (0-indexed and inclusive) of the segment in the text.
    startIndex :: (Core.Maybe Core.Int32)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedTextSegment' with the minimum fields required to make a request.
newAppsDynamiteSharedTextSegment ::
  AppsDynamiteSharedTextSegment
newAppsDynamiteSharedTextSegment =
  AppsDynamiteSharedTextSegment
    { length = Core.Nothing,
      startIndex = Core.Nothing
    }

instance Core.FromJSON AppsDynamiteSharedTextSegment where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedTextSegment"
      ( \o ->
          AppsDynamiteSharedTextSegment
            Core.<$> (o Core..:? "length")
            Core.<*> (o Core..:? "startIndex")
      )

instance Core.ToJSON AppsDynamiteSharedTextSegment where
  toJSON AppsDynamiteSharedTextSegment {..} =
    Core.object
      ( Core.catMaybes
          [ ("length" Core..=) Core.<$> length,
            ("startIndex" Core..=) Core.<$> startIndex
          ]
      )

-- | Defines text segments with description type associated.
--
-- /See:/ 'newAppsDynamiteSharedTextSegmentsWithDescription' smart constructor.
data AppsDynamiteSharedTextSegmentsWithDescription = AppsDynamiteSharedTextSegmentsWithDescription
  { -- |
    descriptionType ::
      ( Core.Maybe
          AppsDynamiteSharedTextSegmentsWithDescription_DescriptionType
      ),
    -- |
    textSegment :: (Core.Maybe [AppsDynamiteSharedTextSegment])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedTextSegmentsWithDescription' with the minimum fields required to make a request.
newAppsDynamiteSharedTextSegmentsWithDescription ::
  AppsDynamiteSharedTextSegmentsWithDescription
newAppsDynamiteSharedTextSegmentsWithDescription =
  AppsDynamiteSharedTextSegmentsWithDescription
    { descriptionType = Core.Nothing,
      textSegment = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedTextSegmentsWithDescription
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedTextSegmentsWithDescription"
      ( \o ->
          AppsDynamiteSharedTextSegmentsWithDescription
            Core.<$> (o Core..:? "descriptionType")
              Core.<*> (o Core..:? "textSegment")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedTextSegmentsWithDescription
  where
  toJSON
    AppsDynamiteSharedTextSegmentsWithDescription {..} =
      Core.object
        ( Core.catMaybes
            [ ("descriptionType" Core..=)
                Core.<$> descriptionType,
              ("textSegment" Core..=) Core.<$> textSegment
            ]
        )

-- | Defines a text with descriptive text segments associated.
--
-- /See:/ 'newAppsDynamiteSharedTextWithDescription' smart constructor.
data AppsDynamiteSharedTextWithDescription = AppsDynamiteSharedTextWithDescription
  { -- |
    textBody :: (Core.Maybe Core.Text),
    -- |
    textSegmentsWithDescription :: (Core.Maybe [AppsDynamiteSharedTextSegmentsWithDescription])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedTextWithDescription' with the minimum fields required to make a request.
newAppsDynamiteSharedTextWithDescription ::
  AppsDynamiteSharedTextWithDescription
newAppsDynamiteSharedTextWithDescription =
  AppsDynamiteSharedTextWithDescription
    { textBody = Core.Nothing,
      textSegmentsWithDescription = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedTextWithDescription
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedTextWithDescription"
      ( \o ->
          AppsDynamiteSharedTextWithDescription
            Core.<$> (o Core..:? "textBody")
            Core.<*> (o Core..:? "textSegmentsWithDescription")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedTextWithDescription
  where
  toJSON AppsDynamiteSharedTextWithDescription {..} =
    Core.object
      ( Core.catMaybes
          [ ("textBody" Core..=) Core.<$> textBody,
            ("textSegmentsWithDescription" Core..=)
              Core.<$> textSegmentsWithDescription
          ]
      )

-- | User-block relationship
--
-- /See:/ 'newAppsDynamiteSharedUserBlockRelationship' smart constructor.
data AppsDynamiteSharedUserBlockRelationship = AppsDynamiteSharedUserBlockRelationship
  { -- |
    hasBlockedRequester :: (Core.Maybe Core.Bool),
    -- |
    isBlockedByRequester :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedUserBlockRelationship' with the minimum fields required to make a request.
newAppsDynamiteSharedUserBlockRelationship ::
  AppsDynamiteSharedUserBlockRelationship
newAppsDynamiteSharedUserBlockRelationship =
  AppsDynamiteSharedUserBlockRelationship
    { hasBlockedRequester = Core.Nothing,
      isBlockedByRequester = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedUserBlockRelationship
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedUserBlockRelationship"
      ( \o ->
          AppsDynamiteSharedUserBlockRelationship
            Core.<$> (o Core..:? "hasBlockedRequester")
            Core.<*> (o Core..:? "isBlockedByRequester")
      )

instance
  Core.ToJSON
    AppsDynamiteSharedUserBlockRelationship
  where
  toJSON AppsDynamiteSharedUserBlockRelationship {..} =
    Core.object
      ( Core.catMaybes
          [ ("hasBlockedRequester" Core..=)
              Core.<$> hasBlockedRequester,
            ("isBlockedByRequester" Core..=)
              Core.<$> isBlockedByRequester
          ]
      )

-- | Reference to a transcoded video attachment.
--
-- /See:/ 'newAppsDynamiteSharedVideoReference' smart constructor.
data AppsDynamiteSharedVideoReference = AppsDynamiteSharedVideoReference
  { -- | Available transcode format. Value is defined in video\/storage\/proto\/content_header.proto
    format :: (Core.Maybe [Core.Int32]),
    -- | Transcode status
    status :: (Core.Maybe AppsDynamiteSharedVideoReference_Status)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteSharedVideoReference' with the minimum fields required to make a request.
newAppsDynamiteSharedVideoReference ::
  AppsDynamiteSharedVideoReference
newAppsDynamiteSharedVideoReference =
  AppsDynamiteSharedVideoReference
    { format = Core.Nothing,
      status = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteSharedVideoReference
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteSharedVideoReference"
      ( \o ->
          AppsDynamiteSharedVideoReference
            Core.<$> (o Core..:? "format") Core.<*> (o Core..:? "status")
      )

instance Core.ToJSON AppsDynamiteSharedVideoReference where
  toJSON AppsDynamiteSharedVideoReference {..} =
    Core.object
      ( Core.catMaybes
          [ ("format" Core..=) Core.<$> format,
            ("status" Core..=) Core.<$> status
          ]
      )

-- | An action that describes the behavior when the form is submitted. For example, an Apps Script can be invoked to handle the form.
--
-- /See:/ 'newAppsDynamiteStorageAction' smart constructor.
data AppsDynamiteStorageAction = AppsDynamiteStorageAction
  { -- | Apps Script function to invoke when the containing element is clicked\/activated.
    function :: (Core.Maybe Core.Text),
    -- |
    interaction :: (Core.Maybe AppsDynamiteStorageAction_Interaction),
    -- |
    loadIndicator :: (Core.Maybe AppsDynamiteStorageAction_LoadIndicator),
    -- | List of action parameters.
    parameters :: (Core.Maybe [AppsDynamiteStorageActionActionParameter]),
    -- | Indicates whether form values persist after the action. The default value is @false@. If @true@, form values remain after the action is triggered. When using <workspace/add-ons/reference/rpc/google.apps.card.v1#loadindicator LoadIndicator.NONE> for actions, @persist_values@ = @true@is recommended, as it ensures that any changes made by the user after form or on change actions are sent to the server are not overwritten by the response. If @false@, the form values are cleared when the action is triggered. When @persist_values@ is set to @false@, it is strongly recommended that the card use <workspace/add-ons/reference/rpc/google.apps.card.v1#loadindicator LoadIndicator.SPINNER> for all actions, as this locks the UI to ensure no changes are made by the user while the action is being processed.
    persistValues :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageAction' with the minimum fields required to make a request.
newAppsDynamiteStorageAction ::
  AppsDynamiteStorageAction
newAppsDynamiteStorageAction =
  AppsDynamiteStorageAction
    { function = Core.Nothing,
      interaction = Core.Nothing,
      loadIndicator = Core.Nothing,
      parameters = Core.Nothing,
      persistValues = Core.Nothing
    }

instance Core.FromJSON AppsDynamiteStorageAction where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageAction"
      ( \o ->
          AppsDynamiteStorageAction
            Core.<$> (o Core..:? "function")
            Core.<*> (o Core..:? "interaction")
            Core.<*> (o Core..:? "loadIndicator")
            Core.<*> (o Core..:? "parameters")
            Core.<*> (o Core..:? "persistValues")
      )

instance Core.ToJSON AppsDynamiteStorageAction where
  toJSON AppsDynamiteStorageAction {..} =
    Core.object
      ( Core.catMaybes
          [ ("function" Core..=) Core.<$> function,
            ("interaction" Core..=) Core.<$> interaction,
            ("loadIndicator" Core..=) Core.<$> loadIndicator,
            ("parameters" Core..=) Core.<$> parameters,
            ("persistValues" Core..=) Core.<$> persistValues
          ]
      )

-- | List of string parameters to supply when the action method is invoked. For example, consider three snooze buttons: snooze now, snooze 1 day, snooze next week. You might use action method = snooze(), passing the snooze type and snooze time in the list of string parameters.
--
-- /See:/ 'newAppsDynamiteStorageActionActionParameter' smart constructor.
data AppsDynamiteStorageActionActionParameter = AppsDynamiteStorageActionActionParameter
  { -- | The name of the parameter for the action script.
    key :: (Core.Maybe Core.Text),
    -- | The value of the parameter.
    value :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageActionActionParameter' with the minimum fields required to make a request.
newAppsDynamiteStorageActionActionParameter ::
  AppsDynamiteStorageActionActionParameter
newAppsDynamiteStorageActionActionParameter =
  AppsDynamiteStorageActionActionParameter
    { key = Core.Nothing,
      value = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteStorageActionActionParameter
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageActionActionParameter"
      ( \o ->
          AppsDynamiteStorageActionActionParameter
            Core.<$> (o Core..:? "key") Core.<*> (o Core..:? "value")
      )

instance
  Core.ToJSON
    AppsDynamiteStorageActionActionParameter
  where
  toJSON AppsDynamiteStorageActionActionParameter {..} =
    Core.object
      ( Core.catMaybes
          [ ("key" Core..=) Core.<$> key,
            ("value" Core..=) Core.<$> value
          ]
      )

-- | Represents the complete border style applied to widgets.
--
-- /See:/ 'newAppsDynamiteStorageBorderStyle' smart constructor.
data AppsDynamiteStorageBorderStyle = AppsDynamiteStorageBorderStyle
  { -- | The corner radius for the border.
    cornerRadius :: (Core.Maybe Core.Int32),
    -- | The colors to use when the type is @BORDER_TYPE_STROKE@.
    strokeColor :: (Core.Maybe Color),
    -- | The border type.
    type' :: (Core.Maybe AppsDynamiteStorageBorderStyle_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageBorderStyle' with the minimum fields required to make a request.
newAppsDynamiteStorageBorderStyle ::
  AppsDynamiteStorageBorderStyle
newAppsDynamiteStorageBorderStyle =
  AppsDynamiteStorageBorderStyle
    { cornerRadius = Core.Nothing,
      strokeColor = Core.Nothing,
      type' = Core.Nothing
    }

instance Core.FromJSON AppsDynamiteStorageBorderStyle where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageBorderStyle"
      ( \o ->
          AppsDynamiteStorageBorderStyle
            Core.<$> (o Core..:? "cornerRadius")
            Core.<*> (o Core..:? "strokeColor")
            Core.<*> (o Core..:? "type")
      )

instance Core.ToJSON AppsDynamiteStorageBorderStyle where
  toJSON AppsDynamiteStorageBorderStyle {..} =
    Core.object
      ( Core.catMaybes
          [ ("cornerRadius" Core..=) Core.<$> cornerRadius,
            ("strokeColor" Core..=) Core.<$> strokeColor,
            ("type" Core..=) Core.<$> type'
          ]
      )

-- | A button. Can be a text button or an image button.
--
-- /See:/ 'newAppsDynamiteStorageButton' smart constructor.
data AppsDynamiteStorageButton = AppsDynamiteStorageButton
  { -- | The alternative text used for accessibility. Has no effect when an icon is set; use @icon.alt_text@ instead.
    altText :: (Core.Maybe Core.Text),
    -- | If set, the button is filled with a solid background.
    color :: (Core.Maybe Color),
    -- | If true, the button is displayed in a disabled state and doesn\'t respond to user actions.
    disabled :: (Core.Maybe Core.Bool),
    -- | The icon image.
    icon :: (Core.Maybe AppsDynamiteStorageIcon),
    -- | The action to perform when the button is clicked.
    onClick :: (Core.Maybe AppsDynamiteStorageOnClick),
    -- | The text of the button.
    text :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageButton' with the minimum fields required to make a request.
newAppsDynamiteStorageButton ::
  AppsDynamiteStorageButton
newAppsDynamiteStorageButton =
  AppsDynamiteStorageButton
    { altText = Core.Nothing,
      color = Core.Nothing,
      disabled = Core.Nothing,
      icon = Core.Nothing,
      onClick = Core.Nothing,
      text = Core.Nothing
    }

instance Core.FromJSON AppsDynamiteStorageButton where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageButton"
      ( \o ->
          AppsDynamiteStorageButton
            Core.<$> (o Core..:? "altText")
            Core.<*> (o Core..:? "color")
            Core.<*> (o Core..:? "disabled")
            Core.<*> (o Core..:? "icon")
            Core.<*> (o Core..:? "onClick")
            Core.<*> (o Core..:? "text")
      )

instance Core.ToJSON AppsDynamiteStorageButton where
  toJSON AppsDynamiteStorageButton {..} =
    Core.object
      ( Core.catMaybes
          [ ("altText" Core..=) Core.<$> altText,
            ("color" Core..=) Core.<$> color,
            ("disabled" Core..=) Core.<$> disabled,
            ("icon" Core..=) Core.<$> icon,
            ("onClick" Core..=) Core.<$> onClick,
            ("text" Core..=) Core.<$> text
          ]
      )

-- | A list of buttons layed out horizontally.
--
-- /See:/ 'newAppsDynamiteStorageButtonList' smart constructor.
newtype AppsDynamiteStorageButtonList = AppsDynamiteStorageButtonList
  { -- |
    buttons :: (Core.Maybe [AppsDynamiteStorageButton])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageButtonList' with the minimum fields required to make a request.
newAppsDynamiteStorageButtonList ::
  AppsDynamiteStorageButtonList
newAppsDynamiteStorageButtonList =
  AppsDynamiteStorageButtonList {buttons = Core.Nothing}

instance Core.FromJSON AppsDynamiteStorageButtonList where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageButtonList"
      ( \o ->
          AppsDynamiteStorageButtonList
            Core.<$> (o Core..:? "buttons")
      )

instance Core.ToJSON AppsDynamiteStorageButtonList where
  toJSON AppsDynamiteStorageButtonList {..} =
    Core.object
      ( Core.catMaybes
          [("buttons" Core..=) Core.<$> buttons]
      )

-- | A card is a UI element that can contain UI widgets such as text and images. For more information, see Cards . For example, the following JSON creates a card that has a header with the name, position, icons, and link for a contact, followed by a section with contact information like email and phone number.
-- @{ \"header\": { \"title\": \"Heba Salam\", \"subtitle\": \"Software Engineer\", \"imageStyle\": \"ImageStyle.AVATAR\", \"imageUrl\": \"https:\/\/example.com\/heba_salam.png\", \"imageAltText\": \"Avatar for Heba Salam\" }, \"sections\" : [ { \"header\": \"Contact Info\", \"widgets\": [ { \"decorated_text\": { \"icon\": { \"knownIcon\": \"EMAIL\" }, \"content\": \"heba.salam\@example.com\" } }, { \"decoratedText\": { \"icon\": { \"knownIcon\": \"PERSON\" }, \"content\": \"Online\" } }, { \"decoratedText\": { \"icon\": { \"knownIcon\": \"PHONE\" }, \"content\": \"+1 (555) 555-1234\" } }, { \"buttons\": [ { \"textButton\": { \"text\": \"Share\", }, \"onClick\": { \"openLink\": { \"url\": \"https:\/\/example.com\/share\" } } }, { \"textButton\": { \"text\": \"Edit\", }, \"onClick\": { \"action\": { \"function\": \"goToView\", \"parameters\": [ { \"key\": \"viewType\", \"value\": \"EDIT\" } ], \"loadIndicator\": \"LoadIndicator.SPINNER\" } } } ] } ], \"collapsible\": true, \"uncollapsibleWidgetsCount\": 3 } ], \"cardActions\": [ { \"actionLabel\": \"Send Feedback\", \"onClick\": { \"openLink\": { \"url\": \"https:\/\/example.com\/feedback\" } } } ], \"name\": \"contact-card-K3wB6arF2H9L\" }@
--
-- /See:/ 'newAppsDynamiteStorageCard' smart constructor.
data AppsDynamiteStorageCard = AppsDynamiteStorageCard
  { -- | The actions of this card. They are added to a card\'s generated toolbar menu. For example, the following JSON constructs a card action menu with Settings and Send Feedback options: @\"card_actions\": [ { \"actionLabel\": \"Setting\", \"onClick\": { \"action\": { \"functionName\": \"goToView\", \"parameters\": [ { \"key\": \"viewType\", \"value\": \"SETTING\" } ], \"loadIndicator\": \"LoadIndicator.SPINNER\" } } }, { \"actionLabel\": \"Send Feedback\", \"onClick\": { \"openLink\": { \"url\": \"https:\/\/example.com\/feedback\" } } } ]@
    cardActions :: (Core.Maybe [AppsDynamiteStorageCardCardAction]),
    -- | The header of the card. A header usually contains a title and an image.
    header :: (Core.Maybe AppsDynamiteStorageCardCardHeader),
    -- | Name of the card, which is used as a identifier for the card in card navigation.
    name :: (Core.Maybe Core.Text),
    -- | Sections are separated by a line divider.
    sections :: (Core.Maybe [AppsDynamiteStorageCardSection])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageCard' with the minimum fields required to make a request.
newAppsDynamiteStorageCard ::
  AppsDynamiteStorageCard
newAppsDynamiteStorageCard =
  AppsDynamiteStorageCard
    { cardActions = Core.Nothing,
      header = Core.Nothing,
      name = Core.Nothing,
      sections = Core.Nothing
    }

instance Core.FromJSON AppsDynamiteStorageCard where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageCard"
      ( \o ->
          AppsDynamiteStorageCard
            Core.<$> (o Core..:? "cardActions")
            Core.<*> (o Core..:? "header")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "sections")
      )

instance Core.ToJSON AppsDynamiteStorageCard where
  toJSON AppsDynamiteStorageCard {..} =
    Core.object
      ( Core.catMaybes
          [ ("cardActions" Core..=) Core.<$> cardActions,
            ("header" Core..=) Core.<$> header,
            ("name" Core..=) Core.<$> name,
            ("sections" Core..=) Core.<$> sections
          ]
      )

-- | A card action is the action associated with the card. For example, an invoice card might include actions such as delete invoice, email invoice, or open the invoice in a browser.
--
-- /See:/ 'newAppsDynamiteStorageCardCardAction' smart constructor.
data AppsDynamiteStorageCardCardAction = AppsDynamiteStorageCardCardAction
  { -- | The label that displays as the action menu item.
    actionLabel :: (Core.Maybe Core.Text),
    -- | The onclick action for this action item.
    onClick :: (Core.Maybe AppsDynamiteStorageOnClick)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageCardCardAction' with the minimum fields required to make a request.
newAppsDynamiteStorageCardCardAction ::
  AppsDynamiteStorageCardCardAction
newAppsDynamiteStorageCardCardAction =
  AppsDynamiteStorageCardCardAction
    { actionLabel = Core.Nothing,
      onClick = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteStorageCardCardAction
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageCardCardAction"
      ( \o ->
          AppsDynamiteStorageCardCardAction
            Core.<$> (o Core..:? "actionLabel")
            Core.<*> (o Core..:? "onClick")
      )

instance
  Core.ToJSON
    AppsDynamiteStorageCardCardAction
  where
  toJSON AppsDynamiteStorageCardCardAction {..} =
    Core.object
      ( Core.catMaybes
          [ ("actionLabel" Core..=) Core.<$> actionLabel,
            ("onClick" Core..=) Core.<$> onClick
          ]
      )

--
-- /See:/ 'newAppsDynamiteStorageCardCardHeader' smart constructor.
data AppsDynamiteStorageCardCardHeader = AppsDynamiteStorageCardCardHeader
  { -- | The alternative text of this image which is used for accessibility.
    imageAltText :: (Core.Maybe Core.Text),
    -- | The image\'s type.
    imageType :: (Core.Maybe AppsDynamiteStorageCardCardHeader_ImageType),
    -- | The URL of the image in the card header.
    imageUrl :: (Core.Maybe Core.Text),
    -- | The subtitle of the card header.
    subtitle :: (Core.Maybe Core.Text),
    -- | The title of the card header. The title must be specified. The header has a fixed height: if both a title and subtitle are specified, each takes up one line. If only the title is specified, it takes up both lines.
    title :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageCardCardHeader' with the minimum fields required to make a request.
newAppsDynamiteStorageCardCardHeader ::
  AppsDynamiteStorageCardCardHeader
newAppsDynamiteStorageCardCardHeader =
  AppsDynamiteStorageCardCardHeader
    { imageAltText = Core.Nothing,
      imageType = Core.Nothing,
      imageUrl = Core.Nothing,
      subtitle = Core.Nothing,
      title = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteStorageCardCardHeader
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageCardCardHeader"
      ( \o ->
          AppsDynamiteStorageCardCardHeader
            Core.<$> (o Core..:? "imageAltText")
            Core.<*> (o Core..:? "imageType")
            Core.<*> (o Core..:? "imageUrl")
            Core.<*> (o Core..:? "subtitle")
            Core.<*> (o Core..:? "title")
      )

instance
  Core.ToJSON
    AppsDynamiteStorageCardCardHeader
  where
  toJSON AppsDynamiteStorageCardCardHeader {..} =
    Core.object
      ( Core.catMaybes
          [ ("imageAltText" Core..=) Core.<$> imageAltText,
            ("imageType" Core..=) Core.<$> imageType,
            ("imageUrl" Core..=) Core.<$> imageUrl,
            ("subtitle" Core..=) Core.<$> subtitle,
            ("title" Core..=) Core.<$> title
          ]
      )

-- | A section contains a collection of widgets that are rendered vertically in the order that they are specified. Across all platforms, cards have a narrow fixed width, so there is currently no need for layout properties, for example, float.
--
-- /See:/ 'newAppsDynamiteStorageCardSection' smart constructor.
data AppsDynamiteStorageCardSection = AppsDynamiteStorageCardSection
  { -- | Indicates whether this section is collapsible. If a section is collapsible, the description must be given.
    collapsible :: (Core.Maybe Core.Bool),
    -- | The header of the section. Formatted text is supported.
    header :: (Core.Maybe Core.Text),
    -- | The number of uncollapsible widgets. For example, when a section contains five widgets and the @numUncollapsibleWidget@ is set to @2@, the first two widgets are always shown and the last three are collapsed as default. The @numUncollapsibleWidget@ is taken into account only when collapsible is set to @true@.
    uncollapsibleWidgetsCount :: (Core.Maybe Core.Int32),
    -- | A section must contain at least 1 widget.
    widgets :: (Core.Maybe [AppsDynamiteStorageWidget])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageCardSection' with the minimum fields required to make a request.
newAppsDynamiteStorageCardSection ::
  AppsDynamiteStorageCardSection
newAppsDynamiteStorageCardSection =
  AppsDynamiteStorageCardSection
    { collapsible = Core.Nothing,
      header = Core.Nothing,
      uncollapsibleWidgetsCount = Core.Nothing,
      widgets = Core.Nothing
    }

instance Core.FromJSON AppsDynamiteStorageCardSection where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageCardSection"
      ( \o ->
          AppsDynamiteStorageCardSection
            Core.<$> (o Core..:? "collapsible")
            Core.<*> (o Core..:? "header")
            Core.<*> (o Core..:? "uncollapsibleWidgetsCount")
            Core.<*> (o Core..:? "widgets")
      )

instance Core.ToJSON AppsDynamiteStorageCardSection where
  toJSON AppsDynamiteStorageCardSection {..} =
    Core.object
      ( Core.catMaybes
          [ ("collapsible" Core..=) Core.<$> collapsible,
            ("header" Core..=) Core.<$> header,
            ("uncollapsibleWidgetsCount" Core..=)
              Core.<$> uncollapsibleWidgetsCount,
            ("widgets" Core..=) Core.<$> widgets
          ]
      )

-- | Represents a Columns widget that displays a single row of columns.
--
-- /See:/ 'newAppsDynamiteStorageColumns' smart constructor.
data AppsDynamiteStorageColumns = AppsDynamiteStorageColumns
  { -- | Each card supports up to 2 columns.
    columnItems :: (Core.Maybe [AppsDynamiteStorageColumnsColumn]),
    -- | Controls how the column resizes based on screen width.
    wrapStyle :: (Core.Maybe AppsDynamiteStorageColumns_WrapStyle)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageColumns' with the minimum fields required to make a request.
newAppsDynamiteStorageColumns ::
  AppsDynamiteStorageColumns
newAppsDynamiteStorageColumns =
  AppsDynamiteStorageColumns
    { columnItems = Core.Nothing,
      wrapStyle = Core.Nothing
    }

instance Core.FromJSON AppsDynamiteStorageColumns where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageColumns"
      ( \o ->
          AppsDynamiteStorageColumns
            Core.<$> (o Core..:? "columnItems")
            Core.<*> (o Core..:? "wrapStyle")
      )

instance Core.ToJSON AppsDynamiteStorageColumns where
  toJSON AppsDynamiteStorageColumns {..} =
    Core.object
      ( Core.catMaybes
          [ ("columnItems" Core..=) Core.<$> columnItems,
            ("wrapStyle" Core..=) Core.<$> wrapStyle
          ]
      )

-- | Represents a Column that consists of widgets stacked vertically.
--
-- /See:/ 'newAppsDynamiteStorageColumnsColumn' smart constructor.
data AppsDynamiteStorageColumnsColumn = AppsDynamiteStorageColumnsColumn
  { -- | The horizontal alignment of the column.
    horizontalAlignment :: (Core.Maybe AppsDynamiteStorageColumnsColumn_HorizontalAlignment),
    -- | Specifies how the column content is sized horizontally.
    horizontalSizeStyle :: (Core.Maybe AppsDynamiteStorageColumnsColumn_HorizontalSizeStyle),
    -- | The vertical alignment of the column.
    verticalAlignment :: (Core.Maybe AppsDynamiteStorageColumnsColumn_VerticalAlignment),
    -- | LINT.ThenChange(\/\/depot\/google3\/google\/apps\/card\/v1\/card.proto) Array of widgets included in the column.
    widgets :: (Core.Maybe [AppsDynamiteStorageColumnsColumnWidgets])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageColumnsColumn' with the minimum fields required to make a request.
newAppsDynamiteStorageColumnsColumn ::
  AppsDynamiteStorageColumnsColumn
newAppsDynamiteStorageColumnsColumn =
  AppsDynamiteStorageColumnsColumn
    { horizontalAlignment = Core.Nothing,
      horizontalSizeStyle = Core.Nothing,
      verticalAlignment = Core.Nothing,
      widgets = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteStorageColumnsColumn
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageColumnsColumn"
      ( \o ->
          AppsDynamiteStorageColumnsColumn
            Core.<$> (o Core..:? "horizontalAlignment")
            Core.<*> (o Core..:? "horizontalSizeStyle")
            Core.<*> (o Core..:? "verticalAlignment")
            Core.<*> (o Core..:? "widgets")
      )

instance Core.ToJSON AppsDynamiteStorageColumnsColumn where
  toJSON AppsDynamiteStorageColumnsColumn {..} =
    Core.object
      ( Core.catMaybes
          [ ("horizontalAlignment" Core..=)
              Core.<$> horizontalAlignment,
            ("horizontalSizeStyle" Core..=)
              Core.<$> horizontalSizeStyle,
            ("verticalAlignment" Core..=)
              Core.<$> verticalAlignment,
            ("widgets" Core..=) Core.<$> widgets
          ]
      )

-- | LINT.IfChange The @column@ widget can contain these widgets.
--
-- /See:/ 'newAppsDynamiteStorageColumnsColumnWidgets' smart constructor.
data AppsDynamiteStorageColumnsColumnWidgets = AppsDynamiteStorageColumnsColumnWidgets
  { -- | ButtonList widget.
    buttonList :: (Core.Maybe AppsDynamiteStorageButtonList),
    -- | DateTimePicker widget.
    dateTimePicker :: (Core.Maybe AppsDynamiteStorageDateTimePicker),
    -- | DecoratedText widget.
    decoratedText :: (Core.Maybe AppsDynamiteStorageDecoratedText),
    -- | Image widget.
    image :: (Core.Maybe AppsDynamiteStorageImage),
    -- | SelectionInput widget.
    selectionInput :: (Core.Maybe AppsDynamiteStorageSelectionInput),
    -- | TextInput widget.
    textInput :: (Core.Maybe AppsDynamiteStorageTextInput),
    -- | Text paragraph widget.
    textParagraph :: (Core.Maybe AppsDynamiteStorageTextParagraph)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageColumnsColumnWidgets' with the minimum fields required to make a request.
newAppsDynamiteStorageColumnsColumnWidgets ::
  AppsDynamiteStorageColumnsColumnWidgets
newAppsDynamiteStorageColumnsColumnWidgets =
  AppsDynamiteStorageColumnsColumnWidgets
    { buttonList = Core.Nothing,
      dateTimePicker = Core.Nothing,
      decoratedText = Core.Nothing,
      image = Core.Nothing,
      selectionInput = Core.Nothing,
      textInput = Core.Nothing,
      textParagraph = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteStorageColumnsColumnWidgets
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageColumnsColumnWidgets"
      ( \o ->
          AppsDynamiteStorageColumnsColumnWidgets
            Core.<$> (o Core..:? "buttonList")
            Core.<*> (o Core..:? "dateTimePicker")
            Core.<*> (o Core..:? "decoratedText")
            Core.<*> (o Core..:? "image")
            Core.<*> (o Core..:? "selectionInput")
            Core.<*> (o Core..:? "textInput")
            Core.<*> (o Core..:? "textParagraph")
      )

instance
  Core.ToJSON
    AppsDynamiteStorageColumnsColumnWidgets
  where
  toJSON AppsDynamiteStorageColumnsColumnWidgets {..} =
    Core.object
      ( Core.catMaybes
          [ ("buttonList" Core..=) Core.<$> buttonList,
            ("dateTimePicker" Core..=) Core.<$> dateTimePicker,
            ("decoratedText" Core..=) Core.<$> decoratedText,
            ("image" Core..=) Core.<$> image,
            ("selectionInput" Core..=) Core.<$> selectionInput,
            ("textInput" Core..=) Core.<$> textInput,
            ("textParagraph" Core..=) Core.<$> textParagraph
          ]
      )

-- | The widget that lets users to specify a date and time.
--
-- /See:/ 'newAppsDynamiteStorageDateTimePicker' smart constructor.
data AppsDynamiteStorageDateTimePicker = AppsDynamiteStorageDateTimePicker
  { -- | The label for the field that displays to the user.
    label :: (Core.Maybe Core.Text),
    -- | The name of the text input that\'s used in formInput, and uniquely identifies this input.
    name :: (Core.Maybe Core.Text),
    -- | Triggered when the user clicks Save or Clear from the date\/time picker dialog. This is only triggered if the value changed as a result of the Save\/Clear operation.
    onChangeAction :: (Core.Maybe AppsDynamiteStorageAction),
    -- | The number representing the time zone offset from UTC, in minutes. If set, the @value_ms_epoch@ is displayed in the specified time zone. If not set, it uses the user\'s time zone setting on the client side.
    timezoneOffsetDate :: (Core.Maybe Core.Int32),
    -- | The type of the date\/time picker.
    type' :: (Core.Maybe AppsDynamiteStorageDateTimePicker_Type),
    -- | The value to display as the default value before user input or previous user input. It is represented in milliseconds (Epoch time). For @DATE_AND_TIME@ type, the full epoch value is used. For @DATE_ONLY@ type, only date of the epoch time is used. For @TIME_ONLY@ type, only time of the epoch time is used. For example, you can set epoch time to @3 * 60 * 60 * 1000@ to represent 3am.
    valueMsEpoch :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageDateTimePicker' with the minimum fields required to make a request.
newAppsDynamiteStorageDateTimePicker ::
  AppsDynamiteStorageDateTimePicker
newAppsDynamiteStorageDateTimePicker =
  AppsDynamiteStorageDateTimePicker
    { label = Core.Nothing,
      name = Core.Nothing,
      onChangeAction = Core.Nothing,
      timezoneOffsetDate = Core.Nothing,
      type' = Core.Nothing,
      valueMsEpoch = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteStorageDateTimePicker
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageDateTimePicker"
      ( \o ->
          AppsDynamiteStorageDateTimePicker
            Core.<$> (o Core..:? "label")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "onChangeAction")
            Core.<*> (o Core..:? "timezoneOffsetDate")
            Core.<*> (o Core..:? "type")
            Core.<*> ( o Core..:? "valueMsEpoch"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance
  Core.ToJSON
    AppsDynamiteStorageDateTimePicker
  where
  toJSON AppsDynamiteStorageDateTimePicker {..} =
    Core.object
      ( Core.catMaybes
          [ ("label" Core..=) Core.<$> label,
            ("name" Core..=) Core.<$> name,
            ("onChangeAction" Core..=) Core.<$> onChangeAction,
            ("timezoneOffsetDate" Core..=)
              Core.<$> timezoneOffsetDate,
            ("type" Core..=) Core.<$> type',
            ("valueMsEpoch" Core..=) Core.. Core.AsText
              Core.<$> valueMsEpoch
          ]
      )

-- | A widget that displays text with optional decorations such as a label above or below the text, an icon in front of the text, a selection widget or a button after the text.
--
-- /See:/ 'newAppsDynamiteStorageDecoratedText' smart constructor.
data AppsDynamiteStorageDecoratedText = AppsDynamiteStorageDecoratedText
  { -- | The formatted text label that shows below the main text.
    bottomLabel :: (Core.Maybe Core.Text),
    -- | A button that can be clicked to trigger an action.
    button :: (Core.Maybe AppsDynamiteStorageButton),
    -- | An icon displayed after the text.
    endIcon :: (Core.Maybe AppsDynamiteStorageIcon),
    -- | Deprecated in favor of start_icon.
    icon :: (Core.Maybe AppsDynamiteStorageIcon),
    -- | Only the top and bottom label and content region are clickable.
    onClick :: (Core.Maybe AppsDynamiteStorageOnClick),
    -- | The icon displayed in front of the text.
    startIcon :: (Core.Maybe AppsDynamiteStorageIcon),
    -- | A switch widget can be clicked to change its state or trigger an action.
    switchControl :: (Core.Maybe AppsDynamiteStorageDecoratedTextSwitchControl),
    -- | Required. The main widget formatted text. See Text formatting for details.
    text :: (Core.Maybe Core.Text),
    -- | The formatted text label that shows above the main text.
    topLabel :: (Core.Maybe Core.Text),
    -- | The wrap text setting. If @true@, the text is wrapped and displayed in multiline. Otherwise, the text is truncated.
    wrapText :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageDecoratedText' with the minimum fields required to make a request.
newAppsDynamiteStorageDecoratedText ::
  AppsDynamiteStorageDecoratedText
newAppsDynamiteStorageDecoratedText =
  AppsDynamiteStorageDecoratedText
    { bottomLabel = Core.Nothing,
      button = Core.Nothing,
      endIcon = Core.Nothing,
      icon = Core.Nothing,
      onClick = Core.Nothing,
      startIcon = Core.Nothing,
      switchControl = Core.Nothing,
      text = Core.Nothing,
      topLabel = Core.Nothing,
      wrapText = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteStorageDecoratedText
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageDecoratedText"
      ( \o ->
          AppsDynamiteStorageDecoratedText
            Core.<$> (o Core..:? "bottomLabel")
            Core.<*> (o Core..:? "button")
            Core.<*> (o Core..:? "endIcon")
            Core.<*> (o Core..:? "icon")
            Core.<*> (o Core..:? "onClick")
            Core.<*> (o Core..:? "startIcon")
            Core.<*> (o Core..:? "switchControl")
            Core.<*> (o Core..:? "text")
            Core.<*> (o Core..:? "topLabel")
            Core.<*> (o Core..:? "wrapText")
      )

instance Core.ToJSON AppsDynamiteStorageDecoratedText where
  toJSON AppsDynamiteStorageDecoratedText {..} =
    Core.object
      ( Core.catMaybes
          [ ("bottomLabel" Core..=) Core.<$> bottomLabel,
            ("button" Core..=) Core.<$> button,
            ("endIcon" Core..=) Core.<$> endIcon,
            ("icon" Core..=) Core.<$> icon,
            ("onClick" Core..=) Core.<$> onClick,
            ("startIcon" Core..=) Core.<$> startIcon,
            ("switchControl" Core..=) Core.<$> switchControl,
            ("text" Core..=) Core.<$> text,
            ("topLabel" Core..=) Core.<$> topLabel,
            ("wrapText" Core..=) Core.<$> wrapText
          ]
      )

--
-- /See:/ 'newAppsDynamiteStorageDecoratedTextSwitchControl' smart constructor.
data AppsDynamiteStorageDecoratedTextSwitchControl = AppsDynamiteStorageDecoratedTextSwitchControl
  { -- | The control type, either switch or checkbox.
    controlType ::
      ( Core.Maybe
          AppsDynamiteStorageDecoratedTextSwitchControl_ControlType
      ),
    -- | The name of the switch widget that\'s used in formInput.
    name :: (Core.Maybe Core.Text),
    -- | The action when the switch state is changed.
    onChangeAction :: (Core.Maybe AppsDynamiteStorageAction),
    -- | If the switch is selected.
    selected :: (Core.Maybe Core.Bool),
    -- | The value is what is passed back in the callback.
    value :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageDecoratedTextSwitchControl' with the minimum fields required to make a request.
newAppsDynamiteStorageDecoratedTextSwitchControl ::
  AppsDynamiteStorageDecoratedTextSwitchControl
newAppsDynamiteStorageDecoratedTextSwitchControl =
  AppsDynamiteStorageDecoratedTextSwitchControl
    { controlType = Core.Nothing,
      name = Core.Nothing,
      onChangeAction = Core.Nothing,
      selected = Core.Nothing,
      value = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteStorageDecoratedTextSwitchControl
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageDecoratedTextSwitchControl"
      ( \o ->
          AppsDynamiteStorageDecoratedTextSwitchControl
            Core.<$> (o Core..:? "controlType")
              Core.<*> (o Core..:? "name")
              Core.<*> (o Core..:? "onChangeAction")
              Core.<*> (o Core..:? "selected")
              Core.<*> (o Core..:? "value")
      )

instance
  Core.ToJSON
    AppsDynamiteStorageDecoratedTextSwitchControl
  where
  toJSON
    AppsDynamiteStorageDecoratedTextSwitchControl {..} =
      Core.object
        ( Core.catMaybes
            [ ("controlType" Core..=) Core.<$> controlType,
              ("name" Core..=) Core.<$> name,
              ("onChangeAction" Core..=) Core.<$> onChangeAction,
              ("selected" Core..=) Core.<$> selected,
              ("value" Core..=) Core.<$> value
            ]
        )

-- | A divider that appears in between widgets.
--
-- /See:/ 'newAppsDynamiteStorageDivider' smart constructor.
data AppsDynamiteStorageDivider = AppsDynamiteStorageDivider
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageDivider' with the minimum fields required to make a request.
newAppsDynamiteStorageDivider ::
  AppsDynamiteStorageDivider
newAppsDynamiteStorageDivider = AppsDynamiteStorageDivider

instance Core.FromJSON AppsDynamiteStorageDivider where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageDivider"
      (\o -> Core.pure AppsDynamiteStorageDivider)

instance Core.ToJSON AppsDynamiteStorageDivider where
  toJSON = Core.const Core.emptyObject

-- | Represents a Grid widget that displays items in a configurable grid layout.
--
-- /See:/ 'newAppsDynamiteStorageGrid' smart constructor.
data AppsDynamiteStorageGrid = AppsDynamiteStorageGrid
  { -- | The border style to apply to each grid item.
    borderStyle :: (Core.Maybe AppsDynamiteStorageBorderStyle),
    -- | The number of columns to display in the grid. A default value is used if this field isn\'t specified, and that default value is different depending on where the grid is shown (dialog versus companion).
    columnCount :: (Core.Maybe Core.Int32),
    -- | The items to display in the grid.
    items :: (Core.Maybe [AppsDynamiteStorageGridGridItem]),
    -- | This callback is reused by each individual grid item, but with the item\'s identifier and index in the items list added to the callback\'s parameters.
    onClick :: (Core.Maybe AppsDynamiteStorageOnClick),
    -- | The text that displays in the grid header.
    title :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageGrid' with the minimum fields required to make a request.
newAppsDynamiteStorageGrid ::
  AppsDynamiteStorageGrid
newAppsDynamiteStorageGrid =
  AppsDynamiteStorageGrid
    { borderStyle = Core.Nothing,
      columnCount = Core.Nothing,
      items = Core.Nothing,
      onClick = Core.Nothing,
      title = Core.Nothing
    }

instance Core.FromJSON AppsDynamiteStorageGrid where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageGrid"
      ( \o ->
          AppsDynamiteStorageGrid
            Core.<$> (o Core..:? "borderStyle")
            Core.<*> (o Core..:? "columnCount")
            Core.<*> (o Core..:? "items")
            Core.<*> (o Core..:? "onClick")
            Core.<*> (o Core..:? "title")
      )

instance Core.ToJSON AppsDynamiteStorageGrid where
  toJSON AppsDynamiteStorageGrid {..} =
    Core.object
      ( Core.catMaybes
          [ ("borderStyle" Core..=) Core.<$> borderStyle,
            ("columnCount" Core..=) Core.<$> columnCount,
            ("items" Core..=) Core.<$> items,
            ("onClick" Core..=) Core.<$> onClick,
            ("title" Core..=) Core.<$> title
          ]
      )

-- | Represents a single item in the grid layout.
--
-- /See:/ 'newAppsDynamiteStorageGridGridItem' smart constructor.
data AppsDynamiteStorageGridGridItem = AppsDynamiteStorageGridGridItem
  { -- | A user-specified identifier for this grid item. This identifier is returned in the parent Grid\'s onClick callback parameters.
    id :: (Core.Maybe Core.Text),
    -- | The image that displays in the grid item.
    image :: (Core.Maybe AppsDynamiteStorageImageComponent),
    -- | The layout to use for the grid item.
    layout :: (Core.Maybe AppsDynamiteStorageGridGridItem_Layout),
    -- | The grid item\'s subtitle.
    subtitle :: (Core.Maybe Core.Text),
    -- | The horizontal alignment of the grid item\'s text.
    textAlignment :: (Core.Maybe AppsDynamiteStorageGridGridItem_TextAlignment),
    -- | The grid item\'s title.
    title :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageGridGridItem' with the minimum fields required to make a request.
newAppsDynamiteStorageGridGridItem ::
  AppsDynamiteStorageGridGridItem
newAppsDynamiteStorageGridGridItem =
  AppsDynamiteStorageGridGridItem
    { id = Core.Nothing,
      image = Core.Nothing,
      layout = Core.Nothing,
      subtitle = Core.Nothing,
      textAlignment = Core.Nothing,
      title = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteStorageGridGridItem
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageGridGridItem"
      ( \o ->
          AppsDynamiteStorageGridGridItem
            Core.<$> (o Core..:? "id")
            Core.<*> (o Core..:? "image")
            Core.<*> (o Core..:? "layout")
            Core.<*> (o Core..:? "subtitle")
            Core.<*> (o Core..:? "textAlignment")
            Core.<*> (o Core..:? "title")
      )

instance Core.ToJSON AppsDynamiteStorageGridGridItem where
  toJSON AppsDynamiteStorageGridGridItem {..} =
    Core.object
      ( Core.catMaybes
          [ ("id" Core..=) Core.<$> id,
            ("image" Core..=) Core.<$> image,
            ("layout" Core..=) Core.<$> layout,
            ("subtitle" Core..=) Core.<$> subtitle,
            ("textAlignment" Core..=) Core.<$> textAlignment,
            ("title" Core..=) Core.<$> title
          ]
      )

--
-- /See:/ 'newAppsDynamiteStorageIcon' smart constructor.
data AppsDynamiteStorageIcon = AppsDynamiteStorageIcon
  { -- | The description of the icon, used for accessibility. The default value is provided if you don\'t specify one.
    altText :: (Core.Maybe Core.Text),
    -- | The icon specified by a URL.
    iconUrl :: (Core.Maybe Core.Text),
    -- | The crop style applied to the image. In some cases, applying a @CIRCLE@ crop causes the image to be drawn larger than a standard icon.
    imageType :: (Core.Maybe AppsDynamiteStorageIcon_ImageType),
    -- | The icon specified by the string name of a list of known icons
    knownIcon :: (Core.Maybe Core.Text),
    -- | Display one of the <https://fonts.google.com/icons Google Material Icons>. For example, to display a <https://fonts.google.com/icons?selected=Material%20Symbols%20Outlined%3Acheck_box%3AFILL%400%3Bwght%40400%3BGRAD%400%3Bopsz%4048 check box icon>, use \"material/icon\": { \"name\": \"check/box\" }
    materialIcon :: (Core.Maybe AppsDynamiteStorageMaterialIcon)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageIcon' with the minimum fields required to make a request.
newAppsDynamiteStorageIcon ::
  AppsDynamiteStorageIcon
newAppsDynamiteStorageIcon =
  AppsDynamiteStorageIcon
    { altText = Core.Nothing,
      iconUrl = Core.Nothing,
      imageType = Core.Nothing,
      knownIcon = Core.Nothing,
      materialIcon = Core.Nothing
    }

instance Core.FromJSON AppsDynamiteStorageIcon where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageIcon"
      ( \o ->
          AppsDynamiteStorageIcon
            Core.<$> (o Core..:? "altText")
            Core.<*> (o Core..:? "iconUrl")
            Core.<*> (o Core..:? "imageType")
            Core.<*> (o Core..:? "knownIcon")
            Core.<*> (o Core..:? "materialIcon")
      )

instance Core.ToJSON AppsDynamiteStorageIcon where
  toJSON AppsDynamiteStorageIcon {..} =
    Core.object
      ( Core.catMaybes
          [ ("altText" Core..=) Core.<$> altText,
            ("iconUrl" Core..=) Core.<$> iconUrl,
            ("imageType" Core..=) Core.<$> imageType,
            ("knownIcon" Core..=) Core.<$> knownIcon,
            ("materialIcon" Core..=) Core.<$> materialIcon
          ]
      )

-- | An image that is specified by a URL and can have an onClick action.
--
-- /See:/ 'newAppsDynamiteStorageImage' smart constructor.
data AppsDynamiteStorageImage = AppsDynamiteStorageImage
  { -- | The alternative text of this image, used for accessibility.
    altText :: (Core.Maybe Core.Text),
    -- | An image URL.
    imageUrl :: (Core.Maybe Core.Text),
    -- |
    onClick :: (Core.Maybe AppsDynamiteStorageOnClick)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageImage' with the minimum fields required to make a request.
newAppsDynamiteStorageImage ::
  AppsDynamiteStorageImage
newAppsDynamiteStorageImage =
  AppsDynamiteStorageImage
    { altText = Core.Nothing,
      imageUrl = Core.Nothing,
      onClick = Core.Nothing
    }

instance Core.FromJSON AppsDynamiteStorageImage where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageImage"
      ( \o ->
          AppsDynamiteStorageImage
            Core.<$> (o Core..:? "altText")
            Core.<*> (o Core..:? "imageUrl")
            Core.<*> (o Core..:? "onClick")
      )

instance Core.ToJSON AppsDynamiteStorageImage where
  toJSON AppsDynamiteStorageImage {..} =
    Core.object
      ( Core.catMaybes
          [ ("altText" Core..=) Core.<$> altText,
            ("imageUrl" Core..=) Core.<$> imageUrl,
            ("onClick" Core..=) Core.<$> onClick
          ]
      )

--
-- /See:/ 'newAppsDynamiteStorageImageComponent' smart constructor.
data AppsDynamiteStorageImageComponent = AppsDynamiteStorageImageComponent
  { -- | The accessibility label for the image.
    altText :: (Core.Maybe Core.Text),
    -- | The border style to apply to the image.
    borderStyle :: (Core.Maybe AppsDynamiteStorageBorderStyle),
    -- | The crop style to apply to the image.
    cropStyle :: (Core.Maybe AppsDynamiteStorageImageCropStyle),
    -- | The image URL.
    imageUri :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageImageComponent' with the minimum fields required to make a request.
newAppsDynamiteStorageImageComponent ::
  AppsDynamiteStorageImageComponent
newAppsDynamiteStorageImageComponent =
  AppsDynamiteStorageImageComponent
    { altText = Core.Nothing,
      borderStyle = Core.Nothing,
      cropStyle = Core.Nothing,
      imageUri = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteStorageImageComponent
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageImageComponent"
      ( \o ->
          AppsDynamiteStorageImageComponent
            Core.<$> (o Core..:? "altText")
            Core.<*> (o Core..:? "borderStyle")
            Core.<*> (o Core..:? "cropStyle")
            Core.<*> (o Core..:? "imageUri")
      )

instance
  Core.ToJSON
    AppsDynamiteStorageImageComponent
  where
  toJSON AppsDynamiteStorageImageComponent {..} =
    Core.object
      ( Core.catMaybes
          [ ("altText" Core..=) Core.<$> altText,
            ("borderStyle" Core..=) Core.<$> borderStyle,
            ("cropStyle" Core..=) Core.<$> cropStyle,
            ("imageUri" Core..=) Core.<$> imageUri
          ]
      )

-- | Represents the crop style applied to an image.
--
-- /See:/ 'newAppsDynamiteStorageImageCropStyle' smart constructor.
data AppsDynamiteStorageImageCropStyle = AppsDynamiteStorageImageCropStyle
  { -- | The aspect ratio to use if the crop type is @RECTANGLE_CUSTOM@.
    aspectRatio :: (Core.Maybe Core.Double),
    -- | The crop type.
    type' :: (Core.Maybe AppsDynamiteStorageImageCropStyle_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageImageCropStyle' with the minimum fields required to make a request.
newAppsDynamiteStorageImageCropStyle ::
  AppsDynamiteStorageImageCropStyle
newAppsDynamiteStorageImageCropStyle =
  AppsDynamiteStorageImageCropStyle
    { aspectRatio = Core.Nothing,
      type' = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteStorageImageCropStyle
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageImageCropStyle"
      ( \o ->
          AppsDynamiteStorageImageCropStyle
            Core.<$> (o Core..:? "aspectRatio")
            Core.<*> (o Core..:? "type")
      )

instance
  Core.ToJSON
    AppsDynamiteStorageImageCropStyle
  where
  toJSON AppsDynamiteStorageImageCropStyle {..} =
    Core.object
      ( Core.catMaybes
          [ ("aspectRatio" Core..=) Core.<$> aspectRatio,
            ("type" Core..=) Core.<$> type'
          ]
      )

-- | A <https://fonts.google.com/icons Google Font Icon>, which includes over 2500+ options. For example, to display a <https://fonts.google.com/icons?selected=Material%20Symbols%20Outlined%3Acheck_box%3AFILL%400%3Bwght%40400%3BGRAD%400%3Bopsz%4048 check box icon> with customized weight and grade, write { \"name\": \"check_box\", \"fill\": true, \"weight\": 300, \"grade\": -25 }
--
-- /See:/ 'newAppsDynamiteStorageMaterialIcon' smart constructor.
data AppsDynamiteStorageMaterialIcon = AppsDynamiteStorageMaterialIcon
  { -- | Whether it renders a filled icon. Default value is false. See Customization in <https://fonts.google.com/icons Google Font Icon> for details.
    fill :: (Core.Maybe Core.Bool),
    -- | Weight and grade affect a symbol’s thickness. Adjustments to grade are more granular than adjustments to weight and have a small impact on the size of the symbol. Choose from {-25, 0, 200}. If absent, default value is 0. If any other value is specified, a broken image icon will be displayed. See Customization in <https://fonts.google.com/icons Google Font Icon> for details.
    grade :: (Core.Maybe Core.Int32),
    -- | The icon name defined in the <https://fonts.google.com/icons Google Material Icon> in snake/case. e.g. \"check/box\". Any invalid name will be trimmed as empty string result in the icon falied to render.
    name :: (Core.Maybe Core.Text),
    -- | The stroke weight of the icon. Choose from {100, 200, 300, 400, 500, 600, 700}. If absent, default value is 400. If any other value is specified, a broken image icon will be displayed. See Customization in <https://fonts.google.com/icons Google Font Icon> for details.
    weight :: (Core.Maybe Core.Int32)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageMaterialIcon' with the minimum fields required to make a request.
newAppsDynamiteStorageMaterialIcon ::
  AppsDynamiteStorageMaterialIcon
newAppsDynamiteStorageMaterialIcon =
  AppsDynamiteStorageMaterialIcon
    { fill = Core.Nothing,
      grade = Core.Nothing,
      name = Core.Nothing,
      weight = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteStorageMaterialIcon
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageMaterialIcon"
      ( \o ->
          AppsDynamiteStorageMaterialIcon
            Core.<$> (o Core..:? "fill")
            Core.<*> (o Core..:? "grade")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "weight")
      )

instance Core.ToJSON AppsDynamiteStorageMaterialIcon where
  toJSON AppsDynamiteStorageMaterialIcon {..} =
    Core.object
      ( Core.catMaybes
          [ ("fill" Core..=) Core.<$> fill,
            ("grade" Core..=) Core.<$> grade,
            ("name" Core..=) Core.<$> name,
            ("weight" Core..=) Core.<$> weight
          ]
      )

--
-- /See:/ 'newAppsDynamiteStorageOnClick' smart constructor.
data AppsDynamiteStorageOnClick = AppsDynamiteStorageOnClick
  { -- | If specified, an action is triggered by this onClick.
    action :: (Core.Maybe AppsDynamiteStorageAction),
    -- | Triggers host app action on click directly without invoking form actions. This is currently not available to end-users and is used internal only.
    hostAppAction :: (Core.Maybe HostAppActionMarkup),
    -- | An add-on triggers this action when the action needs to open a link. This differs from the open_link above in that this needs to talk to server to get the link. Thus some preparation work is required for web client to do before the open link action response comes back.
    openDynamicLinkAction :: (Core.Maybe AppsDynamiteStorageAction),
    -- | If specified, this onClick triggers an open link action.
    openLink :: (Core.Maybe AppsDynamiteStorageOpenLink)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageOnClick' with the minimum fields required to make a request.
newAppsDynamiteStorageOnClick ::
  AppsDynamiteStorageOnClick
newAppsDynamiteStorageOnClick =
  AppsDynamiteStorageOnClick
    { action = Core.Nothing,
      hostAppAction = Core.Nothing,
      openDynamicLinkAction = Core.Nothing,
      openLink = Core.Nothing
    }

instance Core.FromJSON AppsDynamiteStorageOnClick where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageOnClick"
      ( \o ->
          AppsDynamiteStorageOnClick
            Core.<$> (o Core..:? "action")
            Core.<*> (o Core..:? "hostAppAction")
            Core.<*> (o Core..:? "openDynamicLinkAction")
            Core.<*> (o Core..:? "openLink")
      )

instance Core.ToJSON AppsDynamiteStorageOnClick where
  toJSON AppsDynamiteStorageOnClick {..} =
    Core.object
      ( Core.catMaybes
          [ ("action" Core..=) Core.<$> action,
            ("hostAppAction" Core..=) Core.<$> hostAppAction,
            ("openDynamicLinkAction" Core..=)
              Core.<$> openDynamicLinkAction,
            ("openLink" Core..=) Core.<$> openLink
          ]
      )

--
-- /See:/ 'newAppsDynamiteStorageOpenLink' smart constructor.
data AppsDynamiteStorageOpenLink = AppsDynamiteStorageOpenLink
  { -- | Represents the platform specific uri\/intent to open on each client. For example: A companion_url will open in a companion window on the web. An iOS URL and android intent will open in the corresponding hosting apps. If these platform specific URLs can\'t be handled correctly, i.e. if the companion isn\'t supported on web and the hosting apps aren\'t available on the mobile platforms then the @uri@ will open in a new browser window on all the platforms.
    appUri :: (Core.Maybe AppsDynamiteStorageOpenLinkAppUri),
    -- |
    onClose :: (Core.Maybe AppsDynamiteStorageOpenLink_OnClose),
    -- |
    openAs :: (Core.Maybe AppsDynamiteStorageOpenLink_OpenAs),
    -- | The URL to open.
    url :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageOpenLink' with the minimum fields required to make a request.
newAppsDynamiteStorageOpenLink ::
  AppsDynamiteStorageOpenLink
newAppsDynamiteStorageOpenLink =
  AppsDynamiteStorageOpenLink
    { appUri = Core.Nothing,
      onClose = Core.Nothing,
      openAs = Core.Nothing,
      url = Core.Nothing
    }

instance Core.FromJSON AppsDynamiteStorageOpenLink where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageOpenLink"
      ( \o ->
          AppsDynamiteStorageOpenLink
            Core.<$> (o Core..:? "appUri")
            Core.<*> (o Core..:? "onClose")
            Core.<*> (o Core..:? "openAs")
            Core.<*> (o Core..:? "url")
      )

instance Core.ToJSON AppsDynamiteStorageOpenLink where
  toJSON AppsDynamiteStorageOpenLink {..} =
    Core.object
      ( Core.catMaybes
          [ ("appUri" Core..=) Core.<$> appUri,
            ("onClose" Core..=) Core.<$> onClose,
            ("openAs" Core..=) Core.<$> openAs,
            ("url" Core..=) Core.<$> url
          ]
      )

-- | Represents the platform specific uri\/intent to open for each client.
--
-- /See:/ 'newAppsDynamiteStorageOpenLinkAppUri' smart constructor.
data AppsDynamiteStorageOpenLinkAppUri = AppsDynamiteStorageOpenLinkAppUri
  { -- | An intent object to be opened in the corresponding android hosting app.
    androidIntent :: (Core.Maybe AppsDynamiteStorageOpenLinkAppUriIntent),
    -- | A companion uri string to be opened in the chat companion window. on the web.
    companionUri :: (Core.Maybe Core.Text),
    -- | A uri string to be opened in the corresponding iOS hosting app.
    iosUri :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageOpenLinkAppUri' with the minimum fields required to make a request.
newAppsDynamiteStorageOpenLinkAppUri ::
  AppsDynamiteStorageOpenLinkAppUri
newAppsDynamiteStorageOpenLinkAppUri =
  AppsDynamiteStorageOpenLinkAppUri
    { androidIntent = Core.Nothing,
      companionUri = Core.Nothing,
      iosUri = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteStorageOpenLinkAppUri
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageOpenLinkAppUri"
      ( \o ->
          AppsDynamiteStorageOpenLinkAppUri
            Core.<$> (o Core..:? "androidIntent")
            Core.<*> (o Core..:? "companionUri")
            Core.<*> (o Core..:? "iosUri")
      )

instance
  Core.ToJSON
    AppsDynamiteStorageOpenLinkAppUri
  where
  toJSON AppsDynamiteStorageOpenLinkAppUri {..} =
    Core.object
      ( Core.catMaybes
          [ ("androidIntent" Core..=) Core.<$> androidIntent,
            ("companionUri" Core..=) Core.<$> companionUri,
            ("iosUri" Core..=) Core.<$> iosUri
          ]
      )

-- | Android intent.
--
-- /See:/ 'newAppsDynamiteStorageOpenLinkAppUriIntent' smart constructor.
data AppsDynamiteStorageOpenLinkAppUriIntent = AppsDynamiteStorageOpenLinkAppUriIntent
  { -- | A list of extra data for the android intent. For example, for a calendar event edit intent, the event title information can be passed as extra data.
    extraData :: (Core.Maybe [AppsDynamiteStorageOpenLinkAppUriIntentExtraData]),
    -- | An android intent action string for the {\@link android.content.Intent} object. For example: for the view intent action type, a valid value will be android.content.Intent.ACTION_VIEW.
    intentAction :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageOpenLinkAppUriIntent' with the minimum fields required to make a request.
newAppsDynamiteStorageOpenLinkAppUriIntent ::
  AppsDynamiteStorageOpenLinkAppUriIntent
newAppsDynamiteStorageOpenLinkAppUriIntent =
  AppsDynamiteStorageOpenLinkAppUriIntent
    { extraData = Core.Nothing,
      intentAction = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteStorageOpenLinkAppUriIntent
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageOpenLinkAppUriIntent"
      ( \o ->
          AppsDynamiteStorageOpenLinkAppUriIntent
            Core.<$> (o Core..:? "extraData")
            Core.<*> (o Core..:? "intentAction")
      )

instance
  Core.ToJSON
    AppsDynamiteStorageOpenLinkAppUriIntent
  where
  toJSON AppsDynamiteStorageOpenLinkAppUriIntent {..} =
    Core.object
      ( Core.catMaybes
          [ ("extraData" Core..=) Core.<$> extraData,
            ("intentAction" Core..=) Core.<$> intentAction
          ]
      )

-- | Extra data for an android intent. Valid keys are defined in the hosting app contract.
--
-- /See:/ 'newAppsDynamiteStorageOpenLinkAppUriIntentExtraData' smart constructor.
data AppsDynamiteStorageOpenLinkAppUriIntentExtraData = AppsDynamiteStorageOpenLinkAppUriIntentExtraData
  { -- | A key for the intent extra data.
    key :: (Core.Maybe Core.Text),
    -- | Value for the given extra data key.
    value :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageOpenLinkAppUriIntentExtraData' with the minimum fields required to make a request.
newAppsDynamiteStorageOpenLinkAppUriIntentExtraData ::
  AppsDynamiteStorageOpenLinkAppUriIntentExtraData
newAppsDynamiteStorageOpenLinkAppUriIntentExtraData =
  AppsDynamiteStorageOpenLinkAppUriIntentExtraData
    { key = Core.Nothing,
      value = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteStorageOpenLinkAppUriIntentExtraData
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageOpenLinkAppUriIntentExtraData"
      ( \o ->
          AppsDynamiteStorageOpenLinkAppUriIntentExtraData
            Core.<$> (o Core..:? "key") Core.<*> (o Core..:? "value")
      )

instance
  Core.ToJSON
    AppsDynamiteStorageOpenLinkAppUriIntentExtraData
  where
  toJSON
    AppsDynamiteStorageOpenLinkAppUriIntentExtraData {..} =
      Core.object
        ( Core.catMaybes
            [ ("key" Core..=) Core.<$> key,
              ("value" Core..=) Core.<$> value
            ]
        )

-- | A widget that creates a UI item (for example, a drop-down list) with options for users to select.
--
-- /See:/ 'newAppsDynamiteStorageSelectionInput' smart constructor.
data AppsDynamiteStorageSelectionInput = AppsDynamiteStorageSelectionInput
  { -- |
    items :: (Core.Maybe [AppsDynamiteStorageSelectionInputSelectionItem]),
    -- | The label displayed ahead of the switch control.
    label :: (Core.Maybe Core.Text),
    -- | The name of the text input which is used in formInput.
    name :: (Core.Maybe Core.Text),
    -- | If specified, the form is submitted when the selection changes. If not specified, you must specify a separate button.
    onChangeAction :: (Core.Maybe AppsDynamiteStorageAction),
    -- |
    type' :: (Core.Maybe AppsDynamiteStorageSelectionInput_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageSelectionInput' with the minimum fields required to make a request.
newAppsDynamiteStorageSelectionInput ::
  AppsDynamiteStorageSelectionInput
newAppsDynamiteStorageSelectionInput =
  AppsDynamiteStorageSelectionInput
    { items = Core.Nothing,
      label = Core.Nothing,
      name = Core.Nothing,
      onChangeAction = Core.Nothing,
      type' = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteStorageSelectionInput
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageSelectionInput"
      ( \o ->
          AppsDynamiteStorageSelectionInput
            Core.<$> (o Core..:? "items")
            Core.<*> (o Core..:? "label")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "onChangeAction")
            Core.<*> (o Core..:? "type")
      )

instance
  Core.ToJSON
    AppsDynamiteStorageSelectionInput
  where
  toJSON AppsDynamiteStorageSelectionInput {..} =
    Core.object
      ( Core.catMaybes
          [ ("items" Core..=) Core.<$> items,
            ("label" Core..=) Core.<$> label,
            ("name" Core..=) Core.<$> name,
            ("onChangeAction" Core..=) Core.<$> onChangeAction,
            ("type" Core..=) Core.<$> type'
          ]
      )

-- | The item in the switch control. A radio button, at most one of the items is selected.
--
-- /See:/ 'newAppsDynamiteStorageSelectionInputSelectionItem' smart constructor.
data AppsDynamiteStorageSelectionInputSelectionItem = AppsDynamiteStorageSelectionInputSelectionItem
  { -- | If more than one item is selected for @RADIO_BUTTON@ and @DROPDOWN@, the first selected item is treated as selected and the ones after are ignored.
    selected :: (Core.Maybe Core.Bool),
    -- | The text to be displayed.
    text :: (Core.Maybe Core.Text),
    -- | The value associated with this item. The client should use this as a form input value.
    value :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageSelectionInputSelectionItem' with the minimum fields required to make a request.
newAppsDynamiteStorageSelectionInputSelectionItem ::
  AppsDynamiteStorageSelectionInputSelectionItem
newAppsDynamiteStorageSelectionInputSelectionItem =
  AppsDynamiteStorageSelectionInputSelectionItem
    { selected = Core.Nothing,
      text = Core.Nothing,
      value = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteStorageSelectionInputSelectionItem
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageSelectionInputSelectionItem"
      ( \o ->
          AppsDynamiteStorageSelectionInputSelectionItem
            Core.<$> (o Core..:? "selected") Core.<*> (o Core..:? "text")
              Core.<*> (o Core..:? "value")
      )

instance
  Core.ToJSON
    AppsDynamiteStorageSelectionInputSelectionItem
  where
  toJSON
    AppsDynamiteStorageSelectionInputSelectionItem {..} =
      Core.object
        ( Core.catMaybes
            [ ("selected" Core..=) Core.<$> selected,
              ("text" Core..=) Core.<$> text,
              ("value" Core..=) Core.<$> value
            ]
        )

-- | A container wrapping elements necessary for showing suggestion items used in text input autocomplete.
--
-- /See:/ 'newAppsDynamiteStorageSuggestions' smart constructor.
newtype AppsDynamiteStorageSuggestions = AppsDynamiteStorageSuggestions
  { -- | A list of suggestions items which will be used in are used in autocomplete.
    items :: (Core.Maybe [AppsDynamiteStorageSuggestionsSuggestionItem])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageSuggestions' with the minimum fields required to make a request.
newAppsDynamiteStorageSuggestions ::
  AppsDynamiteStorageSuggestions
newAppsDynamiteStorageSuggestions =
  AppsDynamiteStorageSuggestions {items = Core.Nothing}

instance Core.FromJSON AppsDynamiteStorageSuggestions where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageSuggestions"
      ( \o ->
          AppsDynamiteStorageSuggestions
            Core.<$> (o Core..:? "items")
      )

instance Core.ToJSON AppsDynamiteStorageSuggestions where
  toJSON AppsDynamiteStorageSuggestions {..} =
    Core.object
      (Core.catMaybes [("items" Core..=) Core.<$> items])

-- | A suggestion item. Only supports text for now.
--
-- /See:/ 'newAppsDynamiteStorageSuggestionsSuggestionItem' smart constructor.
newtype AppsDynamiteStorageSuggestionsSuggestionItem = AppsDynamiteStorageSuggestionsSuggestionItem
  { -- |
    text :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageSuggestionsSuggestionItem' with the minimum fields required to make a request.
newAppsDynamiteStorageSuggestionsSuggestionItem ::
  AppsDynamiteStorageSuggestionsSuggestionItem
newAppsDynamiteStorageSuggestionsSuggestionItem =
  AppsDynamiteStorageSuggestionsSuggestionItem {text = Core.Nothing}

instance
  Core.FromJSON
    AppsDynamiteStorageSuggestionsSuggestionItem
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageSuggestionsSuggestionItem"
      ( \o ->
          AppsDynamiteStorageSuggestionsSuggestionItem
            Core.<$> (o Core..:? "text")
      )

instance
  Core.ToJSON
    AppsDynamiteStorageSuggestionsSuggestionItem
  where
  toJSON
    AppsDynamiteStorageSuggestionsSuggestionItem {..} =
      Core.object
        (Core.catMaybes [("text" Core..=) Core.<$> text])

-- | A text input is a UI item where users can input text. A text input can also have an onChange action and suggestions.
--
-- /See:/ 'newAppsDynamiteStorageTextInput' smart constructor.
data AppsDynamiteStorageTextInput = AppsDynamiteStorageTextInput
  { -- | The refresh function that returns suggestions based on the user\'s input text. If the callback is not specified, autocomplete is done in client side based on the initial suggestion items.
    autoCompleteAction :: (Core.Maybe AppsDynamiteStorageAction),
    -- | The hint text.
    hintText :: (Core.Maybe Core.Text),
    -- | The initial suggestions made before any user input.
    initialSuggestions :: (Core.Maybe AppsDynamiteStorageSuggestions),
    -- | At least one of label and hintText must be specified.
    label :: (Core.Maybe Core.Text),
    -- | The name of the text input which is used in formInput.
    name :: (Core.Maybe Core.Text),
    -- | The onChange action, for example, invoke a function.
    onChangeAction :: (Core.Maybe AppsDynamiteStorageAction),
    -- | The style of the text, for example, a single line or multiple lines.
    type' :: (Core.Maybe AppsDynamiteStorageTextInput_Type),
    -- | The default value when there is no input from the user.
    value :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageTextInput' with the minimum fields required to make a request.
newAppsDynamiteStorageTextInput ::
  AppsDynamiteStorageTextInput
newAppsDynamiteStorageTextInput =
  AppsDynamiteStorageTextInput
    { autoCompleteAction = Core.Nothing,
      hintText = Core.Nothing,
      initialSuggestions = Core.Nothing,
      label = Core.Nothing,
      name = Core.Nothing,
      onChangeAction = Core.Nothing,
      type' = Core.Nothing,
      value = Core.Nothing
    }

instance Core.FromJSON AppsDynamiteStorageTextInput where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageTextInput"
      ( \o ->
          AppsDynamiteStorageTextInput
            Core.<$> (o Core..:? "autoCompleteAction")
            Core.<*> (o Core..:? "hintText")
            Core.<*> (o Core..:? "initialSuggestions")
            Core.<*> (o Core..:? "label")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "onChangeAction")
            Core.<*> (o Core..:? "type")
            Core.<*> (o Core..:? "value")
      )

instance Core.ToJSON AppsDynamiteStorageTextInput where
  toJSON AppsDynamiteStorageTextInput {..} =
    Core.object
      ( Core.catMaybes
          [ ("autoCompleteAction" Core..=)
              Core.<$> autoCompleteAction,
            ("hintText" Core..=) Core.<$> hintText,
            ("initialSuggestions" Core..=)
              Core.<$> initialSuggestions,
            ("label" Core..=) Core.<$> label,
            ("name" Core..=) Core.<$> name,
            ("onChangeAction" Core..=) Core.<$> onChangeAction,
            ("type" Core..=) Core.<$> type',
            ("value" Core..=) Core.<$> value
          ]
      )

-- | A paragraph of text that supports formatting. See <workspace/add-ons/concepts/widgets#text_formatting%22 Text formatting> for details.
--
-- /See:/ 'newAppsDynamiteStorageTextParagraph' smart constructor.
newtype AppsDynamiteStorageTextParagraph = AppsDynamiteStorageTextParagraph
  { -- | The text that\'s shown in the widget.
    text :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageTextParagraph' with the minimum fields required to make a request.
newAppsDynamiteStorageTextParagraph ::
  AppsDynamiteStorageTextParagraph
newAppsDynamiteStorageTextParagraph =
  AppsDynamiteStorageTextParagraph {text = Core.Nothing}

instance
  Core.FromJSON
    AppsDynamiteStorageTextParagraph
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageTextParagraph"
      ( \o ->
          AppsDynamiteStorageTextParagraph
            Core.<$> (o Core..:? "text")
      )

instance Core.ToJSON AppsDynamiteStorageTextParagraph where
  toJSON AppsDynamiteStorageTextParagraph {..} =
    Core.object
      (Core.catMaybes [("text" Core..=) Core.<$> text])

-- | A widget is a UI element that presents texts, images, etc.
--
-- /See:/ 'newAppsDynamiteStorageWidget' smart constructor.
data AppsDynamiteStorageWidget = AppsDynamiteStorageWidget
  { -- | A list of buttons. For example, the following JSON creates two buttons. The first is a filled text button and the second is an image button that opens a link: @\"buttonList\": { \"buttons\": [ \"button\": { \"text\": \"Edit\", \"Color\": { \"Red\": 255 \"Green\": 255 \"Blue\": 255 } \"disabled\": true }, \"button\": { \"icon\": { \"knownIcon\": \"INVITE\" \"altText\": \"check calendar\" }, \"onClick\": { \"openLink\": { \"url\": \"https:\/\/example.com\/calendar\" } } }, ] }@
    buttonList :: (Core.Maybe AppsDynamiteStorageButtonList),
    -- | Displays a single row of columns with widgets stacked vertically in each column. For example, the following JSON creates a 2 column widget each containing a single item. @\"columns\": { \"wrapStyle\": \"WRAP\", \"columnItems\": [ { \"horizontalSizeStyle\": \"FILL_AVAILABLE_SPACE\", \"horizontalAlignment\": \"CENTER\", \"verticalAlignment\" : \"CENTER\", \"widgets\": [ { \"textParagraph\": { \"text\": \"First column text paragraph\", } } ] }, { \"horizontalSizeStyle\": \"FILL_AVAILABLE_SPACE\", \"horizontalAlignment\": \"CENTER\", \"verticalAlignment\" : \"CENTER\", \"widgets\": [ { \"textParagraph\": { \"text\": \"Second column text paragraph\", } } ] }, ] } }@
    columns :: (Core.Maybe AppsDynamiteStorageColumns),
    -- | Displays a selection\/input widget for date\/time. For example, the following JSON creates a date\/time picker for an appointment time: @\"date_time_picker\": { \"name\": \"appointment_time\", \"label\": \"Book your appointment at:\", \"type\": \"DateTimePickerType.DATE_AND_TIME\", \"valueMsEpoch\": \"796435200000\" }@
    dateTimePicker :: (Core.Maybe AppsDynamiteStorageDateTimePicker),
    -- | Displays a decorated text item in this widget. For example, the following JSON creates a decorated text widget showing email address: @\"decoratedText\": { \"icon\": { \"knownIcon\": \"EMAIL\" }, \"topLabel\": \"Email Address\", \"content\": \"heba.salam\@example.com\", \"bottomLabel\": \"This is a new Email address!\", \"switchWidget\": { \"name\": \"has_send_welcome_email_to_heba_salam\", \"selected\": false, \"controlType\": \"ControlType.CHECKBOX\" } }@
    decoratedText :: (Core.Maybe AppsDynamiteStorageDecoratedText),
    -- | Displays a divider. For example, the following JSON creates a divider: @\"divider\": { }@
    divider :: (Core.Maybe AppsDynamiteStorageDivider),
    -- | Displays a grid with a collection of items. For example, the following JSON creates a 2 column grid with a single item: @\"grid\": { \"title\": \"A fine collection of items\", \"numColumns\": 2, \"borderStyle\": { \"type\": \"STROKE\", \"cornerRadius\": 4.0 }, \"items\": [ \"image\": { \"imageUri\": \"https:\/\/www.example.com\/image.png\", \"cropStyle\": { \"type\": \"SQUARE\" }, \"borderStyle\": { \"type\": \"STROKE\" } }, \"title\": \"An item\", \"textAlignment\": \"CENTER\" ], \"onClick\": { \"openLink\": { \"url\":\"https:\/\/www.example.com\" } } }@
    grid :: (Core.Maybe AppsDynamiteStorageGrid),
    -- | The horizontal alignment of this widget.
    horizontalAlignment :: (Core.Maybe AppsDynamiteStorageWidget_HorizontalAlignment),
    -- | Displays an image in this widget. For example, the following JSON creates an image with alternative text: @\"image\": { \"imageUrl\": \"https:\/\/example.com\/heba_salam.png\" \"altText\": \"Avatar for Heba Salam\" }@
    image :: (Core.Maybe AppsDynamiteStorageImage),
    -- | Displays a switch control in this widget. For example, the following JSON creates a dropdown selection for size: @\"switchControl\": { \"name\": \"size\", \"label\": \"Size\" \"type\": \"SelectionType.DROPDOWN\", \"items\": [ { \"text\": \"S\", \"value\": \"small\", \"selected\": false }, { \"text\": \"M\", \"value\": \"medium\", \"selected\": true }, { \"text\": \"L\", \"value\": \"large\", \"selected\": false }, { \"text\": \"XL\", \"value\": \"extra_large\", \"selected\": false } ] }@
    selectionInput :: (Core.Maybe AppsDynamiteStorageSelectionInput),
    -- | Displays a text input in this widget. For example, the following JSON creates a text input for mail address: @\"textInput\": { \"name\": \"mailing_address\", \"label\": \"Mailing Address\" }@ As another example, the following JSON creates a text input for programming language with static suggestions: @\"textInput\": { \"name\": \"preferred_programing_language\", \"label\": \"Preferred Language\", \"initialSuggestions\": { \"items\": [ { \"text\": \"C++\" }, { \"text\": \"Java\" }, { \"text\": \"JavaScript\" }, { \"text\": \"Python\" } ] } }@
    textInput :: (Core.Maybe AppsDynamiteStorageTextInput),
    -- | Displays a text paragraph in this widget. For example, the following JSON creates a bolded text: @\"textParagraph\": { \"text\": \" *bold text*\" }@
    textParagraph :: (Core.Maybe AppsDynamiteStorageTextParagraph)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteStorageWidget' with the minimum fields required to make a request.
newAppsDynamiteStorageWidget ::
  AppsDynamiteStorageWidget
newAppsDynamiteStorageWidget =
  AppsDynamiteStorageWidget
    { buttonList = Core.Nothing,
      columns = Core.Nothing,
      dateTimePicker = Core.Nothing,
      decoratedText = Core.Nothing,
      divider = Core.Nothing,
      grid = Core.Nothing,
      horizontalAlignment = Core.Nothing,
      image = Core.Nothing,
      selectionInput = Core.Nothing,
      textInput = Core.Nothing,
      textParagraph = Core.Nothing
    }

instance Core.FromJSON AppsDynamiteStorageWidget where
  parseJSON =
    Core.withObject
      "AppsDynamiteStorageWidget"
      ( \o ->
          AppsDynamiteStorageWidget
            Core.<$> (o Core..:? "buttonList")
            Core.<*> (o Core..:? "columns")
            Core.<*> (o Core..:? "dateTimePicker")
            Core.<*> (o Core..:? "decoratedText")
            Core.<*> (o Core..:? "divider")
            Core.<*> (o Core..:? "grid")
            Core.<*> (o Core..:? "horizontalAlignment")
            Core.<*> (o Core..:? "image")
            Core.<*> (o Core..:? "selectionInput")
            Core.<*> (o Core..:? "textInput")
            Core.<*> (o Core..:? "textParagraph")
      )

instance Core.ToJSON AppsDynamiteStorageWidget where
  toJSON AppsDynamiteStorageWidget {..} =
    Core.object
      ( Core.catMaybes
          [ ("buttonList" Core..=) Core.<$> buttonList,
            ("columns" Core..=) Core.<$> columns,
            ("dateTimePicker" Core..=) Core.<$> dateTimePicker,
            ("decoratedText" Core..=) Core.<$> decoratedText,
            ("divider" Core..=) Core.<$> divider,
            ("grid" Core..=) Core.<$> grid,
            ("horizontalAlignment" Core..=)
              Core.<$> horizontalAlignment,
            ("image" Core..=) Core.<$> image,
            ("selectionInput" Core..=) Core.<$> selectionInput,
            ("textInput" Core..=) Core.<$> textInput,
            ("textParagraph" Core..=) Core.<$> textParagraph
          ]
      )

-- | Interactive objects inside a message. Documentation: - https:\/\/api.slack.com\/docs\/message-buttons
--
-- /See:/ 'newAppsDynamiteV1ApiCompatV1Action' smart constructor.
data AppsDynamiteV1ApiCompatV1Action = AppsDynamiteV1ApiCompatV1Action
  { -- | Confirmation dialog config.
    confirm :: (Core.Maybe AppsDynamiteV1ApiCompatV1ActionConfirm),
    -- | Unique identifier for this action.
    name :: (Core.Maybe Core.Text),
    -- | Button style (\"default\", \"primary\", or \"danger\").
    style :: (Core.Maybe Core.Text),
    -- | User-facing label for the action.
    text :: (Core.Maybe Core.Text),
    -- | Action type - currently only \"button\".
    type' :: (Core.Maybe Core.Text),
    -- | Payload for this action. Will be sent to the action handler along with name.
    value :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteV1ApiCompatV1Action' with the minimum fields required to make a request.
newAppsDynamiteV1ApiCompatV1Action ::
  AppsDynamiteV1ApiCompatV1Action
newAppsDynamiteV1ApiCompatV1Action =
  AppsDynamiteV1ApiCompatV1Action
    { confirm = Core.Nothing,
      name = Core.Nothing,
      style = Core.Nothing,
      text = Core.Nothing,
      type' = Core.Nothing,
      value = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteV1ApiCompatV1Action
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteV1ApiCompatV1Action"
      ( \o ->
          AppsDynamiteV1ApiCompatV1Action
            Core.<$> (o Core..:? "confirm")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "style")
            Core.<*> (o Core..:? "text")
            Core.<*> (o Core..:? "type")
            Core.<*> (o Core..:? "value")
      )

instance Core.ToJSON AppsDynamiteV1ApiCompatV1Action where
  toJSON AppsDynamiteV1ApiCompatV1Action {..} =
    Core.object
      ( Core.catMaybes
          [ ("confirm" Core..=) Core.<$> confirm,
            ("name" Core..=) Core.<$> name,
            ("style" Core..=) Core.<$> style,
            ("text" Core..=) Core.<$> text,
            ("type" Core..=) Core.<$> type',
            ("value" Core..=) Core.<$> value
          ]
      )

-- | Confirmation dialog config.
--
-- /See:/ 'newAppsDynamiteV1ApiCompatV1ActionConfirm' smart constructor.
data AppsDynamiteV1ApiCompatV1ActionConfirm = AppsDynamiteV1ApiCompatV1ActionConfirm
  { -- | \"Cancel\" button label.
    dismissText :: (Core.Maybe Core.Text),
    -- | \"OK\" button label.
    okText :: (Core.Maybe Core.Text),
    -- | Confirmation dialog body text.
    text :: (Core.Maybe Core.Text),
    -- | Confirmation dialog title.
    title :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteV1ApiCompatV1ActionConfirm' with the minimum fields required to make a request.
newAppsDynamiteV1ApiCompatV1ActionConfirm ::
  AppsDynamiteV1ApiCompatV1ActionConfirm
newAppsDynamiteV1ApiCompatV1ActionConfirm =
  AppsDynamiteV1ApiCompatV1ActionConfirm
    { dismissText = Core.Nothing,
      okText = Core.Nothing,
      text = Core.Nothing,
      title = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteV1ApiCompatV1ActionConfirm
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteV1ApiCompatV1ActionConfirm"
      ( \o ->
          AppsDynamiteV1ApiCompatV1ActionConfirm
            Core.<$> (o Core..:? "dismiss_text")
            Core.<*> (o Core..:? "ok_text")
            Core.<*> (o Core..:? "text")
            Core.<*> (o Core..:? "title")
      )

instance
  Core.ToJSON
    AppsDynamiteV1ApiCompatV1ActionConfirm
  where
  toJSON AppsDynamiteV1ApiCompatV1ActionConfirm {..} =
    Core.object
      ( Core.catMaybes
          [ ("dismiss_text" Core..=) Core.<$> dismissText,
            ("ok_text" Core..=) Core.<$> okText,
            ("text" Core..=) Core.<$> text,
            ("title" Core..=) Core.<$> title
          ]
      )

-- | Richly formatted attachments. Documentation: - https:\/\/api.slack.com\/docs\/message-attachments
--
-- /See:/ 'newAppsDynamiteV1ApiCompatV1Attachment' smart constructor.
data AppsDynamiteV1ApiCompatV1Attachment = AppsDynamiteV1ApiCompatV1Attachment
  { -- | Array of actions (currently only buttons).
    actions :: (Core.Maybe [AppsDynamiteV1ApiCompatV1Action]),
    -- | Undocumented - used in interactive button examples. The only valid value appears to be \"default\".
    attachmentType :: (Core.Maybe Core.Text),
    -- | Avatar URL for the user.
    authorIcon :: (Core.Maybe Core.Text),
    -- | URL that the user name should link to.
    authorLink :: (Core.Maybe Core.Text),
    -- | User name to display as the author of the message.
    authorName :: (Core.Maybe Core.Text),
    -- | Unique identifier for the collection of buttons within this attachment. Will be sent back to the action handler URL when a button is clicked.
    callbackId :: (Core.Maybe Core.Text),
    -- | A color \"bar\" to display to the left of the attachment.
    color :: (Core.Maybe Core.Text),
    -- | Fallback plain-text string for clients that don\'t support attachments.
    fallback :: (Core.Maybe Core.Text),
    -- | Columns of text inside the attachment body.
    fields :: (Core.Maybe [AppsDynamiteV1ApiCompatV1Field]),
    -- | A string displayed at the bottom of the attachment.
    footer :: (Core.Maybe Core.Text),
    -- | Avatar URL displayed to the left of the footer.
    footerIcon :: (Core.Maybe Core.Text),
    -- | URL of an image to display in an image chip.
    imageUrl :: (Core.Maybe Core.Text),
    -- | List of fields to apply formatting to.
    mrkdwnIn :: (Core.Maybe [Core.Text]),
    -- | A string to show above the attachment.
    pretext :: (Core.Maybe Core.Text),
    -- | Main text.
    text :: (Core.Maybe Core.Text),
    -- | URL of a thumbnail image to display to the right of the attachment body.
    thumbUrl :: (Core.Maybe Core.Text),
    -- | Title string of this attachment.
    title :: (Core.Maybe Core.Text),
    -- | URL that the title string should link to.
    titleLink :: (Core.Maybe Core.Text),
    -- | UNIX timestamp of the attachment.
    ts :: (Core.Maybe Core.Int32)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteV1ApiCompatV1Attachment' with the minimum fields required to make a request.
newAppsDynamiteV1ApiCompatV1Attachment ::
  AppsDynamiteV1ApiCompatV1Attachment
newAppsDynamiteV1ApiCompatV1Attachment =
  AppsDynamiteV1ApiCompatV1Attachment
    { actions = Core.Nothing,
      attachmentType = Core.Nothing,
      authorIcon = Core.Nothing,
      authorLink = Core.Nothing,
      authorName = Core.Nothing,
      callbackId = Core.Nothing,
      color = Core.Nothing,
      fallback = Core.Nothing,
      fields = Core.Nothing,
      footer = Core.Nothing,
      footerIcon = Core.Nothing,
      imageUrl = Core.Nothing,
      mrkdwnIn = Core.Nothing,
      pretext = Core.Nothing,
      text = Core.Nothing,
      thumbUrl = Core.Nothing,
      title = Core.Nothing,
      titleLink = Core.Nothing,
      ts = Core.Nothing
    }

instance
  Core.FromJSON
    AppsDynamiteV1ApiCompatV1Attachment
  where
  parseJSON =
    Core.withObject
      "AppsDynamiteV1ApiCompatV1Attachment"
      ( \o ->
          AppsDynamiteV1ApiCompatV1Attachment
            Core.<$> (o Core..:? "actions")
            Core.<*> (o Core..:? "attachment_type")
            Core.<*> (o Core..:? "author_icon")
            Core.<*> (o Core..:? "author_link")
            Core.<*> (o Core..:? "author_name")
            Core.<*> (o Core..:? "callback_id")
            Core.<*> (o Core..:? "color")
            Core.<*> (o Core..:? "fallback")
            Core.<*> (o Core..:? "fields")
            Core.<*> (o Core..:? "footer")
            Core.<*> (o Core..:? "footer_icon")
            Core.<*> (o Core..:? "image_url")
            Core.<*> (o Core..:? "mrkdwn_in")
            Core.<*> (o Core..:? "pretext")
            Core.<*> (o Core..:? "text")
            Core.<*> (o Core..:? "thumb_url")
            Core.<*> (o Core..:? "title")
            Core.<*> (o Core..:? "title_link")
            Core.<*> (o Core..:? "ts")
      )

instance
  Core.ToJSON
    AppsDynamiteV1ApiCompatV1Attachment
  where
  toJSON AppsDynamiteV1ApiCompatV1Attachment {..} =
    Core.object
      ( Core.catMaybes
          [ ("actions" Core..=) Core.<$> actions,
            ("attachment_type" Core..=) Core.<$> attachmentType,
            ("author_icon" Core..=) Core.<$> authorIcon,
            ("author_link" Core..=) Core.<$> authorLink,
            ("author_name" Core..=) Core.<$> authorName,
            ("callback_id" Core..=) Core.<$> callbackId,
            ("color" Core..=) Core.<$> color,
            ("fallback" Core..=) Core.<$> fallback,
            ("fields" Core..=) Core.<$> fields,
            ("footer" Core..=) Core.<$> footer,
            ("footer_icon" Core..=) Core.<$> footerIcon,
            ("image_url" Core..=) Core.<$> imageUrl,
            ("mrkdwn_in" Core..=) Core.<$> mrkdwnIn,
            ("pretext" Core..=) Core.<$> pretext,
            ("text" Core..=) Core.<$> text,
            ("thumb_url" Core..=) Core.<$> thumbUrl,
            ("title" Core..=) Core.<$> title,
            ("title_link" Core..=) Core.<$> titleLink,
            ("ts" Core..=) Core.<$> ts
          ]
      )

-- | A column of text in an attachment. Documentation: - https:\/\/api.slack.com\/docs\/message-attachments
--
-- /See:/ 'newAppsDynamiteV1ApiCompatV1Field' smart constructor.
data AppsDynamiteV1ApiCompatV1Field = AppsDynamiteV1ApiCompatV1Field
  { -- | Whether the field can be shown side-by-side with another field.
    short :: (Core.Maybe Core.Bool),
    -- | The heading text, shown in bold.
    title :: (Core.Maybe Core.Text),
    -- | The text value of the field.
    value :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsDynamiteV1ApiCompatV1Field' with the minimum fields required to make a request.
newAppsDynamiteV1ApiCompatV1Field ::
  AppsDynamiteV1ApiCompatV1Field
newAppsDynamiteV1ApiCompatV1Field =
  AppsDynamiteV1ApiCompatV1Field
    { short = Core.Nothing,
      title = Core.Nothing,
      value = Core.Nothing
    }

instance Core.FromJSON AppsDynamiteV1ApiCompatV1Field where
  parseJSON =
    Core.withObject
      "AppsDynamiteV1ApiCompatV1Field"
      ( \o ->
          AppsDynamiteV1ApiCompatV1Field
            Core.<$> (o Core..:? "short")
            Core.<*> (o Core..:? "title")
            Core.<*> (o Core..:? "value")
      )

instance Core.ToJSON AppsDynamiteV1ApiCompatV1Field where
  toJSON AppsDynamiteV1ApiCompatV1Field {..} =
    Core.object
      ( Core.catMaybes
          [ ("short" Core..=) Core.<$> short,
            ("title" Core..=) Core.<$> title,
            ("value" Core..=) Core.<$> value
          ]
      )

--
-- /See:/ 'newAppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkup' smart constructor.
newtype AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkup = AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkup
  { -- |
    addonAttachments ::
      ( Core.Maybe
          [AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkupAddonAttachment]
      )
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkup' with the minimum fields required to make a request.
newAppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkup ::
  AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkup
newAppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkup =
  AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkup
    { addonAttachments = Core.Nothing
    }

instance
  Core.FromJSON
    AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkup
  where
  parseJSON =
    Core.withObject
      "AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkup"
      ( \o ->
          AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkup
            Core.<$> (o Core..:? "addonAttachments")
      )

instance
  Core.ToJSON
    AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkup
  where
  toJSON
    AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkup {..} =
      Core.object
        ( Core.catMaybes
            [ ("addonAttachments" Core..=)
                Core.<$> addonAttachments
            ]
        )

--
-- /See:/ 'newAppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkupAddonAttachment' smart constructor.
data AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkupAddonAttachment = AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkupAddonAttachment
  { -- | Link to the resource\'s icon.
    iconUrl :: (Core.Maybe Core.Text),
    -- | MIME type of the content in resource_url.
    mimeType :: (Core.Maybe Core.Text),
    -- |
    resourceUrl :: (Core.Maybe Core.Text),
    -- | Title of the attachment.
    title :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkupAddonAttachment' with the minimum fields required to make a request.
newAppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkupAddonAttachment ::
  AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkupAddonAttachment
newAppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkupAddonAttachment =
  AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkupAddonAttachment
    { iconUrl = Core.Nothing,
      mimeType = Core.Nothing,
      resourceUrl = Core.Nothing,
      title = Core.Nothing
    }

instance
  Core.FromJSON
    AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkupAddonAttachment
  where
  parseJSON =
    Core.withObject
      "AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkupAddonAttachment"
      ( \o ->
          AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkupAddonAttachment
            Core.<$> (o Core..:? "iconUrl")
              Core.<*> (o Core..:? "mimeType")
              Core.<*> (o Core..:? "resourceUrl")
              Core.<*> (o Core..:? "title")
      )

instance
  Core.ToJSON
    AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkupAddonAttachment
  where
  toJSON
    AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkupAddonAttachment {..} =
      Core.object
        ( Core.catMaybes
            [ ("iconUrl" Core..=) Core.<$> iconUrl,
              ("mimeType" Core..=) Core.<$> mimeType,
              ("resourceUrl" Core..=) Core.<$> resourceUrl,
              ("title" Core..=) Core.<$> title
            ]
        )

-- | Markup that defines conference data associated to a Google Calendar event.
--
-- /See:/ 'newAppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkup' smart constructor.
data AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkup = AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkup
  { -- | Unique identifier for this conference data. Maximum 512 characters long.
    conferenceId :: (Core.Maybe Core.Text),
    -- | An identifier of the conferencing solution. Must match a value from the deployment\'s @calendar.conferenceSolution.id@ field.
    conferenceSolutionId :: (Core.Maybe Core.Text),
    -- | Entry points to the conference. Maximum 300 entry points are allowed.
    entryPoints ::
      ( Core.Maybe
          [AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup]
      ),
    -- | If set, it means an error occurred during conference creation.
    error ::
      ( Core.Maybe
          AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupError
      ),
    -- | Additional notes (such as instructions from the administrator, legal notices) to display to the user. Can contain HTML. Max length 2048 characters.
    note :: (Core.Maybe Core.Text),
    -- | Additional add-on parameters. Maximum 300 parameters are allowed.
    parameters ::
      ( Core.Maybe
          [AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupParameter]
      )
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkup' with the minimum fields required to make a request.
newAppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkup ::
  AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkup
newAppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkup =
  AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkup
    { conferenceId = Core.Nothing,
      conferenceSolutionId = Core.Nothing,
      entryPoints = Core.Nothing,
      error = Core.Nothing,
      note = Core.Nothing,
      parameters = Core.Nothing
    }

instance
  Core.FromJSON
    AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkup
  where
  parseJSON =
    Core.withObject
      "AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkup"
      ( \o ->
          AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkup
            Core.<$> (o Core..:? "conferenceId")
              Core.<*> (o Core..:? "conferenceSolutionId")
              Core.<*> (o Core..:? "entryPoints")
              Core.<*> (o Core..:? "error")
              Core.<*> (o Core..:? "note")
              Core.<*> (o Core..:? "parameters")
      )

instance
  Core.ToJSON
    AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkup
  where
  toJSON
    AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkup {..} =
      Core.object
        ( Core.catMaybes
            [ ("conferenceId" Core..=) Core.<$> conferenceId,
              ("conferenceSolutionId" Core..=)
                Core.<$> conferenceSolutionId,
              ("entryPoints" Core..=) Core.<$> entryPoints,
              ("error" Core..=) Core.<$> error,
              ("note" Core..=) Core.<$> note,
              ("parameters" Core..=) Core.<$> parameters
            ]
        )

-- | A way to join the conference.
--
-- /See:/ 'newAppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup' smart constructor.
data AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup = AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup
  { -- | An access code for accessing the conference. Maximum 128 characters long.
    accessCode :: (Core.Maybe Core.Text),
    -- | Features of the entry point, such as being toll or toll-free. One entry point can have multiple features.
    features ::
      ( Core.Maybe
          [AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup_FeaturesItem]
      ),
    -- | The label of the entry point to display to the user. Maximum 512 characters long.
    label :: (Core.Maybe Core.Text),
    -- | A meeting code for accessing the conference. Maximum 128 characters long.
    meetingCode :: (Core.Maybe Core.Text),
    -- | A passcode for accessing the conference. Maximum 128 characters long.
    passcode :: (Core.Maybe Core.Text),
    -- | A password for accessing the conference. Maximum 128 characters long.
    password :: (Core.Maybe Core.Text),
    -- | A PIN for accessing the conference. Maximum 128 characters long.
    pin :: (Core.Maybe Core.Text),
    -- | The CLDR\/ISO 3166 region code for the country associated with this entry point. Applicable only to @Type.PHONE@.
    regionCode :: (Core.Maybe Core.Text),
    -- | The type of the entry point. Required.
    type' ::
      ( Core.Maybe
          AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup_Type
      ),
    -- | A URI for joining the conference. Supports tel: and http(s): and should be at most 1300 characters long. Required.
    uri :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup' with the minimum fields required to make a request.
newAppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup ::
  AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup
newAppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup =
  AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup
    { accessCode = Core.Nothing,
      features = Core.Nothing,
      label = Core.Nothing,
      meetingCode = Core.Nothing,
      passcode = Core.Nothing,
      password = Core.Nothing,
      pin = Core.Nothing,
      regionCode = Core.Nothing,
      type' = Core.Nothing,
      uri = Core.Nothing
    }

instance
  Core.FromJSON
    AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup
  where
  parseJSON =
    Core.withObject
      "AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup"
      ( \o ->
          AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup
            Core.<$> (o Core..:? "accessCode")
              Core.<*> (o Core..:? "features")
              Core.<*> (o Core..:? "label")
              Core.<*> (o Core..:? "meetingCode")
              Core.<*> (o Core..:? "passcode")
              Core.<*> (o Core..:? "password")
              Core.<*> (o Core..:? "pin")
              Core.<*> (o Core..:? "regionCode")
              Core.<*> (o Core..:? "type")
              Core.<*> (o Core..:? "uri")
      )

instance
  Core.ToJSON
    AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup
  where
  toJSON
    AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupEntryPointMarkup {..} =
      Core.object
        ( Core.catMaybes
            [ ("accessCode" Core..=) Core.<$> accessCode,
              ("features" Core..=) Core.<$> features,
              ("label" Core..=) Core.<$> label,
              ("meetingCode" Core..=) Core.<$> meetingCode,
              ("passcode" Core..=) Core.<$> passcode,
              ("password" Core..=) Core.<$> password,
              ("pin" Core..=) Core.<$> pin,
              ("regionCode" Core..=) Core.<$> regionCode,
              ("type" Core..=) Core.<$> type',
              ("uri" Core..=) Core.<$> uri
            ]
        )

-- | Represents an error that occurred during conference creation.
--
-- /See:/ 'newAppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupError' smart constructor.
data AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupError = AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupError
  { -- | If the error type is @AUTHENTICATION@, the add-on can provide a URL allowing users to log in. Maximum 1300 characters long.
    authenticationUrl :: (Core.Maybe Core.Text),
    -- | The type of error. Required.
    type' ::
      ( Core.Maybe
          AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupError_Type
      )
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupError' with the minimum fields required to make a request.
newAppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupError ::
  AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupError
newAppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupError =
  AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupError
    { authenticationUrl = Core.Nothing,
      type' = Core.Nothing
    }

instance
  Core.FromJSON
    AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupError
  where
  parseJSON =
    Core.withObject
      "AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupError"
      ( \o ->
          AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupError
            Core.<$> (o Core..:? "authenticationUrl")
              Core.<*> (o Core..:? "type")
      )

instance
  Core.ToJSON
    AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupError
  where
  toJSON
    AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupError {..} =
      Core.object
        ( Core.catMaybes
            [ ("authenticationUrl" Core..=)
                Core.<$> authenticationUrl,
              ("type" Core..=) Core.<$> type'
            ]
        )

-- | Solution-specific parameters that are persisted with the event data and, if an update or delete is needed, are passed to the add-on. For example: @[{key: \'sessionKey\', value: \'123\'}, {key: \'meetingId\', value: \'456\'}]@
--
-- /See:/ 'newAppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupParameter' smart constructor.
data AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupParameter = AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupParameter
  { -- | The key of the parameter. Maximum 50 characters long. Required.
    key :: (Core.Maybe Core.Text),
    -- | The value of the parameter. Maximum 1024 characters long. Required.
    value :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupParameter' with the minimum fields required to make a request.
newAppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupParameter ::
  AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupParameter
newAppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupParameter =
  AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupParameter
    { key = Core.Nothing,
      value = Core.Nothing
    }

instance
  Core.FromJSON
    AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupParameter
  where
  parseJSON =
    Core.withObject
      "AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupParameter"
      ( \o ->
          AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupParameter
            Core.<$> (o Core..:? "key") Core.<*> (o Core..:? "value")
      )

instance
  Core.ToJSON
    AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupParameter
  where
  toJSON
    AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkupParameter {..} =
      Core.object
        ( Core.catMaybes
            [ ("key" Core..=) Core.<$> key,
              ("value" Core..=) Core.<$> value
            ]
        )

--
-- /See:/ 'newAppsExtensionsMarkupCalendarClientActionMarkupEditAttendeesActionMarkup' smart constructor.
newtype AppsExtensionsMarkupCalendarClientActionMarkupEditAttendeesActionMarkup = AppsExtensionsMarkupCalendarClientActionMarkupEditAttendeesActionMarkup
  { -- | A list of attendees to add to the Google Calendar event.
    addAttendeeEmails :: (Core.Maybe [Core.Text])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsExtensionsMarkupCalendarClientActionMarkupEditAttendeesActionMarkup' with the minimum fields required to make a request.
newAppsExtensionsMarkupCalendarClientActionMarkupEditAttendeesActionMarkup ::
  AppsExtensionsMarkupCalendarClientActionMarkupEditAttendeesActionMarkup
newAppsExtensionsMarkupCalendarClientActionMarkupEditAttendeesActionMarkup =
  AppsExtensionsMarkupCalendarClientActionMarkupEditAttendeesActionMarkup
    { addAttendeeEmails = Core.Nothing
    }

instance
  Core.FromJSON
    AppsExtensionsMarkupCalendarClientActionMarkupEditAttendeesActionMarkup
  where
  parseJSON =
    Core.withObject
      "AppsExtensionsMarkupCalendarClientActionMarkupEditAttendeesActionMarkup"
      ( \o ->
          AppsExtensionsMarkupCalendarClientActionMarkupEditAttendeesActionMarkup
            Core.<$> (o Core..:? "addAttendeeEmails")
      )

instance
  Core.ToJSON
    AppsExtensionsMarkupCalendarClientActionMarkupEditAttendeesActionMarkup
  where
  toJSON
    AppsExtensionsMarkupCalendarClientActionMarkupEditAttendeesActionMarkup {..} =
      Core.object
        ( Core.catMaybes
            [ ("addAttendeeEmails" Core..=)
                Core.<$> addAttendeeEmails
            ]
        )

--
-- /See:/ 'newAppsExtensionsMarkupCalendarClientActionMarkupEditConferenceDataActionMarkup' smart constructor.
newtype AppsExtensionsMarkupCalendarClientActionMarkupEditConferenceDataActionMarkup = AppsExtensionsMarkupCalendarClientActionMarkupEditConferenceDataActionMarkup
  { -- | The conference data to add to the Google Calendar event.
    conferenceData ::
      ( Core.Maybe
          AppsExtensionsMarkupCalendarClientActionMarkupConferenceDataMarkup
      )
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AppsExtensionsMarkupCalendarClientActionMarkupEditConferenceDataActionMarkup' with the minimum fields required to make a request.
newAppsExtensionsMarkupCalendarClientActionMarkupEditConferenceDataActionMarkup ::
  AppsExtensionsMarkupCalendarClientActionMarkupEditConferenceDataActionMarkup
newAppsExtensionsMarkupCalendarClientActionMarkupEditConferenceDataActionMarkup =
  AppsExtensionsMarkupCalendarClientActionMarkupEditConferenceDataActionMarkup
    { conferenceData = Core.Nothing
    }

instance
  Core.FromJSON
    AppsExtensionsMarkupCalendarClientActionMarkupEditConferenceDataActionMarkup
  where
  parseJSON =
    Core.withObject
      "AppsExtensionsMarkupCalendarClientActionMarkupEditConferenceDataActionMarkup"
      ( \o ->
          AppsExtensionsMarkupCalendarClientActionMarkupEditConferenceDataActionMarkup
            Core.<$> (o Core..:? "conferenceData")
      )

instance
  Core.ToJSON
    AppsExtensionsMarkupCalendarClientActionMarkupEditConferenceDataActionMarkup
  where
  toJSON
    AppsExtensionsMarkupCalendarClientActionMarkupEditConferenceDataActionMarkup {..} =
      Core.object
        ( Core.catMaybes
            [("conferenceData" Core..=) Core.<$> conferenceData]
        )

-- | Attachments that follow the message text.
--
-- /See:/ 'newAttachment' smart constructor.
data Attachment = Attachment
  { -- | Revised version of Gmail AddOn attachment approved by API design review.
    addOnData :: (Core.Maybe GoogleChatV1ContextualAddOnMarkup),
    -- | The userId for the bot\/app that created this data, to be used for attribution of attachments when the attachment was not created by the message sender.
    appId :: (Core.Maybe UserId),
    -- | To identify an attachment within repeated in a message
    attachmentId :: (Core.Maybe Core.Text),
    -- | Card AddOn attachment with the possibility for specifying editable widgets.
    cardAddOnData :: (Core.Maybe AppsDynamiteStorageCard),
    -- | Deprecated version of Gmail AddOn attachment.
    deprecatedAddOnData :: (Core.Maybe ContextualAddOnMarkup),
    -- | Slack attachment.
    slackData :: (Core.Maybe AppsDynamiteV1ApiCompatV1Attachment),
    -- | The height of image url as fetched by fife. This field is asynchronously filled.
    slackDataImageUrlHeight :: (Core.Maybe Core.Int32)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Attachment' with the minimum fields required to make a request.
newAttachment ::
  Attachment
newAttachment =
  Attachment
    { addOnData = Core.Nothing,
      appId = Core.Nothing,
      attachmentId = Core.Nothing,
      cardAddOnData = Core.Nothing,
      deprecatedAddOnData = Core.Nothing,
      slackData = Core.Nothing,
      slackDataImageUrlHeight = Core.Nothing
    }

instance Core.FromJSON Attachment where
  parseJSON =
    Core.withObject
      "Attachment"
      ( \o ->
          Attachment
            Core.<$> (o Core..:? "addOnData")
            Core.<*> (o Core..:? "appId")
            Core.<*> (o Core..:? "attachmentId")
            Core.<*> (o Core..:? "cardAddOnData")
            Core.<*> (o Core..:? "deprecatedAddOnData")
            Core.<*> (o Core..:? "slackData")
            Core.<*> (o Core..:? "slackDataImageUrlHeight")
      )

instance Core.ToJSON Attachment where
  toJSON Attachment {..} =
    Core.object
      ( Core.catMaybes
          [ ("addOnData" Core..=) Core.<$> addOnData,
            ("appId" Core..=) Core.<$> appId,
            ("attachmentId" Core..=) Core.<$> attachmentId,
            ("cardAddOnData" Core..=) Core.<$> cardAddOnData,
            ("deprecatedAddOnData" Core..=)
              Core.<$> deprecatedAddOnData,
            ("slackData" Core..=) Core.<$> slackData,
            ("slackDataImageUrlHeight" Core..=)
              Core.<$> slackDataImageUrlHeight
          ]
      )

-- | An Attribute is a piece of data attached an Item. Attributes are opaque to the Starbox and have no effect on, nor are they effected by, message storage, indexing, or search.
--
-- /See:/ 'newAttribute' smart constructor.
data Attribute = Attribute
  { -- | The name of the attribute. Required - If a write is attempted with an empty string, the server will return an error.
    name :: (Core.Maybe Core.Text),
    -- |
    value :: (Core.Maybe CaribouAttributeValue)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Attribute' with the minimum fields required to make a request.
newAttribute ::
  Attribute
newAttribute = Attribute {name = Core.Nothing, value = Core.Nothing}

instance Core.FromJSON Attribute where
  parseJSON =
    Core.withObject
      "Attribute"
      ( \o ->
          Attribute
            Core.<$> (o Core..:? "name") Core.<*> (o Core..:? "value")
      )

instance Core.ToJSON Attribute where
  toJSON Attribute {..} =
    Core.object
      ( Core.catMaybes
          [ ("name" Core..=) Core.<$> name,
            ("value" Core..=) Core.<$> value
          ]
      )

-- | An attribute was deleted from some (subset of the) messages in this thread.
--
-- /See:/ 'newAttributeRemoved' smart constructor.
data AttributeRemoved = AttributeRemoved
  { -- |
    attributeId :: (Core.Maybe Core.Text),
    -- |
    messageKeys :: (Core.Maybe [MultiKey])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AttributeRemoved' with the minimum fields required to make a request.
newAttributeRemoved ::
  AttributeRemoved
newAttributeRemoved =
  AttributeRemoved {attributeId = Core.Nothing, messageKeys = Core.Nothing}

instance Core.FromJSON AttributeRemoved where
  parseJSON =
    Core.withObject
      "AttributeRemoved"
      ( \o ->
          AttributeRemoved
            Core.<$> (o Core..:? "attributeId")
            Core.<*> (o Core..:? "messageKeys")
      )

instance Core.ToJSON AttributeRemoved where
  toJSON AttributeRemoved {..} =
    Core.object
      ( Core.catMaybes
          [ ("attributeId" Core..=) Core.<$> attributeId,
            ("messageKeys" Core..=) Core.<$> messageKeys
          ]
      )

-- | An attribute was added to some (subset of the) messages in this thread.
--
-- /See:/ 'newAttributeSet' smart constructor.
data AttributeSet = AttributeSet
  { -- |
    attributeId :: (Core.Maybe Core.Text),
    -- | The serialized attribute_value as persisted in the storage layer. The application is responsible for deserializing it to an Attribute.Value if appropriate.
    attributeValue :: (Core.Maybe Core.Base64),
    -- |
    messageKeys :: (Core.Maybe [MultiKey])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AttributeSet' with the minimum fields required to make a request.
newAttributeSet ::
  AttributeSet
newAttributeSet =
  AttributeSet
    { attributeId = Core.Nothing,
      attributeValue = Core.Nothing,
      messageKeys = Core.Nothing
    }

instance Core.FromJSON AttributeSet where
  parseJSON =
    Core.withObject
      "AttributeSet"
      ( \o ->
          AttributeSet
            Core.<$> (o Core..:? "attributeId")
            Core.<*> (o Core..:? "attributeValue")
            Core.<*> (o Core..:? "messageKeys")
      )

instance Core.ToJSON AttributeSet where
  toJSON AttributeSet {..} =
    Core.object
      ( Core.catMaybes
          [ ("attributeId" Core..=) Core.<$> attributeId,
            ("attributeValue" Core..=) Core.<$> attributeValue,
            ("messageKeys" Core..=) Core.<$> messageKeys
          ]
      )

--
-- /See:/ 'newAttributes' smart constructor.
newtype Attributes = Attributes
  { -- |
    attribute :: (Core.Maybe [Attribute])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Attributes' with the minimum fields required to make a request.
newAttributes ::
  Attributes
newAttributes = Attributes {attribute = Core.Nothing}

instance Core.FromJSON Attributes where
  parseJSON =
    Core.withObject
      "Attributes"
      (\o -> Attributes Core.<$> (o Core..:? "attribute"))

instance Core.ToJSON Attributes where
  toJSON Attributes {..} =
    Core.object
      ( Core.catMaybes
          [("attribute" Core..=) Core.<$> attribute]
      )

-- | Represents the settings for Cloud audit logging
--
-- /See:/ 'newAuditLoggingSettings' smart constructor.
data AuditLoggingSettings = AuditLoggingSettings
  { -- | Indicates whether audit logging is on\/off for admin activity read APIs i.e. Get\/List DataSources, Get\/List SearchApplications etc.
    logAdminReadActions :: (Core.Maybe Core.Bool),
    -- | Indicates whether audit logging is on\/off for data access read APIs i.e. ListItems, GetItem etc.
    logDataReadActions :: (Core.Maybe Core.Bool),
    -- | Indicates whether audit logging is on\/off for data access write APIs i.e. IndexItem etc.
    logDataWriteActions :: (Core.Maybe Core.Bool),
    -- | The resource name of the GCP Project to store audit logs. Cloud audit logging will be enabled after project/name has been updated through CustomerService. Format: projects\/{project/id}
    project :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AuditLoggingSettings' with the minimum fields required to make a request.
newAuditLoggingSettings ::
  AuditLoggingSettings
newAuditLoggingSettings =
  AuditLoggingSettings
    { logAdminReadActions = Core.Nothing,
      logDataReadActions = Core.Nothing,
      logDataWriteActions = Core.Nothing,
      project = Core.Nothing
    }

instance Core.FromJSON AuditLoggingSettings where
  parseJSON =
    Core.withObject
      "AuditLoggingSettings"
      ( \o ->
          AuditLoggingSettings
            Core.<$> (o Core..:? "logAdminReadActions")
            Core.<*> (o Core..:? "logDataReadActions")
            Core.<*> (o Core..:? "logDataWriteActions")
            Core.<*> (o Core..:? "project")
      )

instance Core.ToJSON AuditLoggingSettings where
  toJSON AuditLoggingSettings {..} =
    Core.object
      ( Core.catMaybes
          [ ("logAdminReadActions" Core..=)
              Core.<$> logAdminReadActions,
            ("logDataReadActions" Core..=)
              Core.<$> logDataReadActions,
            ("logDataWriteActions" Core..=)
              Core.<$> logDataWriteActions,
            ("project" Core..=) Core.<$> project
          ]
      )

-- | A combination of an identifier for a Drive resource (e.g. file, folder, or drive) and any secrets needed to access it. The secrets should never be logged, and this proto annotates those secret fields to ensure that they are not. Clients are encouraged to use this proto rather than defining their own, to ensure that secrets are correctly annotated.
--
-- /See:/ 'newAuthorizedItemId' smart constructor.
data AuthorizedItemId = AuthorizedItemId
  { -- | Serialized ID of the Drive resource
    id :: (Core.Maybe Core.Text),
    -- | Resource key of the Drive item. This field should be unset if, depending on the context, the item does not have a resource key, or if none was specified. This must never be logged.
    resourceKey :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AuthorizedItemId' with the minimum fields required to make a request.
newAuthorizedItemId ::
  AuthorizedItemId
newAuthorizedItemId =
  AuthorizedItemId {id = Core.Nothing, resourceKey = Core.Nothing}

instance Core.FromJSON AuthorizedItemId where
  parseJSON =
    Core.withObject
      "AuthorizedItemId"
      ( \o ->
          AuthorizedItemId
            Core.<$> (o Core..:? "id")
            Core.<*> (o Core..:? "resourceKey")
      )

instance Core.ToJSON AuthorizedItemId where
  toJSON AuthorizedItemId {..} =
    Core.object
      ( Core.catMaybes
          [ ("id" Core..=) Core.<$> id,
            ("resourceKey" Core..=) Core.<$> resourceKey
          ]
      )

--
-- /See:/ 'newAutoComplete' smart constructor.
newtype AutoComplete = AutoComplete
  { -- |
    items :: (Core.Maybe [AutoCompleteItem])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AutoComplete' with the minimum fields required to make a request.
newAutoComplete ::
  AutoComplete
newAutoComplete = AutoComplete {items = Core.Nothing}

instance Core.FromJSON AutoComplete where
  parseJSON =
    Core.withObject
      "AutoComplete"
      (\o -> AutoComplete Core.<$> (o Core..:? "items"))

instance Core.ToJSON AutoComplete where
  toJSON AutoComplete {..} =
    Core.object
      (Core.catMaybes [("items" Core..=) Core.<$> items])

--
-- /See:/ 'newAutoCompleteItem' smart constructor.
newtype AutoCompleteItem = AutoCompleteItem
  { -- |
    text :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'AutoCompleteItem' with the minimum fields required to make a request.
newAutoCompleteItem ::
  AutoCompleteItem
newAutoCompleteItem = AutoCompleteItem {text = Core.Nothing}

instance Core.FromJSON AutoCompleteItem where
  parseJSON =
    Core.withObject
      "AutoCompleteItem"
      ( \o ->
          AutoCompleteItem Core.<$> (o Core..:? "text")
      )

instance Core.ToJSON AutoCompleteItem where
  toJSON AutoCompleteItem {..} =
    Core.object
      (Core.catMaybes [("text" Core..=) Core.<$> text])

-- | Container for Babel (Hangouts Classic) only message properties. The properties here will not be consumed by Dynamite clients. They are relevant only for Hangouts Classic.
--
-- /See:/ 'newBabelMessageProps' smart constructor.
data BabelMessageProps = BabelMessageProps
  { -- | Babel clients locally generate this ID to dedupe against the async fanout.
    clientGeneratedId :: (Core.Maybe Core.Int64),
    -- | Stores additional Babel-specific properties (such as event metadata).
    contentExtension :: (Core.Maybe ChatContentExtension),
    -- | Stores the delivery source of messages (such as phone number for SMS).
    deliveryMedium :: (Core.Maybe DeliveryMedium),
    -- | Primary identifier used by Hangouts Classic for its events (messages).
    eventId :: (Core.Maybe Core.Text),
    -- | Stores message segments (text content) and attachments (media URLs).
    messageContent :: (Core.Maybe ChatConserverMessageContent),
    -- | Whether or not these message properties were backfilled by go\/dinnertrain.
    wasUpdatedByBackfill :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'BabelMessageProps' with the minimum fields required to make a request.
newBabelMessageProps ::
  BabelMessageProps
newBabelMessageProps =
  BabelMessageProps
    { clientGeneratedId = Core.Nothing,
      contentExtension = Core.Nothing,
      deliveryMedium = Core.Nothing,
      eventId = Core.Nothing,
      messageContent = Core.Nothing,
      wasUpdatedByBackfill = Core.Nothing
    }

instance Core.FromJSON BabelMessageProps where
  parseJSON =
    Core.withObject
      "BabelMessageProps"
      ( \o ->
          BabelMessageProps
            Core.<$> ( o Core..:? "clientGeneratedId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "contentExtension")
            Core.<*> (o Core..:? "deliveryMedium")
            Core.<*> (o Core..:? "eventId")
            Core.<*> (o Core..:? "messageContent")
            Core.<*> (o Core..:? "wasUpdatedByBackfill")
      )

instance Core.ToJSON BabelMessageProps where
  toJSON BabelMessageProps {..} =
    Core.object
      ( Core.catMaybes
          [ ("clientGeneratedId" Core..=) Core.. Core.AsText
              Core.<$> clientGeneratedId,
            ("contentExtension" Core..=)
              Core.<$> contentExtension,
            ("deliveryMedium" Core..=) Core.<$> deliveryMedium,
            ("eventId" Core..=) Core.<$> eventId,
            ("messageContent" Core..=) Core.<$> messageContent,
            ("wasUpdatedByBackfill" Core..=)
              Core.<$> wasUpdatedByBackfill
          ]
      )

-- | Annotation metadata for Babel-only items that signals which type of placeholder message should be displayed in Babel clients.
--
-- /See:/ 'newBabelPlaceholderMetadata' smart constructor.
data BabelPlaceholderMetadata = BabelPlaceholderMetadata
  { -- |
    deleteMetadata :: (Core.Maybe DeleteMetadata),
    -- |
    editMetadata :: (Core.Maybe EditMetadata),
    -- |
    hangoutVideoMetadata :: (Core.Maybe HangoutVideoEventMetadata)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'BabelPlaceholderMetadata' with the minimum fields required to make a request.
newBabelPlaceholderMetadata ::
  BabelPlaceholderMetadata
newBabelPlaceholderMetadata =
  BabelPlaceholderMetadata
    { deleteMetadata = Core.Nothing,
      editMetadata = Core.Nothing,
      hangoutVideoMetadata = Core.Nothing
    }

instance Core.FromJSON BabelPlaceholderMetadata where
  parseJSON =
    Core.withObject
      "BabelPlaceholderMetadata"
      ( \o ->
          BabelPlaceholderMetadata
            Core.<$> (o Core..:? "deleteMetadata")
            Core.<*> (o Core..:? "editMetadata")
            Core.<*> (o Core..:? "hangoutVideoMetadata")
      )

instance Core.ToJSON BabelPlaceholderMetadata where
  toJSON BabelPlaceholderMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("deleteMetadata" Core..=) Core.<$> deleteMetadata,
            ("editMetadata" Core..=) Core.<$> editMetadata,
            ("hangoutVideoMetadata" Core..=)
              Core.<$> hangoutVideoMetadata
          ]
      )

-- | Used to provide a search operator for boolean properties. This is optional. Search operators let users restrict the query to specific fields relevant to the type of item being searched.
--
-- /See:/ 'newBooleanOperatorOptions' smart constructor.
newtype BooleanOperatorOptions = BooleanOperatorOptions
  { -- | Indicates the operator name required in the query in order to isolate the boolean property. For example, if operatorName is /closed/ and the property\'s name is /isClosed/, then queries like /closed:\<value>/ show results only where the value of the property named /isClosed/ matches /\<value>/. By contrast, a search that uses the same /\<value>/ without an operator returns all items where /\<value>/ matches the value of any String properties or text within the content field for the item. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.
    operatorName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'BooleanOperatorOptions' with the minimum fields required to make a request.
newBooleanOperatorOptions ::
  BooleanOperatorOptions
newBooleanOperatorOptions = BooleanOperatorOptions {operatorName = Core.Nothing}

instance Core.FromJSON BooleanOperatorOptions where
  parseJSON =
    Core.withObject
      "BooleanOperatorOptions"
      ( \o ->
          BooleanOperatorOptions
            Core.<$> (o Core..:? "operatorName")
      )

instance Core.ToJSON BooleanOperatorOptions where
  toJSON BooleanOperatorOptions {..} =
    Core.object
      ( Core.catMaybes
          [("operatorName" Core..=) Core.<$> operatorName]
      )

-- | The options for boolean properties.
--
-- /See:/ 'newBooleanPropertyOptions' smart constructor.
newtype BooleanPropertyOptions = BooleanPropertyOptions
  { -- | If set, describes how the boolean should be used as a search operator.
    operatorOptions :: (Core.Maybe BooleanOperatorOptions)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'BooleanPropertyOptions' with the minimum fields required to make a request.
newBooleanPropertyOptions ::
  BooleanPropertyOptions
newBooleanPropertyOptions =
  BooleanPropertyOptions {operatorOptions = Core.Nothing}

instance Core.FromJSON BooleanPropertyOptions where
  parseJSON =
    Core.withObject
      "BooleanPropertyOptions"
      ( \o ->
          BooleanPropertyOptions
            Core.<$> (o Core..:? "operatorOptions")
      )

instance Core.ToJSON BooleanPropertyOptions where
  toJSON BooleanPropertyOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("operatorOptions" Core..=)
              Core.<$> operatorOptions
          ]
      )

-- | Represents a complete border style that can be applied to widgets.
--
-- /See:/ 'newBorderStyle' smart constructor.
data BorderStyle = BorderStyle
  { -- | The corner radius for the border.
    cornerRadius :: (Core.Maybe Core.Int32),
    -- | The colors to use when the type is STROKE.
    strokeColor :: (Core.Maybe Core.Text),
    -- | The border type.
    type' :: (Core.Maybe BorderStyle_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'BorderStyle' with the minimum fields required to make a request.
newBorderStyle ::
  BorderStyle
newBorderStyle =
  BorderStyle
    { cornerRadius = Core.Nothing,
      strokeColor = Core.Nothing,
      type' = Core.Nothing
    }

instance Core.FromJSON BorderStyle where
  parseJSON =
    Core.withObject
      "BorderStyle"
      ( \o ->
          BorderStyle
            Core.<$> (o Core..:? "cornerRadius")
            Core.<*> (o Core..:? "strokeColor")
            Core.<*> (o Core..:? "type")
      )

instance Core.ToJSON BorderStyle where
  toJSON BorderStyle {..} =
    Core.object
      ( Core.catMaybes
          [ ("cornerRadius" Core..=) Core.<$> cornerRadius,
            ("strokeColor" Core..=) Core.<$> strokeColor,
            ("type" Core..=) Core.<$> type'
          ]
      )

-- | Bot-specific profile information.
--
-- /See:/ 'newBotInfo' smart constructor.
data BotInfo = BotInfo
  { -- |
    appAllowlistStatus :: (Core.Maybe BotInfo_AppAllowlistStatus),
    -- | Identifier of the application associated with the bot.
    appId :: (Core.Maybe AppId),
    -- | URL for the avatar picture of the User in dynamite. This field should be populated if the request is FetchBotCategories\/ListBotCatalogEntries
    botAvatarUrl :: (Core.Maybe Core.Text),
    -- | Non-unique, user-defined display name of the Bot. This field should be populated if the request is FetchBotCategories\/ListBotCatalogEntries.
    botName :: (Core.Maybe Core.Text),
    -- | Short description for the bot.
    description :: (Core.Maybe Core.Text),
    -- | Name of bot developer.
    developerName :: (Core.Maybe Core.Text),
    -- | URL for the banner image in GSuite Market Place. The banner will be 220x140.
    marketPlaceBannerUrl :: (Core.Maybe Core.Text),
    -- | Indicates whether bot is enabled\/disabled.
    status :: (Core.Maybe BotInfo_Status),
    -- | If the app supports a home screen.
    supportHomeScreen :: (Core.Maybe Core.Bool),
    -- | Urls with additional information related to the bot. This field should always be set even if all the fields within it are empty, so that it is convenient for clients to work with this field in javascript.
    supportUrls :: (Core.Maybe SupportUrls),
    -- | The supported uses are limited according to the user that made the request. If the user does not have permission to use the bot, the list will be empty. This could occur for non whitelisted bots in the catalog.
    supportedUses :: (Core.Maybe [BotInfo_SupportedUsesItem])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'BotInfo' with the minimum fields required to make a request.
newBotInfo ::
  BotInfo
newBotInfo =
  BotInfo
    { appAllowlistStatus = Core.Nothing,
      appId = Core.Nothing,
      botAvatarUrl = Core.Nothing,
      botName = Core.Nothing,
      description = Core.Nothing,
      developerName = Core.Nothing,
      marketPlaceBannerUrl = Core.Nothing,
      status = Core.Nothing,
      supportHomeScreen = Core.Nothing,
      supportUrls = Core.Nothing,
      supportedUses = Core.Nothing
    }

instance Core.FromJSON BotInfo where
  parseJSON =
    Core.withObject
      "BotInfo"
      ( \o ->
          BotInfo
            Core.<$> (o Core..:? "appAllowlistStatus")
            Core.<*> (o Core..:? "appId")
            Core.<*> (o Core..:? "botAvatarUrl")
            Core.<*> (o Core..:? "botName")
            Core.<*> (o Core..:? "description")
            Core.<*> (o Core..:? "developerName")
            Core.<*> (o Core..:? "marketPlaceBannerUrl")
            Core.<*> (o Core..:? "status")
            Core.<*> (o Core..:? "supportHomeScreen")
            Core.<*> (o Core..:? "supportUrls")
            Core.<*> (o Core..:? "supportedUses")
      )

instance Core.ToJSON BotInfo where
  toJSON BotInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("appAllowlistStatus" Core..=)
              Core.<$> appAllowlistStatus,
            ("appId" Core..=) Core.<$> appId,
            ("botAvatarUrl" Core..=) Core.<$> botAvatarUrl,
            ("botName" Core..=) Core.<$> botName,
            ("description" Core..=) Core.<$> description,
            ("developerName" Core..=) Core.<$> developerName,
            ("marketPlaceBannerUrl" Core..=)
              Core.<$> marketPlaceBannerUrl,
            ("status" Core..=) Core.<$> status,
            ("supportHomeScreen" Core..=)
              Core.<$> supportHomeScreen,
            ("supportUrls" Core..=) Core.<$> supportUrls,
            ("supportedUses" Core..=) Core.<$> supportedUses
          ]
      )

-- | Information about a bot response, branched from shared\/bot_response.proto without frontend User proto as we never store it.
--
-- /See:/ 'newBotResponse' smart constructor.
data BotResponse = BotResponse
  { -- |
    botId :: (Core.Maybe UserId),
    -- |
    requiredAction :: (Core.Maybe BotResponse_RequiredAction),
    -- |
    responseType :: (Core.Maybe BotResponse_ResponseType),
    -- | URL for setting up bot.
    setupUrl :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'BotResponse' with the minimum fields required to make a request.
newBotResponse ::
  BotResponse
newBotResponse =
  BotResponse
    { botId = Core.Nothing,
      requiredAction = Core.Nothing,
      responseType = Core.Nothing,
      setupUrl = Core.Nothing
    }

instance Core.FromJSON BotResponse where
  parseJSON =
    Core.withObject
      "BotResponse"
      ( \o ->
          BotResponse
            Core.<$> (o Core..:? "botId")
            Core.<*> (o Core..:? "requiredAction")
            Core.<*> (o Core..:? "responseType")
            Core.<*> (o Core..:? "setupUrl")
      )

instance Core.ToJSON BotResponse where
  toJSON BotResponse {..} =
    Core.object
      ( Core.catMaybes
          [ ("botId" Core..=) Core.<$> botId,
            ("requiredAction" Core..=) Core.<$> requiredAction,
            ("responseType" Core..=) Core.<$> responseType,
            ("setupUrl" Core..=) Core.<$> setupUrl
          ]
      )

-- | Broadcast access information of a meeting space.
--
-- /See:/ 'newBroadcastAccess' smart constructor.
data BroadcastAccess = BroadcastAccess
  { -- | The policy that controls the broadcast\'s viewer access.
    accessPolicy :: (Core.Maybe BroadcastAccess_AccessPolicy),
    -- | A URL that can be used to access the broadcast of the meeting. This field will be empty if broadcast is not enabled. It will be populated by the backend. Clients cannot modify the value.
    viewUrl :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'BroadcastAccess' with the minimum fields required to make a request.
newBroadcastAccess ::
  BroadcastAccess
newBroadcastAccess =
  BroadcastAccess {accessPolicy = Core.Nothing, viewUrl = Core.Nothing}

instance Core.FromJSON BroadcastAccess where
  parseJSON =
    Core.withObject
      "BroadcastAccess"
      ( \o ->
          BroadcastAccess
            Core.<$> (o Core..:? "accessPolicy")
            Core.<*> (o Core..:? "viewUrl")
      )

instance Core.ToJSON BroadcastAccess where
  toJSON BroadcastAccess {..} =
    Core.object
      ( Core.catMaybes
          [ ("accessPolicy" Core..=) Core.<$> accessPolicy,
            ("viewUrl" Core..=) Core.<$> viewUrl
          ]
      )

-- | Information about a broadcast session.
--
-- /See:/ 'newBroadcastSessionInfo' smart constructor.
data BroadcastSessionInfo = BroadcastSessionInfo
  { -- | A unique server-generated ID for the broadcast session.
    broadcastSessionId :: (Core.Maybe Core.Text),
    -- | Output only. Current broadcast session\'s statistics.
    broadcastStats :: (Core.Maybe BroadcastStats),
    -- | Input only. Deprecated field, should not be used.
    ingestionId :: (Core.Maybe Core.Text),
    -- | Broadcast session\'s state information.
    sessionStateInfo :: (Core.Maybe SessionStateInfo)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'BroadcastSessionInfo' with the minimum fields required to make a request.
newBroadcastSessionInfo ::
  BroadcastSessionInfo
newBroadcastSessionInfo =
  BroadcastSessionInfo
    { broadcastSessionId = Core.Nothing,
      broadcastStats = Core.Nothing,
      ingestionId = Core.Nothing,
      sessionStateInfo = Core.Nothing
    }

instance Core.FromJSON BroadcastSessionInfo where
  parseJSON =
    Core.withObject
      "BroadcastSessionInfo"
      ( \o ->
          BroadcastSessionInfo
            Core.<$> (o Core..:? "broadcastSessionId")
            Core.<*> (o Core..:? "broadcastStats")
            Core.<*> (o Core..:? "ingestionId")
            Core.<*> (o Core..:? "sessionStateInfo")
      )

instance Core.ToJSON BroadcastSessionInfo where
  toJSON BroadcastSessionInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("broadcastSessionId" Core..=)
              Core.<$> broadcastSessionId,
            ("broadcastStats" Core..=) Core.<$> broadcastStats,
            ("ingestionId" Core..=) Core.<$> ingestionId,
            ("sessionStateInfo" Core..=)
              Core.<$> sessionStateInfo
          ]
      )

-- | Statistics of the broadcast session.
--
-- /See:/ 'newBroadcastStats' smart constructor.
newtype BroadcastStats = BroadcastStats
  { -- | Estimated concurrent viewer count.
    estimatedViewerCount :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'BroadcastStats' with the minimum fields required to make a request.
newBroadcastStats ::
  BroadcastStats
newBroadcastStats = BroadcastStats {estimatedViewerCount = Core.Nothing}

instance Core.FromJSON BroadcastStats where
  parseJSON =
    Core.withObject
      "BroadcastStats"
      ( \o ->
          BroadcastStats
            Core.<$> ( o Core..:? "estimatedViewerCount"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON BroadcastStats where
  toJSON BroadcastStats {..} =
    Core.object
      ( Core.catMaybes
          [ ("estimatedViewerCount" Core..=) Core.. Core.AsText
              Core.<$> estimatedViewerCount
          ]
      )

--
-- /See:/ 'newButton' smart constructor.
data Button = Button
  { -- |
    imageButton :: (Core.Maybe ImageButton),
    -- |
    textButton :: (Core.Maybe TextButton)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Button' with the minimum fields required to make a request.
newButton ::
  Button
newButton = Button {imageButton = Core.Nothing, textButton = Core.Nothing}

instance Core.FromJSON Button where
  parseJSON =
    Core.withObject
      "Button"
      ( \o ->
          Button
            Core.<$> (o Core..:? "imageButton")
            Core.<*> (o Core..:? "textButton")
      )

instance Core.ToJSON Button where
  toJSON Button {..} =
    Core.object
      ( Core.catMaybes
          [ ("imageButton" Core..=) Core.<$> imageButton,
            ("textButton" Core..=) Core.<$> textButton
          ]
      )

--
-- /See:/ 'newCalendarClientActionMarkup' smart constructor.
data CalendarClientActionMarkup = CalendarClientActionMarkup
  { -- | An action that adds attachments to the Google Calendar event.
    addAttachmentsActionMarkup ::
      ( Core.Maybe
          AppsExtensionsMarkupCalendarClientActionMarkupAddAttachmentsActionMarkup
      ),
    -- | An action that adds attendees to the Google Calendar event.
    editAttendeesActionMarkup ::
      ( Core.Maybe
          AppsExtensionsMarkupCalendarClientActionMarkupEditAttendeesActionMarkup
      ),
    -- | An action that adds conference data to the Google Calendar event.
    editConferenceDataActionMarkup ::
      ( Core.Maybe
          AppsExtensionsMarkupCalendarClientActionMarkupEditConferenceDataActionMarkup
      )
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'CalendarClientActionMarkup' with the minimum fields required to make a request.
newCalendarClientActionMarkup ::
  CalendarClientActionMarkup
newCalendarClientActionMarkup =
  CalendarClientActionMarkup
    { addAttachmentsActionMarkup = Core.Nothing,
      editAttendeesActionMarkup = Core.Nothing,
      editConferenceDataActionMarkup = Core.Nothing
    }

instance Core.FromJSON CalendarClientActionMarkup where
  parseJSON =
    Core.withObject
      "CalendarClientActionMarkup"
      ( \o ->
          CalendarClientActionMarkup
            Core.<$> (o Core..:? "addAttachmentsActionMarkup")
            Core.<*> (o Core..:? "editAttendeesActionMarkup")
            Core.<*> (o Core..:? "editConferenceDataActionMarkup")
      )

instance Core.ToJSON CalendarClientActionMarkup where
  toJSON CalendarClientActionMarkup {..} =
    Core.object
      ( Core.catMaybes
          [ ("addAttachmentsActionMarkup" Core..=)
              Core.<$> addAttachmentsActionMarkup,
            ("editAttendeesActionMarkup" Core..=)
              Core.<$> editAttendeesActionMarkup,
            ("editConferenceDataActionMarkup" Core..=)
              Core.<$> editConferenceDataActionMarkup
          ]
      )

-- | Contains information regarding an ongoing conference (aka call) for a meeting space.
--
-- /See:/ 'newCallInfo' smart constructor.
data CallInfo = CallInfo
  { -- | Abuse reporting configuration for the ongoing conference.
    abuseReportingConfig :: (Core.Maybe AbuseReportingConfig),
    -- | Output only. Display name of the owner of artifacts generated in this conference. The expected use of this in clients is to present info like \"This recording will be sent to John Doe\'s Drive\". This field can be empty if preferred display name determination fails for any reason.
    artifactOwner :: (Core.Maybe UserDisplayInfo),
    -- | Output only. Documents attached to an ongoing conference.
    attachedDocuments :: (Core.Maybe [DocumentInfo]),
    -- | List of available access types of the conference.
    availableAccessTypes :: (Core.Maybe [CallInfo_AvailableAccessTypesItem]),
    -- | Output only. The set of reactions that clients are allowed to send and can expect to receive. Note that a device in the conference should have the MAY/SEND/REACTIONS privilege to be able to send reactions.
    availableReactions :: (Core.Maybe [ReactionInfo]),
    -- | Information about active broadcast session in the ongoing conference.
    broadcastSessionInfo :: (Core.Maybe BroadcastSessionInfo),
    -- | Output only. The calendar event ID of a Google Calendar event that the meeting space is associated with. If the meeting space is not associated with an event in Google Calendar, this field is empty. For recurring events, it refers to the recurring instance associated with the current call, as determined by the server.
    calendarEventId :: (Core.Maybe Core.Text),
    -- | The current co-activity session, or unset if there is none in progress. A co-activity session can be initiated by devices in JOINED state . Initiator of the co-activity is expected to populate this field to start the session. Once clients detect that the co-activity has finished, any JOINED device can clear this field to end the co-activity session. In the case of switching activities, the initiator of the new activity merely needs to override this with the new co-activity data, and all connected clients are expected to handle the transition gracefully.
    coActivity :: (Core.Maybe CoActivity),
    -- | The current collaboration session, or unset if no collaboration is in progress.
    collaboration :: (Core.Maybe Collaboration),
    -- | CSE information for the ongoing conference.
    cseInfo :: (Core.Maybe CseInfo),
    -- | Output only. The maximum number of devices that may be in the joined state simultaneously in this conference. This can be used by clients to guess whether it will be possible to join, but the only way to know is to try to join. It can also be used to inform users about the limit that is in effect. This limit is normally set when the conference is created and not changed during the lifetime of the conference. But there are some cases where it may change, so clients should be aware that the information may be stale.
    maxJoinedDevices :: (Core.Maybe Core.Int32),
    -- | Output only. The name or description of the organization or domain that the organizer belongs to. The expected use of this in clients is to present messages like \"John Doe (outside of Google.com) is trying to join this call\", where \"Google.com\" is the organization name. The field will be empty if the organization name could not be determined, possibly because of a backend error.
    organizationName :: (Core.Maybe Core.Text),
    -- | Paygate information to clients.
    paygateInfo :: (Core.Maybe PaygateInfo),
    -- | The current presenter in the call, or unset if there is no current presenter. Clients can set this to change the presenter.
    presenter :: (Core.Maybe Presenter),
    -- | Deprecated, use RecordingSessionInfo instead. Info about recording for this conference. This will always be set in server responses, with a valid recording status. This is superseded by streaming_sessions field, which contains the same information about this recording as well as additional information about other application type at the same time. This will be deprecated and removed at some point.
    recordingInfo :: (Core.Maybe RecordingInfo),
    -- | Information about active recording session in the ongoing conference.
    recordingSessionInfo :: (Core.Maybe RecordingSessionInfo),
    -- | Settings of the ongoing conference.
    settings :: (Core.Maybe CallSettings),
    -- | Output only. Info about streaming sessions (recording or broadcast) for this conference. This should contain all active sessions. Currently, it\'s guaranteed to have at most one recording and at most one broadcast (at most two sessions in total). For each application type (recording or broadcast), latest inactive session is included if there\'s no active one.
    streamingSessions :: (Core.Maybe [StreamingSessionInfo]),
    -- | Information about active transcription session in the ongoing conference.
    transcriptionSessionInfo :: (Core.Maybe TranscriptionSessionInfo),
    -- | The number of devices viewing the conference - MeetingDevices that are in VIEWER role and JOINED state in the conference.
    viewerCount :: (Core.Maybe Core.Int32),
    -- | Information about active YouTube broadcast sessions in the ongoing conference.
    youTubeBroadcastSessionInfos :: (Core.Maybe [YouTubeBroadcastSessionInfo])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'CallInfo' with the minimum fields required to make a request.
newCallInfo ::
  CallInfo
newCallInfo =
  CallInfo
    { abuseReportingConfig = Core.Nothing,
      artifactOwner = Core.Nothing,
      attachedDocuments = Core.Nothing,
      availableAccessTypes = Core.Nothing,
      availableReactions = Core.Nothing,
      broadcastSessionInfo = Core.Nothing,
      calendarEventId = Core.Nothing,
      coActivity = Core.Nothing,
      collaboration = Core.Nothing,
      cseInfo = Core.Nothing,
      maxJoinedDevices = Core.Nothing,
      organizationName = Core.Nothing,
      paygateInfo = Core.Nothing,
      presenter = Core.Nothing,
      recordingInfo = Core.Nothing,
      recordingSessionInfo = Core.Nothing,
      settings = Core.Nothing,
      streamingSessions = Core.Nothing,
      transcriptionSessionInfo = Core.Nothing,
      viewerCount = Core.Nothing,
      youTubeBroadcastSessionInfos = Core.Nothing
    }

instance Core.FromJSON CallInfo where
  parseJSON =
    Core.withObject
      "CallInfo"
      ( \o ->
          CallInfo
            Core.<$> (o Core..:? "abuseReportingConfig")
            Core.<*> (o Core..:? "artifactOwner")
            Core.<*> (o Core..:? "attachedDocuments")
            Core.<*> (o Core..:? "availableAccessTypes")
            Core.<*> (o Core..:? "availableReactions")
            Core.<*> (o Core..:? "broadcastSessionInfo")
            Core.<*> (o Core..:? "calendarEventId")
            Core.<*> (o Core..:? "coActivity")
            Core.<*> (o Core..:? "collaboration")
            Core.<*> (o Core..:? "cseInfo")
            Core.<*> (o Core..:? "maxJoinedDevices")
            Core.<*> (o Core..:? "organizationName")
            Core.<*> (o Core..:? "paygateInfo")
            Core.<*> (o Core..:? "presenter")
            Core.<*> (o Core..:? "recordingInfo")
            Core.<*> (o Core..:? "recordingSessionInfo")
            Core.<*> (o Core..:? "settings")
            Core.<*> (o Core..:? "streamingSessions")
            Core.<*> (o Core..:? "transcriptionSessionInfo")
            Core.<*> (o Core..:? "viewerCount")
            Core.<*> (o Core..:? "youTubeBroadcastSessionInfos")
      )

instance Core.ToJSON CallInfo where
  toJSON CallInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("abuseReportingConfig" Core..=)
              Core.<$> abuseReportingConfig,
            ("artifactOwner" Core..=) Core.<$> artifactOwner,
            ("attachedDocuments" Core..=)
              Core.<$> attachedDocuments,
            ("availableAccessTypes" Core..=)
              Core.<$> availableAccessTypes,
            ("availableReactions" Core..=)
              Core.<$> availableReactions,
            ("broadcastSessionInfo" Core..=)
              Core.<$> broadcastSessionInfo,
            ("calendarEventId" Core..=) Core.<$> calendarEventId,
            ("coActivity" Core..=) Core.<$> coActivity,
            ("collaboration" Core..=) Core.<$> collaboration,
            ("cseInfo" Core..=) Core.<$> cseInfo,
            ("maxJoinedDevices" Core..=)
              Core.<$> maxJoinedDevices,
            ("organizationName" Core..=)
              Core.<$> organizationName,
            ("paygateInfo" Core..=) Core.<$> paygateInfo,
            ("presenter" Core..=) Core.<$> presenter,
            ("recordingInfo" Core..=) Core.<$> recordingInfo,
            ("recordingSessionInfo" Core..=)
              Core.<$> recordingSessionInfo,
            ("settings" Core..=) Core.<$> settings,
            ("streamingSessions" Core..=)
              Core.<$> streamingSessions,
            ("transcriptionSessionInfo" Core..=)
              Core.<$> transcriptionSessionInfo,
            ("viewerCount" Core..=) Core.<$> viewerCount,
            ("youTubeBroadcastSessionInfos" Core..=)
              Core.<$> youTubeBroadcastSessionInfos
          ]
      )

-- | Effective settings of the ongoing conference.
--
-- /See:/ 'newCallSettings' smart constructor.
data CallSettings = CallSettings
  { -- | Indicates whether the access lock is currently on or off.
    accessLock :: (Core.Maybe Core.Bool),
    -- | The current access type of the conference.
    accessType :: (Core.Maybe CallSettings_AccessType),
    -- | Whether users can join this conference before a host (Host or Cohost).
    allowJoiningBeforeHost :: (Core.Maybe Core.Bool),
    -- | Indicates whether the attendance report is currently enabled or disabled.
    attendanceReportEnabled :: (Core.Maybe Core.Bool),
    -- | Indicates whether the audio lock is currently on or off.
    audioLock :: (Core.Maybe Core.Bool),
    -- | Indicates whether the chat lock is currently on or off.
    chatLock :: (Core.Maybe Core.Bool),
    -- | Whether Client-side Encryption is enabled for this conference.
    cseEnabled :: (Core.Maybe Core.Bool),
    -- | Indicates whether moderation is currently on or off.
    moderationEnabled :: (Core.Maybe Core.Bool),
    -- | Indicates whether the present lock is currently on or off.
    presentLock :: (Core.Maybe Core.Bool),
    -- | Indicates whether the reactions lock is currently on or off.
    reactionsLock :: (Core.Maybe Core.Bool),
    -- | Indicates whether the video lock is currently on or off.
    videoLock :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'CallSettings' with the minimum fields required to make a request.
newCallSettings ::
  CallSettings
newCallSettings =
  CallSettings
    { accessLock = Core.Nothing,
      accessType = Core.Nothing,
      allowJoiningBeforeHost = Core.Nothing,
      attendanceReportEnabled = Core.Nothing,
      audioLock = Core.Nothing,
      chatLock = Core.Nothing,
      cseEnabled = Core.Nothing,
      moderationEnabled = Core.Nothing,
      presentLock = Core.Nothing,
      reactionsLock = Core.Nothing,
      videoLock = Core.Nothing
    }

instance Core.FromJSON CallSettings where
  parseJSON =
    Core.withObject
      "CallSettings"
      ( \o ->
          CallSettings
            Core.<$> (o Core..:? "accessLock")
            Core.<*> (o Core..:? "accessType")
            Core.<*> (o Core..:? "allowJoiningBeforeHost")
            Core.<*> (o Core..:? "attendanceReportEnabled")
            Core.<*> (o Core..:? "audioLock")
            Core.<*> (o Core..:? "chatLock")
            Core.<*> (o Core..:? "cseEnabled")
            Core.<*> (o Core..:? "moderationEnabled")
            Core.<*> (o Core..:? "presentLock")
            Core.<*> (o Core..:? "reactionsLock")
            Core.<*> (o Core..:? "videoLock")
      )

instance Core.ToJSON CallSettings where
  toJSON CallSettings {..} =
    Core.object
      ( Core.catMaybes
          [ ("accessLock" Core..=) Core.<$> accessLock,
            ("accessType" Core..=) Core.<$> accessType,
            ("allowJoiningBeforeHost" Core..=)
              Core.<$> allowJoiningBeforeHost,
            ("attendanceReportEnabled" Core..=)
              Core.<$> attendanceReportEnabled,
            ("audioLock" Core..=) Core.<$> audioLock,
            ("chatLock" Core..=) Core.<$> chatLock,
            ("cseEnabled" Core..=) Core.<$> cseEnabled,
            ("moderationEnabled" Core..=)
              Core.<$> moderationEnabled,
            ("presentLock" Core..=) Core.<$> presentLock,
            ("reactionsLock" Core..=) Core.<$> reactionsLock,
            ("videoLock" Core..=) Core.<$> videoLock
          ]
      )

-- | Represents a principal which possesses a particular secret string whose cryptographic hash is specified here. CapTokens (\"Capability Tokens\") are used in ACLProto. It\'s expected that ACLs with CapTokenHolders will strongly enforce them by Keystore-wrapping crypto keys for the corresponding CapTokens.
--
-- /See:/ 'newCapTokenHolderProto' smart constructor.
newtype CapTokenHolderProto = CapTokenHolderProto
  { -- | The hash of the corresponding capability token. The value is defined to be identical to the one in acl.proto\'s CapTokenMetadata: 10-byte prefix of HMAC-SHA1 of the token. The HMAC key is the following fixed (non-secret) 512-bit value: 79b1c8f4 82baf523 b8a9ab4a e960f438 c45be041 11f1f222 e8a3f64d aeb05e3d c3576acc ec649194 aede422c 4e48e0d1 ff21234a a6ed6b49 a7fa592e efd7bba3
    tokenHmacSha1Prefix :: (Core.Maybe Core.Base64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'CapTokenHolderProto' with the minimum fields required to make a request.
newCapTokenHolderProto ::
  CapTokenHolderProto
newCapTokenHolderProto =
  CapTokenHolderProto {tokenHmacSha1Prefix = Core.Nothing}

instance Core.FromJSON CapTokenHolderProto where
  parseJSON =
    Core.withObject
      "CapTokenHolderProto"
      ( \o ->
          CapTokenHolderProto
            Core.<$> (o Core..:? "tokenHmacSha1Prefix")
      )

instance Core.ToJSON CapTokenHolderProto where
  toJSON CapTokenHolderProto {..} =
    Core.object
      ( Core.catMaybes
          [ ("tokenHmacSha1Prefix" Core..=)
              Core.<$> tokenHmacSha1Prefix
          ]
      )

--
-- /See:/ 'newCard' smart constructor.
data Card = Card
  { -- |
    cardActions :: (Core.Maybe [CardAction]),
    -- |
    displayStyle :: (Core.Maybe Card_DisplayStyle),
    -- |
    fixedFooter :: (Core.Maybe FixedFooter),
    -- |
    header :: (Core.Maybe CardHeader),
    -- | Name of the card used in CardNavigation.pop/to/card_name.
    name :: (Core.Maybe Core.Text),
    -- | When displaying contextual content, the peek card header acts as a placeholder so that the user can navigate forward between the homepage cards and the contextual cards.
    peekCardHeader :: (Core.Maybe CardHeader),
    -- |
    sections :: (Core.Maybe [Section])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Card' with the minimum fields required to make a request.
newCard ::
  Card
newCard =
  Card
    { cardActions = Core.Nothing,
      displayStyle = Core.Nothing,
      fixedFooter = Core.Nothing,
      header = Core.Nothing,
      name = Core.Nothing,
      peekCardHeader = Core.Nothing,
      sections = Core.Nothing
    }

instance Core.FromJSON Card where
  parseJSON =
    Core.withObject
      "Card"
      ( \o ->
          Card
            Core.<$> (o Core..:? "cardActions")
            Core.<*> (o Core..:? "displayStyle")
            Core.<*> (o Core..:? "fixedFooter")
            Core.<*> (o Core..:? "header")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "peekCardHeader")
            Core.<*> (o Core..:? "sections")
      )

instance Core.ToJSON Card where
  toJSON Card {..} =
    Core.object
      ( Core.catMaybes
          [ ("cardActions" Core..=) Core.<$> cardActions,
            ("displayStyle" Core..=) Core.<$> displayStyle,
            ("fixedFooter" Core..=) Core.<$> fixedFooter,
            ("header" Core..=) Core.<$> header,
            ("name" Core..=) Core.<$> name,
            ("peekCardHeader" Core..=) Core.<$> peekCardHeader,
            ("sections" Core..=) Core.<$> sections
          ]
      )

-- | When an AddOn Card is shown in detailed view, a card action is the action associated with the card. For an invoice card, a typical action would be: delete invoice, email invoice or open the invoice in browser.
--
-- /See:/ 'newCardAction' smart constructor.
data CardAction = CardAction
  { -- | The label used to be displayed in the action menu item.
    actionLabel :: (Core.Maybe Core.Text),
    -- |
    onClick :: (Core.Maybe OnClick)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'CardAction' with the minimum fields required to make a request.
newCardAction ::
  CardAction
newCardAction = CardAction {actionLabel = Core.Nothing, onClick = Core.Nothing}

instance Core.FromJSON CardAction where
  parseJSON =
    Core.withObject
      "CardAction"
      ( \o ->
          CardAction
            Core.<$> (o Core..:? "actionLabel")
            Core.<*> (o Core..:? "onClick")
      )

instance Core.ToJSON CardAction where
  toJSON CardAction {..} =
    Core.object
      ( Core.catMaybes
          [ ("actionLabel" Core..=) Core.<$> actionLabel,
            ("onClick" Core..=) Core.<$> onClick
          ]
      )

--
-- /See:/ 'newCardCapabilityMetadata' smart constructor.
newtype CardCapabilityMetadata = CardCapabilityMetadata
  { -- | NEXT TAG : 2
    requiredCapabilities :: (Core.Maybe [CardCapabilityMetadata_RequiredCapabilitiesItem])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'CardCapabilityMetadata' with the minimum fields required to make a request.
newCardCapabilityMetadata ::
  CardCapabilityMetadata
newCardCapabilityMetadata =
  CardCapabilityMetadata {requiredCapabilities = Core.Nothing}

instance Core.FromJSON CardCapabilityMetadata where
  parseJSON =
    Core.withObject
      "CardCapabilityMetadata"
      ( \o ->
          CardCapabilityMetadata
            Core.<$> (o Core..:? "requiredCapabilities")
      )

instance Core.ToJSON CardCapabilityMetadata where
  toJSON CardCapabilityMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("requiredCapabilities" Core..=)
              Core.<$> requiredCapabilities
          ]
      )

--
-- /See:/ 'newCardHeader' smart constructor.
data CardHeader = CardHeader
  { -- | The alternative text of this image which will be used for accessibility.
    imageAltText :: (Core.Maybe Core.Text),
    -- |
    imageStyle :: (Core.Maybe CardHeader_ImageStyle),
    -- |
    imageUrl :: (Core.Maybe Core.Text),
    -- |
    subtitle :: (Core.Maybe Core.Text),
    -- | The title must be specified. The header has a fixed height: if both a title and subtitle is specified, each will take up 1 line. If only the title is specified, it will take up both lines. The header is rendered in collapsed and detailed view.
    title :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'CardHeader' with the minimum fields required to make a request.
newCardHeader ::
  CardHeader
newCardHeader =
  CardHeader
    { imageAltText = Core.Nothing,
      imageStyle = Core.Nothing,
      imageUrl = Core.Nothing,
      subtitle = Core.Nothing,
      title = Core.Nothing
    }

instance Core.FromJSON CardHeader where
  parseJSON =
    Core.withObject
      "CardHeader"
      ( \o ->
          CardHeader
            Core.<$> (o Core..:? "imageAltText")
            Core.<*> (o Core..:? "imageStyle")
            Core.<*> (o Core..:? "imageUrl")
            Core.<*> (o Core..:? "subtitle")
            Core.<*> (o Core..:? "title")
      )

instance Core.ToJSON CardHeader where
  toJSON CardHeader {..} =
    Core.object
      ( Core.catMaybes
          [ ("imageAltText" Core..=) Core.<$> imageAltText,
            ("imageStyle" Core..=) Core.<$> imageStyle,
            ("imageUrl" Core..=) Core.<$> imageUrl,
            ("subtitle" Core..=) Core.<$> subtitle,
            ("title" Core..=) Core.<$> title
          ]
      )

--
-- /See:/ 'newCaribouAttributeValue' smart constructor.
data CaribouAttributeValue = CaribouAttributeValue
  { -- | Tags 1 through 15 are reserved for the most commonly used fields.
    booleanValue :: (Core.Maybe Core.Bool),
    -- |
    intValue :: (Core.Maybe Core.Int32),
    -- |
    longValue :: (Core.Maybe Core.Int64),
    -- | Generally, applications should avoid storing raw bytes and instead store structured data as protocol buffer extensions. This both reduces the amount of ad-hoc attribute parsing code as well as eliminates an intermediate copy of the data when deserializing the value. The rawByteValue field is mainly provided for compatibility with attributes stored before the introduction of the Attribute.Value.
    rawByteValue :: (Core.Maybe Core.Base64),
    -- |
    stringValue :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'CaribouAttributeValue' with the minimum fields required to make a request.
newCaribouAttributeValue ::
  CaribouAttributeValue
newCaribouAttributeValue =
  CaribouAttributeValue
    { booleanValue = Core.Nothing,
      intValue = Core.Nothing,
      longValue = Core.Nothing,
      rawByteValue = Core.Nothing,
      stringValue = Core.Nothing
    }

instance Core.FromJSON CaribouAttributeValue where
  parseJSON =
    Core.withObject
      "CaribouAttributeValue"
      ( \o ->
          CaribouAttributeValue
            Core.<$> (o Core..:? "booleanValue")
            Core.<*> (o Core..:? "intValue")
            Core.<*> ( o Core..:? "longValue"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "rawByteValue")
            Core.<*> (o Core..:? "stringValue")
      )

instance Core.ToJSON CaribouAttributeValue where
  toJSON CaribouAttributeValue {..} =
    Core.object
      ( Core.catMaybes
          [ ("booleanValue" Core..=) Core.<$> booleanValue,
            ("intValue" Core..=) Core.<$> intValue,
            ("longValue" Core..=) Core.. Core.AsText
              Core.<$> longValue,
            ("rawByteValue" Core..=) Core.<$> rawByteValue,
            ("stringValue" Core..=) Core.<$> stringValue
          ]
      )

-- | Actions handled by Chat Clients.
--
-- /See:/ 'newChatClientActionMarkup' smart constructor.
data ChatClientActionMarkup = ChatClientActionMarkup
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ChatClientActionMarkup' with the minimum fields required to make a request.
newChatClientActionMarkup ::
  ChatClientActionMarkup
newChatClientActionMarkup = ChatClientActionMarkup

instance Core.FromJSON ChatClientActionMarkup where
  parseJSON =
    Core.withObject
      "ChatClientActionMarkup"
      (\o -> Core.pure ChatClientActionMarkup)

instance Core.ToJSON ChatClientActionMarkup where
  toJSON = Core.const Core.emptyObject

-- | Metadata used as inputs to the localization that is performed on Dynamite-originated messages that are incompatible with Hangouts clients. See go\/localization-of-system-messages for more details.
--
-- /See:/ 'newChatConserverDynamitePlaceholderMetadata' smart constructor.
data ChatConserverDynamitePlaceholderMetadata = ChatConserverDynamitePlaceholderMetadata
  { -- |
    attachmentMetadata ::
      ( Core.Maybe
          ChatConserverDynamitePlaceholderMetadataAttachmentMetadata
      ),
    -- |
    botMessageMetadata ::
      ( Core.Maybe
          ChatConserverDynamitePlaceholderMetadataBotMessageMetadata
      ),
    -- |
    calendarEventMetadata ::
      ( Core.Maybe
          ChatConserverDynamitePlaceholderMetadataCalendarEventMetadata
      ),
    -- |
    deleteMetadata :: (Core.Maybe ChatConserverDynamitePlaceholderMetadataDeleteMetadata),
    -- |
    editMetadata :: (Core.Maybe ChatConserverDynamitePlaceholderMetadataEditMetadata),
    -- | The space URL embedded in the localized string.
    spaceUrl :: (Core.Maybe Core.Text),
    -- |
    tasksMetadata :: (Core.Maybe ChatConserverDynamitePlaceholderMetadataTasksMetadata),
    -- |
    videoCallMetadata ::
      ( Core.Maybe
          ChatConserverDynamitePlaceholderMetadataVideoCallMetadata
      )
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ChatConserverDynamitePlaceholderMetadata' with the minimum fields required to make a request.
newChatConserverDynamitePlaceholderMetadata ::
  ChatConserverDynamitePlaceholderMetadata
newChatConserverDynamitePlaceholderMetadata =
  ChatConserverDynamitePlaceholderMetadata
    { attachmentMetadata = Core.Nothing,
      botMessageMetadata = Core.Nothing,
      calendarEventMetadata = Core.Nothing,
      deleteMetadata = Core.Nothing,
      editMetadata = Core.Nothing,
      spaceUrl = Core.Nothing,
      tasksMetadata = Core.Nothing,
      videoCallMetadata = Core.Nothing
    }

instance
  Core.FromJSON
    ChatConserverDynamitePlaceholderMetadata
  where
  parseJSON =
    Core.withObject
      "ChatConserverDynamitePlaceholderMetadata"
      ( \o ->
          ChatConserverDynamitePlaceholderMetadata
            Core.<$> (o Core..:? "attachmentMetadata")
            Core.<*> (o Core..:? "botMessageMetadata")
            Core.<*> (o Core..:? "calendarEventMetadata")
            Core.<*> (o Core..:? "deleteMetadata")
            Core.<*> (o Core..:? "editMetadata")
            Core.<*> (o Core..:? "spaceUrl")
            Core.<*> (o Core..:? "tasksMetadata")
            Core.<*> (o Core..:? "videoCallMetadata")
      )

instance
  Core.ToJSON
    ChatConserverDynamitePlaceholderMetadata
  where
  toJSON ChatConserverDynamitePlaceholderMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("attachmentMetadata" Core..=)
              Core.<$> attachmentMetadata,
            ("botMessageMetadata" Core..=)
              Core.<$> botMessageMetadata,
            ("calendarEventMetadata" Core..=)
              Core.<$> calendarEventMetadata,
            ("deleteMetadata" Core..=) Core.<$> deleteMetadata,
            ("editMetadata" Core..=) Core.<$> editMetadata,
            ("spaceUrl" Core..=) Core.<$> spaceUrl,
            ("tasksMetadata" Core..=) Core.<$> tasksMetadata,
            ("videoCallMetadata" Core..=)
              Core.<$> videoCallMetadata
          ]
      )

-- | An attachment uploaded in Dynamite and its filename.
--
-- /See:/ 'newChatConserverDynamitePlaceholderMetadataAttachmentMetadata' smart constructor.
newtype ChatConserverDynamitePlaceholderMetadataAttachmentMetadata = ChatConserverDynamitePlaceholderMetadataAttachmentMetadata
  { -- |
    filename :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ChatConserverDynamitePlaceholderMetadataAttachmentMetadata' with the minimum fields required to make a request.
newChatConserverDynamitePlaceholderMetadataAttachmentMetadata ::
  ChatConserverDynamitePlaceholderMetadataAttachmentMetadata
newChatConserverDynamitePlaceholderMetadataAttachmentMetadata =
  ChatConserverDynamitePlaceholderMetadataAttachmentMetadata
    { filename = Core.Nothing
    }

instance
  Core.FromJSON
    ChatConserverDynamitePlaceholderMetadataAttachmentMetadata
  where
  parseJSON =
    Core.withObject
      "ChatConserverDynamitePlaceholderMetadataAttachmentMetadata"
      ( \o ->
          ChatConserverDynamitePlaceholderMetadataAttachmentMetadata
            Core.<$> (o Core..:? "filename")
      )

instance
  Core.ToJSON
    ChatConserverDynamitePlaceholderMetadataAttachmentMetadata
  where
  toJSON
    ChatConserverDynamitePlaceholderMetadataAttachmentMetadata {..} =
      Core.object
        ( Core.catMaybes
            [("filename" Core..=) Core.<$> filename]
        )

-- | A bot sent a message in Dynamite.
--
-- /See:/ 'newChatConserverDynamitePlaceholderMetadataBotMessageMetadata' smart constructor.
data ChatConserverDynamitePlaceholderMetadataBotMessageMetadata = ChatConserverDynamitePlaceholderMetadataBotMessageMetadata
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ChatConserverDynamitePlaceholderMetadataBotMessageMetadata' with the minimum fields required to make a request.
newChatConserverDynamitePlaceholderMetadataBotMessageMetadata ::
  ChatConserverDynamitePlaceholderMetadataBotMessageMetadata
newChatConserverDynamitePlaceholderMetadataBotMessageMetadata =
  ChatConserverDynamitePlaceholderMetadataBotMessageMetadata

instance
  Core.FromJSON
    ChatConserverDynamitePlaceholderMetadataBotMessageMetadata
  where
  parseJSON =
    Core.withObject
      "ChatConserverDynamitePlaceholderMetadataBotMessageMetadata"
      ( \o ->
          Core.pure
            ChatConserverDynamitePlaceholderMetadataBotMessageMetadata
      )

instance
  Core.ToJSON
    ChatConserverDynamitePlaceholderMetadataBotMessageMetadata
  where
  toJSON = Core.const Core.emptyObject

-- | A Calendar event message in Dynamite.
--
-- /See:/ 'newChatConserverDynamitePlaceholderMetadataCalendarEventMetadata' smart constructor.
data ChatConserverDynamitePlaceholderMetadataCalendarEventMetadata = ChatConserverDynamitePlaceholderMetadataCalendarEventMetadata
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ChatConserverDynamitePlaceholderMetadataCalendarEventMetadata' with the minimum fields required to make a request.
newChatConserverDynamitePlaceholderMetadataCalendarEventMetadata ::
  ChatConserverDynamitePlaceholderMetadataCalendarEventMetadata
newChatConserverDynamitePlaceholderMetadataCalendarEventMetadata =
  ChatConserverDynamitePlaceholderMetadataCalendarEventMetadata

instance
  Core.FromJSON
    ChatConserverDynamitePlaceholderMetadataCalendarEventMetadata
  where
  parseJSON =
    Core.withObject
      "ChatConserverDynamitePlaceholderMetadataCalendarEventMetadata"
      ( \o ->
          Core.pure
            ChatConserverDynamitePlaceholderMetadataCalendarEventMetadata
      )

instance
  Core.ToJSON
    ChatConserverDynamitePlaceholderMetadataCalendarEventMetadata
  where
  toJSON = Core.const Core.emptyObject

-- | A message was deleted in Dynamite.
--
-- /See:/ 'newChatConserverDynamitePlaceholderMetadataDeleteMetadata' smart constructor.
data ChatConserverDynamitePlaceholderMetadataDeleteMetadata = ChatConserverDynamitePlaceholderMetadataDeleteMetadata
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ChatConserverDynamitePlaceholderMetadataDeleteMetadata' with the minimum fields required to make a request.
newChatConserverDynamitePlaceholderMetadataDeleteMetadata ::
  ChatConserverDynamitePlaceholderMetadataDeleteMetadata
newChatConserverDynamitePlaceholderMetadataDeleteMetadata =
  ChatConserverDynamitePlaceholderMetadataDeleteMetadata

instance
  Core.FromJSON
    ChatConserverDynamitePlaceholderMetadataDeleteMetadata
  where
  parseJSON =
    Core.withObject
      "ChatConserverDynamitePlaceholderMetadataDeleteMetadata"
      ( \o ->
          Core.pure
            ChatConserverDynamitePlaceholderMetadataDeleteMetadata
      )

instance
  Core.ToJSON
    ChatConserverDynamitePlaceholderMetadataDeleteMetadata
  where
  toJSON = Core.const Core.emptyObject

-- | An edit was made in Dynamite.
--
-- /See:/ 'newChatConserverDynamitePlaceholderMetadataEditMetadata' smart constructor.
data ChatConserverDynamitePlaceholderMetadataEditMetadata = ChatConserverDynamitePlaceholderMetadataEditMetadata
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ChatConserverDynamitePlaceholderMetadataEditMetadata' with the minimum fields required to make a request.
newChatConserverDynamitePlaceholderMetadataEditMetadata ::
  ChatConserverDynamitePlaceholderMetadataEditMetadata
newChatConserverDynamitePlaceholderMetadataEditMetadata =
  ChatConserverDynamitePlaceholderMetadataEditMetadata

instance
  Core.FromJSON
    ChatConserverDynamitePlaceholderMetadataEditMetadata
  where
  parseJSON =
    Core.withObject
      "ChatConserverDynamitePlaceholderMetadataEditMetadata"
      ( \o ->
          Core.pure
            ChatConserverDynamitePlaceholderMetadataEditMetadata
      )

instance
  Core.ToJSON
    ChatConserverDynamitePlaceholderMetadataEditMetadata
  where
  toJSON = Core.const Core.emptyObject

-- | A Tasks message in Dynamite.
--
-- /See:/ 'newChatConserverDynamitePlaceholderMetadataTasksMetadata' smart constructor.
data ChatConserverDynamitePlaceholderMetadataTasksMetadata = ChatConserverDynamitePlaceholderMetadataTasksMetadata
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ChatConserverDynamitePlaceholderMetadataTasksMetadata' with the minimum fields required to make a request.
newChatConserverDynamitePlaceholderMetadataTasksMetadata ::
  ChatConserverDynamitePlaceholderMetadataTasksMetadata
newChatConserverDynamitePlaceholderMetadataTasksMetadata =
  ChatConserverDynamitePlaceholderMetadataTasksMetadata

instance
  Core.FromJSON
    ChatConserverDynamitePlaceholderMetadataTasksMetadata
  where
  parseJSON =
    Core.withObject
      "ChatConserverDynamitePlaceholderMetadataTasksMetadata"
      ( \o ->
          Core.pure
            ChatConserverDynamitePlaceholderMetadataTasksMetadata
      )

instance
  Core.ToJSON
    ChatConserverDynamitePlaceholderMetadataTasksMetadata
  where
  toJSON = Core.const Core.emptyObject

-- | A Meet initiated in Dynamite and its URL.
--
-- /See:/ 'newChatConserverDynamitePlaceholderMetadataVideoCallMetadata' smart constructor.
newtype ChatConserverDynamitePlaceholderMetadataVideoCallMetadata = ChatConserverDynamitePlaceholderMetadataVideoCallMetadata
  { -- |
    meetingUrl :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ChatConserverDynamitePlaceholderMetadataVideoCallMetadata' with the minimum fields required to make a request.
newChatConserverDynamitePlaceholderMetadataVideoCallMetadata ::
  ChatConserverDynamitePlaceholderMetadataVideoCallMetadata
newChatConserverDynamitePlaceholderMetadataVideoCallMetadata =
  ChatConserverDynamitePlaceholderMetadataVideoCallMetadata
    { meetingUrl = Core.Nothing
    }

instance
  Core.FromJSON
    ChatConserverDynamitePlaceholderMetadataVideoCallMetadata
  where
  parseJSON =
    Core.withObject
      "ChatConserverDynamitePlaceholderMetadataVideoCallMetadata"
      ( \o ->
          ChatConserverDynamitePlaceholderMetadataVideoCallMetadata
            Core.<$> (o Core..:? "meetingUrl")
      )

instance
  Core.ToJSON
    ChatConserverDynamitePlaceholderMetadataVideoCallMetadata
  where
  toJSON
    ChatConserverDynamitePlaceholderMetadataVideoCallMetadata {..} =
      Core.object
        ( Core.catMaybes
            [("meetingUrl" Core..=) Core.<$> meetingUrl]
        )

-- | The content of a chat message, which includes 0 or more segments along with 0 or more embeds, which represent various attachment types (like photos).
--
-- /See:/ 'newChatConserverMessageContent' smart constructor.
data ChatConserverMessageContent = ChatConserverMessageContent
  { -- | Items attached to this message, such as photos. This should /NOT/ be set by clients. It will be automatically set from media uploaded along with this request and using the information provided in existing_media.
    attachment :: (Core.Maybe [SocialCommonAttachmentAttachment]),
    -- | The text part of the message content. Segments are concatenated together to yield the full message. A message can have zero or more segments.
    segment :: (Core.Maybe [Segment])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ChatConserverMessageContent' with the minimum fields required to make a request.
newChatConserverMessageContent ::
  ChatConserverMessageContent
newChatConserverMessageContent =
  ChatConserverMessageContent
    { attachment = Core.Nothing,
      segment = Core.Nothing
    }

instance Core.FromJSON ChatConserverMessageContent where
  parseJSON =
    Core.withObject
      "ChatConserverMessageContent"
      ( \o ->
          ChatConserverMessageContent
            Core.<$> (o Core..:? "attachment")
            Core.<*> (o Core..:? "segment")
      )

instance Core.ToJSON ChatConserverMessageContent where
  toJSON ChatConserverMessageContent {..} =
    Core.object
      ( Core.catMaybes
          [ ("attachment" Core..=) Core.<$> attachment,
            ("segment" Core..=) Core.<$> segment
          ]
      )

-- | NEXT ID: 12
--
-- /See:/ 'newChatContentExtension' smart constructor.
data ChatContentExtension = ChatContentExtension
  { -- | Annotations to decorate this event.
    annotation :: (Core.Maybe [EventAnnotation]),
    -- | This metadata informs how the placeholder string will be localized dynamically in Hangouts. See go\/localization-of-system-messages. This is only used as part of REGULAR/CHAT/MESSAGE events.
    dynamitePlaceholderMetadata :: (Core.Maybe ChatConserverDynamitePlaceholderMetadata),
    -- | Is this event OnTR or OffTR? Since some events can be ON/THE/RECORD and have an expiration_timestamp (for example enterprise retention users) we need to store the otr status.
    eventOtrStatus :: (Core.Maybe ChatContentExtension_EventOtrStatus),
    -- | Group-link sharing toggle event.
    groupLinkSharingModificationEvent :: (Core.Maybe GroupLinkSharingModificationEvent),
    -- | Audio\/video Hangout event.
    hangoutEvent :: (Core.Maybe HangoutEvent),
    -- | Invite accepted events. Note: this is only used ephemerally to sync to Gmail. No actual cent is stored in Papyrus.
    inviteAcceptedEvent :: (Core.Maybe InviteAcceptedEvent),
    -- | Join\/leave events.
    membershipChangeEvent :: (Core.Maybe MembershipChangeEvent),
    -- | Metadata for off-the-record message.
    otrChatMessageEvent :: (Core.Maybe OtrChatMessageEvent),
    -- |
    otrModificationEvent :: (Core.Maybe OtrModificationEvent),
    -- |
    renameEvent :: (Core.Maybe RenameEvent)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ChatContentExtension' with the minimum fields required to make a request.
newChatContentExtension ::
  ChatContentExtension
newChatContentExtension =
  ChatContentExtension
    { annotation = Core.Nothing,
      dynamitePlaceholderMetadata = Core.Nothing,
      eventOtrStatus = Core.Nothing,
      groupLinkSharingModificationEvent = Core.Nothing,
      hangoutEvent = Core.Nothing,
      inviteAcceptedEvent = Core.Nothing,
      membershipChangeEvent = Core.Nothing,
      otrChatMessageEvent = Core.Nothing,
      otrModificationEvent = Core.Nothing,
      renameEvent = Core.Nothing
    }

instance Core.FromJSON ChatContentExtension where
  parseJSON =
    Core.withObject
      "ChatContentExtension"
      ( \o ->
          ChatContentExtension
            Core.<$> (o Core..:? "annotation")
            Core.<*> (o Core..:? "dynamitePlaceholderMetadata")
            Core.<*> (o Core..:? "eventOtrStatus")
            Core.<*> (o Core..:? "groupLinkSharingModificationEvent")
            Core.<*> (o Core..:? "hangoutEvent")
            Core.<*> (o Core..:? "inviteAcceptedEvent")
            Core.<*> (o Core..:? "membershipChangeEvent")
            Core.<*> (o Core..:? "otrChatMessageEvent")
            Core.<*> (o Core..:? "otrModificationEvent")
            Core.<*> (o Core..:? "renameEvent")
      )

instance Core.ToJSON ChatContentExtension where
  toJSON ChatContentExtension {..} =
    Core.object
      ( Core.catMaybes
          [ ("annotation" Core..=) Core.<$> annotation,
            ("dynamitePlaceholderMetadata" Core..=)
              Core.<$> dynamitePlaceholderMetadata,
            ("eventOtrStatus" Core..=) Core.<$> eventOtrStatus,
            ("groupLinkSharingModificationEvent" Core..=)
              Core.<$> groupLinkSharingModificationEvent,
            ("hangoutEvent" Core..=) Core.<$> hangoutEvent,
            ("inviteAcceptedEvent" Core..=)
              Core.<$> inviteAcceptedEvent,
            ("membershipChangeEvent" Core..=)
              Core.<$> membershipChangeEvent,
            ("otrChatMessageEvent" Core..=)
              Core.<$> otrChatMessageEvent,
            ("otrModificationEvent" Core..=)
              Core.<$> otrModificationEvent,
            ("renameEvent" Core..=) Core.<$> renameEvent
          ]
      )

-- | Represents the invitees or other users associated with a Babel Chat (see http:\/\/goto\/babel). Corresponds to GroupType CHAT in \/\/social\/graph\/storage\/proto\/data.proto.
--
-- /See:/ 'newChatProto' smart constructor.
data ChatProto = ChatProto
  { -- | Chat IDs consist of alphanumeric characters and colons. Currently required.
    chatId :: (Core.Maybe Core.Text),
    -- | The type of Chat members to consider, e.g. \"all members\" vs. \"invitee\" These are defined by legacy/relation/id values in social.graph.storage.EdgeTypeEnum.EdgeType enum options in social\/graph\/storage\/proto\/id.proto. See chat.pb (defined in production\/config\/cdd\/socialgraph\/mixer/config\/prod\/node/type_config) for all valid edge types associated with chat. Currently required.
    memberType :: (Core.Maybe Core.Int32)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ChatProto' with the minimum fields required to make a request.
newChatProto ::
  ChatProto
newChatProto = ChatProto {chatId = Core.Nothing, memberType = Core.Nothing}

instance Core.FromJSON ChatProto where
  parseJSON =
    Core.withObject
      "ChatProto"
      ( \o ->
          ChatProto
            Core.<$> (o Core..:? "chatId")
            Core.<*> (o Core..:? "memberType")
      )

instance Core.ToJSON ChatProto where
  toJSON ChatProto {..} =
    Core.object
      ( Core.catMaybes
          [ ("chatId" Core..=) Core.<$> chatId,
            ("memberType" Core..=) Core.<$> memberType
          ]
      )

--
-- /See:/ 'newCheckAccessResponse' smart constructor.
newtype CheckAccessResponse = CheckAccessResponse
  { -- | Returns true if principal has access. Returns false otherwise.
    hasAccess :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'CheckAccessResponse' with the minimum fields required to make a request.
newCheckAccessResponse ::
  CheckAccessResponse
newCheckAccessResponse = CheckAccessResponse {hasAccess = Core.Nothing}

instance Core.FromJSON CheckAccessResponse where
  parseJSON =
    Core.withObject
      "CheckAccessResponse"
      ( \o ->
          CheckAccessResponse
            Core.<$> (o Core..:? "hasAccess")
      )

instance Core.ToJSON CheckAccessResponse where
  toJSON CheckAccessResponse {..} =
    Core.object
      ( Core.catMaybes
          [("hasAccess" Core..=) Core.<$> hasAccess]
      )

-- | Represents a Google+ Circle. Currently (12\/2011), a Circle is identical to the ContactGroup with matching parameters, but Circle must only be used for true Circles and not other Focus groups, and should be preferred over ContactGroup where applicable. Soon it may become more efficient to check membership in a Circle than in a ContactGroup (see http:\/\/go\/superglue). Support for this principal type is currently (12\/2011) incomplete -- e.g., Keystore does not support it yet (see b\/5703421).
--
-- /See:/ 'newCircleProto' smart constructor.
data CircleProto = CircleProto
  { -- | Circle ID is unique only relative to the owner\'s Gaia ID. Currently required.
    circleId :: (Core.Maybe Core.Int64),
    -- | The owner of the circle. Currently required.
    ownerGaiaId :: (Core.Maybe Core.Int64),
    -- | If present, then tests for membership in this circle must use data known to be at least as fresh as the given (FBS-assigned) timestamp. See http:\/\/go\/fbs-consistent-read-after-important-write Before using this, be sure that any service checking authorization against this circle supports checking consistency timestamps. For example, as of 12\/2011, Keystore only supports this for the Moonshine configuration, and in others authorization checks will fail if the timestamp is present.
    requiredConsistencyTimestampUsec :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'CircleProto' with the minimum fields required to make a request.
newCircleProto ::
  CircleProto
newCircleProto =
  CircleProto
    { circleId = Core.Nothing,
      ownerGaiaId = Core.Nothing,
      requiredConsistencyTimestampUsec = Core.Nothing
    }

instance Core.FromJSON CircleProto where
  parseJSON =
    Core.withObject
      "CircleProto"
      ( \o ->
          CircleProto
            Core.<$> ( o Core..:? "circleId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> ( o Core..:? "ownerGaiaId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> ( o Core..:? "requiredConsistencyTimestampUsec"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON CircleProto where
  toJSON CircleProto {..} =
    Core.object
      ( Core.catMaybes
          [ ("circleId" Core..=) Core.. Core.AsText
              Core.<$> circleId,
            ("ownerGaiaId" Core..=) Core.. Core.AsText
              Core.<$> ownerGaiaId,
            ("requiredConsistencyTimestampUsec" Core..=)
              Core.. Core.AsText
              Core.<$> requiredConsistencyTimestampUsec
          ]
      )

-- | Represents the context of the client on behalf of which a HistoryRecord is produced. The ClientContext message can be used to hold context about the service client (e.g. the internal server making fusebox requests) or the user client (e.g. the IP address of the end user).
--
-- /See:/ 'newClientContext' smart constructor.
data ClientContext = ClientContext
  { -- | The client operation to which this history record belongs. The notion of a client operation is provided to keep track of client operations which might span multiple transactions in the lower level.
    clientOperationId :: (Core.Maybe Core.Text),
    -- | E.g. \"pinto\", \"imap\", \"bigtop\", \"upload\"
    clientType :: (Core.Maybe Core.Text),
    -- | Contains information about the session which created this history record. This will be empty if the history record was generated by an internal request.
    sessionContext :: (Core.Maybe SessionContext),
    -- | Textual representation of the user\'s IP address, if available.
    userIp :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ClientContext' with the minimum fields required to make a request.
newClientContext ::
  ClientContext
newClientContext =
  ClientContext
    { clientOperationId = Core.Nothing,
      clientType = Core.Nothing,
      sessionContext = Core.Nothing,
      userIp = Core.Nothing
    }

instance Core.FromJSON ClientContext where
  parseJSON =
    Core.withObject
      "ClientContext"
      ( \o ->
          ClientContext
            Core.<$> (o Core..:? "clientOperationId")
            Core.<*> (o Core..:? "clientType")
            Core.<*> (o Core..:? "sessionContext")
            Core.<*> (o Core..:? "userIp")
      )

instance Core.ToJSON ClientContext where
  toJSON ClientContext {..} =
    Core.object
      ( Core.catMaybes
          [ ("clientOperationId" Core..=)
              Core.<$> clientOperationId,
            ("clientType" Core..=) Core.<$> clientType,
            ("sessionContext" Core..=) Core.<$> sessionContext,
            ("userIp" Core..=) Core.<$> userIp
          ]
      )

-- | Principal associated with a Cloud Principal representing third party user.
--
-- /See:/ 'newCloudPrincipalProto' smart constructor.
newtype CloudPrincipalProto = CloudPrincipalProto
  { -- | Format: \"{identity-pool}:{subject}#\" Details: go\/cloud-principal-identifiers
    id :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'CloudPrincipalProto' with the minimum fields required to make a request.
newCloudPrincipalProto ::
  CloudPrincipalProto
newCloudPrincipalProto = CloudPrincipalProto {id = Core.Nothing}

instance Core.FromJSON CloudPrincipalProto where
  parseJSON =
    Core.withObject
      "CloudPrincipalProto"
      ( \o ->
          CloudPrincipalProto Core.<$> (o Core..:? "id")
      )

instance Core.ToJSON CloudPrincipalProto where
  toJSON CloudPrincipalProto {..} =
    Core.object
      (Core.catMaybes [("id" Core..=) Core.<$> id])

-- | ClusterInfo contains clustering related information for a particular thread that would be sent as part of the conversation view. Today, this information would be used by iOS notification server to identify whether the thread belongs to a cluster. If the thread belongs to a grouped cluster, it would identify whether the cluster is throttled.
--
-- /See:/ 'newClusterInfo' smart constructor.
data ClusterInfo = ClusterInfo
  { -- | IDs of the highest priority clusters to which the thread belongs to. If this field is not present, the thread does not belong to any cluster and would be shown in the inbox, unclustered.
    clusterId :: (Core.Maybe [Core.Text]),
    -- | If the thread belongs to a grouped cluster and all of those clusters are throttled, then this field is set to true.
    throttled :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ClusterInfo' with the minimum fields required to make a request.
newClusterInfo ::
  ClusterInfo
newClusterInfo =
  ClusterInfo {clusterId = Core.Nothing, throttled = Core.Nothing}

instance Core.FromJSON ClusterInfo where
  parseJSON =
    Core.withObject
      "ClusterInfo"
      ( \o ->
          ClusterInfo
            Core.<$> (o Core..:? "clusterId")
            Core.<*> (o Core..:? "throttled")
      )

instance Core.ToJSON ClusterInfo where
  toJSON ClusterInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("clusterId" Core..=) Core.<$> clusterId,
            ("throttled" Core..=) Core.<$> throttled
          ]
      )

-- | Metadata about a co-activity session.
--
-- /See:/ 'newCoActivity' smart constructor.
data CoActivity = CoActivity
  { -- | The title of the activity in this co-activity session. For example, this might be the title of the video being co-watched, or the name of the round of a game being co-played.
    activityTitle :: (Core.Maybe Core.Text),
    -- | Identifies the app handling this co-activity.
    coActivityApp :: (Core.Maybe CoActivity_CoActivityApp)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'CoActivity' with the minimum fields required to make a request.
newCoActivity ::
  CoActivity
newCoActivity =
  CoActivity {activityTitle = Core.Nothing, coActivityApp = Core.Nothing}

instance Core.FromJSON CoActivity where
  parseJSON =
    Core.withObject
      "CoActivity"
      ( \o ->
          CoActivity
            Core.<$> (o Core..:? "activityTitle")
            Core.<*> (o Core..:? "coActivityApp")
      )

instance Core.ToJSON CoActivity where
  toJSON CoActivity {..} =
    Core.object
      ( Core.catMaybes
          [ ("activityTitle" Core..=) Core.<$> activityTitle,
            ("coActivityApp" Core..=) Core.<$> coActivityApp
          ]
      )

-- | Information about a collaboration session.
--
-- /See:/ 'newCollaboration' smart constructor.
data Collaboration = Collaboration
  { -- | The attachment being collaborated on.
    attachmentId :: (Core.Maybe Core.Text),
    -- | Display info of the user who initiated the collaboration session.
    initiator :: (Core.Maybe UserDisplayInfo),
    -- | The uri of the artifact being collaborated on.
    uri :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Collaboration' with the minimum fields required to make a request.
newCollaboration ::
  Collaboration
newCollaboration =
  Collaboration
    { attachmentId = Core.Nothing,
      initiator = Core.Nothing,
      uri = Core.Nothing
    }

instance Core.FromJSON Collaboration where
  parseJSON =
    Core.withObject
      "Collaboration"
      ( \o ->
          Collaboration
            Core.<$> (o Core..:? "attachmentId")
            Core.<*> (o Core..:? "initiator")
            Core.<*> (o Core..:? "uri")
      )

instance Core.ToJSON Collaboration where
  toJSON Collaboration {..} =
    Core.object
      ( Core.catMaybes
          [ ("attachmentId" Core..=) Core.<$> attachmentId,
            ("initiator" Core..=) Core.<$> initiator,
            ("uri" Core..=) Core.<$> uri
          ]
      )

-- | Represents a color in the RGBA color space. This representation is designed for simplicity of conversion to\/from color representations in various languages over compactness. For example, the fields of this representation can be trivially provided to the constructor of @java.awt.Color@ in Java; it can also be trivially provided to UIColor\'s @+colorWithRed:green:blue:alpha@ method in iOS; and, with just a little work, it can be easily formatted into a CSS @rgba()@ string in JavaScript. This reference page doesn\'t carry information about the absolute color space that should be used to interpret the RGB value (e.g. sRGB, Adobe RGB, DCI-P3, BT.2020, etc.). By default, applications should assume the sRGB color space. When color equality needs to be decided, implementations, unless documented otherwise, treat two colors as equal if all their red, green, blue, and alpha values each differ by at most 1e-5. Example (Java): import com.google.type.Color; \/\/ ... public static java.awt.Color fromProto(Color
-- protocolor) { float alpha = protocolor.hasAlpha() ? protocolor.getAlpha().getValue() : 1.0; return new java.awt.Color( protocolor.getRed(), protocolor.getGreen(), protocolor.getBlue(), alpha); } public static Color toProto(java.awt.Color color) { float red = (float) color.getRed(); float green = (float) color.getGreen(); float blue = (float) color.getBlue(); float denominator = 255.0; Color.Builder resultBuilder = Color .newBuilder() .setRed(red \/ denominator) .setGreen(green \/ denominator) .setBlue(blue \/ denominator); int alpha = color.getAlpha(); if (alpha != 255) { result.setAlpha( FloatValue .newBuilder() .setValue(((float) alpha) \/ denominator) .build()); } return resultBuilder.build(); } \/\/ ... Example (iOS \/ Obj-C): \/\/ ... static UIColor* fromProto(Color* protocolor) { float red = [protocolor red]; float green = [protocolor green]; float blue = [protocolor blue]; FloatValue* alpha/wrapper = [protocolor alpha]; float alpha = 1.0; if (alpha/wrapper != nil) { alpha = [alpha/wrapper value]; }
-- return [UIColor colorWithRed:red green:green blue:blue alpha:alpha]; } static Color* toProto(UIColor* color) { CGFloat red, green, blue, alpha; if (![color getRed:&red green:&green blue:&blue alpha:&alpha]) { return nil; } Color* result = [[Color alloc] init]; [result setRed:red]; [result setGreen:green]; [result setBlue:blue]; if (alpha \<= 0.9999) { [result setAlpha:floatWrapperWithValue(alpha)]; } [result autorelease]; return result; } \/\/ ... Example (JavaScript): \/\/ ... var protoToCssColor = function(rgb/color) { var redFrac = rgb/color.red || 0.0; var greenFrac = rgb/color.green || 0.0; var blueFrac = rgb/color.blue || 0.0; var red = Math.floor(redFrac * 255); var green = Math.floor(greenFrac * 255); var blue = Math.floor(blueFrac * 255); if (!(\'alpha\' in rgb/color)) { return rgbToCssColor(red, green, blue); } var alphaFrac = rgb_color.alpha.value || 0.0; var rgbParams = [red, green, blue].join(\',\'); return [\'rgba(\', rgbParams, \',\', alphaFrac, \')\'].join(\'\'); }; var rgbToCssColor =
-- function(red, green, blue) { var rgbNumber = new Number((red \<\< 16) | (green \<\< 8) | blue); var hexString = rgbNumber.toString(16); var missingZeros = 6 - hexString.length; var resultBuilder = [\'#\']; for (var i = 0; i \< missingZeros; i++) { resultBuilder.push(\'0\'); } resultBuilder.push(hexString); return resultBuilder.join(\'\'); }; \/\/ ...
--
-- /See:/ 'newColor' smart constructor.
data Color = Color
  { -- | The fraction of this color that should be applied to the pixel. That is, the final pixel color is defined by the equation: @pixel color = alpha * (this color) + (1.0 - alpha) * (background color)@ This means that a value of 1.0 corresponds to a solid color, whereas a value of 0.0 corresponds to a completely transparent color. This uses a wrapper message rather than a simple float scalar so that it is possible to distinguish between a default value and the value being unset. If omitted, this color object is rendered as a solid color (as if the alpha value had been explicitly given a value of 1.0).
    alpha :: (Core.Maybe Core.Double),
    -- | The amount of blue in the color as a value in the interval [0, 1].
    blue :: (Core.Maybe Core.Double),
    -- | The amount of green in the color as a value in the interval [0, 1].
    green :: (Core.Maybe Core.Double),
    -- | The amount of red in the color as a value in the interval [0, 1].
    red :: (Core.Maybe Core.Double)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Color' with the minimum fields required to make a request.
newColor ::
  Color
newColor =
  Color
    { alpha = Core.Nothing,
      blue = Core.Nothing,
      green = Core.Nothing,
      red = Core.Nothing
    }

instance Core.FromJSON Color where
  parseJSON =
    Core.withObject
      "Color"
      ( \o ->
          Color
            Core.<$> (o Core..:? "alpha")
            Core.<*> (o Core..:? "blue")
            Core.<*> (o Core..:? "green")
            Core.<*> (o Core..:? "red")
      )

instance Core.ToJSON Color where
  toJSON Color {..} =
    Core.object
      ( Core.catMaybes
          [ ("alpha" Core..=) Core.<$> alpha,
            ("blue" Core..=) Core.<$> blue,
            ("green" Core..=) Core.<$> green,
            ("red" Core..=) Core.<$> red
          ]
      )

-- | An individual instance (or \"tag\") of a label configured as a communal type that\'s associated with a message.
--
-- /See:/ 'newCommunalLabelTag' smart constructor.
data CommunalLabelTag = CommunalLabelTag
  { -- | Gaia ID of the user who added the tag, if any. Not present for any tags automatically created by server-side processing.
    creatorUserId :: (Core.Maybe Core.Int64),
    -- | A string ID representing the label. Possible ID values are documented at go\/chat-labels-howto:ids. Example: \"^*t_p\" for \"Pinned\".
    labelId :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'CommunalLabelTag' with the minimum fields required to make a request.
newCommunalLabelTag ::
  CommunalLabelTag
newCommunalLabelTag =
  CommunalLabelTag {creatorUserId = Core.Nothing, labelId = Core.Nothing}

instance Core.FromJSON CommunalLabelTag where
  parseJSON =
    Core.withObject
      "CommunalLabelTag"
      ( \o ->
          CommunalLabelTag
            Core.<$> ( o Core..:? "creatorUserId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "labelId")
      )

instance Core.ToJSON CommunalLabelTag where
  toJSON CommunalLabelTag {..} =
    Core.object
      ( Core.catMaybes
          [ ("creatorUserId" Core..=) Core.. Core.AsText
              Core.<$> creatorUserId,
            ("labelId" Core..=) Core.<$> labelId
          ]
      )

--
-- /See:/ 'newCompositeFilter' smart constructor.
data CompositeFilter = CompositeFilter
  { -- | The logic operator of the sub filter.
    logicOperator :: (Core.Maybe CompositeFilter_LogicOperator),
    -- | Sub filters.
    subFilters :: (Core.Maybe [Filter])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'CompositeFilter' with the minimum fields required to make a request.
newCompositeFilter ::
  CompositeFilter
newCompositeFilter =
  CompositeFilter {logicOperator = Core.Nothing, subFilters = Core.Nothing}

instance Core.FromJSON CompositeFilter where
  parseJSON =
    Core.withObject
      "CompositeFilter"
      ( \o ->
          CompositeFilter
            Core.<$> (o Core..:? "logicOperator")
            Core.<*> (o Core..:? "subFilters")
      )

instance Core.ToJSON CompositeFilter where
  toJSON CompositeFilter {..} =
    Core.object
      ( Core.catMaybes
          [ ("logicOperator" Core..=) Core.<$> logicOperator,
            ("subFilters" Core..=) Core.<$> subFilters
          ]
      )

-- | Annotation metadata app unfurl consent.
--
-- /See:/ 'newConsentedAppUnfurlMetadata' smart constructor.
newtype ConsentedAppUnfurlMetadata = ConsentedAppUnfurlMetadata
  { -- | Client specified AppId, which will not be sanitized and is untrusted.
    clientSpecifiedAppId :: (Core.Maybe UserId)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ConsentedAppUnfurlMetadata' with the minimum fields required to make a request.
newConsentedAppUnfurlMetadata ::
  ConsentedAppUnfurlMetadata
newConsentedAppUnfurlMetadata =
  ConsentedAppUnfurlMetadata {clientSpecifiedAppId = Core.Nothing}

instance Core.FromJSON ConsentedAppUnfurlMetadata where
  parseJSON =
    Core.withObject
      "ConsentedAppUnfurlMetadata"
      ( \o ->
          ConsentedAppUnfurlMetadata
            Core.<$> (o Core..:? "clientSpecifiedAppId")
      )

instance Core.ToJSON ConsentedAppUnfurlMetadata where
  toJSON ConsentedAppUnfurlMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("clientSpecifiedAppId" Core..=)
              Core.<$> clientSpecifiedAppId
          ]
      )

-- | A group of contacts for a given user, as described in http:\/\/cs\/p#google3\/focus\/backend\/proto\/backend.proto Historically (and in still-existing ACLs), this was used to represent Google+ circles as well as contact groups, but this use is now deprecated. New code should use the CIRCLE principal type to represent Google+ circles.
--
-- /See:/ 'newContactGroupProto' smart constructor.
data ContactGroupProto = ContactGroupProto
  { -- | Group ID is unique only relative to the owner\'s Gaia ID.
    groupId :: (Core.Maybe Core.Int64),
    -- |
    ownerGaiaId :: (Core.Maybe Core.Int64),
    -- | If present, then tests for membership in this ContactGroup must use data known to be at least as fresh as the given (FBS-assigned) timestamp. See http:\/\/go\/fbs-consistent-read-after-important-write Before using this, be sure that any service checking authorization against this group supports checking consistency timestamps. For example, as of 12\/2011, Keystore only supports this for the Moonshine configuration, and in others authorization checks will fail if the timestamp is present.
    requiredConsistencyTimestampUsec :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ContactGroupProto' with the minimum fields required to make a request.
newContactGroupProto ::
  ContactGroupProto
newContactGroupProto =
  ContactGroupProto
    { groupId = Core.Nothing,
      ownerGaiaId = Core.Nothing,
      requiredConsistencyTimestampUsec = Core.Nothing
    }

instance Core.FromJSON ContactGroupProto where
  parseJSON =
    Core.withObject
      "ContactGroupProto"
      ( \o ->
          ContactGroupProto
            Core.<$> ( o Core..:? "groupId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> ( o Core..:? "ownerGaiaId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> ( o Core..:? "requiredConsistencyTimestampUsec"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON ContactGroupProto where
  toJSON ContactGroupProto {..} =
    Core.object
      ( Core.catMaybes
          [ ("groupId" Core..=) Core.. Core.AsText
              Core.<$> groupId,
            ("ownerGaiaId" Core..=) Core.. Core.AsText
              Core.<$> ownerGaiaId,
            ("requiredConsistencyTimestampUsec" Core..=)
              Core.. Core.AsText
              Core.<$> requiredConsistencyTimestampUsec
          ]
      )

--
-- /See:/ 'newContentReport' smart constructor.
data ContentReport = ContentReport
  { -- | The time at which the report is generated. Always populated when it is in a response.
    reportCreateTimestamp :: (Core.Maybe Core.DateTime),
    -- | Additional user-provided justification on the report. Optional.
    reportJustification :: (Core.Maybe ContentReportJustification),
    -- | Type of the report. Always populated when it is in a response.
    reportType :: (Core.Maybe AppsDynamiteSharedContentReportType),
    -- | User ID of the reporter. Always populated when it is in a response.
    reporterUserId :: (Core.Maybe UserId),
    -- | Create timestamp of the revisions of the message when it\'s reported. Always populated when it is in a response.
    revisionCreateTimestamp :: (Core.Maybe Core.DateTime)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ContentReport' with the minimum fields required to make a request.
newContentReport ::
  ContentReport
newContentReport =
  ContentReport
    { reportCreateTimestamp = Core.Nothing,
      reportJustification = Core.Nothing,
      reportType = Core.Nothing,
      reporterUserId = Core.Nothing,
      revisionCreateTimestamp = Core.Nothing
    }

instance Core.FromJSON ContentReport where
  parseJSON =
    Core.withObject
      "ContentReport"
      ( \o ->
          ContentReport
            Core.<$> (o Core..:? "reportCreateTimestamp")
            Core.<*> (o Core..:? "reportJustification")
            Core.<*> (o Core..:? "reportType")
            Core.<*> (o Core..:? "reporterUserId")
            Core.<*> (o Core..:? "revisionCreateTimestamp")
      )

instance Core.ToJSON ContentReport where
  toJSON ContentReport {..} =
    Core.object
      ( Core.catMaybes
          [ ("reportCreateTimestamp" Core..=)
              Core.<$> reportCreateTimestamp,
            ("reportJustification" Core..=)
              Core.<$> reportJustification,
            ("reportType" Core..=) Core.<$> reportType,
            ("reporterUserId" Core..=) Core.<$> reporterUserId,
            ("revisionCreateTimestamp" Core..=)
              Core.<$> revisionCreateTimestamp
          ]
      )

--
-- /See:/ 'newContentReportJustification' smart constructor.
newtype ContentReportJustification = ContentReportJustification
  { -- | Optional. User-generated free-text justification for the content report.
    userJustification :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ContentReportJustification' with the minimum fields required to make a request.
newContentReportJustification ::
  ContentReportJustification
newContentReportJustification =
  ContentReportJustification {userJustification = Core.Nothing}

instance Core.FromJSON ContentReportJustification where
  parseJSON =
    Core.withObject
      "ContentReportJustification"
      ( \o ->
          ContentReportJustification
            Core.<$> (o Core..:? "userJustification")
      )

instance Core.ToJSON ContentReportJustification where
  toJSON ContentReportJustification {..} =
    Core.object
      ( Core.catMaybes
          [ ("userJustification" Core..=)
              Core.<$> userJustification
          ]
      )

-- | Summarized info of content reports. Usually less expensive to fetch than to fetch all detailed reports. Set only when the request asks for it.
--
-- /See:/ 'newContentReportSummary' smart constructor.
data ContentReportSummary = ContentReportSummary
  { -- | Total number of reports attached to this (revision of) message.
    numberReports :: (Core.Maybe Core.Int32),
    -- | Totoal number of reports attached to all revisions of this message (i.e. since creation). Set only when the request asks for it.
    numberReportsAllRevisions :: (Core.Maybe Core.Int32)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ContentReportSummary' with the minimum fields required to make a request.
newContentReportSummary ::
  ContentReportSummary
newContentReportSummary =
  ContentReportSummary
    { numberReports = Core.Nothing,
      numberReportsAllRevisions = Core.Nothing
    }

instance Core.FromJSON ContentReportSummary where
  parseJSON =
    Core.withObject
      "ContentReportSummary"
      ( \o ->
          ContentReportSummary
            Core.<$> (o Core..:? "numberReports")
            Core.<*> (o Core..:? "numberReportsAllRevisions")
      )

instance Core.ToJSON ContentReportSummary where
  toJSON ContentReportSummary {..} =
    Core.object
      ( Core.catMaybes
          [ ("numberReports" Core..=) Core.<$> numberReports,
            ("numberReportsAllRevisions" Core..=)
              Core.<$> numberReportsAllRevisions
          ]
      )

-- | A named attribute associated with an item which can be used for influencing the ranking of the item based on the context in the request.
--
-- /See:/ 'newContextAttribute' smart constructor.
data ContextAttribute = ContextAttribute
  { -- | The name of the attribute. It should not be empty. The maximum length is 32 characters. The name must start with a letter and can only contain letters (A-Z, a-z) or numbers (0-9). The name will be normalized (lower-cased) before being matched.
    name :: (Core.Maybe Core.Text),
    -- | Text values of the attribute. The maximum number of elements is 10. The maximum length of an element in the array is 32 characters. The value will be normalized (lower-cased) before being matched.
    values :: (Core.Maybe [Core.Text])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ContextAttribute' with the minimum fields required to make a request.
newContextAttribute ::
  ContextAttribute
newContextAttribute =
  ContextAttribute {name = Core.Nothing, values = Core.Nothing}

instance Core.FromJSON ContextAttribute where
  parseJSON =
    Core.withObject
      "ContextAttribute"
      ( \o ->
          ContextAttribute
            Core.<$> (o Core..:? "name") Core.<*> (o Core..:? "values")
      )

instance Core.ToJSON ContextAttribute where
  toJSON ContextAttribute {..} =
    Core.object
      ( Core.catMaybes
          [ ("name" Core..=) Core.<$> name,
            ("values" Core..=) Core.<$> values
          ]
      )

-- | The markup for developers to specify the contents of a contextual AddOn. A contextual AddOn is triggered in context of an email. For that email, there can be N items that are associated with the email (e.g. contacts, sales lead, meeting information). Each item is represented as a \"card\". A card has two views, collapsed and detailed. If there are more than 1 card, the cards are show as a list of collapsed views. The end user can expand into the detailed view for each of those cards. In the detailed view, developers have the freedom to use a variety of \"widgets\" to construct it. The model here is to restrict (make consistent for end users) the navigation of the N cards but providing developers the freedom to build the detailed view that can best represent their use case\/content. Go http:\/\/go\/aoig-widgets1 to see the mocks. Post v1, we plan to support new AddOn use cases that will require different and separate \'templates\'. For example, a compose triggered AddOn which will support a new set of use
-- cases with different user interaction patterns. As a result, we will likely need a very different template than this one.
--
-- /See:/ 'newContextualAddOnMarkup' smart constructor.
data ContextualAddOnMarkup = ContextualAddOnMarkup
  { -- | A card must contain a header and at least 1 section.
    cards :: (Core.Maybe [Card]),
    -- | Deprecated.
    toolbar :: (Core.Maybe Toolbar)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ContextualAddOnMarkup' with the minimum fields required to make a request.
newContextualAddOnMarkup ::
  ContextualAddOnMarkup
newContextualAddOnMarkup =
  ContextualAddOnMarkup {cards = Core.Nothing, toolbar = Core.Nothing}

instance Core.FromJSON ContextualAddOnMarkup where
  parseJSON =
    Core.withObject
      "ContextualAddOnMarkup"
      ( \o ->
          ContextualAddOnMarkup
            Core.<$> (o Core..:? "cards") Core.<*> (o Core..:? "toolbar")
      )

instance Core.ToJSON ContextualAddOnMarkup where
  toJSON ContextualAddOnMarkup {..} =
    Core.object
      ( Core.catMaybes
          [ ("cards" Core..=) Core.<$> cards,
            ("toolbar" Core..=) Core.<$> toolbar
          ]
      )

-- | Information needed for Client-side Encryption.
--
-- /See:/ 'newCseInfo' smart constructor.
data CseInfo = CseInfo
  { -- | CSE domain name claimed by the meeting owner\'s company. This field is expected to be used for display purposes only, i.e., \"Extra encryption added by $cse_domain\". It can differ from the @cse_domain@ as defined elsewhere on the User, in the case of cross-domain meetings.
    cseDomain :: (Core.Maybe Core.Text),
    -- | The wrapped CSE key used by this conference.
    wrappedKey :: (Core.Maybe Core.Base64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'CseInfo' with the minimum fields required to make a request.
newCseInfo ::
  CseInfo
newCseInfo = CseInfo {cseDomain = Core.Nothing, wrappedKey = Core.Nothing}

instance Core.FromJSON CseInfo where
  parseJSON =
    Core.withObject
      "CseInfo"
      ( \o ->
          CseInfo
            Core.<$> (o Core..:? "cseDomain")
            Core.<*> (o Core..:? "wrappedKey")
      )

instance Core.ToJSON CseInfo where
  toJSON CseInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("cseDomain" Core..=) Core.<$> cseDomain,
            ("wrappedKey" Core..=) Core.<$> wrappedKey
          ]
      )

--
-- /See:/ 'newCustomEmojiMetadata' smart constructor.
newtype CustomEmojiMetadata = CustomEmojiMetadata
  { -- |
    customEmoji :: (Core.Maybe AppsDynamiteSharedCustomEmoji)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'CustomEmojiMetadata' with the minimum fields required to make a request.
newCustomEmojiMetadata ::
  CustomEmojiMetadata
newCustomEmojiMetadata = CustomEmojiMetadata {customEmoji = Core.Nothing}

instance Core.FromJSON CustomEmojiMetadata where
  parseJSON =
    Core.withObject
      "CustomEmojiMetadata"
      ( \o ->
          CustomEmojiMetadata
            Core.<$> (o Core..:? "customEmoji")
      )

instance Core.ToJSON CustomEmojiMetadata where
  toJSON CustomEmojiMetadata {..} =
    Core.object
      ( Core.catMaybes
          [("customEmoji" Core..=) Core.<$> customEmoji]
      )

-- | The result of a user running a custom function.
--
-- /See:/ 'newCustomFunctionReturnValueMarkup' smart constructor.
data CustomFunctionReturnValueMarkup = CustomFunctionReturnValueMarkup
  { -- | The error message to show to the user if something went wrong.
    errorMessage :: (Core.Maybe Core.Text),
    -- | The value that resulted from running the custom function.
    value :: (Core.Maybe Core.Value)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'CustomFunctionReturnValueMarkup' with the minimum fields required to make a request.
newCustomFunctionReturnValueMarkup ::
  CustomFunctionReturnValueMarkup
newCustomFunctionReturnValueMarkup =
  CustomFunctionReturnValueMarkup
    { errorMessage = Core.Nothing,
      value = Core.Nothing
    }

instance
  Core.FromJSON
    CustomFunctionReturnValueMarkup
  where
  parseJSON =
    Core.withObject
      "CustomFunctionReturnValueMarkup"
      ( \o ->
          CustomFunctionReturnValueMarkup
            Core.<$> (o Core..:? "errorMessage")
            Core.<*> (o Core..:? "value")
      )

instance Core.ToJSON CustomFunctionReturnValueMarkup where
  toJSON CustomFunctionReturnValueMarkup {..} =
    Core.object
      ( Core.catMaybes
          [ ("errorMessage" Core..=) Core.<$> errorMessage,
            ("value" Core..=) Core.<$> value
          ]
      )

-- | Represents a GSuite customer ID. Obfuscated with CustomerIdObfuscator.
--
-- /See:/ 'newCustomerId' smart constructor.
newtype CustomerId = CustomerId
  { -- |
    customerId :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'CustomerId' with the minimum fields required to make a request.
newCustomerId ::
  CustomerId
newCustomerId = CustomerId {customerId = Core.Nothing}

instance Core.FromJSON CustomerId where
  parseJSON =
    Core.withObject
      "CustomerId"
      ( \o ->
          CustomerId Core.<$> (o Core..:? "customerId")
      )

instance Core.ToJSON CustomerId where
  toJSON CustomerId {..} =
    Core.object
      ( Core.catMaybes
          [("customerId" Core..=) Core.<$> customerId]
      )

-- | Aggregation of items by status code as of the specified date.
--
-- /See:/ 'newCustomerIndexStats' smart constructor.
data CustomerIndexStats = CustomerIndexStats
  { -- | The date for which statistics were calculated.
    date :: (Core.Maybe Date),
    -- | Number of items aggregrated by status code.
    itemCountByStatus :: (Core.Maybe [ItemCountByStatus])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'CustomerIndexStats' with the minimum fields required to make a request.
newCustomerIndexStats ::
  CustomerIndexStats
newCustomerIndexStats =
  CustomerIndexStats {date = Core.Nothing, itemCountByStatus = Core.Nothing}

instance Core.FromJSON CustomerIndexStats where
  parseJSON =
    Core.withObject
      "CustomerIndexStats"
      ( \o ->
          CustomerIndexStats
            Core.<$> (o Core..:? "date")
            Core.<*> (o Core..:? "itemCountByStatus")
      )

instance Core.ToJSON CustomerIndexStats where
  toJSON CustomerIndexStats {..} =
    Core.object
      ( Core.catMaybes
          [ ("date" Core..=) Core.<$> date,
            ("itemCountByStatus" Core..=)
              Core.<$> itemCountByStatus
          ]
      )

--
-- /See:/ 'newCustomerQueryStats' smart constructor.
data CustomerQueryStats = CustomerQueryStats
  { -- | The date for which query stats were calculated. Stats calculated on the next day close to midnight are returned.
    date :: (Core.Maybe Date),
    -- |
    queryCountByStatus :: (Core.Maybe [QueryCountByStatus])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'CustomerQueryStats' with the minimum fields required to make a request.
newCustomerQueryStats ::
  CustomerQueryStats
newCustomerQueryStats =
  CustomerQueryStats {date = Core.Nothing, queryCountByStatus = Core.Nothing}

instance Core.FromJSON CustomerQueryStats where
  parseJSON =
    Core.withObject
      "CustomerQueryStats"
      ( \o ->
          CustomerQueryStats
            Core.<$> (o Core..:? "date")
            Core.<*> (o Core..:? "queryCountByStatus")
      )

instance Core.ToJSON CustomerQueryStats where
  toJSON CustomerQueryStats {..} =
    Core.object
      ( Core.catMaybes
          [ ("date" Core..=) Core.<$> date,
            ("queryCountByStatus" Core..=)
              Core.<$> queryCountByStatus
          ]
      )

-- | Search application stats for a customer for the given date.
--
-- /See:/ 'newCustomerSearchApplicationStats' smart constructor.
data CustomerSearchApplicationStats = CustomerSearchApplicationStats
  { -- | The count of search applications for the date.
    count :: (Core.Maybe Core.Int64),
    -- | The date for which search application stats were calculated.
    date :: (Core.Maybe Date)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'CustomerSearchApplicationStats' with the minimum fields required to make a request.
newCustomerSearchApplicationStats ::
  CustomerSearchApplicationStats
newCustomerSearchApplicationStats =
  CustomerSearchApplicationStats {count = Core.Nothing, date = Core.Nothing}

instance Core.FromJSON CustomerSearchApplicationStats where
  parseJSON =
    Core.withObject
      "CustomerSearchApplicationStats"
      ( \o ->
          CustomerSearchApplicationStats
            Core.<$> ( o Core..:? "count"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "date")
      )

instance Core.ToJSON CustomerSearchApplicationStats where
  toJSON CustomerSearchApplicationStats {..} =
    Core.object
      ( Core.catMaybes
          [ ("count" Core..=) Core.. Core.AsText Core.<$> count,
            ("date" Core..=) Core.<$> date
          ]
      )

--
-- /See:/ 'newCustomerSessionStats' smart constructor.
data CustomerSessionStats = CustomerSessionStats
  { -- | The date for which session stats were calculated. Stats are calculated on the following day, close to midnight PST, and then returned.
    date :: (Core.Maybe Date),
    -- | The count of search sessions on the day
    searchSessionsCount :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'CustomerSessionStats' with the minimum fields required to make a request.
newCustomerSessionStats ::
  CustomerSessionStats
newCustomerSessionStats =
  CustomerSessionStats {date = Core.Nothing, searchSessionsCount = Core.Nothing}

instance Core.FromJSON CustomerSessionStats where
  parseJSON =
    Core.withObject
      "CustomerSessionStats"
      ( \o ->
          CustomerSessionStats
            Core.<$> (o Core..:? "date")
            Core.<*> ( o Core..:? "searchSessionsCount"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON CustomerSessionStats where
  toJSON CustomerSessionStats {..} =
    Core.object
      ( Core.catMaybes
          [ ("date" Core..=) Core.<$> date,
            ("searchSessionsCount" Core..=) Core.. Core.AsText
              Core.<$> searchSessionsCount
          ]
      )

-- | Represents settings at a customer level.
--
-- /See:/ 'newCustomerSettings' smart constructor.
data CustomerSettings = CustomerSettings
  { -- | Audit Logging settings for the customer. If update_mask is empty then this field will be updated based on UpdateCustomerSettings request.
    auditLoggingSettings :: (Core.Maybe AuditLoggingSettings),
    -- | VPC SC settings for the customer. If update_mask is empty then this field will be updated based on UpdateCustomerSettings request.
    vpcSettings :: (Core.Maybe VPCSettings)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'CustomerSettings' with the minimum fields required to make a request.
newCustomerSettings ::
  CustomerSettings
newCustomerSettings =
  CustomerSettings
    { auditLoggingSettings = Core.Nothing,
      vpcSettings = Core.Nothing
    }

instance Core.FromJSON CustomerSettings where
  parseJSON =
    Core.withObject
      "CustomerSettings"
      ( \o ->
          CustomerSettings
            Core.<$> (o Core..:? "auditLoggingSettings")
            Core.<*> (o Core..:? "vpcSettings")
      )

instance Core.ToJSON CustomerSettings where
  toJSON CustomerSettings {..} =
    Core.object
      ( Core.catMaybes
          [ ("auditLoggingSettings" Core..=)
              Core.<$> auditLoggingSettings,
            ("vpcSettings" Core..=) Core.<$> vpcSettings
          ]
      )

--
-- /See:/ 'newCustomerUserStats' smart constructor.
data CustomerUserStats = CustomerUserStats
  { -- | The date for which session stats were calculated. Stats calculated on the next day close to midnight are returned.
    date :: (Core.Maybe Date),
    -- | The count of unique active users in the past one day
    oneDayActiveUsersCount :: (Core.Maybe Core.Int64),
    -- | The count of unique active users in the past seven days
    sevenDaysActiveUsersCount :: (Core.Maybe Core.Int64),
    -- | The count of unique active users in the past thirty days
    thirtyDaysActiveUsersCount :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'CustomerUserStats' with the minimum fields required to make a request.
newCustomerUserStats ::
  CustomerUserStats
newCustomerUserStats =
  CustomerUserStats
    { date = Core.Nothing,
      oneDayActiveUsersCount = Core.Nothing,
      sevenDaysActiveUsersCount = Core.Nothing,
      thirtyDaysActiveUsersCount = Core.Nothing
    }

instance Core.FromJSON CustomerUserStats where
  parseJSON =
    Core.withObject
      "CustomerUserStats"
      ( \o ->
          CustomerUserStats
            Core.<$> (o Core..:? "date")
            Core.<*> ( o Core..:? "oneDayActiveUsersCount"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> ( o Core..:? "sevenDaysActiveUsersCount"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> ( o Core..:? "thirtyDaysActiveUsersCount"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON CustomerUserStats where
  toJSON CustomerUserStats {..} =
    Core.object
      ( Core.catMaybes
          [ ("date" Core..=) Core.<$> date,
            ("oneDayActiveUsersCount" Core..=) Core.. Core.AsText
              Core.<$> oneDayActiveUsersCount,
            ("sevenDaysActiveUsersCount" Core..=)
              Core.. Core.AsText
              Core.<$> sevenDaysActiveUsersCount,
            ("thirtyDaysActiveUsersCount" Core..=)
              Core.. Core.AsText
              Core.<$> thirtyDaysActiveUsersCount
          ]
      )

-- | Annotation metadata for Data Loss Prevention that pertains to DLP violation on message send or edit events. It is used for client -> BE communication and other downstream process in BE (e.g. storage and audit logging), and it should never be returned to the client.
--
-- /See:/ 'newDataLossPreventionMetadata' smart constructor.
data DataLossPreventionMetadata = DataLossPreventionMetadata
  { -- | The DLP scan summary that should only be set after the message is scanned in the Chat backend.
    dlpScanSummary :: (Core.Maybe DlpScanSummary),
    -- | Flag set by client on message resend to bypass WARN violation.
    warnAcknowledged :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DataLossPreventionMetadata' with the minimum fields required to make a request.
newDataLossPreventionMetadata ::
  DataLossPreventionMetadata
newDataLossPreventionMetadata =
  DataLossPreventionMetadata
    { dlpScanSummary = Core.Nothing,
      warnAcknowledged = Core.Nothing
    }

instance Core.FromJSON DataLossPreventionMetadata where
  parseJSON =
    Core.withObject
      "DataLossPreventionMetadata"
      ( \o ->
          DataLossPreventionMetadata
            Core.<$> (o Core..:? "dlpScanSummary")
            Core.<*> (o Core..:? "warnAcknowledged")
      )

instance Core.ToJSON DataLossPreventionMetadata where
  toJSON DataLossPreventionMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("dlpScanSummary" Core..=) Core.<$> dlpScanSummary,
            ("warnAcknowledged" Core..=)
              Core.<$> warnAcknowledged
          ]
      )

-- | Datasource is a logical namespace for items to be indexed. All items must belong to a datasource. This is the prerequisite before items can be indexed into Cloud Search.
--
-- /See:/ 'newDataSource' smart constructor.
data DataSource = DataSource
  { -- | If true, sets the datasource to read-only mode. In read-only mode, the Indexing API rejects any requests to index or delete items in this source. Enabling read-only mode does not stop the processing of previously accepted data.
    disableModifications :: (Core.Maybe Core.Bool),
    -- | Disable serving any search or assist results.
    disableServing :: (Core.Maybe Core.Bool),
    -- | Required. Display name of the datasource The maximum length is 300 characters.
    displayName :: (Core.Maybe Core.Text),
    -- | List of service accounts that have indexing access.
    indexingServiceAccounts :: (Core.Maybe [Core.Text]),
    -- | This field restricts visibility to items at the datasource level. Items within the datasource are restricted to the union of users and groups included in this field. Note that, this does not ensure access to a specific item, as users need to have ACL permissions on the contained items. This ensures a high level access on the entire datasource, and that the individual items are not shared outside this visibility.
    itemsVisibility :: (Core.Maybe [GSuitePrincipal]),
    -- | The name of the datasource resource. Format: datasources\/{source_id}. The name is ignored when creating a datasource.
    name :: (Core.Maybe Core.Text),
    -- | IDs of the Long Running Operations (LROs) currently running for this schema.
    operationIds :: (Core.Maybe [Core.Text]),
    -- | Can a user request to get thumbnail URI for Items indexed in this data source.
    returnThumbnailUrls :: (Core.Maybe Core.Bool),
    -- | A short name or alias for the source. This value will be used to match the \'source\' operator. For example, if the short name is /\<value>/ then queries like /source:\<value>/ will only return results for this source. The value must be unique across all datasources. The value must only contain alphanumeric characters (a-zA-Z0-9). The value cannot start with \'google\' and cannot be one of the following: mail, gmail, docs, drive, groups, sites, calendar, hangouts, gplus, keep, people, teams. Its maximum length is 32 characters.
    shortName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DataSource' with the minimum fields required to make a request.
newDataSource ::
  DataSource
newDataSource =
  DataSource
    { disableModifications = Core.Nothing,
      disableServing = Core.Nothing,
      displayName = Core.Nothing,
      indexingServiceAccounts = Core.Nothing,
      itemsVisibility = Core.Nothing,
      name = Core.Nothing,
      operationIds = Core.Nothing,
      returnThumbnailUrls = Core.Nothing,
      shortName = Core.Nothing
    }

instance Core.FromJSON DataSource where
  parseJSON =
    Core.withObject
      "DataSource"
      ( \o ->
          DataSource
            Core.<$> (o Core..:? "disableModifications")
            Core.<*> (o Core..:? "disableServing")
            Core.<*> (o Core..:? "displayName")
            Core.<*> (o Core..:? "indexingServiceAccounts")
            Core.<*> (o Core..:? "itemsVisibility")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "operationIds")
            Core.<*> (o Core..:? "returnThumbnailUrls")
            Core.<*> (o Core..:? "shortName")
      )

instance Core.ToJSON DataSource where
  toJSON DataSource {..} =
    Core.object
      ( Core.catMaybes
          [ ("disableModifications" Core..=)
              Core.<$> disableModifications,
            ("disableServing" Core..=) Core.<$> disableServing,
            ("displayName" Core..=) Core.<$> displayName,
            ("indexingServiceAccounts" Core..=)
              Core.<$> indexingServiceAccounts,
            ("itemsVisibility" Core..=) Core.<$> itemsVisibility,
            ("name" Core..=) Core.<$> name,
            ("operationIds" Core..=) Core.<$> operationIds,
            ("returnThumbnailUrls" Core..=)
              Core.<$> returnThumbnailUrls,
            ("shortName" Core..=) Core.<$> shortName
          ]
      )

-- | Aggregation of items by status code as of the specified date.
--
-- /See:/ 'newDataSourceIndexStats' smart constructor.
data DataSourceIndexStats = DataSourceIndexStats
  { -- | The date for which index stats were calculated. If the date of request is not the current date then stats calculated on the next day are returned. Stats are calculated close to mid night in this case. If date of request is current date, then real time stats are returned.
    date :: (Core.Maybe Date),
    -- | Number of items aggregrated by status code.
    itemCountByStatus :: (Core.Maybe [ItemCountByStatus])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DataSourceIndexStats' with the minimum fields required to make a request.
newDataSourceIndexStats ::
  DataSourceIndexStats
newDataSourceIndexStats =
  DataSourceIndexStats {date = Core.Nothing, itemCountByStatus = Core.Nothing}

instance Core.FromJSON DataSourceIndexStats where
  parseJSON =
    Core.withObject
      "DataSourceIndexStats"
      ( \o ->
          DataSourceIndexStats
            Core.<$> (o Core..:? "date")
            Core.<*> (o Core..:? "itemCountByStatus")
      )

instance Core.ToJSON DataSourceIndexStats where
  toJSON DataSourceIndexStats {..} =
    Core.object
      ( Core.catMaybes
          [ ("date" Core..=) Core.<$> date,
            ("itemCountByStatus" Core..=)
              Core.<$> itemCountByStatus
          ]
      )

-- | Restriction on Datasource.
--
-- /See:/ 'newDataSourceRestriction' smart constructor.
data DataSourceRestriction = DataSourceRestriction
  { -- | Filter options restricting the results. If multiple filters are present, they are grouped by object type before joining. Filters with the same object type are joined conjunctively, then the resulting expressions are joined disjunctively. The maximum number of elements is 20. NOTE: Suggest API supports only few filters at the moment: \"objecttype\", \"type\" and \"mimetype\". For now, schema specific filters cannot be used to filter suggestions.
    filterOptions :: (Core.Maybe [FilterOptions]),
    -- | The source of restriction.
    source :: (Core.Maybe Source)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DataSourceRestriction' with the minimum fields required to make a request.
newDataSourceRestriction ::
  DataSourceRestriction
newDataSourceRestriction =
  DataSourceRestriction {filterOptions = Core.Nothing, source = Core.Nothing}

instance Core.FromJSON DataSourceRestriction where
  parseJSON =
    Core.withObject
      "DataSourceRestriction"
      ( \o ->
          DataSourceRestriction
            Core.<$> (o Core..:? "filterOptions")
            Core.<*> (o Core..:? "source")
      )

instance Core.ToJSON DataSourceRestriction where
  toJSON DataSourceRestriction {..} =
    Core.object
      ( Core.catMaybes
          [ ("filterOptions" Core..=) Core.<$> filterOptions,
            ("source" Core..=) Core.<$> source
          ]
      )

-- | Represents a whole calendar date, for example a date of birth. The time of day and time zone are either specified elsewhere or are not significant. The date is relative to the <https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar Proleptic Gregorian Calendar>. The date must be a valid calendar date between the year 1 and 9999.
--
-- /See:/ 'newDate' smart constructor.
data Date = Date
  { -- | Day of month. Must be from 1 to 31 and valid for the year and month.
    day :: (Core.Maybe Core.Int32),
    -- | Month of date. Must be from 1 to 12.
    month :: (Core.Maybe Core.Int32),
    -- | Year of date. Must be from 1 to 9999.
    year :: (Core.Maybe Core.Int32)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Date' with the minimum fields required to make a request.
newDate ::
  Date
newDate = Date {day = Core.Nothing, month = Core.Nothing, year = Core.Nothing}

instance Core.FromJSON Date where
  parseJSON =
    Core.withObject
      "Date"
      ( \o ->
          Date
            Core.<$> (o Core..:? "day")
            Core.<*> (o Core..:? "month")
            Core.<*> (o Core..:? "year")
      )

instance Core.ToJSON Date where
  toJSON Date {..} =
    Core.object
      ( Core.catMaybes
          [ ("day" Core..=) Core.<$> day,
            ("month" Core..=) Core.<$> month,
            ("year" Core..=) Core.<$> year
          ]
      )

-- | Optional. Provides a search operator for date properties. Search operators let users restrict the query to specific fields relevant to the type of item being searched.
--
-- /See:/ 'newDateOperatorOptions' smart constructor.
data DateOperatorOptions = DateOperatorOptions
  { -- | Indicates the operator name required in the query in order to isolate the date property using the greater-than operator. For example, if greaterThanOperatorName is /closedafter/ and the property\'s name is /closeDate/, then queries like /closedafter:\<value>/ show results only where the value of the property named /closeDate/ is later than /\<value>/. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.
    greaterThanOperatorName :: (Core.Maybe Core.Text),
    -- | Indicates the operator name required in the query in order to isolate the date property using the less-than operator. For example, if lessThanOperatorName is /closedbefore/ and the property\'s name is /closeDate/, then queries like /closedbefore:\<value>/ show results only where the value of the property named /closeDate/ is earlier than /\<value>/. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.
    lessThanOperatorName :: (Core.Maybe Core.Text),
    -- | Indicates the actual string required in the query in order to isolate the date property. For example, suppose an issue tracking schema object has a property named /closeDate/ that specifies an operator with an operatorName of /closedon/. For searches on that data, queries like /closedon:\<value>/ show results only where the value of the /closeDate/ property matches /\<value>/. By contrast, a search that uses the same /\<value>/ without an operator returns all items where /\<value>/ matches the value of any String properties or text within the content field for the indexed datasource. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.
    operatorName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DateOperatorOptions' with the minimum fields required to make a request.
newDateOperatorOptions ::
  DateOperatorOptions
newDateOperatorOptions =
  DateOperatorOptions
    { greaterThanOperatorName = Core.Nothing,
      lessThanOperatorName = Core.Nothing,
      operatorName = Core.Nothing
    }

instance Core.FromJSON DateOperatorOptions where
  parseJSON =
    Core.withObject
      "DateOperatorOptions"
      ( \o ->
          DateOperatorOptions
            Core.<$> (o Core..:? "greaterThanOperatorName")
            Core.<*> (o Core..:? "lessThanOperatorName")
            Core.<*> (o Core..:? "operatorName")
      )

instance Core.ToJSON DateOperatorOptions where
  toJSON DateOperatorOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("greaterThanOperatorName" Core..=)
              Core.<$> greaterThanOperatorName,
            ("lessThanOperatorName" Core..=)
              Core.<$> lessThanOperatorName,
            ("operatorName" Core..=) Core.<$> operatorName
          ]
      )

-- | The options for date properties.
--
-- /See:/ 'newDatePropertyOptions' smart constructor.
newtype DatePropertyOptions = DatePropertyOptions
  { -- | If set, describes how the date should be used as a search operator.
    operatorOptions :: (Core.Maybe DateOperatorOptions)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DatePropertyOptions' with the minimum fields required to make a request.
newDatePropertyOptions ::
  DatePropertyOptions
newDatePropertyOptions = DatePropertyOptions {operatorOptions = Core.Nothing}

instance Core.FromJSON DatePropertyOptions where
  parseJSON =
    Core.withObject
      "DatePropertyOptions"
      ( \o ->
          DatePropertyOptions
            Core.<$> (o Core..:? "operatorOptions")
      )

instance Core.ToJSON DatePropertyOptions where
  toJSON DatePropertyOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("operatorOptions" Core..=)
              Core.<$> operatorOptions
          ]
      )

--
-- /See:/ 'newDateTimePicker' smart constructor.
data DateTimePicker = DateTimePicker
  { -- | The label for the field, which is displayed to the user.
    label :: (Core.Maybe Core.Text),
    -- | The name of the text field which is used in FormInput, and uniquely identifies this input.
    name :: (Core.Maybe Core.Text),
    -- | Triggered when the user clicks on the Save, or Clear button from the date \/ time picker dialog. Will only be triggered if the value changed as a result of the Save \/ Clear operation.
    onChange :: (Core.Maybe FormAction),
    -- | The number representing the time-zone offset from UTC, in minutes. If set, the value/ms/epoch will be displayed in the specified time zone. If not set, it will use the user\'s timezone setting in client side.
    timezoneOffsetDate :: (Core.Maybe Core.Int32),
    -- | The type of the DateTimePicker.
    type' :: (Core.Maybe DateTimePicker_Type),
    -- | The value to display which can be the default value before user input or previous user input. It is represented in milliseconds (Epoch time). - For DATE/AND/TIME type, the full epoch value is used. - For DATE/ONLY type, only date of the epoch time is used. - For TIME/ONLY type, only time of the epoch time is used. For example, you can set epoch time to 3 * 60 * 60 * 1000 to represent 3am.
    valueMsEpoch :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DateTimePicker' with the minimum fields required to make a request.
newDateTimePicker ::
  DateTimePicker
newDateTimePicker =
  DateTimePicker
    { label = Core.Nothing,
      name = Core.Nothing,
      onChange = Core.Nothing,
      timezoneOffsetDate = Core.Nothing,
      type' = Core.Nothing,
      valueMsEpoch = Core.Nothing
    }

instance Core.FromJSON DateTimePicker where
  parseJSON =
    Core.withObject
      "DateTimePicker"
      ( \o ->
          DateTimePicker
            Core.<$> (o Core..:? "label")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "onChange")
            Core.<*> (o Core..:? "timezoneOffsetDate")
            Core.<*> (o Core..:? "type")
            Core.<*> ( o Core..:? "valueMsEpoch"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON DateTimePicker where
  toJSON DateTimePicker {..} =
    Core.object
      ( Core.catMaybes
          [ ("label" Core..=) Core.<$> label,
            ("name" Core..=) Core.<$> name,
            ("onChange" Core..=) Core.<$> onChange,
            ("timezoneOffsetDate" Core..=)
              Core.<$> timezoneOffsetDate,
            ("type" Core..=) Core.<$> type',
            ("valueMsEpoch" Core..=) Core.. Core.AsText
              Core.<$> valueMsEpoch
          ]
      )

-- | List of date values.
--
-- /See:/ 'newDateValues' smart constructor.
newtype DateValues = DateValues
  { -- |
    values :: (Core.Maybe [Date])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DateValues' with the minimum fields required to make a request.
newDateValues ::
  DateValues
newDateValues = DateValues {values = Core.Nothing}

instance Core.FromJSON DateValues where
  parseJSON =
    Core.withObject
      "DateValues"
      (\o -> DateValues Core.<$> (o Core..:? "values"))

instance Core.ToJSON DateValues where
  toJSON DateValues {..} =
    Core.object
      (Core.catMaybes [("values" Core..=) Core.<$> values])

-- | Shared request debug options for all cloudsearch RPC methods.
--
-- /See:/ 'newDebugOptions' smart constructor.
newtype DebugOptions = DebugOptions
  { -- | If you are asked by Google to help with debugging, set this field. Otherwise, ignore this field.
    enableDebugging :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DebugOptions' with the minimum fields required to make a request.
newDebugOptions ::
  DebugOptions
newDebugOptions = DebugOptions {enableDebugging = Core.Nothing}

instance Core.FromJSON DebugOptions where
  parseJSON =
    Core.withObject
      "DebugOptions"
      ( \o ->
          DebugOptions Core.<$> (o Core..:? "enableDebugging")
      )

instance Core.ToJSON DebugOptions where
  toJSON DebugOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("enableDebugging" Core..=)
              Core.<$> enableDebugging
          ]
      )

-- | Deep-linking data is used to construct a deep-link URI for an activity or frame\'s embed, such that on click, the user is taken to the right place in a mobile app. If the app is not installed, the user is taken to the app store. If not on mobile, an analogous web uri is used.
--
-- /See:/ 'newDeepLinkData' smart constructor.
data DeepLinkData = DeepLinkData
  { -- | Application ID (or project ID) from Google API Console.
    appId :: (Core.Maybe Core.Int64),
    -- | The data for a Google API Console client is entered by a developer during client registration and is stored in PackagingService.
    client :: (Core.Maybe [PackagingServiceClient]),
    -- | The ID for non-URL content. Embeds may either have no analogous web presence or prefer a native mobile experience if supported. In the case of no web presence, instead of setting the \"url\" field of an embed, such developers will set this field and other content fields, e.g. thumbnail, title, description. If set, this field is used to construct the deep-link URI. Note that the native experience is preferred over the web link and the web link is used as a fallback.
    deepLinkId :: (Core.Maybe Core.Text),
    -- | Analogous web presence. Used as desktop fallback or when no native link data is present.
    url :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DeepLinkData' with the minimum fields required to make a request.
newDeepLinkData ::
  DeepLinkData
newDeepLinkData =
  DeepLinkData
    { appId = Core.Nothing,
      client = Core.Nothing,
      deepLinkId = Core.Nothing,
      url = Core.Nothing
    }

instance Core.FromJSON DeepLinkData where
  parseJSON =
    Core.withObject
      "DeepLinkData"
      ( \o ->
          DeepLinkData
            Core.<$> ( o Core..:? "appId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "client")
            Core.<*> (o Core..:? "deepLinkId")
            Core.<*> (o Core..:? "url")
      )

instance Core.ToJSON DeepLinkData where
  toJSON DeepLinkData {..} =
    Core.object
      ( Core.catMaybes
          [ ("appId" Core..=) Core.. Core.AsText Core.<$> appId,
            ("client" Core..=) Core.<$> client,
            ("deepLinkId" Core..=) Core.<$> deepLinkId,
            ("url" Core..=) Core.<$> url
          ]
      )

-- | A message delete in Dynamite inserts a Babel-only item containing this field. This is only inserted for messages before the source-of-truth flip. See go\/hsc-message-deletions for more details.
--
-- /See:/ 'newDeleteMetadata' smart constructor.
data DeleteMetadata = DeleteMetadata
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DeleteMetadata' with the minimum fields required to make a request.
newDeleteMetadata ::
  DeleteMetadata
newDeleteMetadata = DeleteMetadata

instance Core.FromJSON DeleteMetadata where
  parseJSON =
    Core.withObject
      "DeleteMetadata"
      (\o -> Core.pure DeleteMetadata)

instance Core.ToJSON DeleteMetadata where
  toJSON = Core.const Core.emptyObject

--
-- /See:/ 'newDeleteQueueItemsRequest' smart constructor.
data DeleteQueueItemsRequest = DeleteQueueItemsRequest
  { -- | The name of connector making this call. Format: datasources\/{source_id}\/connectors\/{ID}
    connectorName :: (Core.Maybe Core.Text),
    -- | Common debug options.
    debugOptions :: (Core.Maybe DebugOptions),
    -- | The name of a queue to delete items from.
    queue :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DeleteQueueItemsRequest' with the minimum fields required to make a request.
newDeleteQueueItemsRequest ::
  DeleteQueueItemsRequest
newDeleteQueueItemsRequest =
  DeleteQueueItemsRequest
    { connectorName = Core.Nothing,
      debugOptions = Core.Nothing,
      queue = Core.Nothing
    }

instance Core.FromJSON DeleteQueueItemsRequest where
  parseJSON =
    Core.withObject
      "DeleteQueueItemsRequest"
      ( \o ->
          DeleteQueueItemsRequest
            Core.<$> (o Core..:? "connectorName")
            Core.<*> (o Core..:? "debugOptions")
            Core.<*> (o Core..:? "queue")
      )

instance Core.ToJSON DeleteQueueItemsRequest where
  toJSON DeleteQueueItemsRequest {..} =
    Core.object
      ( Core.catMaybes
          [ ("connectorName" Core..=) Core.<$> connectorName,
            ("debugOptions" Core..=) Core.<$> debugOptions,
            ("queue" Core..=) Core.<$> queue
          ]
      )

--
-- /See:/ 'newDeliveryMedium' smart constructor.
data DeliveryMedium = DeliveryMedium
  { -- | Describes the medium the cent was sent\/received. For example, if I receive an SMS via GV, the medium_type will be GV.
    mediumType :: (Core.Maybe DeliveryMedium_MediumType),
    -- | In the case of multiple GV\/native numbers, this defines the exact number to send from. It is used to differentiate mediums that have the same type, but different addresses (e.g. two android phones).
    selfPhone :: (Core.Maybe VoicePhoneNumber)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DeliveryMedium' with the minimum fields required to make a request.
newDeliveryMedium ::
  DeliveryMedium
newDeliveryMedium =
  DeliveryMedium {mediumType = Core.Nothing, selfPhone = Core.Nothing}

instance Core.FromJSON DeliveryMedium where
  parseJSON =
    Core.withObject
      "DeliveryMedium"
      ( \o ->
          DeliveryMedium
            Core.<$> (o Core..:? "mediumType")
            Core.<*> (o Core..:? "selfPhone")
      )

instance Core.ToJSON DeliveryMedium where
  toJSON DeliveryMedium {..} =
    Core.object
      ( Core.catMaybes
          [ ("mediumType" Core..=) Core.<$> mediumType,
            ("selfPhone" Core..=) Core.<$> selfPhone
          ]
      )

-- | A reference to a top-level property within the object that should be displayed in search results. The values of the chosen properties is displayed in the search results along with the display label for that property if one is specified. If a display label is not specified, only the values is shown.
--
-- /See:/ 'newDisplayedProperty' smart constructor.
newtype DisplayedProperty = DisplayedProperty
  { -- | The name of the top-level property as defined in a property definition for the object. If the name is not a defined property in the schema, an error is given when attempting to update the schema.
    propertyName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DisplayedProperty' with the minimum fields required to make a request.
newDisplayedProperty ::
  DisplayedProperty
newDisplayedProperty = DisplayedProperty {propertyName = Core.Nothing}

instance Core.FromJSON DisplayedProperty where
  parseJSON =
    Core.withObject
      "DisplayedProperty"
      ( \o ->
          DisplayedProperty
            Core.<$> (o Core..:? "propertyName")
      )

instance Core.ToJSON DisplayedProperty where
  toJSON DisplayedProperty {..} =
    Core.object
      ( Core.catMaybes
          [("propertyName" Core..=) Core.<$> propertyName]
      )

--
-- /See:/ 'newDivider' smart constructor.
data Divider = Divider
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Divider' with the minimum fields required to make a request.
newDivider ::
  Divider
newDivider = Divider

instance Core.FromJSON Divider where
  parseJSON =
    Core.withObject
      "Divider"
      (\o -> Core.pure Divider)

instance Core.ToJSON Divider where
  toJSON = Core.const Core.emptyObject

--
-- /See:/ 'newDlpAction' smart constructor.
data DlpAction = DlpAction
  { -- |
    actionType :: (Core.Maybe DlpAction_ActionType),
    -- | The custom error message defined by the customer administrator.
    unsafeHtmlMessageBody :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DlpAction' with the minimum fields required to make a request.
newDlpAction ::
  DlpAction
newDlpAction =
  DlpAction {actionType = Core.Nothing, unsafeHtmlMessageBody = Core.Nothing}

instance Core.FromJSON DlpAction where
  parseJSON =
    Core.withObject
      "DlpAction"
      ( \o ->
          DlpAction
            Core.<$> (o Core..:? "actionType")
            Core.<*> (o Core..:? "unsafeHtmlMessageBody")
      )

instance Core.ToJSON DlpAction where
  toJSON DlpAction {..} =
    Core.object
      ( Core.catMaybes
          [ ("actionType" Core..=) Core.<$> actionType,
            ("unsafeHtmlMessageBody" Core..=)
              Core.<$> unsafeHtmlMessageBody
          ]
      )

-- | A summary of a DLP scan event. This is a summary and should contain the minimum amount of data required to identify and process DLP scans. It is written to Starcast and encoded & returned to the client on attachment upload.
--
-- /See:/ 'newDlpScanSummary' smart constructor.
data DlpScanSummary = DlpScanSummary
  { -- |
    dlpAction :: (Core.Maybe DlpAction),
    -- | The scan ID of the corresponding {\@link DlpViolationScanRecord} in the {\@link EphemeralDlpScans} Spanner table. This can be used to fetch additional details about the scan, e.g. for audit logging.
    scanId :: (Core.Maybe Core.Text),
    -- | Indicates that was no attempt to scan a message or attachment because it was not applicable in the given context (e.g. atomic mutuate). If this is true, scan/outcome should not be set. This flag is used to identify messages that DLP did not attempt to scan for monitoring scan coverage. Contents that DLP attempted to scan but skipped can be identified by DlpScanOutcome.SCAN/SKIPPED_* reasons. DEPRECATED: The prober can determine this from the context.
    scanNotApplicableForContext :: (Core.Maybe Core.Bool),
    -- | The outcome of a DLP Scan. If this is set, scan/not/applicable/for/context should not be true.
    scanOutcome :: (Core.Maybe DlpScanSummary_ScanOutcome)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DlpScanSummary' with the minimum fields required to make a request.
newDlpScanSummary ::
  DlpScanSummary
newDlpScanSummary =
  DlpScanSummary
    { dlpAction = Core.Nothing,
      scanId = Core.Nothing,
      scanNotApplicableForContext = Core.Nothing,
      scanOutcome = Core.Nothing
    }

instance Core.FromJSON DlpScanSummary where
  parseJSON =
    Core.withObject
      "DlpScanSummary"
      ( \o ->
          DlpScanSummary
            Core.<$> (o Core..:? "dlpAction")
            Core.<*> (o Core..:? "scanId")
            Core.<*> (o Core..:? "scanNotApplicableForContext")
            Core.<*> (o Core..:? "scanOutcome")
      )

instance Core.ToJSON DlpScanSummary where
  toJSON DlpScanSummary {..} =
    Core.object
      ( Core.catMaybes
          [ ("dlpAction" Core..=) Core.<$> dlpAction,
            ("scanId" Core..=) Core.<$> scanId,
            ("scanNotApplicableForContext" Core..=)
              Core.<$> scanNotApplicableForContext,
            ("scanOutcome" Core..=) Core.<$> scanOutcome
          ]
      )

--
-- /See:/ 'newDmId' smart constructor.
newtype DmId = DmId
  { -- | Unique server assigned Id, per Direct Message Space.
    dmId :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DmId' with the minimum fields required to make a request.
newDmId ::
  DmId
newDmId = DmId {dmId = Core.Nothing}

instance Core.FromJSON DmId where
  parseJSON =
    Core.withObject
      "DmId"
      (\o -> DmId Core.<$> (o Core..:? "dmId"))

instance Core.ToJSON DmId where
  toJSON DmId {..} =
    Core.object
      (Core.catMaybes [("dmId" Core..=) Core.<$> dmId])

-- | Information on a document attached to an active conference.
--
-- /See:/ 'newDocumentInfo' smart constructor.
newtype DocumentInfo = DocumentInfo
  { -- | A whiteboard document.
    whiteboardInfo :: (Core.Maybe WhiteboardInfo)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DocumentInfo' with the minimum fields required to make a request.
newDocumentInfo ::
  DocumentInfo
newDocumentInfo = DocumentInfo {whiteboardInfo = Core.Nothing}

instance Core.FromJSON DocumentInfo where
  parseJSON =
    Core.withObject
      "DocumentInfo"
      ( \o ->
          DocumentInfo Core.<$> (o Core..:? "whiteboardInfo")
      )

instance Core.ToJSON DocumentInfo where
  toJSON DocumentInfo {..} =
    Core.object
      ( Core.catMaybes
          [("whiteboardInfo" Core..=) Core.<$> whiteboardInfo]
      )

-- | Used to provide a search operator for double properties. This is optional. Search operators let users restrict the query to specific fields relevant to the type of item being searched.
--
-- /See:/ 'newDoubleOperatorOptions' smart constructor.
newtype DoubleOperatorOptions = DoubleOperatorOptions
  { -- | Indicates the operator name required in the query in order to use the double property in sorting or as a facet. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.
    operatorName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DoubleOperatorOptions' with the minimum fields required to make a request.
newDoubleOperatorOptions ::
  DoubleOperatorOptions
newDoubleOperatorOptions = DoubleOperatorOptions {operatorName = Core.Nothing}

instance Core.FromJSON DoubleOperatorOptions where
  parseJSON =
    Core.withObject
      "DoubleOperatorOptions"
      ( \o ->
          DoubleOperatorOptions
            Core.<$> (o Core..:? "operatorName")
      )

instance Core.ToJSON DoubleOperatorOptions where
  toJSON DoubleOperatorOptions {..} =
    Core.object
      ( Core.catMaybes
          [("operatorName" Core..=) Core.<$> operatorName]
      )

-- | The options for double properties.
--
-- /See:/ 'newDoublePropertyOptions' smart constructor.
newtype DoublePropertyOptions = DoublePropertyOptions
  { -- | If set, describes how the double should be used as a search operator.
    operatorOptions :: (Core.Maybe DoubleOperatorOptions)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DoublePropertyOptions' with the minimum fields required to make a request.
newDoublePropertyOptions ::
  DoublePropertyOptions
newDoublePropertyOptions =
  DoublePropertyOptions {operatorOptions = Core.Nothing}

instance Core.FromJSON DoublePropertyOptions where
  parseJSON =
    Core.withObject
      "DoublePropertyOptions"
      ( \o ->
          DoublePropertyOptions
            Core.<$> (o Core..:? "operatorOptions")
      )

instance Core.ToJSON DoublePropertyOptions where
  toJSON DoublePropertyOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("operatorOptions" Core..=)
              Core.<$> operatorOptions
          ]
      )

-- | List of double values.
--
-- /See:/ 'newDoubleValues' smart constructor.
newtype DoubleValues = DoubleValues
  { -- |
    values :: (Core.Maybe [Core.Double])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DoubleValues' with the minimum fields required to make a request.
newDoubleValues ::
  DoubleValues
newDoubleValues = DoubleValues {values = Core.Nothing}

instance Core.FromJSON DoubleValues where
  parseJSON =
    Core.withObject
      "DoubleValues"
      (\o -> DoubleValues Core.<$> (o Core..:? "values"))

instance Core.ToJSON DoubleValues where
  toJSON DoubleValues {..} =
    Core.object
      (Core.catMaybes [("values" Core..=) Core.<$> values])

--
-- /See:/ 'newDriveClientActionMarkup' smart constructor.
newtype DriveClientActionMarkup = DriveClientActionMarkup
  { -- |
    requestFileScope :: (Core.Maybe RequestFileScope)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DriveClientActionMarkup' with the minimum fields required to make a request.
newDriveClientActionMarkup ::
  DriveClientActionMarkup
newDriveClientActionMarkup =
  DriveClientActionMarkup {requestFileScope = Core.Nothing}

instance Core.FromJSON DriveClientActionMarkup where
  parseJSON =
    Core.withObject
      "DriveClientActionMarkup"
      ( \o ->
          DriveClientActionMarkup
            Core.<$> (o Core..:? "requestFileScope")
      )

instance Core.ToJSON DriveClientActionMarkup where
  toJSON DriveClientActionMarkup {..} =
    Core.object
      ( Core.catMaybes
          [ ("requestFileScope" Core..=)
              Core.<$> requestFileScope
          ]
      )

-- | Drive follow-up search restricts (e.g. \"followup:suggestions\").
--
-- /See:/ 'newDriveFollowUpRestrict' smart constructor.
newtype DriveFollowUpRestrict = DriveFollowUpRestrict
  { -- |
    type' :: (Core.Maybe DriveFollowUpRestrict_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DriveFollowUpRestrict' with the minimum fields required to make a request.
newDriveFollowUpRestrict ::
  DriveFollowUpRestrict
newDriveFollowUpRestrict = DriveFollowUpRestrict {type' = Core.Nothing}

instance Core.FromJSON DriveFollowUpRestrict where
  parseJSON =
    Core.withObject
      "DriveFollowUpRestrict"
      ( \o ->
          DriveFollowUpRestrict Core.<$> (o Core..:? "type")
      )

instance Core.ToJSON DriveFollowUpRestrict where
  toJSON DriveFollowUpRestrict {..} =
    Core.object
      (Core.catMaybes [("type" Core..=) Core.<$> type'])

-- | Drive location search restricts (e.g. \"is:starred\").
--
-- /See:/ 'newDriveLocationRestrict' smart constructor.
newtype DriveLocationRestrict = DriveLocationRestrict
  { -- |
    type' :: (Core.Maybe DriveLocationRestrict_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DriveLocationRestrict' with the minimum fields required to make a request.
newDriveLocationRestrict ::
  DriveLocationRestrict
newDriveLocationRestrict = DriveLocationRestrict {type' = Core.Nothing}

instance Core.FromJSON DriveLocationRestrict where
  parseJSON =
    Core.withObject
      "DriveLocationRestrict"
      ( \o ->
          DriveLocationRestrict Core.<$> (o Core..:? "type")
      )

instance Core.ToJSON DriveLocationRestrict where
  toJSON DriveLocationRestrict {..} =
    Core.object
      (Core.catMaybes [("type" Core..=) Core.<$> type'])

-- | Annotation metadata for Drive artifacts.
--
-- /See:/ 'newDriveMetadata' smart constructor.
data DriveMetadata = DriveMetadata
  { -- |
    aclFixRequest :: (Core.Maybe AclFixRequest),
    -- |
    aclFixStatus :: (Core.Maybe AclFixStatus),
    -- | Can the current user edit this resource
    canEdit :: (Core.Maybe Core.Bool),
    -- | Can the current user share this resource
    canShare :: (Core.Maybe Core.Bool),
    -- | Can the current user view this resource
    canView :: (Core.Maybe Core.Bool),
    -- | DriveAction for organizing this file in Drive. If the user does not have access to the Drive file, the value will be DriveAction.DRIVE/ACTION/UNSPECIFIED. This field is only set when part of a FileResult in a ListFilesResponse.
    driveAction :: (Core.Maybe DriveMetadata_DriveAction),
    -- |
    driveState :: (Core.Maybe DriveMetadata_DriveState),
    -- | Output only. Trusted Resource URL for drive file embedding.
    embedUrl :: (Core.Maybe TrustedResourceUrlProto),
    -- | Indicates whether the Drive link contains an encrypted doc ID. If true, Dynamite should not attempt to query the doc ID in Drive Service. See go\/docid-encryption for details.
    encryptedDocId :: (Core.Maybe Core.Bool),
    -- | This is deprecated and unneeded. TODO (b\/182479059): Remove this.
    encryptedResourceKey :: (Core.Maybe Core.Text),
    -- | External mimetype of the Drive Resource (Useful for creating Drive URL) See: http:\/\/b\/35219462
    externalMimetype :: (Core.Maybe Core.Text),
    -- | Drive resource ID of the artifact.
    id :: (Core.Maybe Core.Text),
    -- | Deprecated. Whether the setting to restrict downloads is enabled for this file. This was previously used to determine whether to hide the download and print buttons in the UI, but is no longer used by clients, because Projector now independently queries Drive to ensure that we have the most up-to-date value.
    isDownloadRestricted :: (Core.Maybe Core.Bool),
    -- | If the current user is the Drive file\'s owner. The field is currently only set for Annotations for the ListFiles action (as opposed to fetching Topics\/Messages with Drive annotations).
    isOwner :: (Core.Maybe Core.Bool),
    -- | Only present if this DriveMetadata is converted from an UploadMetadata.
    legacyUploadMetadata :: (Core.Maybe LegacyUploadMetadata),
    -- | Mimetype of the Drive Resource
    mimetype :: (Core.Maybe Core.Text),
    -- | The display name of the organization owning the Drive item.
    organizationDisplayName :: (Core.Maybe Core.Text),
    -- | Shortcut ID of this drive file in the shared drive, which is associated with a named room this file was shared in. Shortcuts will not be created for DMs or unnamed rooms. This is populated after the DriveMetadata is migrated to shared drive. go\/chat-shared-drive-uploads.
    shortcutAuthorizedItemId :: (Core.Maybe AuthorizedItemId),
    -- | If this field is set to true, server should still contact external backends to get metadata for search but clients should not render this chip.
    shouldNotRender :: (Core.Maybe Core.Bool),
    -- | Thumbnail image of the Drive Resource
    thumbnailHeight :: (Core.Maybe Core.Int32),
    -- | Thumbnail image of the Drive Resource
    thumbnailUrl :: (Core.Maybe Core.Text),
    -- | Thumbnail image of the Drive Resource
    thumbnailWidth :: (Core.Maybe Core.Int32),
    -- | Title of the Drive Resource
    title :: (Core.Maybe Core.Text),
    -- | Url string fragment that generally indicates the specific location in the linked file. Example: #header=h.123abc456. If the fragment is not present this will not be present and therefore default to an empty string. The \"#\" will not be included.
    urlFragment :: (Core.Maybe Core.Text),
    -- | This is considered SPII and should not be logged.
    wrappedResourceKey :: (Core.Maybe WrappedResourceKey)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DriveMetadata' with the minimum fields required to make a request.
newDriveMetadata ::
  DriveMetadata
newDriveMetadata =
  DriveMetadata
    { aclFixRequest = Core.Nothing,
      aclFixStatus = Core.Nothing,
      canEdit = Core.Nothing,
      canShare = Core.Nothing,
      canView = Core.Nothing,
      driveAction = Core.Nothing,
      driveState = Core.Nothing,
      embedUrl = Core.Nothing,
      encryptedDocId = Core.Nothing,
      encryptedResourceKey = Core.Nothing,
      externalMimetype = Core.Nothing,
      id = Core.Nothing,
      isDownloadRestricted = Core.Nothing,
      isOwner = Core.Nothing,
      legacyUploadMetadata = Core.Nothing,
      mimetype = Core.Nothing,
      organizationDisplayName = Core.Nothing,
      shortcutAuthorizedItemId = Core.Nothing,
      shouldNotRender = Core.Nothing,
      thumbnailHeight = Core.Nothing,
      thumbnailUrl = Core.Nothing,
      thumbnailWidth = Core.Nothing,
      title = Core.Nothing,
      urlFragment = Core.Nothing,
      wrappedResourceKey = Core.Nothing
    }

instance Core.FromJSON DriveMetadata where
  parseJSON =
    Core.withObject
      "DriveMetadata"
      ( \o ->
          DriveMetadata
            Core.<$> (o Core..:? "aclFixRequest")
            Core.<*> (o Core..:? "aclFixStatus")
            Core.<*> (o Core..:? "canEdit")
            Core.<*> (o Core..:? "canShare")
            Core.<*> (o Core..:? "canView")
            Core.<*> (o Core..:? "driveAction")
            Core.<*> (o Core..:? "driveState")
            Core.<*> (o Core..:? "embedUrl")
            Core.<*> (o Core..:? "encryptedDocId")
            Core.<*> (o Core..:? "encryptedResourceKey")
            Core.<*> (o Core..:? "externalMimetype")
            Core.<*> (o Core..:? "id")
            Core.<*> (o Core..:? "isDownloadRestricted")
            Core.<*> (o Core..:? "isOwner")
            Core.<*> (o Core..:? "legacyUploadMetadata")
            Core.<*> (o Core..:? "mimetype")
            Core.<*> (o Core..:? "organizationDisplayName")
            Core.<*> (o Core..:? "shortcutAuthorizedItemId")
            Core.<*> (o Core..:? "shouldNotRender")
            Core.<*> (o Core..:? "thumbnailHeight")
            Core.<*> (o Core..:? "thumbnailUrl")
            Core.<*> (o Core..:? "thumbnailWidth")
            Core.<*> (o Core..:? "title")
            Core.<*> (o Core..:? "urlFragment")
            Core.<*> (o Core..:? "wrappedResourceKey")
      )

instance Core.ToJSON DriveMetadata where
  toJSON DriveMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("aclFixRequest" Core..=) Core.<$> aclFixRequest,
            ("aclFixStatus" Core..=) Core.<$> aclFixStatus,
            ("canEdit" Core..=) Core.<$> canEdit,
            ("canShare" Core..=) Core.<$> canShare,
            ("canView" Core..=) Core.<$> canView,
            ("driveAction" Core..=) Core.<$> driveAction,
            ("driveState" Core..=) Core.<$> driveState,
            ("embedUrl" Core..=) Core.<$> embedUrl,
            ("encryptedDocId" Core..=) Core.<$> encryptedDocId,
            ("encryptedResourceKey" Core..=)
              Core.<$> encryptedResourceKey,
            ("externalMimetype" Core..=)
              Core.<$> externalMimetype,
            ("id" Core..=) Core.<$> id,
            ("isDownloadRestricted" Core..=)
              Core.<$> isDownloadRestricted,
            ("isOwner" Core..=) Core.<$> isOwner,
            ("legacyUploadMetadata" Core..=)
              Core.<$> legacyUploadMetadata,
            ("mimetype" Core..=) Core.<$> mimetype,
            ("organizationDisplayName" Core..=)
              Core.<$> organizationDisplayName,
            ("shortcutAuthorizedItemId" Core..=)
              Core.<$> shortcutAuthorizedItemId,
            ("shouldNotRender" Core..=) Core.<$> shouldNotRender,
            ("thumbnailHeight" Core..=) Core.<$> thumbnailHeight,
            ("thumbnailUrl" Core..=) Core.<$> thumbnailUrl,
            ("thumbnailWidth" Core..=) Core.<$> thumbnailWidth,
            ("title" Core..=) Core.<$> title,
            ("urlFragment" Core..=) Core.<$> urlFragment,
            ("wrappedResourceKey" Core..=)
              Core.<$> wrappedResourceKey
          ]
      )

-- | Drive mime-type search restricts (e.g. \"type:pdf\").
--
-- /See:/ 'newDriveMimeTypeRestrict' smart constructor.
newtype DriveMimeTypeRestrict = DriveMimeTypeRestrict
  { -- |
    type' :: (Core.Maybe DriveMimeTypeRestrict_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DriveMimeTypeRestrict' with the minimum fields required to make a request.
newDriveMimeTypeRestrict ::
  DriveMimeTypeRestrict
newDriveMimeTypeRestrict = DriveMimeTypeRestrict {type' = Core.Nothing}

instance Core.FromJSON DriveMimeTypeRestrict where
  parseJSON =
    Core.withObject
      "DriveMimeTypeRestrict"
      ( \o ->
          DriveMimeTypeRestrict Core.<$> (o Core..:? "type")
      )

instance Core.ToJSON DriveMimeTypeRestrict where
  toJSON DriveMimeTypeRestrict {..} =
    Core.object
      (Core.catMaybes [("type" Core..=) Core.<$> type'])

-- | The time span search restrict (e.g. \"after:2017-09-11 before:2017-09-12\").
--
-- /See:/ 'newDriveTimeSpanRestrict' smart constructor.
newtype DriveTimeSpanRestrict = DriveTimeSpanRestrict
  { -- |
    type' :: (Core.Maybe DriveTimeSpanRestrict_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DriveTimeSpanRestrict' with the minimum fields required to make a request.
newDriveTimeSpanRestrict ::
  DriveTimeSpanRestrict
newDriveTimeSpanRestrict = DriveTimeSpanRestrict {type' = Core.Nothing}

instance Core.FromJSON DriveTimeSpanRestrict where
  parseJSON =
    Core.withObject
      "DriveTimeSpanRestrict"
      ( \o ->
          DriveTimeSpanRestrict Core.<$> (o Core..:? "type")
      )

instance Core.ToJSON DriveTimeSpanRestrict where
  toJSON DriveTimeSpanRestrict {..} =
    Core.object
      (Core.catMaybes [("type" Core..=) Core.<$> type'])

-- | This is the proto for holding message level scoring information. This data is used for logging in query-api server and for testing purposes.
--
-- /See:/ 'newDynamiteMessagesScoringInfo' smart constructor.
data DynamiteMessagesScoringInfo = DynamiteMessagesScoringInfo
  { -- |
    commonContactCount :: (Core.Maybe Core.Int64),
    -- |
    commonCountToContactListCountRatio :: (Core.Maybe Core.Double),
    -- |
    commonCountToMembershipCountRatio :: (Core.Maybe Core.Double),
    -- |
    creatorGaiaId :: (Core.Maybe Core.Int64),
    -- |
    creatorInSearcherContactList :: (Core.Maybe Core.Bool),
    -- |
    crowdingMultiplier :: (Core.Maybe Core.Double),
    -- |
    dasContactCount :: (Core.Maybe Core.Int64),
    -- |
    finalScore :: (Core.Maybe Core.Double),
    -- |
    freshnessScore :: (Core.Maybe Core.Double),
    -- |
    joinedSpaceAffinityScore :: (Core.Maybe Core.Double),
    -- |
    lastReadTimestampAgeInDays :: (Core.Maybe Core.Double),
    -- |
    messageAgeInDays :: (Core.Maybe Core.Double),
    -- |
    messageSenderAffinityScore :: (Core.Maybe Core.Double),
    -- |
    spaceId :: (Core.Maybe Core.Int64),
    -- |
    spaceMembershipCount :: (Core.Maybe Core.Int64),
    -- |
    topicalityScore :: (Core.Maybe Core.Double),
    -- |
    unjoinedSpaceAffinityScore :: (Core.Maybe Core.Double)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DynamiteMessagesScoringInfo' with the minimum fields required to make a request.
newDynamiteMessagesScoringInfo ::
  DynamiteMessagesScoringInfo
newDynamiteMessagesScoringInfo =
  DynamiteMessagesScoringInfo
    { commonContactCount = Core.Nothing,
      commonCountToContactListCountRatio = Core.Nothing,
      commonCountToMembershipCountRatio = Core.Nothing,
      creatorGaiaId = Core.Nothing,
      creatorInSearcherContactList = Core.Nothing,
      crowdingMultiplier = Core.Nothing,
      dasContactCount = Core.Nothing,
      finalScore = Core.Nothing,
      freshnessScore = Core.Nothing,
      joinedSpaceAffinityScore = Core.Nothing,
      lastReadTimestampAgeInDays = Core.Nothing,
      messageAgeInDays = Core.Nothing,
      messageSenderAffinityScore = Core.Nothing,
      spaceId = Core.Nothing,
      spaceMembershipCount = Core.Nothing,
      topicalityScore = Core.Nothing,
      unjoinedSpaceAffinityScore = Core.Nothing
    }

instance Core.FromJSON DynamiteMessagesScoringInfo where
  parseJSON =
    Core.withObject
      "DynamiteMessagesScoringInfo"
      ( \o ->
          DynamiteMessagesScoringInfo
            Core.<$> ( o Core..:? "commonContactCount"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "commonCountToContactListCountRatio")
            Core.<*> (o Core..:? "commonCountToMembershipCountRatio")
            Core.<*> ( o Core..:? "creatorGaiaId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "creatorInSearcherContactList")
            Core.<*> (o Core..:? "crowdingMultiplier")
            Core.<*> ( o Core..:? "dasContactCount"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "finalScore")
            Core.<*> (o Core..:? "freshnessScore")
            Core.<*> (o Core..:? "joinedSpaceAffinityScore")
            Core.<*> (o Core..:? "lastReadTimestampAgeInDays")
            Core.<*> (o Core..:? "messageAgeInDays")
            Core.<*> (o Core..:? "messageSenderAffinityScore")
            Core.<*> ( o Core..:? "spaceId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> ( o Core..:? "spaceMembershipCount"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "topicalityScore")
            Core.<*> (o Core..:? "unjoinedSpaceAffinityScore")
      )

instance Core.ToJSON DynamiteMessagesScoringInfo where
  toJSON DynamiteMessagesScoringInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("commonContactCount" Core..=) Core.. Core.AsText
              Core.<$> commonContactCount,
            ("commonCountToContactListCountRatio" Core..=)
              Core.<$> commonCountToContactListCountRatio,
            ("commonCountToMembershipCountRatio" Core..=)
              Core.<$> commonCountToMembershipCountRatio,
            ("creatorGaiaId" Core..=) Core.. Core.AsText
              Core.<$> creatorGaiaId,
            ("creatorInSearcherContactList" Core..=)
              Core.<$> creatorInSearcherContactList,
            ("crowdingMultiplier" Core..=)
              Core.<$> crowdingMultiplier,
            ("dasContactCount" Core..=) Core.. Core.AsText
              Core.<$> dasContactCount,
            ("finalScore" Core..=) Core.<$> finalScore,
            ("freshnessScore" Core..=) Core.<$> freshnessScore,
            ("joinedSpaceAffinityScore" Core..=)
              Core.<$> joinedSpaceAffinityScore,
            ("lastReadTimestampAgeInDays" Core..=)
              Core.<$> lastReadTimestampAgeInDays,
            ("messageAgeInDays" Core..=)
              Core.<$> messageAgeInDays,
            ("messageSenderAffinityScore" Core..=)
              Core.<$> messageSenderAffinityScore,
            ("spaceId" Core..=) Core.. Core.AsText
              Core.<$> spaceId,
            ("spaceMembershipCount" Core..=) Core.. Core.AsText
              Core.<$> spaceMembershipCount,
            ("topicalityScore" Core..=) Core.<$> topicalityScore,
            ("unjoinedSpaceAffinityScore" Core..=)
              Core.<$> unjoinedSpaceAffinityScore
          ]
      )

-- | This is the proto for holding space level scoring information. This data is used for logging in query-api server and for testing purposes.
--
-- /See:/ 'newDynamiteSpacesScoringInfo' smart constructor.
data DynamiteSpacesScoringInfo = DynamiteSpacesScoringInfo
  { -- |
    affinityScore :: (Core.Maybe Core.Double),
    -- |
    commonContactCountAffinityScore :: (Core.Maybe Core.Double),
    -- |
    contactsIntersectionCount :: (Core.Maybe Core.Double),
    -- |
    finalScore :: (Core.Maybe Core.Double),
    -- |
    freshnessScore :: (Core.Maybe Core.Double),
    -- |
    joinedSpacesAffinityScore :: (Core.Maybe Core.Double),
    -- |
    lastMessagePostedTimestampSecs :: (Core.Maybe Core.Int64),
    -- |
    lastReadTimestampSecs :: (Core.Maybe Core.Int64),
    -- |
    memberCountScore :: (Core.Maybe Core.Double),
    -- |
    memberMetadataCount :: (Core.Maybe Core.Double),
    -- |
    messageScore :: (Core.Maybe Core.Double),
    -- |
    numAucContacts :: (Core.Maybe Core.Int64),
    -- |
    smallContactListAffinityScore :: (Core.Maybe Core.Double),
    -- |
    smallUnjoinedSpacesAffinityScore :: (Core.Maybe Core.Double),
    -- |
    spaceAgeInDays :: (Core.Maybe Core.Double),
    -- |
    spaceCreationTimestampSecs :: (Core.Maybe Core.Int64),
    -- |
    topicalityScore :: (Core.Maybe Core.Double)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'DynamiteSpacesScoringInfo' with the minimum fields required to make a request.
newDynamiteSpacesScoringInfo ::
  DynamiteSpacesScoringInfo
newDynamiteSpacesScoringInfo =
  DynamiteSpacesScoringInfo
    { affinityScore = Core.Nothing,
      commonContactCountAffinityScore = Core.Nothing,
      contactsIntersectionCount = Core.Nothing,
      finalScore = Core.Nothing,
      freshnessScore = Core.Nothing,
      joinedSpacesAffinityScore = Core.Nothing,
      lastMessagePostedTimestampSecs = Core.Nothing,
      lastReadTimestampSecs = Core.Nothing,
      memberCountScore = Core.Nothing,
      memberMetadataCount = Core.Nothing,
      messageScore = Core.Nothing,
      numAucContacts = Core.Nothing,
      smallContactListAffinityScore = Core.Nothing,
      smallUnjoinedSpacesAffinityScore = Core.Nothing,
      spaceAgeInDays = Core.Nothing,
      spaceCreationTimestampSecs = Core.Nothing,
      topicalityScore = Core.Nothing
    }

instance Core.FromJSON DynamiteSpacesScoringInfo where
  parseJSON =
    Core.withObject
      "DynamiteSpacesScoringInfo"
      ( \o ->
          DynamiteSpacesScoringInfo
            Core.<$> (o Core..:? "affinityScore")
            Core.<*> (o Core..:? "commonContactCountAffinityScore")
            Core.<*> (o Core..:? "contactsIntersectionCount")
            Core.<*> (o Core..:? "finalScore")
            Core.<*> (o Core..:? "freshnessScore")
            Core.<*> (o Core..:? "joinedSpacesAffinityScore")
            Core.<*> ( o Core..:? "lastMessagePostedTimestampSecs"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> ( o Core..:? "lastReadTimestampSecs"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "memberCountScore")
            Core.<*> (o Core..:? "memberMetadataCount")
            Core.<*> (o Core..:? "messageScore")
            Core.<*> ( o Core..:? "numAucContacts"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "smallContactListAffinityScore")
            Core.<*> (o Core..:? "smallUnjoinedSpacesAffinityScore")
            Core.<*> (o Core..:? "spaceAgeInDays")
            Core.<*> ( o Core..:? "spaceCreationTimestampSecs"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "topicalityScore")
      )

instance Core.ToJSON DynamiteSpacesScoringInfo where
  toJSON DynamiteSpacesScoringInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("affinityScore" Core..=) Core.<$> affinityScore,
            ("commonContactCountAffinityScore" Core..=)
              Core.<$> commonContactCountAffinityScore,
            ("contactsIntersectionCount" Core..=)
              Core.<$> contactsIntersectionCount,
            ("finalScore" Core..=) Core.<$> finalScore,
            ("freshnessScore" Core..=) Core.<$> freshnessScore,
            ("joinedSpacesAffinityScore" Core..=)
              Core.<$> joinedSpacesAffinityScore,
            ("lastMessagePostedTimestampSecs" Core..=)
              Core.. Core.AsText
              Core.<$> lastMessagePostedTimestampSecs,
            ("lastReadTimestampSecs" Core..=) Core.. Core.AsText
              Core.<$> lastReadTimestampSecs,
            ("memberCountScore" Core..=)
              Core.<$> memberCountScore,
            ("memberMetadataCount" Core..=)
              Core.<$> memberMetadataCount,
            ("messageScore" Core..=) Core.<$> messageScore,
            ("numAucContacts" Core..=) Core.. Core.AsText
              Core.<$> numAucContacts,
            ("smallContactListAffinityScore" Core..=)
              Core.<$> smallContactListAffinityScore,
            ("smallUnjoinedSpacesAffinityScore" Core..=)
              Core.<$> smallUnjoinedSpacesAffinityScore,
            ("spaceAgeInDays" Core..=) Core.<$> spaceAgeInDays,
            ("spaceCreationTimestampSecs" Core..=)
              Core.. Core.AsText
              Core.<$> spaceCreationTimestampSecs,
            ("topicalityScore" Core..=)
              Core.<$> topicalityScore
          ]
      )

-- | A message edit in Dynamite inserts a Babel-only item containing this field.
--
-- /See:/ 'newEditMetadata' smart constructor.
data EditMetadata = EditMetadata
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'EditMetadata' with the minimum fields required to make a request.
newEditMetadata ::
  EditMetadata
newEditMetadata = EditMetadata

instance Core.FromJSON EditMetadata where
  parseJSON =
    Core.withObject
      "EditMetadata"
      (\o -> Core.pure EditMetadata)

instance Core.ToJSON EditMetadata where
  toJSON = Core.const Core.emptyObject

--
-- /See:/ 'newEditorClientActionMarkup' smart constructor.
newtype EditorClientActionMarkup = EditorClientActionMarkup
  { -- |
    requestFileScopeForActiveDocument :: (Core.Maybe RequestFileScopeForActiveDocument)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'EditorClientActionMarkup' with the minimum fields required to make a request.
newEditorClientActionMarkup ::
  EditorClientActionMarkup
newEditorClientActionMarkup =
  EditorClientActionMarkup {requestFileScopeForActiveDocument = Core.Nothing}

instance Core.FromJSON EditorClientActionMarkup where
  parseJSON =
    Core.withObject
      "EditorClientActionMarkup"
      ( \o ->
          EditorClientActionMarkup
            Core.<$> (o Core..:? "requestFileScopeForActiveDocument")
      )

instance Core.ToJSON EditorClientActionMarkup where
  toJSON EditorClientActionMarkup {..} =
    Core.object
      ( Core.catMaybes
          [ ("requestFileScopeForActiveDocument" Core..=)
              Core.<$> requestFileScopeForActiveDocument
          ]
      )

-- | A person\'s email address.
--
-- /See:/ 'newEmailAddress' smart constructor.
data EmailAddress = EmailAddress
  { -- | If the value of type is custom, this property contains the custom type string.
    customType :: (Core.Maybe Core.Text),
    -- | The email address.
    emailAddress :: (Core.Maybe Core.Text),
    -- | The URL to send email.
    emailUrl :: (Core.Maybe Core.Text),
    -- | Indicates if this is the user\'s primary email. Only one entry can be marked as primary.
    primary :: (Core.Maybe Core.Bool),
    -- | The type of the email account. Acceptable values are: \"custom\", \"home\", \"other\", \"work\".
    type' :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'EmailAddress' with the minimum fields required to make a request.
newEmailAddress ::
  EmailAddress
newEmailAddress =
  EmailAddress
    { customType = Core.Nothing,
      emailAddress = Core.Nothing,
      emailUrl = Core.Nothing,
      primary = Core.Nothing,
      type' = Core.Nothing
    }

instance Core.FromJSON EmailAddress where
  parseJSON =
    Core.withObject
      "EmailAddress"
      ( \o ->
          EmailAddress
            Core.<$> (o Core..:? "customType")
            Core.<*> (o Core..:? "emailAddress")
            Core.<*> (o Core..:? "emailUrl")
            Core.<*> (o Core..:? "primary")
            Core.<*> (o Core..:? "type")
      )

instance Core.ToJSON EmailAddress where
  toJSON EmailAddress {..} =
    Core.object
      ( Core.catMaybes
          [ ("customType" Core..=) Core.<$> customType,
            ("emailAddress" Core..=) Core.<$> emailAddress,
            ("emailUrl" Core..=) Core.<$> emailUrl,
            ("primary" Core..=) Core.<$> primary,
            ("type" Core..=) Core.<$> type'
          ]
      )

-- | Represents a verified owner of the given email address. Note that a single address may have many owners, and a single user may own many addresses. (All lower-case, in display form -- see com.google.gaia.client.GaiaEmail)
--
-- /See:/ 'newEmailOwnerProto' smart constructor.
newtype EmailOwnerProto = EmailOwnerProto
  { -- |
    email :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'EmailOwnerProto' with the minimum fields required to make a request.
newEmailOwnerProto ::
  EmailOwnerProto
newEmailOwnerProto = EmailOwnerProto {email = Core.Nothing}

instance Core.FromJSON EmailOwnerProto where
  parseJSON =
    Core.withObject
      "EmailOwnerProto"
      ( \o ->
          EmailOwnerProto Core.<$> (o Core..:? "email")
      )

instance Core.ToJSON EmailOwnerProto where
  toJSON EmailOwnerProto {..} =
    Core.object
      (Core.catMaybes [("email" Core..=) Core.<$> email])

-- | Represents an embedded object in an update. This is a wrapper class that can contain a single specific item proto in an extension field. Think of it as a base class like @Message@ in Java. Each item proto must declare that it extends this proto: message ExampleObject { option (item/type) = EXAMPLE/OBJECT; extend EmbedClientItem { optional ExampleObject example_object = ; } } See go\/es-embeds for details.
--
-- /See:/ 'newEmbedClientItem' smart constructor.
data EmbedClientItem = EmbedClientItem
  { -- | The canonical ID of the embed. If absent, the canonical ID is equal to the ID; if present, then the canonical ID represents an \"equivalence class\" of embeds which really refer to the same object. (For example, the URLs http:\/\/www.foo.com\/ and http:\/\/foo.com\/ refer to the same object) This field may be updated periodically by background processes.
    canonicalId :: (Core.Maybe Core.Text),
    -- | Deep-linking data to take the user to the right place in a mobile app. This is only used for preview and attribution. Links that are specific to a given embed type should live on that specific embed\'s proto by using Link. See http:\/\/goto.google.com\/mariana-design.
    deepLinkData :: (Core.Maybe DeepLinkData),
    -- | The ID of the embed. This corresponds to the schema.org ID, as represented in the ItemScope.id field.
    id :: (Core.Maybe Core.Text),
    -- | The provenance of the embed, populated when the embed originated from a web fetch. The provenance captures information about the web page the embed had originated, like the URL that was retrieved and the retrieved URL\'s canonical form. This is useful in the case where the URL shared by the URL redirects (e.g., in the case of a shortened URL).
    provenance :: (Core.Maybe Provenance),
    -- | The ID used to identify the embed during rendering. This field will match ID, if set, otherwise it will be the ID of the parent activity. This field is only populated on the server for client use and is not persisted to storage.
    renderId :: (Core.Maybe Core.Text),
    -- | Signature of the embed, used for verification.
    signature :: (Core.Maybe Core.Text),
    -- | Transient generic data that will not be saved on the server.
    transientData :: (Core.Maybe TransientData),
    -- | The first value in @type@ determines which extension field will be set. When creating an EmbedClientItem, you only need to set the first (primary) type in this field. When the server receives the item, it will populate the full type list using the parent annotations in the ItemType enum.
    type' :: (Core.Maybe [EmbedClientItem_TypeItem])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'EmbedClientItem' with the minimum fields required to make a request.
newEmbedClientItem ::
  EmbedClientItem
newEmbedClientItem =
  EmbedClientItem
    { canonicalId = Core.Nothing,
      deepLinkData = Core.Nothing,
      id = Core.Nothing,
      provenance = Core.Nothing,
      renderId = Core.Nothing,
      signature = Core.Nothing,
      transientData = Core.Nothing,
      type' = Core.Nothing
    }

instance Core.FromJSON EmbedClientItem where
  parseJSON =
    Core.withObject
      "EmbedClientItem"
      ( \o ->
          EmbedClientItem
            Core.<$> (o Core..:? "canonicalId")
            Core.<*> (o Core..:? "deepLinkData")
            Core.<*> (o Core..:? "id")
            Core.<*> (o Core..:? "provenance")
            Core.<*> (o Core..:? "renderId")
            Core.<*> (o Core..:? "signature")
            Core.<*> (o Core..:? "transientData")
            Core.<*> (o Core..:? "type")
      )

instance Core.ToJSON EmbedClientItem where
  toJSON EmbedClientItem {..} =
    Core.object
      ( Core.catMaybes
          [ ("canonicalId" Core..=) Core.<$> canonicalId,
            ("deepLinkData" Core..=) Core.<$> deepLinkData,
            ("id" Core..=) Core.<$> id,
            ("provenance" Core..=) Core.<$> provenance,
            ("renderId" Core..=) Core.<$> renderId,
            ("signature" Core..=) Core.<$> signature,
            ("transientData" Core..=) Core.<$> transientData,
            ("type" Core..=) Core.<$> type'
          ]
      )

-- | Used to provide a search operator for enum properties. This is optional. Search operators let users restrict the query to specific fields relevant to the type of item being searched. For example, if you provide no operator for a /priority/ enum property with possible values /p0/ and /p1/, a query that contains the term /p0/ returns items that have /p0/ as the value of the /priority/ property, as well as any items that contain the string /p0/ in other fields. If you provide an operator name for the enum, such as /priority/, then search users can use that operator to refine results to only items that have /p0/ as this property\'s value, with the query /priority:p0/.
--
-- /See:/ 'newEnumOperatorOptions' smart constructor.
newtype EnumOperatorOptions = EnumOperatorOptions
  { -- | Indicates the operator name required in the query in order to isolate the enum property. For example, if operatorName is /priority/ and the property\'s name is /priorityVal/, then queries like /priority:\<value>/ show results only where the value of the property named /priorityVal/ matches /\<value>/. By contrast, a search that uses the same /\<value>/ without an operator returns all items where /\<value>/ matches the value of any String properties or text within the content field for the item. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.
    operatorName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'EnumOperatorOptions' with the minimum fields required to make a request.
newEnumOperatorOptions ::
  EnumOperatorOptions
newEnumOperatorOptions = EnumOperatorOptions {operatorName = Core.Nothing}

instance Core.FromJSON EnumOperatorOptions where
  parseJSON =
    Core.withObject
      "EnumOperatorOptions"
      ( \o ->
          EnumOperatorOptions
            Core.<$> (o Core..:? "operatorName")
      )

instance Core.ToJSON EnumOperatorOptions where
  toJSON EnumOperatorOptions {..} =
    Core.object
      ( Core.catMaybes
          [("operatorName" Core..=) Core.<$> operatorName]
      )

-- | The options for enum properties, which allow you to define a restricted set of strings to match user queries, set rankings for those string values, and define an operator name to be paired with those strings so that users can narrow results to only items with a specific value. For example, for items in a request tracking system with priority information, you could define /p0/ as an allowable enum value and tie this enum to the operator name /priority/ so that search users could add /priority:p0/ to their query to restrict the set of results to only those items indexed with the value /p0/.
--
-- /See:/ 'newEnumPropertyOptions' smart constructor.
data EnumPropertyOptions = EnumPropertyOptions
  { -- | If set, describes how the enum should be used as a search operator.
    operatorOptions :: (Core.Maybe EnumOperatorOptions),
    -- | Used to specify the ordered ranking for the enumeration that determines how the integer values provided in the possible EnumValuePairs are used to rank results. If specified, integer values must be provided for all possible EnumValuePair values given for this property. Can only be used if isRepeatable is false.
    orderedRanking :: (Core.Maybe EnumPropertyOptions_OrderedRanking),
    -- | The list of possible values for the enumeration property. All EnumValuePairs must provide a string value. If you specify an integer value for one EnumValuePair, then all possible EnumValuePairs must provide an integer value. Both the string value and integer value must be unique over all possible values. Once set, possible values cannot be removed or modified. If you supply an ordered ranking and think you might insert additional enum values in the future, leave gaps in the initial integer values to allow adding a value in between previously registered values. The maximum number of elements is 100.
    possibleValues :: (Core.Maybe [EnumValuePair])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'EnumPropertyOptions' with the minimum fields required to make a request.
newEnumPropertyOptions ::
  EnumPropertyOptions
newEnumPropertyOptions =
  EnumPropertyOptions
    { operatorOptions = Core.Nothing,
      orderedRanking = Core.Nothing,
      possibleValues = Core.Nothing
    }

instance Core.FromJSON EnumPropertyOptions where
  parseJSON =
    Core.withObject
      "EnumPropertyOptions"
      ( \o ->
          EnumPropertyOptions
            Core.<$> (o Core..:? "operatorOptions")
            Core.<*> (o Core..:? "orderedRanking")
            Core.<*> (o Core..:? "possibleValues")
      )

instance Core.ToJSON EnumPropertyOptions where
  toJSON EnumPropertyOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("operatorOptions" Core..=)
              Core.<$> operatorOptions,
            ("orderedRanking" Core..=) Core.<$> orderedRanking,
            ("possibleValues" Core..=) Core.<$> possibleValues
          ]
      )

-- | The enumeration value pair defines two things: a required string value and an optional integer value. The string value defines the necessary query term required to retrieve that item, such as /p0/ for a priority item. The integer value determines the ranking of that string value relative to other enumerated values for the same property. For example, you might associate /p0/ with /0/ and define another enum pair such as /p1/ and /1/. You must use the integer value in combination with ordered ranking to set the ranking of a given value relative to other enumerated values for the same property name. Here, a ranking order of DESCENDING for /priority/ properties results in a ranking boost for items indexed with a value of /p0/ compared to items indexed with a value of /p1/. Without a specified ranking order, the integer value has no effect on item ranking.
--
-- /See:/ 'newEnumValuePair' smart constructor.
data EnumValuePair = EnumValuePair
  { -- | The integer value of the EnumValuePair which must be non-negative. Optional.
    integerValue :: (Core.Maybe Core.Int32),
    -- | The string value of the EnumValuePair. The maximum length is 32 characters.
    stringValue :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'EnumValuePair' with the minimum fields required to make a request.
newEnumValuePair ::
  EnumValuePair
newEnumValuePair =
  EnumValuePair {integerValue = Core.Nothing, stringValue = Core.Nothing}

instance Core.FromJSON EnumValuePair where
  parseJSON =
    Core.withObject
      "EnumValuePair"
      ( \o ->
          EnumValuePair
            Core.<$> (o Core..:? "integerValue")
            Core.<*> (o Core..:? "stringValue")
      )

instance Core.ToJSON EnumValuePair where
  toJSON EnumValuePair {..} =
    Core.object
      ( Core.catMaybes
          [ ("integerValue" Core..=) Core.<$> integerValue,
            ("stringValue" Core..=) Core.<$> stringValue
          ]
      )

-- | List of enum values.
--
-- /See:/ 'newEnumValues' smart constructor.
newtype EnumValues = EnumValues
  { -- | The maximum allowable length for string values is 32 characters.
    values :: (Core.Maybe [Core.Text])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'EnumValues' with the minimum fields required to make a request.
newEnumValues ::
  EnumValues
newEnumValues = EnumValues {values = Core.Nothing}

instance Core.FromJSON EnumValues where
  parseJSON =
    Core.withObject
      "EnumValues"
      (\o -> EnumValues Core.<$> (o Core..:? "values"))

instance Core.ToJSON EnumValues where
  toJSON EnumValues {..} =
    Core.object
      (Core.catMaybes [("values" Core..=) Core.<$> values])

-- | Error information about the response.
--
-- /See:/ 'newErrorInfo' smart constructor.
newtype ErrorInfo = ErrorInfo
  { -- |
    errorMessages :: (Core.Maybe [ErrorMessage])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ErrorInfo' with the minimum fields required to make a request.
newErrorInfo ::
  ErrorInfo
newErrorInfo = ErrorInfo {errorMessages = Core.Nothing}

instance Core.FromJSON ErrorInfo where
  parseJSON =
    Core.withObject
      "ErrorInfo"
      ( \o ->
          ErrorInfo Core.<$> (o Core..:? "errorMessages")
      )

instance Core.ToJSON ErrorInfo where
  toJSON ErrorInfo {..} =
    Core.object
      ( Core.catMaybes
          [("errorMessages" Core..=) Core.<$> errorMessages]
      )

-- | Error message per source response.
--
-- /See:/ 'newErrorMessage' smart constructor.
data ErrorMessage = ErrorMessage
  { -- |
    errorMessage :: (Core.Maybe Core.Text),
    -- |
    source :: (Core.Maybe Source)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ErrorMessage' with the minimum fields required to make a request.
newErrorMessage ::
  ErrorMessage
newErrorMessage =
  ErrorMessage {errorMessage = Core.Nothing, source = Core.Nothing}

instance Core.FromJSON ErrorMessage where
  parseJSON =
    Core.withObject
      "ErrorMessage"
      ( \o ->
          ErrorMessage
            Core.<$> (o Core..:? "errorMessage")
            Core.<*> (o Core..:? "source")
      )

instance Core.ToJSON ErrorMessage where
  toJSON ErrorMessage {..} =
    Core.object
      ( Core.catMaybes
          [ ("errorMessage" Core..=) Core.<$> errorMessage,
            ("source" Core..=) Core.<$> source
          ]
      )

--
-- /See:/ 'newEventAnnotation' smart constructor.
data EventAnnotation = EventAnnotation
  { -- |
    type' :: (Core.Maybe Core.Int32),
    -- |
    value :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'EventAnnotation' with the minimum fields required to make a request.
newEventAnnotation ::
  EventAnnotation
newEventAnnotation =
  EventAnnotation {type' = Core.Nothing, value = Core.Nothing}

instance Core.FromJSON EventAnnotation where
  parseJSON =
    Core.withObject
      "EventAnnotation"
      ( \o ->
          EventAnnotation
            Core.<$> (o Core..:? "type") Core.<*> (o Core..:? "value")
      )

instance Core.ToJSON EventAnnotation where
  toJSON EventAnnotation {..} =
    Core.object
      ( Core.catMaybes
          [ ("type" Core..=) Core.<$> type',
            ("value" Core..=) Core.<$> value
          ]
      )

-- | Represents the invitees or other users associated with a Google+ Event (see http:\/\/goto\/events-backend-design).
--
-- /See:/ 'newEventProto' smart constructor.
data EventProto = EventProto
  { -- | Event IDs consist of alphanumeric characters and colons. Currently required.
    eventId :: (Core.Maybe Core.Text),
    -- | The type of Event members to consider, e.g. \"all members\" vs. \"owners\" vs. \"admins\". These are defined by legacy/relation/id values in social.graph.storage.EdgeTypeEnum.EdgeType enum options in social\/graph\/storage\/proto\/id.proto. See event.pb (defined in production\/config\/cdd\/socialgraph\/mixer/config\/prod\/node/type_config) for all valid edge types associated with event. Currently required.
    memberType :: (Core.Maybe Core.Int32)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'EventProto' with the minimum fields required to make a request.
newEventProto ::
  EventProto
newEventProto = EventProto {eventId = Core.Nothing, memberType = Core.Nothing}

instance Core.FromJSON EventProto where
  parseJSON =
    Core.withObject
      "EventProto"
      ( \o ->
          EventProto
            Core.<$> (o Core..:? "eventId")
            Core.<*> (o Core..:? "memberType")
      )

instance Core.ToJSON EventProto where
  toJSON EventProto {..} =
    Core.object
      ( Core.catMaybes
          [ ("eventId" Core..=) Core.<$> eventId,
            ("memberType" Core..=) Core.<$> memberType
          ]
      )

-- | A bucket in a facet is the basic unit of operation. A bucket can comprise either a single value OR a contiguous range of values, depending on the type of the field bucketed. FacetBucket is currently used only for returning the response object.
--
-- /See:/ 'newFacetBucket' smart constructor.
data FacetBucket = FacetBucket
  { -- | Number of results that match the bucket value. Counts are only returned for searches when count accuracy is ensured. Cloud Search does not guarantee facet counts for any query and facet counts might be present only intermittently, even for identical queries. Do not build dependencies on facet count existence; instead use facet ount percentages which are always returned.
    count :: (Core.Maybe Core.Int32),
    -- | Filter to be passed in the search request if the corresponding bucket is selected.
    filter :: (Core.Maybe Filter),
    -- | Percent of results that match the bucket value. The returned value is between (0-100], and is rounded down to an integer if fractional. If the value is not explicitly returned, it represents a percentage value that rounds to 0. Percentages are returned for all searches, but are an estimate. Because percentages are always returned, you should render percentages instead of counts.
    percentage :: (Core.Maybe Core.Int32),
    -- |
    value :: (Core.Maybe Value)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'FacetBucket' with the minimum fields required to make a request.
newFacetBucket ::
  FacetBucket
newFacetBucket =
  FacetBucket
    { count = Core.Nothing,
      filter = Core.Nothing,
      percentage = Core.Nothing,
      value = Core.Nothing
    }

instance Core.FromJSON FacetBucket where
  parseJSON =
    Core.withObject
      "FacetBucket"
      ( \o ->
          FacetBucket
            Core.<$> (o Core..:? "count")
            Core.<*> (o Core..:? "filter")
            Core.<*> (o Core..:? "percentage")
            Core.<*> (o Core..:? "value")
      )

instance Core.ToJSON FacetBucket where
  toJSON FacetBucket {..} =
    Core.object
      ( Core.catMaybes
          [ ("count" Core..=) Core.<$> count,
            ("filter" Core..=) Core.<$> filter,
            ("percentage" Core..=) Core.<$> percentage,
            ("value" Core..=) Core.<$> value
          ]
      )

-- | Specifies operators to return facet results for. There will be one FacetResult for every source/name\/object/type\/operator_name combination.
--
-- /See:/ 'newFacetOptions' smart constructor.
data FacetOptions = FacetOptions
  { -- | If set, describes integer faceting options for the given integer property. The corresponding integer property in the schema should be marked isFacetable. The number of buckets returned would be minimum of this and num/facet/buckets.
    integerFacetingOptions :: (Core.Maybe IntegerFacetingOptions),
    -- | Maximum number of facet buckets that should be returned for this facet. Defaults to 10. Maximum value is 100.
    numFacetBuckets :: (Core.Maybe Core.Int32),
    -- | If object_type is set, only those objects of that type will be used to compute facets. If empty, then all objects will be used to compute facets.
    objectType :: (Core.Maybe Core.Text),
    -- | The name of the operator chosen for faceting. \@see cloudsearch.SchemaPropertyOptions
    operatorName :: (Core.Maybe Core.Text),
    -- | Source name to facet on. Format: datasources\/{source_id} If empty, all data sources will be used.
    sourceName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'FacetOptions' with the minimum fields required to make a request.
newFacetOptions ::
  FacetOptions
newFacetOptions =
  FacetOptions
    { integerFacetingOptions = Core.Nothing,
      numFacetBuckets = Core.Nothing,
      objectType = Core.Nothing,
      operatorName = Core.Nothing,
      sourceName = Core.Nothing
    }

instance Core.FromJSON FacetOptions where
  parseJSON =
    Core.withObject
      "FacetOptions"
      ( \o ->
          FacetOptions
            Core.<$> (o Core..:? "integerFacetingOptions")
            Core.<*> (o Core..:? "numFacetBuckets")
            Core.<*> (o Core..:? "objectType")
            Core.<*> (o Core..:? "operatorName")
            Core.<*> (o Core..:? "sourceName")
      )

instance Core.ToJSON FacetOptions where
  toJSON FacetOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("integerFacetingOptions" Core..=)
              Core.<$> integerFacetingOptions,
            ("numFacetBuckets" Core..=) Core.<$> numFacetBuckets,
            ("objectType" Core..=) Core.<$> objectType,
            ("operatorName" Core..=) Core.<$> operatorName,
            ("sourceName" Core..=) Core.<$> sourceName
          ]
      )

-- | Source specific facet response
--
-- /See:/ 'newFacetResult' smart constructor.
data FacetResult = FacetResult
  { -- | FacetBuckets for values in response containing at least a single result with the corresponding filter.
    buckets :: (Core.Maybe [FacetBucket]),
    -- | Object type for which facet results are returned. Can be empty.
    objectType :: (Core.Maybe Core.Text),
    -- | The name of the operator chosen for faceting. \@see cloudsearch.SchemaPropertyOptions
    operatorName :: (Core.Maybe Core.Text),
    -- | Source name for which facet results are returned. Will not be empty.
    sourceName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'FacetResult' with the minimum fields required to make a request.
newFacetResult ::
  FacetResult
newFacetResult =
  FacetResult
    { buckets = Core.Nothing,
      objectType = Core.Nothing,
      operatorName = Core.Nothing,
      sourceName = Core.Nothing
    }

instance Core.FromJSON FacetResult where
  parseJSON =
    Core.withObject
      "FacetResult"
      ( \o ->
          FacetResult
            Core.<$> (o Core..:? "buckets")
            Core.<*> (o Core..:? "objectType")
            Core.<*> (o Core..:? "operatorName")
            Core.<*> (o Core..:? "sourceName")
      )

instance Core.ToJSON FacetResult where
  toJSON FacetResult {..} =
    Core.object
      ( Core.catMaybes
          [ ("buckets" Core..=) Core.<$> buckets,
            ("objectType" Core..=) Core.<$> objectType,
            ("operatorName" Core..=) Core.<$> operatorName,
            ("sourceName" Core..=) Core.<$> sourceName
          ]
      )

--
-- /See:/ 'newFieldViolation' smart constructor.
data FieldViolation = FieldViolation
  { -- | The description of the error.
    description :: (Core.Maybe Core.Text),
    -- | Path of field with violation.
    field :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'FieldViolation' with the minimum fields required to make a request.
newFieldViolation ::
  FieldViolation
newFieldViolation =
  FieldViolation {description = Core.Nothing, field = Core.Nothing}

instance Core.FromJSON FieldViolation where
  parseJSON =
    Core.withObject
      "FieldViolation"
      ( \o ->
          FieldViolation
            Core.<$> (o Core..:? "description")
            Core.<*> (o Core..:? "field")
      )

instance Core.ToJSON FieldViolation where
  toJSON FieldViolation {..} =
    Core.object
      ( Core.catMaybes
          [ ("description" Core..=) Core.<$> description,
            ("field" Core..=) Core.<$> field
          ]
      )

-- | A generic way of expressing filters in a query, which supports two approaches: __1. Setting a ValueFilter.__ The name must match an operator_name defined in the schema for your data source. __2. Setting a CompositeFilter.__ The filters are evaluated using the logical operator. The top-level operators can only be either an AND or a NOT. AND can appear only at the top-most level. OR can appear only under a top-level AND.
--
-- /See:/ 'newFilter' smart constructor.
data Filter = Filter
  { -- |
    compositeFilter :: (Core.Maybe CompositeFilter),
    -- |
    valueFilter :: (Core.Maybe ValueFilter)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Filter' with the minimum fields required to make a request.
newFilter ::
  Filter
newFilter = Filter {compositeFilter = Core.Nothing, valueFilter = Core.Nothing}

instance Core.FromJSON Filter where
  parseJSON =
    Core.withObject
      "Filter"
      ( \o ->
          Filter
            Core.<$> (o Core..:? "compositeFilter")
            Core.<*> (o Core..:? "valueFilter")
      )

instance Core.ToJSON Filter where
  toJSON Filter {..} =
    Core.object
      ( Core.catMaybes
          [ ("compositeFilter" Core..=)
              Core.<$> compositeFilter,
            ("valueFilter" Core..=) Core.<$> valueFilter
          ]
      )

-- | A filter was created.
--
-- /See:/ 'newFilterCreated' smart constructor.
data FilterCreated = FilterCreated
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'FilterCreated' with the minimum fields required to make a request.
newFilterCreated ::
  FilterCreated
newFilterCreated = FilterCreated

instance Core.FromJSON FilterCreated where
  parseJSON =
    Core.withObject
      "FilterCreated"
      (\o -> Core.pure FilterCreated)

instance Core.ToJSON FilterCreated where
  toJSON = Core.const Core.emptyObject

-- | A filter was deleted.
--
-- /See:/ 'newFilterDeleted' smart constructor.
data FilterDeleted = FilterDeleted
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'FilterDeleted' with the minimum fields required to make a request.
newFilterDeleted ::
  FilterDeleted
newFilterDeleted = FilterDeleted

instance Core.FromJSON FilterDeleted where
  parseJSON =
    Core.withObject
      "FilterDeleted"
      (\o -> Core.pure FilterDeleted)

instance Core.ToJSON FilterDeleted where
  toJSON = Core.const Core.emptyObject

-- | Filter options to be applied on query.
--
-- /See:/ 'newFilterOptions' smart constructor.
data FilterOptions = FilterOptions
  { -- | Generic filter to restrict the search, such as @lang:en@, @site:xyz@.
    filter :: (Core.Maybe Filter),
    -- | If object_type is set, only objects of that type are returned. This should correspond to the name of the object that was registered within the definition of schema. The maximum length is 256 characters.
    objectType :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'FilterOptions' with the minimum fields required to make a request.
newFilterOptions ::
  FilterOptions
newFilterOptions =
  FilterOptions {filter = Core.Nothing, objectType = Core.Nothing}

instance Core.FromJSON FilterOptions where
  parseJSON =
    Core.withObject
      "FilterOptions"
      ( \o ->
          FilterOptions
            Core.<$> (o Core..:? "filter")
            Core.<*> (o Core..:? "objectType")
      )

instance Core.ToJSON FilterOptions where
  toJSON FilterOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("filter" Core..=) Core.<$> filter,
            ("objectType" Core..=) Core.<$> objectType
          ]
      )

-- | HistoryRecord for changes associated with a filter, namely: FILTER/CREATED FILTER/DELETED
--
-- /See:/ 'newFilterUpdate' smart constructor.
data FilterUpdate = FilterUpdate
  { -- |
    filterCreated :: (Core.Maybe FilterCreated),
    -- |
    filterDeleted :: (Core.Maybe FilterDeleted),
    -- |
    filterId :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'FilterUpdate' with the minimum fields required to make a request.
newFilterUpdate ::
  FilterUpdate
newFilterUpdate =
  FilterUpdate
    { filterCreated = Core.Nothing,
      filterDeleted = Core.Nothing,
      filterId = Core.Nothing
    }

instance Core.FromJSON FilterUpdate where
  parseJSON =
    Core.withObject
      "FilterUpdate"
      ( \o ->
          FilterUpdate
            Core.<$> (o Core..:? "filterCreated")
            Core.<*> (o Core..:? "filterDeleted")
            Core.<*> (o Core..:? "filterId")
      )

instance Core.ToJSON FilterUpdate where
  toJSON FilterUpdate {..} =
    Core.object
      ( Core.catMaybes
          [ ("filterCreated" Core..=) Core.<$> filterCreated,
            ("filterDeleted" Core..=) Core.<$> filterDeleted,
            ("filterId" Core..=) Core.<$> filterId
          ]
      )

-- | A persistent (sticky) footer that is added to the bottom of the card.
--
-- /See:/ 'newFixedFooter' smart constructor.
data FixedFooter = FixedFooter
  { -- |
    buttons :: (Core.Maybe [Button]),
    -- |
    primaryButton :: (Core.Maybe TextButton),
    -- |
    secondaryButton :: (Core.Maybe TextButton)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'FixedFooter' with the minimum fields required to make a request.
newFixedFooter ::
  FixedFooter
newFixedFooter =
  FixedFooter
    { buttons = Core.Nothing,
      primaryButton = Core.Nothing,
      secondaryButton = Core.Nothing
    }

instance Core.FromJSON FixedFooter where
  parseJSON =
    Core.withObject
      "FixedFooter"
      ( \o ->
          FixedFooter
            Core.<$> (o Core..:? "buttons")
            Core.<*> (o Core..:? "primaryButton")
            Core.<*> (o Core..:? "secondaryButton")
      )

instance Core.ToJSON FixedFooter where
  toJSON FixedFooter {..} =
    Core.object
      ( Core.catMaybes
          [ ("buttons" Core..=) Core.<$> buttons,
            ("primaryButton" Core..=) Core.<$> primaryButton,
            ("secondaryButton" Core..=)
              Core.<$> secondaryButton
          ]
      )

--
-- /See:/ 'newFolder' smart constructor.
data Folder = Folder
  { -- | Folder mapping id.
    id :: (Core.Maybe Core.Word64),
    -- | One for each copy of the message in the IMAP folder.
    message :: (Core.Maybe [ImapsyncFolderAttributeFolderMessage])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Folder' with the minimum fields required to make a request.
newFolder ::
  Folder
newFolder = Folder {id = Core.Nothing, message = Core.Nothing}

instance Core.FromJSON Folder where
  parseJSON =
    Core.withObject
      "Folder"
      ( \o ->
          Folder
            Core.<$> (o Core..:? "id" Core.<&> Core.fmap Core.fromAsText)
            Core.<*> (o Core..:? "message")
      )

instance Core.ToJSON Folder where
  toJSON Folder {..} =
    Core.object
      ( Core.catMaybes
          [ ("id" Core..=) Core.. Core.AsText Core.<$> id,
            ("message" Core..=) Core.<$> message
          ]
      )

-- | This is the content of \/\/imapsync\/folder attribute.
--
-- /See:/ 'newFolderAttribute' smart constructor.
newtype FolderAttribute = FolderAttribute
  { -- | List of all IMAP folders where the message presents.
    folder :: (Core.Maybe [Folder])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'FolderAttribute' with the minimum fields required to make a request.
newFolderAttribute ::
  FolderAttribute
newFolderAttribute = FolderAttribute {folder = Core.Nothing}

instance Core.FromJSON FolderAttribute where
  parseJSON =
    Core.withObject
      "FolderAttribute"
      ( \o ->
          FolderAttribute Core.<$> (o Core..:? "folder")
      )

instance Core.ToJSON FolderAttribute where
  toJSON FolderAttribute {..} =
    Core.object
      (Core.catMaybes [("folder" Core..=) Core.<$> folder])

--
-- /See:/ 'newFormAction' smart constructor.
data FormAction = FormAction
  { -- | Apps script function that should be invoked in the developer\'s apps script when the containing element is clicked\/activated.
    actionMethodName :: (Core.Maybe Core.Text),
    -- |
    loadIndicator :: (Core.Maybe FormAction_LoadIndicator),
    -- |
    parameters :: (Core.Maybe [ActionParameter]),
    -- | Indicates whether form values persist after the action. When false, the Apps Script is responsible for persisting values, by setting any form field values using the formInputs in the event. Disabling this behavior can be used if the add-on needs the ability to clear form fields, for example, as with persistent values, there is no means for clearing existing values. When disabling persistent values, it is strongly recommended that the add-on use LoadIndicator.SPINNER for all events, as this locks the UI to ensure no changes are made by the user while the action is being processed. When using LoadIndicator.NONE for any of the actions, persistent values are recommended, as it ensures that any changes made by the user after form \/ on change actions are sent to the server are not overwritten by the response. Persistent values disabled by default. While we recommend persistent values be used in the typical use case, we do not enable by default, as doing so would change the current behavior of existing add-ons in
    -- prod.
    persistValues :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'FormAction' with the minimum fields required to make a request.
newFormAction ::
  FormAction
newFormAction =
  FormAction
    { actionMethodName = Core.Nothing,
      loadIndicator = Core.Nothing,
      parameters = Core.Nothing,
      persistValues = Core.Nothing
    }

instance Core.FromJSON FormAction where
  parseJSON =
    Core.withObject
      "FormAction"
      ( \o ->
          FormAction
            Core.<$> (o Core..:? "actionMethodName")
            Core.<*> (o Core..:? "loadIndicator")
            Core.<*> (o Core..:? "parameters")
            Core.<*> (o Core..:? "persistValues")
      )

instance Core.ToJSON FormAction where
  toJSON FormAction {..} =
    Core.object
      ( Core.catMaybes
          [ ("actionMethodName" Core..=)
              Core.<$> actionMethodName,
            ("loadIndicator" Core..=) Core.<$> loadIndicator,
            ("parameters" Core..=) Core.<$> parameters,
            ("persistValues" Core..=) Core.<$> persistValues
          ]
      )

-- | Annotation metadata for markup formatting
--
-- /See:/ 'newFormatMetadata' smart constructor.
data FormatMetadata = FormatMetadata
  { -- | Font color is set if and only if format/type is FONT/COLOR. The components are stored as (alpha \<\< 24) | (red \<\< 16) | (green \<\< 8) | blue. Clients should always set the alpha component to 0xFF. NEXT TAG: 3
    fontColor :: (Core.Maybe Core.Word32),
    -- | LINT.ThenChange(\/\/depot\/google3\/apps\/dynamite\/v1\/web\/datakeys\/annotated_span.proto)
    formatType :: (Core.Maybe FormatMetadata_FormatType)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'FormatMetadata' with the minimum fields required to make a request.
newFormatMetadata ::
  FormatMetadata
newFormatMetadata =
  FormatMetadata {fontColor = Core.Nothing, formatType = Core.Nothing}

instance Core.FromJSON FormatMetadata where
  parseJSON =
    Core.withObject
      "FormatMetadata"
      ( \o ->
          FormatMetadata
            Core.<$> (o Core..:? "fontColor")
            Core.<*> (o Core..:? "formatType")
      )

instance Core.ToJSON FormatMetadata where
  toJSON FormatMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("fontColor" Core..=) Core.<$> fontColor,
            ("formatType" Core..=) Core.<$> formatType
          ]
      )

-- | Formatting information for a segment.
--
-- /See:/ 'newFormatting' smart constructor.
data Formatting = Formatting
  { -- |
    bold :: (Core.Maybe Core.Bool),
    -- | This indicates that the segment should be rendered as highlighted or visually emphasized.
    highlight :: (Core.Maybe Core.Bool),
    -- |
    italics :: (Core.Maybe Core.Bool),
    -- |
    strikethrough :: (Core.Maybe Core.Bool),
    -- | If set, this indicates that the segment should be rendered with the specified style. The absence of an explicit style represents \"no style\", i.e. the segment can be rendered with the default style chosen by the application.
    style :: (Core.Maybe Formatting_Style),
    -- |
    underline :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Formatting' with the minimum fields required to make a request.
newFormatting ::
  Formatting
newFormatting =
  Formatting
    { bold = Core.Nothing,
      highlight = Core.Nothing,
      italics = Core.Nothing,
      strikethrough = Core.Nothing,
      style = Core.Nothing,
      underline = Core.Nothing
    }

instance Core.FromJSON Formatting where
  parseJSON =
    Core.withObject
      "Formatting"
      ( \o ->
          Formatting
            Core.<$> (o Core..:? "bold")
            Core.<*> (o Core..:? "highlight")
            Core.<*> (o Core..:? "italics")
            Core.<*> (o Core..:? "strikethrough")
            Core.<*> (o Core..:? "style")
            Core.<*> (o Core..:? "underline")
      )

instance Core.ToJSON Formatting where
  toJSON Formatting {..} =
    Core.object
      ( Core.catMaybes
          [ ("bold" Core..=) Core.<$> bold,
            ("highlight" Core..=) Core.<$> highlight,
            ("italics" Core..=) Core.<$> italics,
            ("strikethrough" Core..=) Core.<$> strikethrough,
            ("style" Core..=) Core.<$> style,
            ("underline" Core..=) Core.<$> underline
          ]
      )

-- | Indicates which freshness property to use when adjusting search ranking for an item. Fresher, more recent dates indicate higher quality. Use the freshness option property that best works with your data. For fileshare documents, last modified time is most relevant. For calendar event data, the time when the event occurs is a more relevant freshness indicator. In this way, calendar events that occur closer to the time of the search query are considered higher quality and ranked accordingly.
--
-- /See:/ 'newFreshnessOptions' smart constructor.
data FreshnessOptions = FreshnessOptions
  { -- | The duration after which an object should be considered stale. The default value is 180 days (in seconds).
    freshnessDuration :: (Core.Maybe Core.Duration),
    -- | This property indicates the freshness level of the object in the index. If set, this property must be a top-level property within the property definitions and it must be a timestamp type or date type. Otherwise, the Indexing API uses updateTime as the freshness indicator. The maximum length is 256 characters. When a property is used to calculate freshness, the value defaults to 2 years from the current time.
    freshnessProperty :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'FreshnessOptions' with the minimum fields required to make a request.
newFreshnessOptions ::
  FreshnessOptions
newFreshnessOptions =
  FreshnessOptions
    { freshnessDuration = Core.Nothing,
      freshnessProperty = Core.Nothing
    }

instance Core.FromJSON FreshnessOptions where
  parseJSON =
    Core.withObject
      "FreshnessOptions"
      ( \o ->
          FreshnessOptions
            Core.<$> (o Core..:? "freshnessDuration")
            Core.<*> (o Core..:? "freshnessProperty")
      )

instance Core.ToJSON FreshnessOptions where
  toJSON FreshnessOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("freshnessDuration" Core..=)
              Core.<$> freshnessDuration,
            ("freshnessProperty" Core..=)
              Core.<$> freshnessProperty
          ]
      )

-- | The Item message is the read interface for user data (traditionally referred to as a \"message\", such as a mail message or a chat message, but generalized to encompass other types such as tasks) and stored in Tingle. Each Item is associated with a single Thread. An Item contains three classes of data. (1): Item \"fields\" are common to items of all message types (e.g. mail, chat, task, etc.) and are identified by the ItemFieldSpec.FetchType enum when fetching Items. (2): Item \"attributes\" represent data associated with an Item that is stored on behalf of the client but to which the fusebox and storage layers are otherwise agnostic. (3): Item \"parts\" are application-defined protocol buffers that affect how the Item is indexed. Item parts are referenced as extensions to the ItemParts message. By default the application specifies the index terms associated with an Item part. For performance sensitive applications, the storage layer can be modified to understand and index data types natively.
--
-- /See:/ 'newFuseboxItem' smart constructor.
data FuseboxItem = FuseboxItem
  { -- |
    attributes :: (Core.Maybe Attributes),
    -- | The creation time of the Item in micro seconds.
    creationTimeMicroseconds :: (Core.Maybe Core.Word64),
    -- |
    history :: (Core.Maybe History),
    -- | The key is used to refer to an item. Note that every field of the MultiKey is unique to the Item, and thus the Item can be looked up by any of the fields.
    itemKey :: (Core.Maybe MultiKey),
    -- |
    labels :: (Core.Maybe Labels),
    -- | The modification time of the Item in micro seconds. Modifications to the message include label addition, deletion, etc.
    lastModificationTimeUs :: (Core.Maybe Core.Word64),
    -- | go\/lockpicker Locker counterpart of references.
    lockerReferences :: (Core.Maybe References),
    -- |
    matchInfo :: (Core.Maybe MatchInfo),
    -- | Type-specific data are represented as extensions to the ItemParts message.
    parts :: (Core.Maybe ItemParts),
    -- | The read timestamp at which this item was read. This is a temporary field used to check if two items streamed during dual reading were read at the same timestamp. This will be populated by Fusebox RPCs. \"DO NOT USE UNLESS YOU TALK TO FUSEBOX TEAM (gmail-fusebox\@)\".
    readTs :: (Core.Maybe Core.Int64),
    -- | References to attachments, video attachments in Youtube and Hangout messages.
    references :: (Core.Maybe References),
    -- | The snippet is a brief bit of text describing this item.
    snippet :: (Core.Maybe Core.Text),
    -- | The key of the Thread with which this Item is associated.
    threadKey :: (Core.Maybe MultiKey),
    -- | A base64 encoded and encrypted string generated from the Gaia Id and the thread id. Used to generate the permalink for this thread, exposed from Gmail API.
    threadLocator :: (Core.Maybe Core.Text),
    -- |
    triggers :: (Core.Maybe Triggers),
    -- | The latest history operation id that resulted in a mutation of the item.
    version :: (Core.Maybe Core.Word64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'FuseboxItem' with the minimum fields required to make a request.
newFuseboxItem ::
  FuseboxItem
newFuseboxItem =
  FuseboxItem
    { attributes = Core.Nothing,
      creationTimeMicroseconds = Core.Nothing,
      history = Core.Nothing,
      itemKey = Core.Nothing,
      labels = Core.Nothing,
      lastModificationTimeUs = Core.Nothing,
      lockerReferences = Core.Nothing,
      matchInfo = Core.Nothing,
      parts = Core.Nothing,
      readTs = Core.Nothing,
      references = Core.Nothing,
      snippet = Core.Nothing,
      threadKey = Core.Nothing,
      threadLocator = Core.Nothing,
      triggers = Core.Nothing,
      version = Core.Nothing
    }

instance Core.FromJSON FuseboxItem where
  parseJSON =
    Core.withObject
      "FuseboxItem"
      ( \o ->
          FuseboxItem
            Core.<$> (o Core..:? "attributes")
            Core.<*> ( o Core..:? "creationTimeMicroseconds"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "history")
            Core.<*> (o Core..:? "itemKey")
            Core.<*> (o Core..:? "labels")
            Core.<*> ( o Core..:? "lastModificationTimeUs"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "lockerReferences")
            Core.<*> (o Core..:? "matchInfo")
            Core.<*> (o Core..:? "parts")
            Core.<*> ( o Core..:? "readTs"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "references")
            Core.<*> (o Core..:? "snippet")
            Core.<*> (o Core..:? "threadKey")
            Core.<*> (o Core..:? "threadLocator")
            Core.<*> (o Core..:? "triggers")
            Core.<*> ( o Core..:? "version"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON FuseboxItem where
  toJSON FuseboxItem {..} =
    Core.object
      ( Core.catMaybes
          [ ("attributes" Core..=) Core.<$> attributes,
            ("creationTimeMicroseconds" Core..=)
              Core.. Core.AsText
              Core.<$> creationTimeMicroseconds,
            ("history" Core..=) Core.<$> history,
            ("itemKey" Core..=) Core.<$> itemKey,
            ("labels" Core..=) Core.<$> labels,
            ("lastModificationTimeUs" Core..=) Core.. Core.AsText
              Core.<$> lastModificationTimeUs,
            ("lockerReferences" Core..=)
              Core.<$> lockerReferences,
            ("matchInfo" Core..=) Core.<$> matchInfo,
            ("parts" Core..=) Core.<$> parts,
            ("readTs" Core..=) Core.. Core.AsText
              Core.<$> readTs,
            ("references" Core..=) Core.<$> references,
            ("snippet" Core..=) Core.<$> snippet,
            ("threadKey" Core..=) Core.<$> threadKey,
            ("threadLocator" Core..=) Core.<$> threadLocator,
            ("triggers" Core..=) Core.<$> triggers,
            ("version" Core..=) Core.. Core.AsText
              Core.<$> version
          ]
      )

-- | In the context of a search, the MatchInfo contains information about which Items matched the query.
--
-- /See:/ 'newFuseboxItemThreadMatchInfo' smart constructor.
data FuseboxItemThreadMatchInfo = FuseboxItemThreadMatchInfo
  { -- | If SearchQuery.Options.Clustering is present, the query will be treated as a cluster query, and this field may be populated with the cluster ID of the cluster to which this thread belongs, if any. The cluster ID will be a label on the message.
    clusterId :: (Core.Maybe Core.Text),
    -- | The server id of the last item that matched the query. This is always set, regardless of the compute/matching/items/per/thread option. This is the value by which search results are sorted, in descending (i.e. newest first) order.
    lastMatchingItemId :: (Core.Maybe Core.Word64),
    -- | The MultiKey of the last item that matched the query. This is always set, regardless of the compute/matching/items/per/thread option. This is the value by which search results are sorted, in descending (i.e. newest first) order.
    lastMatchingItemKey :: (Core.Maybe MultiKey),
    -- | If SearchQuery.Options.compute/matching/items/per/thread, this field will contain the keys of all items that matched the query, in ascending order. Note that this option requires extra computation.
    matchingItemKey :: (Core.Maybe [MultiKey]),
    -- | The rank of this ItemThread in the result set of the query. This rank may be used to sort ItemThreads in proper order. Ranks are specific to a query, and stable for a given query at a specific time.
    rank :: (Core.Maybe Rank)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'FuseboxItemThreadMatchInfo' with the minimum fields required to make a request.
newFuseboxItemThreadMatchInfo ::
  FuseboxItemThreadMatchInfo
newFuseboxItemThreadMatchInfo =
  FuseboxItemThreadMatchInfo
    { clusterId = Core.Nothing,
      lastMatchingItemId = Core.Nothing,
      lastMatchingItemKey = Core.Nothing,
      matchingItemKey = Core.Nothing,
      rank = Core.Nothing
    }

instance Core.FromJSON FuseboxItemThreadMatchInfo where
  parseJSON =
    Core.withObject
      "FuseboxItemThreadMatchInfo"
      ( \o ->
          FuseboxItemThreadMatchInfo
            Core.<$> (o Core..:? "clusterId")
            Core.<*> ( o Core..:? "lastMatchingItemId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "lastMatchingItemKey")
            Core.<*> (o Core..:? "matchingItemKey")
            Core.<*> (o Core..:? "rank")
      )

instance Core.ToJSON FuseboxItemThreadMatchInfo where
  toJSON FuseboxItemThreadMatchInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("clusterId" Core..=) Core.<$> clusterId,
            ("lastMatchingItemId" Core..=) Core.. Core.AsText
              Core.<$> lastMatchingItemId,
            ("lastMatchingItemKey" Core..=)
              Core.<$> lastMatchingItemKey,
            ("matchingItemKey" Core..=) Core.<$> matchingItemKey,
            ("rank" Core..=) Core.<$> rank
          ]
      )

-- | If the Value field is not set this means the pref did not exist.
--
-- /See:/ 'newFuseboxPrefUpdatePreState' smart constructor.
newtype FuseboxPrefUpdatePreState = FuseboxPrefUpdatePreState
  { -- |
    value :: (Core.Maybe Core.Base64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'FuseboxPrefUpdatePreState' with the minimum fields required to make a request.
newFuseboxPrefUpdatePreState ::
  FuseboxPrefUpdatePreState
newFuseboxPrefUpdatePreState = FuseboxPrefUpdatePreState {value = Core.Nothing}

instance Core.FromJSON FuseboxPrefUpdatePreState where
  parseJSON =
    Core.withObject
      "FuseboxPrefUpdatePreState"
      ( \o ->
          FuseboxPrefUpdatePreState
            Core.<$> (o Core..:? "value")
      )

instance Core.ToJSON FuseboxPrefUpdatePreState where
  toJSON FuseboxPrefUpdatePreState {..} =
    Core.object
      (Core.catMaybes [("value" Core..=) Core.<$> value])

--
-- /See:/ 'newGSuitePrincipal' smart constructor.
data GSuitePrincipal = GSuitePrincipal
  { -- | This principal represents all users of the Google Workspace domain of the customer.
    gsuiteDomain :: (Core.Maybe Core.Bool),
    -- | This principal references a Google Workspace group name.
    gsuiteGroupEmail :: (Core.Maybe Core.Text),
    -- | This principal references a Google Workspace user account.
    gsuiteUserEmail :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GSuitePrincipal' with the minimum fields required to make a request.
newGSuitePrincipal ::
  GSuitePrincipal
newGSuitePrincipal =
  GSuitePrincipal
    { gsuiteDomain = Core.Nothing,
      gsuiteGroupEmail = Core.Nothing,
      gsuiteUserEmail = Core.Nothing
    }

instance Core.FromJSON GSuitePrincipal where
  parseJSON =
    Core.withObject
      "GSuitePrincipal"
      ( \o ->
          GSuitePrincipal
            Core.<$> (o Core..:? "gsuiteDomain")
            Core.<*> (o Core..:? "gsuiteGroupEmail")
            Core.<*> (o Core..:? "gsuiteUserEmail")
      )

instance Core.ToJSON GSuitePrincipal where
  toJSON GSuitePrincipal {..} =
    Core.object
      ( Core.catMaybes
          [ ("gsuiteDomain" Core..=) Core.<$> gsuiteDomain,
            ("gsuiteGroupEmail" Core..=)
              Core.<$> gsuiteGroupEmail,
            ("gsuiteUserEmail" Core..=)
              Core.<$> gsuiteUserEmail
          ]
      )

--
-- /See:/ 'newGaiaGroupProto' smart constructor.
newtype GaiaGroupProto = GaiaGroupProto
  { -- |
    groupId :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GaiaGroupProto' with the minimum fields required to make a request.
newGaiaGroupProto ::
  GaiaGroupProto
newGaiaGroupProto = GaiaGroupProto {groupId = Core.Nothing}

instance Core.FromJSON GaiaGroupProto where
  parseJSON =
    Core.withObject
      "GaiaGroupProto"
      ( \o ->
          GaiaGroupProto
            Core.<$> ( o Core..:? "groupId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON GaiaGroupProto where
  toJSON GaiaGroupProto {..} =
    Core.object
      ( Core.catMaybes
          [ ("groupId" Core..=) Core.. Core.AsText
              Core.<$> groupId
          ]
      )

-- | A Gaia account, which may represent a user, device, service account, etc. For prod (\@prod.google.com) accounts, use MdbUserProto instead.
--
-- /See:/ 'newGaiaUserProto' smart constructor.
newtype GaiaUserProto = GaiaUserProto
  { -- |
    userId :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GaiaUserProto' with the minimum fields required to make a request.
newGaiaUserProto ::
  GaiaUserProto
newGaiaUserProto = GaiaUserProto {userId = Core.Nothing}

instance Core.FromJSON GaiaUserProto where
  parseJSON =
    Core.withObject
      "GaiaUserProto"
      ( \o ->
          GaiaUserProto
            Core.<$> ( o Core..:? "userId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON GaiaUserProto where
  toJSON GaiaUserProto {..} =
    Core.object
      ( Core.catMaybes
          [ ("userId" Core..=) Core.. Core.AsText
              Core.<$> userId
          ]
      )

-- | Details on the third-party interoperability settings for the meeting space.
--
-- /See:/ 'newGatewayAccess' smart constructor.
newtype GatewayAccess = GatewayAccess
  { -- | Whether third-party gateway accesses are enabled for this meeting space. If enabled, the actual access code can be retrieved by calling the GetGatewayAccess RPC method.
    enabled :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GatewayAccess' with the minimum fields required to make a request.
newGatewayAccess ::
  GatewayAccess
newGatewayAccess = GatewayAccess {enabled = Core.Nothing}

instance Core.FromJSON GatewayAccess where
  parseJSON =
    Core.withObject
      "GatewayAccess"
      ( \o ->
          GatewayAccess Core.<$> (o Core..:? "enabled")
      )

instance Core.ToJSON GatewayAccess where
  toJSON GatewayAccess {..} =
    Core.object
      ( Core.catMaybes
          [("enabled" Core..=) Core.<$> enabled]
      )

-- | Details how to join the conference via a SIP gateway.
--
-- /See:/ 'newGatewaySipAccess' smart constructor.
data GatewaySipAccess = GatewaySipAccess
  { -- | Permanent numeric code for manual entry on specially configured devices, currently the same as the PSTN \"Universal pin\".
    sipAccessCode :: (Core.Maybe Core.Text),
    -- | The SIP URI the conference can be reached through. The string is on one of the formats: \"sip:\@\" \"sips:\@\" where currently is the 13-digit universal pin (with the future option to support using a Meet meeting code as well), and is a valid address to be resolved using a DNS SRV lookup, or a dotted quad.
    uri :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GatewaySipAccess' with the minimum fields required to make a request.
newGatewaySipAccess ::
  GatewaySipAccess
newGatewaySipAccess =
  GatewaySipAccess {sipAccessCode = Core.Nothing, uri = Core.Nothing}

instance Core.FromJSON GatewaySipAccess where
  parseJSON =
    Core.withObject
      "GatewaySipAccess"
      ( \o ->
          GatewaySipAccess
            Core.<$> (o Core..:? "sipAccessCode")
            Core.<*> (o Core..:? "uri")
      )

instance Core.ToJSON GatewaySipAccess where
  toJSON GatewaySipAccess {..} =
    Core.object
      ( Core.catMaybes
          [ ("sipAccessCode" Core..=) Core.<$> sipAccessCode,
            ("uri" Core..=) Core.<$> uri
          ]
      )

--
-- /See:/ 'newGetCustomerIndexStatsResponse' smart constructor.
data GetCustomerIndexStatsResponse = GetCustomerIndexStatsResponse
  { -- | Average item count for the given date range for which billing is done.
    averageIndexedItemCount :: (Core.Maybe Core.Int64),
    -- | Summary of indexed item counts, one for each day in the requested range.
    stats :: (Core.Maybe [CustomerIndexStats])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GetCustomerIndexStatsResponse' with the minimum fields required to make a request.
newGetCustomerIndexStatsResponse ::
  GetCustomerIndexStatsResponse
newGetCustomerIndexStatsResponse =
  GetCustomerIndexStatsResponse
    { averageIndexedItemCount = Core.Nothing,
      stats = Core.Nothing
    }

instance Core.FromJSON GetCustomerIndexStatsResponse where
  parseJSON =
    Core.withObject
      "GetCustomerIndexStatsResponse"
      ( \o ->
          GetCustomerIndexStatsResponse
            Core.<$> ( o Core..:? "averageIndexedItemCount"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "stats")
      )

instance Core.ToJSON GetCustomerIndexStatsResponse where
  toJSON GetCustomerIndexStatsResponse {..} =
    Core.object
      ( Core.catMaybes
          [ ("averageIndexedItemCount" Core..=)
              Core.. Core.AsText
              Core.<$> averageIndexedItemCount,
            ("stats" Core..=) Core.<$> stats
          ]
      )

--
-- /See:/ 'newGetCustomerQueryStatsResponse' smart constructor.
data GetCustomerQueryStatsResponse = GetCustomerQueryStatsResponse
  { -- |
    stats :: (Core.Maybe [CustomerQueryStats]),
    -- | Total successful query count (status code 200) for the given date range.
    totalQueryCount :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GetCustomerQueryStatsResponse' with the minimum fields required to make a request.
newGetCustomerQueryStatsResponse ::
  GetCustomerQueryStatsResponse
newGetCustomerQueryStatsResponse =
  GetCustomerQueryStatsResponse
    { stats = Core.Nothing,
      totalQueryCount = Core.Nothing
    }

instance Core.FromJSON GetCustomerQueryStatsResponse where
  parseJSON =
    Core.withObject
      "GetCustomerQueryStatsResponse"
      ( \o ->
          GetCustomerQueryStatsResponse
            Core.<$> (o Core..:? "stats")
            Core.<*> ( o Core..:? "totalQueryCount"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON GetCustomerQueryStatsResponse where
  toJSON GetCustomerQueryStatsResponse {..} =
    Core.object
      ( Core.catMaybes
          [ ("stats" Core..=) Core.<$> stats,
            ("totalQueryCount" Core..=) Core.. Core.AsText
              Core.<$> totalQueryCount
          ]
      )

-- | Response format for search application stats for a customer.
--
-- /See:/ 'newGetCustomerSearchApplicationStatsResponse' smart constructor.
data GetCustomerSearchApplicationStatsResponse = GetCustomerSearchApplicationStatsResponse
  { -- | Average search application count for the given date range.
    averageSearchApplicationCount :: (Core.Maybe Core.Int64),
    -- | Search application stats by date.
    stats :: (Core.Maybe [CustomerSearchApplicationStats])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GetCustomerSearchApplicationStatsResponse' with the minimum fields required to make a request.
newGetCustomerSearchApplicationStatsResponse ::
  GetCustomerSearchApplicationStatsResponse
newGetCustomerSearchApplicationStatsResponse =
  GetCustomerSearchApplicationStatsResponse
    { averageSearchApplicationCount = Core.Nothing,
      stats = Core.Nothing
    }

instance
  Core.FromJSON
    GetCustomerSearchApplicationStatsResponse
  where
  parseJSON =
    Core.withObject
      "GetCustomerSearchApplicationStatsResponse"
      ( \o ->
          GetCustomerSearchApplicationStatsResponse
            Core.<$> ( o Core..:? "averageSearchApplicationCount"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "stats")
      )

instance
  Core.ToJSON
    GetCustomerSearchApplicationStatsResponse
  where
  toJSON GetCustomerSearchApplicationStatsResponse {..} =
    Core.object
      ( Core.catMaybes
          [ ("averageSearchApplicationCount" Core..=)
              Core.. Core.AsText
              Core.<$> averageSearchApplicationCount,
            ("stats" Core..=) Core.<$> stats
          ]
      )

--
-- /See:/ 'newGetCustomerSessionStatsResponse' smart constructor.
newtype GetCustomerSessionStatsResponse = GetCustomerSessionStatsResponse
  { -- |
    stats :: (Core.Maybe [CustomerSessionStats])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GetCustomerSessionStatsResponse' with the minimum fields required to make a request.
newGetCustomerSessionStatsResponse ::
  GetCustomerSessionStatsResponse
newGetCustomerSessionStatsResponse =
  GetCustomerSessionStatsResponse {stats = Core.Nothing}

instance
  Core.FromJSON
    GetCustomerSessionStatsResponse
  where
  parseJSON =
    Core.withObject
      "GetCustomerSessionStatsResponse"
      ( \o ->
          GetCustomerSessionStatsResponse
            Core.<$> (o Core..:? "stats")
      )

instance Core.ToJSON GetCustomerSessionStatsResponse where
  toJSON GetCustomerSessionStatsResponse {..} =
    Core.object
      (Core.catMaybes [("stats" Core..=) Core.<$> stats])

--
-- /See:/ 'newGetCustomerUserStatsResponse' smart constructor.
newtype GetCustomerUserStatsResponse = GetCustomerUserStatsResponse
  { -- |
    stats :: (Core.Maybe [CustomerUserStats])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GetCustomerUserStatsResponse' with the minimum fields required to make a request.
newGetCustomerUserStatsResponse ::
  GetCustomerUserStatsResponse
newGetCustomerUserStatsResponse =
  GetCustomerUserStatsResponse {stats = Core.Nothing}

instance Core.FromJSON GetCustomerUserStatsResponse where
  parseJSON =
    Core.withObject
      "GetCustomerUserStatsResponse"
      ( \o ->
          GetCustomerUserStatsResponse
            Core.<$> (o Core..:? "stats")
      )

instance Core.ToJSON GetCustomerUserStatsResponse where
  toJSON GetCustomerUserStatsResponse {..} =
    Core.object
      (Core.catMaybes [("stats" Core..=) Core.<$> stats])

--
-- /See:/ 'newGetDataSourceIndexStatsResponse' smart constructor.
data GetDataSourceIndexStatsResponse = GetDataSourceIndexStatsResponse
  { -- | Average item count for the given date range for which billing is done.
    averageIndexedItemCount :: (Core.Maybe Core.Int64),
    -- | Summary of indexed item counts, one for each day in the requested range.
    stats :: (Core.Maybe [DataSourceIndexStats])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GetDataSourceIndexStatsResponse' with the minimum fields required to make a request.
newGetDataSourceIndexStatsResponse ::
  GetDataSourceIndexStatsResponse
newGetDataSourceIndexStatsResponse =
  GetDataSourceIndexStatsResponse
    { averageIndexedItemCount = Core.Nothing,
      stats = Core.Nothing
    }

instance
  Core.FromJSON
    GetDataSourceIndexStatsResponse
  where
  parseJSON =
    Core.withObject
      "GetDataSourceIndexStatsResponse"
      ( \o ->
          GetDataSourceIndexStatsResponse
            Core.<$> ( o Core..:? "averageIndexedItemCount"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "stats")
      )

instance Core.ToJSON GetDataSourceIndexStatsResponse where
  toJSON GetDataSourceIndexStatsResponse {..} =
    Core.object
      ( Core.catMaybes
          [ ("averageIndexedItemCount" Core..=)
              Core.. Core.AsText
              Core.<$> averageIndexedItemCount,
            ("stats" Core..=) Core.<$> stats
          ]
      )

-- | Response format for getting query stats for a search application between given dates.
--
-- /See:/ 'newGetSearchApplicationQueryStatsResponse' smart constructor.
data GetSearchApplicationQueryStatsResponse = GetSearchApplicationQueryStatsResponse
  { -- | Query stats per date for a search application.
    stats :: (Core.Maybe [SearchApplicationQueryStats]),
    -- | Total successful query count (status code 200) for the given date range.
    totalQueryCount :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GetSearchApplicationQueryStatsResponse' with the minimum fields required to make a request.
newGetSearchApplicationQueryStatsResponse ::
  GetSearchApplicationQueryStatsResponse
newGetSearchApplicationQueryStatsResponse =
  GetSearchApplicationQueryStatsResponse
    { stats = Core.Nothing,
      totalQueryCount = Core.Nothing
    }

instance
  Core.FromJSON
    GetSearchApplicationQueryStatsResponse
  where
  parseJSON =
    Core.withObject
      "GetSearchApplicationQueryStatsResponse"
      ( \o ->
          GetSearchApplicationQueryStatsResponse
            Core.<$> (o Core..:? "stats")
            Core.<*> ( o Core..:? "totalQueryCount"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance
  Core.ToJSON
    GetSearchApplicationQueryStatsResponse
  where
  toJSON GetSearchApplicationQueryStatsResponse {..} =
    Core.object
      ( Core.catMaybes
          [ ("stats" Core..=) Core.<$> stats,
            ("totalQueryCount" Core..=) Core.. Core.AsText
              Core.<$> totalQueryCount
          ]
      )

--
-- /See:/ 'newGetSearchApplicationSessionStatsResponse' smart constructor.
newtype GetSearchApplicationSessionStatsResponse = GetSearchApplicationSessionStatsResponse
  { -- |
    stats :: (Core.Maybe [SearchApplicationSessionStats])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GetSearchApplicationSessionStatsResponse' with the minimum fields required to make a request.
newGetSearchApplicationSessionStatsResponse ::
  GetSearchApplicationSessionStatsResponse
newGetSearchApplicationSessionStatsResponse =
  GetSearchApplicationSessionStatsResponse {stats = Core.Nothing}

instance
  Core.FromJSON
    GetSearchApplicationSessionStatsResponse
  where
  parseJSON =
    Core.withObject
      "GetSearchApplicationSessionStatsResponse"
      ( \o ->
          GetSearchApplicationSessionStatsResponse
            Core.<$> (o Core..:? "stats")
      )

instance
  Core.ToJSON
    GetSearchApplicationSessionStatsResponse
  where
  toJSON GetSearchApplicationSessionStatsResponse {..} =
    Core.object
      (Core.catMaybes [("stats" Core..=) Core.<$> stats])

--
-- /See:/ 'newGetSearchApplicationUserStatsResponse' smart constructor.
newtype GetSearchApplicationUserStatsResponse = GetSearchApplicationUserStatsResponse
  { -- |
    stats :: (Core.Maybe [SearchApplicationUserStats])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GetSearchApplicationUserStatsResponse' with the minimum fields required to make a request.
newGetSearchApplicationUserStatsResponse ::
  GetSearchApplicationUserStatsResponse
newGetSearchApplicationUserStatsResponse =
  GetSearchApplicationUserStatsResponse {stats = Core.Nothing}

instance
  Core.FromJSON
    GetSearchApplicationUserStatsResponse
  where
  parseJSON =
    Core.withObject
      "GetSearchApplicationUserStatsResponse"
      ( \o ->
          GetSearchApplicationUserStatsResponse
            Core.<$> (o Core..:? "stats")
      )

instance
  Core.ToJSON
    GetSearchApplicationUserStatsResponse
  where
  toJSON GetSearchApplicationUserStatsResponse {..} =
    Core.object
      (Core.catMaybes [("stats" Core..=) Core.<$> stats])

--
-- /See:/ 'newGmailClientActionMarkup' smart constructor.
data GmailClientActionMarkup = GmailClientActionMarkup
  { -- |
    addonComposeUiActionMarkup :: (Core.Maybe AddonComposeUiActionMarkup),
    -- |
    openCreatedDraftActionMarkup :: (Core.Maybe OpenCreatedDraftActionMarkup),
    -- |
    taskAction :: (Core.Maybe TaskActionMarkup),
    -- |
    updateDraftActionMarkup :: (Core.Maybe UpdateDraftActionMarkup)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GmailClientActionMarkup' with the minimum fields required to make a request.
newGmailClientActionMarkup ::
  GmailClientActionMarkup
newGmailClientActionMarkup =
  GmailClientActionMarkup
    { addonComposeUiActionMarkup = Core.Nothing,
      openCreatedDraftActionMarkup = Core.Nothing,
      taskAction = Core.Nothing,
      updateDraftActionMarkup = Core.Nothing
    }

instance Core.FromJSON GmailClientActionMarkup where
  parseJSON =
    Core.withObject
      "GmailClientActionMarkup"
      ( \o ->
          GmailClientActionMarkup
            Core.<$> (o Core..:? "addonComposeUiActionMarkup")
            Core.<*> (o Core..:? "openCreatedDraftActionMarkup")
            Core.<*> (o Core..:? "taskAction")
            Core.<*> (o Core..:? "updateDraftActionMarkup")
      )

instance Core.ToJSON GmailClientActionMarkup where
  toJSON GmailClientActionMarkup {..} =
    Core.object
      ( Core.catMaybes
          [ ("addonComposeUiActionMarkup" Core..=)
              Core.<$> addonComposeUiActionMarkup,
            ("openCreatedDraftActionMarkup" Core..=)
              Core.<$> openCreatedDraftActionMarkup,
            ("taskAction" Core..=) Core.<$> taskAction,
            ("updateDraftActionMarkup" Core..=)
              Core.<$> updateDraftActionMarkup
          ]
      )

-- | The markup for developers to specify the contents of a contextual AddOn.
--
-- /See:/ 'newGoogleChatV1ContextualAddOnMarkup' smart constructor.
newtype GoogleChatV1ContextualAddOnMarkup = GoogleChatV1ContextualAddOnMarkup
  { -- | A list of cards. A card must contain a header and at least 1 section.
    cards :: (Core.Maybe [GoogleChatV1ContextualAddOnMarkupCard])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GoogleChatV1ContextualAddOnMarkup' with the minimum fields required to make a request.
newGoogleChatV1ContextualAddOnMarkup ::
  GoogleChatV1ContextualAddOnMarkup
newGoogleChatV1ContextualAddOnMarkup =
  GoogleChatV1ContextualAddOnMarkup {cards = Core.Nothing}

instance
  Core.FromJSON
    GoogleChatV1ContextualAddOnMarkup
  where
  parseJSON =
    Core.withObject
      "GoogleChatV1ContextualAddOnMarkup"
      ( \o ->
          GoogleChatV1ContextualAddOnMarkup
            Core.<$> (o Core..:? "cards")
      )

instance
  Core.ToJSON
    GoogleChatV1ContextualAddOnMarkup
  where
  toJSON GoogleChatV1ContextualAddOnMarkup {..} =
    Core.object
      (Core.catMaybes [("cards" Core..=) Core.<$> cards])

-- | A card is a UI element that can contain UI widgets such as texts, images.
--
-- /See:/ 'newGoogleChatV1ContextualAddOnMarkupCard' smart constructor.
data GoogleChatV1ContextualAddOnMarkupCard = GoogleChatV1ContextualAddOnMarkupCard
  { -- | The actions of this card.
    cardActions :: (Core.Maybe [GoogleChatV1ContextualAddOnMarkupCardCardAction]),
    -- | The header of the card. A header usually contains a title and an image.
    header :: (Core.Maybe GoogleChatV1ContextualAddOnMarkupCardCardHeader),
    -- | Name of the card.
    name :: (Core.Maybe Core.Text),
    -- | Sections are separated by a line divider.
    sections :: (Core.Maybe [GoogleChatV1ContextualAddOnMarkupCardSection])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GoogleChatV1ContextualAddOnMarkupCard' with the minimum fields required to make a request.
newGoogleChatV1ContextualAddOnMarkupCard ::
  GoogleChatV1ContextualAddOnMarkupCard
newGoogleChatV1ContextualAddOnMarkupCard =
  GoogleChatV1ContextualAddOnMarkupCard
    { cardActions = Core.Nothing,
      header = Core.Nothing,
      name = Core.Nothing,
      sections = Core.Nothing
    }

instance
  Core.FromJSON
    GoogleChatV1ContextualAddOnMarkupCard
  where
  parseJSON =
    Core.withObject
      "GoogleChatV1ContextualAddOnMarkupCard"
      ( \o ->
          GoogleChatV1ContextualAddOnMarkupCard
            Core.<$> (o Core..:? "cardActions")
            Core.<*> (o Core..:? "header")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "sections")
      )

instance
  Core.ToJSON
    GoogleChatV1ContextualAddOnMarkupCard
  where
  toJSON GoogleChatV1ContextualAddOnMarkupCard {..} =
    Core.object
      ( Core.catMaybes
          [ ("cardActions" Core..=) Core.<$> cardActions,
            ("header" Core..=) Core.<$> header,
            ("name" Core..=) Core.<$> name,
            ("sections" Core..=) Core.<$> sections
          ]
      )

-- | A card action is the action associated with the card. For an invoice card, a typical action would be: delete invoice, email invoice or open the invoice in browser. Not supported by Google Chat apps.
--
-- /See:/ 'newGoogleChatV1ContextualAddOnMarkupCardCardAction' smart constructor.
data GoogleChatV1ContextualAddOnMarkupCardCardAction = GoogleChatV1ContextualAddOnMarkupCardCardAction
  { -- | The label used to be displayed in the action menu item.
    actionLabel :: (Core.Maybe Core.Text),
    -- | The onclick action for this action item.
    onClick :: (Core.Maybe GoogleChatV1WidgetMarkupOnClick)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GoogleChatV1ContextualAddOnMarkupCardCardAction' with the minimum fields required to make a request.
newGoogleChatV1ContextualAddOnMarkupCardCardAction ::
  GoogleChatV1ContextualAddOnMarkupCardCardAction
newGoogleChatV1ContextualAddOnMarkupCardCardAction =
  GoogleChatV1ContextualAddOnMarkupCardCardAction
    { actionLabel = Core.Nothing,
      onClick = Core.Nothing
    }

instance
  Core.FromJSON
    GoogleChatV1ContextualAddOnMarkupCardCardAction
  where
  parseJSON =
    Core.withObject
      "GoogleChatV1ContextualAddOnMarkupCardCardAction"
      ( \o ->
          GoogleChatV1ContextualAddOnMarkupCardCardAction
            Core.<$> (o Core..:? "actionLabel")
              Core.<*> (o Core..:? "onClick")
      )

instance
  Core.ToJSON
    GoogleChatV1ContextualAddOnMarkupCardCardAction
  where
  toJSON
    GoogleChatV1ContextualAddOnMarkupCardCardAction {..} =
      Core.object
        ( Core.catMaybes
            [ ("actionLabel" Core..=) Core.<$> actionLabel,
              ("onClick" Core..=) Core.<$> onClick
            ]
        )

--
-- /See:/ 'newGoogleChatV1ContextualAddOnMarkupCardCardHeader' smart constructor.
data GoogleChatV1ContextualAddOnMarkupCardCardHeader = GoogleChatV1ContextualAddOnMarkupCardCardHeader
  { -- | The image\'s type (e.g. square border or circular border).
    imageStyle ::
      ( Core.Maybe
          GoogleChatV1ContextualAddOnMarkupCardCardHeader_ImageStyle
      ),
    -- | The URL of the image in the card header.
    imageUrl :: (Core.Maybe Core.Text),
    -- | The subtitle of the card header.
    subtitle :: (Core.Maybe Core.Text),
    -- | The title must be specified. The header has a fixed height: if both a title and subtitle is specified, each will take up 1 line. If only the title is specified, it will take up both lines.
    title :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GoogleChatV1ContextualAddOnMarkupCardCardHeader' with the minimum fields required to make a request.
newGoogleChatV1ContextualAddOnMarkupCardCardHeader ::
  GoogleChatV1ContextualAddOnMarkupCardCardHeader
newGoogleChatV1ContextualAddOnMarkupCardCardHeader =
  GoogleChatV1ContextualAddOnMarkupCardCardHeader
    { imageStyle = Core.Nothing,
      imageUrl = Core.Nothing,
      subtitle = Core.Nothing,
      title = Core.Nothing
    }

instance
  Core.FromJSON
    GoogleChatV1ContextualAddOnMarkupCardCardHeader
  where
  parseJSON =
    Core.withObject
      "GoogleChatV1ContextualAddOnMarkupCardCardHeader"
      ( \o ->
          GoogleChatV1ContextualAddOnMarkupCardCardHeader
            Core.<$> (o Core..:? "imageStyle")
              Core.<*> (o Core..:? "imageUrl")
              Core.<*> (o Core..:? "subtitle")
              Core.<*> (o Core..:? "title")
      )

instance
  Core.ToJSON
    GoogleChatV1ContextualAddOnMarkupCardCardHeader
  where
  toJSON
    GoogleChatV1ContextualAddOnMarkupCardCardHeader {..} =
      Core.object
        ( Core.catMaybes
            [ ("imageStyle" Core..=) Core.<$> imageStyle,
              ("imageUrl" Core..=) Core.<$> imageUrl,
              ("subtitle" Core..=) Core.<$> subtitle,
              ("title" Core..=) Core.<$> title
            ]
        )

-- | A section contains a collection of widgets that are rendered (vertically) in the order that they are specified. Across all platforms, cards have a narrow fixed width, so there is currently no need for layout properties (e.g. float).
--
-- /See:/ 'newGoogleChatV1ContextualAddOnMarkupCardSection' smart constructor.
data GoogleChatV1ContextualAddOnMarkupCardSection = GoogleChatV1ContextualAddOnMarkupCardSection
  { -- | The header of the section, text formatted supported.
    header :: (Core.Maybe Core.Text),
    -- | A section must contain at least 1 widget.
    widgets :: (Core.Maybe [GoogleChatV1WidgetMarkup])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GoogleChatV1ContextualAddOnMarkupCardSection' with the minimum fields required to make a request.
newGoogleChatV1ContextualAddOnMarkupCardSection ::
  GoogleChatV1ContextualAddOnMarkupCardSection
newGoogleChatV1ContextualAddOnMarkupCardSection =
  GoogleChatV1ContextualAddOnMarkupCardSection
    { header = Core.Nothing,
      widgets = Core.Nothing
    }

instance
  Core.FromJSON
    GoogleChatV1ContextualAddOnMarkupCardSection
  where
  parseJSON =
    Core.withObject
      "GoogleChatV1ContextualAddOnMarkupCardSection"
      ( \o ->
          GoogleChatV1ContextualAddOnMarkupCardSection
            Core.<$> (o Core..:? "header")
            Core.<*> (o Core..:? "widgets")
      )

instance
  Core.ToJSON
    GoogleChatV1ContextualAddOnMarkupCardSection
  where
  toJSON
    GoogleChatV1ContextualAddOnMarkupCardSection {..} =
      Core.object
        ( Core.catMaybes
            [ ("header" Core..=) Core.<$> header,
              ("widgets" Core..=) Core.<$> widgets
            ]
        )

-- | A widget is a UI element that presents texts, images, etc.
--
-- /See:/ 'newGoogleChatV1WidgetMarkup' smart constructor.
data GoogleChatV1WidgetMarkup = GoogleChatV1WidgetMarkup
  { -- | A list of buttons. Buttons is also oneof data and only one of these fields should be set.
    buttons :: (Core.Maybe [GoogleChatV1WidgetMarkupButton]),
    -- | Display an image in this widget.
    image :: (Core.Maybe GoogleChatV1WidgetMarkupImage),
    -- | Display a key value item in this widget.
    keyValue :: (Core.Maybe GoogleChatV1WidgetMarkupKeyValue),
    -- | Display a text paragraph in this widget.
    textParagraph :: (Core.Maybe GoogleChatV1WidgetMarkupTextParagraph)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GoogleChatV1WidgetMarkup' with the minimum fields required to make a request.
newGoogleChatV1WidgetMarkup ::
  GoogleChatV1WidgetMarkup
newGoogleChatV1WidgetMarkup =
  GoogleChatV1WidgetMarkup
    { buttons = Core.Nothing,
      image = Core.Nothing,
      keyValue = Core.Nothing,
      textParagraph = Core.Nothing
    }

instance Core.FromJSON GoogleChatV1WidgetMarkup where
  parseJSON =
    Core.withObject
      "GoogleChatV1WidgetMarkup"
      ( \o ->
          GoogleChatV1WidgetMarkup
            Core.<$> (o Core..:? "buttons")
            Core.<*> (o Core..:? "image")
            Core.<*> (o Core..:? "keyValue")
            Core.<*> (o Core..:? "textParagraph")
      )

instance Core.ToJSON GoogleChatV1WidgetMarkup where
  toJSON GoogleChatV1WidgetMarkup {..} =
    Core.object
      ( Core.catMaybes
          [ ("buttons" Core..=) Core.<$> buttons,
            ("image" Core..=) Core.<$> image,
            ("keyValue" Core..=) Core.<$> keyValue,
            ("textParagraph" Core..=) Core.<$> textParagraph
          ]
      )

-- | A button. Can be a text button or an image button.
--
-- /See:/ 'newGoogleChatV1WidgetMarkupButton' smart constructor.
data GoogleChatV1WidgetMarkupButton = GoogleChatV1WidgetMarkupButton
  { -- | A button with image and onclick action.
    imageButton :: (Core.Maybe GoogleChatV1WidgetMarkupImageButton),
    -- | A button with text and onclick action.
    textButton :: (Core.Maybe GoogleChatV1WidgetMarkupTextButton)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GoogleChatV1WidgetMarkupButton' with the minimum fields required to make a request.
newGoogleChatV1WidgetMarkupButton ::
  GoogleChatV1WidgetMarkupButton
newGoogleChatV1WidgetMarkupButton =
  GoogleChatV1WidgetMarkupButton
    { imageButton = Core.Nothing,
      textButton = Core.Nothing
    }

instance Core.FromJSON GoogleChatV1WidgetMarkupButton where
  parseJSON =
    Core.withObject
      "GoogleChatV1WidgetMarkupButton"
      ( \o ->
          GoogleChatV1WidgetMarkupButton
            Core.<$> (o Core..:? "imageButton")
            Core.<*> (o Core..:? "textButton")
      )

instance Core.ToJSON GoogleChatV1WidgetMarkupButton where
  toJSON GoogleChatV1WidgetMarkupButton {..} =
    Core.object
      ( Core.catMaybes
          [ ("imageButton" Core..=) Core.<$> imageButton,
            ("textButton" Core..=) Core.<$> textButton
          ]
      )

-- | A form action describes the behavior when the form is submitted. For example, an Apps Script can be invoked to handle the form.
--
-- /See:/ 'newGoogleChatV1WidgetMarkupFormAction' smart constructor.
data GoogleChatV1WidgetMarkupFormAction = GoogleChatV1WidgetMarkupFormAction
  { -- | The method name is used to identify which part of the form triggered the form submission. This information is echoed back to the Chat app as part of the card click event. The same method name can be used for several elements that trigger a common behavior if desired.
    actionMethodName :: (Core.Maybe Core.Text),
    -- | List of action parameters.
    parameters :: (Core.Maybe [GoogleChatV1WidgetMarkupFormActionActionParameter])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GoogleChatV1WidgetMarkupFormAction' with the minimum fields required to make a request.
newGoogleChatV1WidgetMarkupFormAction ::
  GoogleChatV1WidgetMarkupFormAction
newGoogleChatV1WidgetMarkupFormAction =
  GoogleChatV1WidgetMarkupFormAction
    { actionMethodName = Core.Nothing,
      parameters = Core.Nothing
    }

instance
  Core.FromJSON
    GoogleChatV1WidgetMarkupFormAction
  where
  parseJSON =
    Core.withObject
      "GoogleChatV1WidgetMarkupFormAction"
      ( \o ->
          GoogleChatV1WidgetMarkupFormAction
            Core.<$> (o Core..:? "actionMethodName")
            Core.<*> (o Core..:? "parameters")
      )

instance
  Core.ToJSON
    GoogleChatV1WidgetMarkupFormAction
  where
  toJSON GoogleChatV1WidgetMarkupFormAction {..} =
    Core.object
      ( Core.catMaybes
          [ ("actionMethodName" Core..=)
              Core.<$> actionMethodName,
            ("parameters" Core..=) Core.<$> parameters
          ]
      )

-- | List of string parameters to supply when the action method is invoked. For example, consider three snooze buttons: snooze now, snooze 1 day, snooze next week. You might use action method = snooze(), passing the snooze type and snooze time in the list of string parameters.
--
-- /See:/ 'newGoogleChatV1WidgetMarkupFormActionActionParameter' smart constructor.
data GoogleChatV1WidgetMarkupFormActionActionParameter = GoogleChatV1WidgetMarkupFormActionActionParameter
  { -- | The name of the parameter for the action script.
    key :: (Core.Maybe Core.Text),
    -- | The value of the parameter.
    value :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GoogleChatV1WidgetMarkupFormActionActionParameter' with the minimum fields required to make a request.
newGoogleChatV1WidgetMarkupFormActionActionParameter ::
  GoogleChatV1WidgetMarkupFormActionActionParameter
newGoogleChatV1WidgetMarkupFormActionActionParameter =
  GoogleChatV1WidgetMarkupFormActionActionParameter
    { key = Core.Nothing,
      value = Core.Nothing
    }

instance
  Core.FromJSON
    GoogleChatV1WidgetMarkupFormActionActionParameter
  where
  parseJSON =
    Core.withObject
      "GoogleChatV1WidgetMarkupFormActionActionParameter"
      ( \o ->
          GoogleChatV1WidgetMarkupFormActionActionParameter
            Core.<$> (o Core..:? "key") Core.<*> (o Core..:? "value")
      )

instance
  Core.ToJSON
    GoogleChatV1WidgetMarkupFormActionActionParameter
  where
  toJSON
    GoogleChatV1WidgetMarkupFormActionActionParameter {..} =
      Core.object
        ( Core.catMaybes
            [ ("key" Core..=) Core.<$> key,
              ("value" Core..=) Core.<$> value
            ]
        )

-- | An image that is specified by a URL and can have an onclick action.
--
-- /See:/ 'newGoogleChatV1WidgetMarkupImage' smart constructor.
data GoogleChatV1WidgetMarkupImage = GoogleChatV1WidgetMarkupImage
  { -- | The aspect ratio of this image (width\/height). This field allows clients to reserve the right height for the image while waiting for it to load. It\'s not meant to override the native aspect ratio of the image. If unset, the server fills it by prefetching the image.
    aspectRatio :: (Core.Maybe Core.Double),
    -- | The URL of the image.
    imageUrl :: (Core.Maybe Core.Text),
    -- | The onclick action.
    onClick :: (Core.Maybe GoogleChatV1WidgetMarkupOnClick)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GoogleChatV1WidgetMarkupImage' with the minimum fields required to make a request.
newGoogleChatV1WidgetMarkupImage ::
  GoogleChatV1WidgetMarkupImage
newGoogleChatV1WidgetMarkupImage =
  GoogleChatV1WidgetMarkupImage
    { aspectRatio = Core.Nothing,
      imageUrl = Core.Nothing,
      onClick = Core.Nothing
    }

instance Core.FromJSON GoogleChatV1WidgetMarkupImage where
  parseJSON =
    Core.withObject
      "GoogleChatV1WidgetMarkupImage"
      ( \o ->
          GoogleChatV1WidgetMarkupImage
            Core.<$> (o Core..:? "aspectRatio")
            Core.<*> (o Core..:? "imageUrl")
            Core.<*> (o Core..:? "onClick")
      )

instance Core.ToJSON GoogleChatV1WidgetMarkupImage where
  toJSON GoogleChatV1WidgetMarkupImage {..} =
    Core.object
      ( Core.catMaybes
          [ ("aspectRatio" Core..=) Core.<$> aspectRatio,
            ("imageUrl" Core..=) Core.<$> imageUrl,
            ("onClick" Core..=) Core.<$> onClick
          ]
      )

-- | An image button with an onclick action.
--
-- /See:/ 'newGoogleChatV1WidgetMarkupImageButton' smart constructor.
data GoogleChatV1WidgetMarkupImageButton = GoogleChatV1WidgetMarkupImageButton
  { -- | The icon specified by an enum that indices to an icon provided by Chat API.
    icon :: (Core.Maybe GoogleChatV1WidgetMarkupImageButton_Icon),
    -- | The icon specified by a URL.
    iconUrl :: (Core.Maybe Core.Text),
    -- | The name of this image_button which will be used for accessibility. Default value will be provided if developers don\'t specify.
    name :: (Core.Maybe Core.Text),
    -- | The onclick action.
    onClick :: (Core.Maybe GoogleChatV1WidgetMarkupOnClick)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GoogleChatV1WidgetMarkupImageButton' with the minimum fields required to make a request.
newGoogleChatV1WidgetMarkupImageButton ::
  GoogleChatV1WidgetMarkupImageButton
newGoogleChatV1WidgetMarkupImageButton =
  GoogleChatV1WidgetMarkupImageButton
    { icon = Core.Nothing,
      iconUrl = Core.Nothing,
      name = Core.Nothing,
      onClick = Core.Nothing
    }

instance
  Core.FromJSON
    GoogleChatV1WidgetMarkupImageButton
  where
  parseJSON =
    Core.withObject
      "GoogleChatV1WidgetMarkupImageButton"
      ( \o ->
          GoogleChatV1WidgetMarkupImageButton
            Core.<$> (o Core..:? "icon")
            Core.<*> (o Core..:? "iconUrl")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "onClick")
      )

instance
  Core.ToJSON
    GoogleChatV1WidgetMarkupImageButton
  where
  toJSON GoogleChatV1WidgetMarkupImageButton {..} =
    Core.object
      ( Core.catMaybes
          [ ("icon" Core..=) Core.<$> icon,
            ("iconUrl" Core..=) Core.<$> iconUrl,
            ("name" Core..=) Core.<$> name,
            ("onClick" Core..=) Core.<$> onClick
          ]
      )

-- | A UI element contains a key (label) and a value (content). And this element may also contain some actions such as onclick button.
--
-- /See:/ 'newGoogleChatV1WidgetMarkupKeyValue' smart constructor.
data GoogleChatV1WidgetMarkupKeyValue = GoogleChatV1WidgetMarkupKeyValue
  { -- | The text of the bottom label. Formatted text supported.
    bottomLabel :: (Core.Maybe Core.Text),
    -- | A button that can be clicked to trigger an action.
    button :: (Core.Maybe GoogleChatV1WidgetMarkupButton),
    -- | The text of the content. Formatted text supported and always required.
    content :: (Core.Maybe Core.Text),
    -- | If the content should be multiline.
    contentMultiline :: (Core.Maybe Core.Bool),
    -- | An enum value that will be replaced by the Chat API with the corresponding icon image.
    icon :: (Core.Maybe GoogleChatV1WidgetMarkupKeyValue_Icon),
    -- | The icon specified by a URL.
    iconUrl :: (Core.Maybe Core.Text),
    -- | The onclick action. Only the top label, bottom label and content region are clickable.
    onClick :: (Core.Maybe GoogleChatV1WidgetMarkupOnClick),
    -- | The text of the top label. Formatted text supported.
    topLabel :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GoogleChatV1WidgetMarkupKeyValue' with the minimum fields required to make a request.
newGoogleChatV1WidgetMarkupKeyValue ::
  GoogleChatV1WidgetMarkupKeyValue
newGoogleChatV1WidgetMarkupKeyValue =
  GoogleChatV1WidgetMarkupKeyValue
    { bottomLabel = Core.Nothing,
      button = Core.Nothing,
      content = Core.Nothing,
      contentMultiline = Core.Nothing,
      icon = Core.Nothing,
      iconUrl = Core.Nothing,
      onClick = Core.Nothing,
      topLabel = Core.Nothing
    }

instance
  Core.FromJSON
    GoogleChatV1WidgetMarkupKeyValue
  where
  parseJSON =
    Core.withObject
      "GoogleChatV1WidgetMarkupKeyValue"
      ( \o ->
          GoogleChatV1WidgetMarkupKeyValue
            Core.<$> (o Core..:? "bottomLabel")
            Core.<*> (o Core..:? "button")
            Core.<*> (o Core..:? "content")
            Core.<*> (o Core..:? "contentMultiline")
            Core.<*> (o Core..:? "icon")
            Core.<*> (o Core..:? "iconUrl")
            Core.<*> (o Core..:? "onClick")
            Core.<*> (o Core..:? "topLabel")
      )

instance Core.ToJSON GoogleChatV1WidgetMarkupKeyValue where
  toJSON GoogleChatV1WidgetMarkupKeyValue {..} =
    Core.object
      ( Core.catMaybes
          [ ("bottomLabel" Core..=) Core.<$> bottomLabel,
            ("button" Core..=) Core.<$> button,
            ("content" Core..=) Core.<$> content,
            ("contentMultiline" Core..=)
              Core.<$> contentMultiline,
            ("icon" Core..=) Core.<$> icon,
            ("iconUrl" Core..=) Core.<$> iconUrl,
            ("onClick" Core..=) Core.<$> onClick,
            ("topLabel" Core..=) Core.<$> topLabel
          ]
      )

-- | An onclick action (e.g. open a link).
--
-- /See:/ 'newGoogleChatV1WidgetMarkupOnClick' smart constructor.
data GoogleChatV1WidgetMarkupOnClick = GoogleChatV1WidgetMarkupOnClick
  { -- | A form action will be triggered by this onclick if specified.
    action :: (Core.Maybe GoogleChatV1WidgetMarkupFormAction),
    -- | This onclick triggers an open link action if specified.
    openLink :: (Core.Maybe GoogleChatV1WidgetMarkupOpenLink)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GoogleChatV1WidgetMarkupOnClick' with the minimum fields required to make a request.
newGoogleChatV1WidgetMarkupOnClick ::
  GoogleChatV1WidgetMarkupOnClick
newGoogleChatV1WidgetMarkupOnClick =
  GoogleChatV1WidgetMarkupOnClick
    { action = Core.Nothing,
      openLink = Core.Nothing
    }

instance
  Core.FromJSON
    GoogleChatV1WidgetMarkupOnClick
  where
  parseJSON =
    Core.withObject
      "GoogleChatV1WidgetMarkupOnClick"
      ( \o ->
          GoogleChatV1WidgetMarkupOnClick
            Core.<$> (o Core..:? "action")
            Core.<*> (o Core..:? "openLink")
      )

instance Core.ToJSON GoogleChatV1WidgetMarkupOnClick where
  toJSON GoogleChatV1WidgetMarkupOnClick {..} =
    Core.object
      ( Core.catMaybes
          [ ("action" Core..=) Core.<$> action,
            ("openLink" Core..=) Core.<$> openLink
          ]
      )

-- | A link that opens a new window.
--
-- /See:/ 'newGoogleChatV1WidgetMarkupOpenLink' smart constructor.
newtype GoogleChatV1WidgetMarkupOpenLink = GoogleChatV1WidgetMarkupOpenLink
  { -- | The URL to open.
    url :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GoogleChatV1WidgetMarkupOpenLink' with the minimum fields required to make a request.
newGoogleChatV1WidgetMarkupOpenLink ::
  GoogleChatV1WidgetMarkupOpenLink
newGoogleChatV1WidgetMarkupOpenLink =
  GoogleChatV1WidgetMarkupOpenLink {url = Core.Nothing}

instance
  Core.FromJSON
    GoogleChatV1WidgetMarkupOpenLink
  where
  parseJSON =
    Core.withObject
      "GoogleChatV1WidgetMarkupOpenLink"
      ( \o ->
          GoogleChatV1WidgetMarkupOpenLink
            Core.<$> (o Core..:? "url")
      )

instance Core.ToJSON GoogleChatV1WidgetMarkupOpenLink where
  toJSON GoogleChatV1WidgetMarkupOpenLink {..} =
    Core.object
      (Core.catMaybes [("url" Core..=) Core.<$> url])

-- | A button with text and onclick action.
--
-- /See:/ 'newGoogleChatV1WidgetMarkupTextButton' smart constructor.
data GoogleChatV1WidgetMarkupTextButton = GoogleChatV1WidgetMarkupTextButton
  { -- | The onclick action of the button.
    onClick :: (Core.Maybe GoogleChatV1WidgetMarkupOnClick),
    -- | The text of the button.
    text :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GoogleChatV1WidgetMarkupTextButton' with the minimum fields required to make a request.
newGoogleChatV1WidgetMarkupTextButton ::
  GoogleChatV1WidgetMarkupTextButton
newGoogleChatV1WidgetMarkupTextButton =
  GoogleChatV1WidgetMarkupTextButton
    { onClick = Core.Nothing,
      text = Core.Nothing
    }

instance
  Core.FromJSON
    GoogleChatV1WidgetMarkupTextButton
  where
  parseJSON =
    Core.withObject
      "GoogleChatV1WidgetMarkupTextButton"
      ( \o ->
          GoogleChatV1WidgetMarkupTextButton
            Core.<$> (o Core..:? "onClick") Core.<*> (o Core..:? "text")
      )

instance
  Core.ToJSON
    GoogleChatV1WidgetMarkupTextButton
  where
  toJSON GoogleChatV1WidgetMarkupTextButton {..} =
    Core.object
      ( Core.catMaybes
          [ ("onClick" Core..=) Core.<$> onClick,
            ("text" Core..=) Core.<$> text
          ]
      )

-- | A paragraph of text. Formatted text supported.
--
-- /See:/ 'newGoogleChatV1WidgetMarkupTextParagraph' smart constructor.
newtype GoogleChatV1WidgetMarkupTextParagraph = GoogleChatV1WidgetMarkupTextParagraph
  { -- |
    text :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GoogleChatV1WidgetMarkupTextParagraph' with the minimum fields required to make a request.
newGoogleChatV1WidgetMarkupTextParagraph ::
  GoogleChatV1WidgetMarkupTextParagraph
newGoogleChatV1WidgetMarkupTextParagraph =
  GoogleChatV1WidgetMarkupTextParagraph {text = Core.Nothing}

instance
  Core.FromJSON
    GoogleChatV1WidgetMarkupTextParagraph
  where
  parseJSON =
    Core.withObject
      "GoogleChatV1WidgetMarkupTextParagraph"
      ( \o ->
          GoogleChatV1WidgetMarkupTextParagraph
            Core.<$> (o Core..:? "text")
      )

instance
  Core.ToJSON
    GoogleChatV1WidgetMarkupTextParagraph
  where
  toJSON GoogleChatV1WidgetMarkupTextParagraph {..} =
    Core.object
      (Core.catMaybes [("text" Core..=) Core.<$> text])

-- | The corpus specific metadata for office-type documents, from Google Docs and other sources. This message is passed to the scorer and beyond. Next tag: 9
--
-- /See:/ 'newGoogleDocsMetadata' smart constructor.
data GoogleDocsMetadata = GoogleDocsMetadata
  { -- | Contains number of users and groups which can access the document.
    aclInfo :: (Core.Maybe AclInfo),
    -- | The conceptual type (presentation, document, etc.) of this document.
    documentType :: (Core.Maybe GoogleDocsMetadata_DocumentType),
    -- | The file extension of the document. NOTE: As of October 2018 this field is not backfilled for old documents.
    fileExtension :: (Core.Maybe Core.Text),
    -- | The last time this document was modified, in seconds since epoch. Only counts content modifications.
    lastContentModifiedTimestamp :: (Core.Maybe Core.Int64),
    -- | Contains number of subscribers for the document.
    numSubscribers :: (Core.Maybe Core.Int32),
    -- | Size of untruncated viewers list.
    numViewers :: (Core.Maybe Core.Int32),
    -- | Additional per-result information, akin to Gmail\'s SingleThreadResponse. Note: GWS no longer seems to use this field, but there\'s still one reference to it for Scribe, so we can\'t remove it.
    resultInfo :: (Core.Maybe GoogleDocsResultInfo),
    -- | Contains additional information about the document depending on its type.
    typeInfo :: (Core.Maybe TypeInfo)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GoogleDocsMetadata' with the minimum fields required to make a request.
newGoogleDocsMetadata ::
  GoogleDocsMetadata
newGoogleDocsMetadata =
  GoogleDocsMetadata
    { aclInfo = Core.Nothing,
      documentType = Core.Nothing,
      fileExtension = Core.Nothing,
      lastContentModifiedTimestamp = Core.Nothing,
      numSubscribers = Core.Nothing,
      numViewers = Core.Nothing,
      resultInfo = Core.Nothing,
      typeInfo = Core.Nothing
    }

instance Core.FromJSON GoogleDocsMetadata where
  parseJSON =
    Core.withObject
      "GoogleDocsMetadata"
      ( \o ->
          GoogleDocsMetadata
            Core.<$> (o Core..:? "aclInfo")
            Core.<*> (o Core..:? "documentType")
            Core.<*> (o Core..:? "fileExtension")
            Core.<*> ( o Core..:? "lastContentModifiedTimestamp"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "numSubscribers")
            Core.<*> (o Core..:? "numViewers")
            Core.<*> (o Core..:? "resultInfo")
            Core.<*> (o Core..:? "typeInfo")
      )

instance Core.ToJSON GoogleDocsMetadata where
  toJSON GoogleDocsMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("aclInfo" Core..=) Core.<$> aclInfo,
            ("documentType" Core..=) Core.<$> documentType,
            ("fileExtension" Core..=) Core.<$> fileExtension,
            ("lastContentModifiedTimestamp" Core..=)
              Core.. Core.AsText
              Core.<$> lastContentModifiedTimestamp,
            ("numSubscribers" Core..=) Core.<$> numSubscribers,
            ("numViewers" Core..=) Core.<$> numViewers,
            ("resultInfo" Core..=) Core.<$> resultInfo,
            ("typeInfo" Core..=) Core.<$> typeInfo
          ]
      )

-- | A message containing information about a specific result. This information is passed to the scorer and beyond; in particular, GWS relies on it to format the result in the UI. Split from GoogleDocsMetadata in case we later want to reuse the message.
--
-- /See:/ 'newGoogleDocsResultInfo' smart constructor.
data GoogleDocsResultInfo = GoogleDocsResultInfo
  { -- | The SHA1 hash of the object in Drive, if any.
    attachmentSha1 :: (Core.Maybe Core.Text),
    -- | The storage identifier for the object in Cosmo. This field is intended to used by Stratus\/Moonshine integration only. It should not be exposed externally (please refer to encrypted_id for that purpose).
    cosmoId :: (Core.Maybe Id),
    -- | For Cosmo objects, the Cosmo namespace the object was in. This allows downstream clients to identify whether a document was created in Writely or Kix, Presently or Punch, or whether it was uploaded from GDrive. See storage/cosmo.Id.NAME/SPACE for a list of all Cosmo name spaces.
    cosmoNameSpace :: (Core.Maybe Core.Int32),
    -- | The encrypted (user-visible) id of this object. Knowing the id is sufficient to create a canonical URL for this document.
    encryptedId :: (Core.Maybe Core.Text),
    -- | The mimetype of the document.
    mimeType :: (Core.Maybe Core.Text),
    -- | The visibility indicator in the UI will be based upon this.
    shareScope :: (Core.Maybe ShareScope)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GoogleDocsResultInfo' with the minimum fields required to make a request.
newGoogleDocsResultInfo ::
  GoogleDocsResultInfo
newGoogleDocsResultInfo =
  GoogleDocsResultInfo
    { attachmentSha1 = Core.Nothing,
      cosmoId = Core.Nothing,
      cosmoNameSpace = Core.Nothing,
      encryptedId = Core.Nothing,
      mimeType = Core.Nothing,
      shareScope = Core.Nothing
    }

instance Core.FromJSON GoogleDocsResultInfo where
  parseJSON =
    Core.withObject
      "GoogleDocsResultInfo"
      ( \o ->
          GoogleDocsResultInfo
            Core.<$> (o Core..:? "attachmentSha1")
            Core.<*> (o Core..:? "cosmoId")
            Core.<*> (o Core..:? "cosmoNameSpace")
            Core.<*> (o Core..:? "encryptedId")
            Core.<*> (o Core..:? "mimeType")
            Core.<*> (o Core..:? "shareScope")
      )

instance Core.ToJSON GoogleDocsResultInfo where
  toJSON GoogleDocsResultInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("attachmentSha1" Core..=) Core.<$> attachmentSha1,
            ("cosmoId" Core..=) Core.<$> cosmoId,
            ("cosmoNameSpace" Core..=) Core.<$> cosmoNameSpace,
            ("encryptedId" Core..=) Core.<$> encryptedId,
            ("mimeType" Core..=) Core.<$> mimeType,
            ("shareScope" Core..=) Core.<$> shareScope
          ]
      )

--
-- /See:/ 'newGrid' smart constructor.
data Grid = Grid
  { -- | The border style to apply to each grid item.
    borderStyle :: (Core.Maybe BorderStyle),
    -- | The items to display in the grid.
    items :: (Core.Maybe [GridItem]),
    -- | The number of columns to display in the grid. Note that a default value will be used if this field is not specified, and that default value will be different depending on where the grid is shown (dialog vs companion).
    numColumns :: (Core.Maybe Core.Int32),
    -- | This callback will be reused by each individual GridItem, but with the item\'s identifier and index in the items list added to the callback\'s parameters.
    onClick :: (Core.Maybe OnClick),
    -- | The text to display in the grid header.
    title :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Grid' with the minimum fields required to make a request.
newGrid ::
  Grid
newGrid =
  Grid
    { borderStyle = Core.Nothing,
      items = Core.Nothing,
      numColumns = Core.Nothing,
      onClick = Core.Nothing,
      title = Core.Nothing
    }

instance Core.FromJSON Grid where
  parseJSON =
    Core.withObject
      "Grid"
      ( \o ->
          Grid
            Core.<$> (o Core..:? "borderStyle")
            Core.<*> (o Core..:? "items")
            Core.<*> (o Core..:? "numColumns")
            Core.<*> (o Core..:? "onClick")
            Core.<*> (o Core..:? "title")
      )

instance Core.ToJSON Grid where
  toJSON Grid {..} =
    Core.object
      ( Core.catMaybes
          [ ("borderStyle" Core..=) Core.<$> borderStyle,
            ("items" Core..=) Core.<$> items,
            ("numColumns" Core..=) Core.<$> numColumns,
            ("onClick" Core..=) Core.<$> onClick,
            ("title" Core..=) Core.<$> title
          ]
      )

--
-- /See:/ 'newGridItem' smart constructor.
data GridItem = GridItem
  { -- | A user-specified identifier for this grid item. This identifier will be returned in the parent Grid\'s on_click callback\'s parameters.
    identifier :: (Core.Maybe Core.Text),
    -- |
    image :: (Core.Maybe ImageComponent),
    -- |
    layout :: (Core.Maybe GridItem_Layout),
    -- |
    subtitle :: (Core.Maybe Core.Text),
    -- |
    textAlignment :: (Core.Maybe GridItem_TextAlignment),
    -- | Text properties.
    title :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GridItem' with the minimum fields required to make a request.
newGridItem ::
  GridItem
newGridItem =
  GridItem
    { identifier = Core.Nothing,
      image = Core.Nothing,
      layout = Core.Nothing,
      subtitle = Core.Nothing,
      textAlignment = Core.Nothing,
      title = Core.Nothing
    }

instance Core.FromJSON GridItem where
  parseJSON =
    Core.withObject
      "GridItem"
      ( \o ->
          GridItem
            Core.<$> (o Core..:? "identifier")
            Core.<*> (o Core..:? "image")
            Core.<*> (o Core..:? "layout")
            Core.<*> (o Core..:? "subtitle")
            Core.<*> (o Core..:? "textAlignment")
            Core.<*> (o Core..:? "title")
      )

instance Core.ToJSON GridItem where
  toJSON GridItem {..} =
    Core.object
      ( Core.catMaybes
          [ ("identifier" Core..=) Core.<$> identifier,
            ("image" Core..=) Core.<$> image,
            ("layout" Core..=) Core.<$> layout,
            ("subtitle" Core..=) Core.<$> subtitle,
            ("textAlignment" Core..=) Core.<$> textAlignment,
            ("title" Core..=) Core.<$> title
          ]
      )

--
-- /See:/ 'newGroupDetailsUpdatedMetadata' smart constructor.
data GroupDetailsUpdatedMetadata = GroupDetailsUpdatedMetadata
  { -- |
    newGroupDetails' :: (Core.Maybe AppsDynamiteSharedGroupDetails),
    -- |
    prevGroupDetails :: (Core.Maybe AppsDynamiteSharedGroupDetails)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GroupDetailsUpdatedMetadata' with the minimum fields required to make a request.
newGroupDetailsUpdatedMetadata ::
  GroupDetailsUpdatedMetadata
newGroupDetailsUpdatedMetadata =
  GroupDetailsUpdatedMetadata
    { newGroupDetails' = Core.Nothing,
      prevGroupDetails = Core.Nothing
    }

instance Core.FromJSON GroupDetailsUpdatedMetadata where
  parseJSON =
    Core.withObject
      "GroupDetailsUpdatedMetadata"
      ( \o ->
          GroupDetailsUpdatedMetadata
            Core.<$> (o Core..:? "newGroupDetails")
            Core.<*> (o Core..:? "prevGroupDetails")
      )

instance Core.ToJSON GroupDetailsUpdatedMetadata where
  toJSON GroupDetailsUpdatedMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("newGroupDetails" Core..=)
              Core.<$> newGroupDetails',
            ("prevGroupDetails" Core..=)
              Core.<$> prevGroupDetails
          ]
      )

-- | Id representing a group that could be a space, a chat, or a direct message space. Which ID is set here will determine which group
--
-- /See:/ 'newGroupId' smart constructor.
data GroupId = GroupId
  { -- | Unique, immutable ID of the Direct Message Space
    dmId :: (Core.Maybe DmId),
    -- | Unique, immutable ID of the Space
    spaceId :: (Core.Maybe SpaceId)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GroupId' with the minimum fields required to make a request.
newGroupId ::
  GroupId
newGroupId = GroupId {dmId = Core.Nothing, spaceId = Core.Nothing}

instance Core.FromJSON GroupId where
  parseJSON =
    Core.withObject
      "GroupId"
      ( \o ->
          GroupId
            Core.<$> (o Core..:? "dmId") Core.<*> (o Core..:? "spaceId")
      )

instance Core.ToJSON GroupId where
  toJSON GroupId {..} =
    Core.object
      ( Core.catMaybes
          [ ("dmId" Core..=) Core.<$> dmId,
            ("spaceId" Core..=) Core.<$> spaceId
          ]
      )

--
-- /See:/ 'newGroupLinkSharingModificationEvent' smart constructor.
newtype GroupLinkSharingModificationEvent = GroupLinkSharingModificationEvent
  { -- |
    newStatus' :: (Core.Maybe GroupLinkSharingModificationEvent_NewStatus)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GroupLinkSharingModificationEvent' with the minimum fields required to make a request.
newGroupLinkSharingModificationEvent ::
  GroupLinkSharingModificationEvent
newGroupLinkSharingModificationEvent =
  GroupLinkSharingModificationEvent {newStatus' = Core.Nothing}

instance
  Core.FromJSON
    GroupLinkSharingModificationEvent
  where
  parseJSON =
    Core.withObject
      "GroupLinkSharingModificationEvent"
      ( \o ->
          GroupLinkSharingModificationEvent
            Core.<$> (o Core..:? "newStatus")
      )

instance
  Core.ToJSON
    GroupLinkSharingModificationEvent
  where
  toJSON GroupLinkSharingModificationEvent {..} =
    Core.object
      ( Core.catMaybes
          [("newStatus" Core..=) Core.<$> newStatus']
      )

--
-- /See:/ 'newGroupRetentionSettingsUpdatedMetaData' smart constructor.
data GroupRetentionSettingsUpdatedMetaData = GroupRetentionSettingsUpdatedMetaData
  { -- | The user who triggered the retention settings update
    initiator :: (Core.Maybe UserId),
    -- | The updated space retention settings
    retentionSettings :: (Core.Maybe AppsDynamiteSharedRetentionSettings)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GroupRetentionSettingsUpdatedMetaData' with the minimum fields required to make a request.
newGroupRetentionSettingsUpdatedMetaData ::
  GroupRetentionSettingsUpdatedMetaData
newGroupRetentionSettingsUpdatedMetaData =
  GroupRetentionSettingsUpdatedMetaData
    { initiator = Core.Nothing,
      retentionSettings = Core.Nothing
    }

instance
  Core.FromJSON
    GroupRetentionSettingsUpdatedMetaData
  where
  parseJSON =
    Core.withObject
      "GroupRetentionSettingsUpdatedMetaData"
      ( \o ->
          GroupRetentionSettingsUpdatedMetaData
            Core.<$> (o Core..:? "initiator")
            Core.<*> (o Core..:? "retentionSettings")
      )

instance
  Core.ToJSON
    GroupRetentionSettingsUpdatedMetaData
  where
  toJSON GroupRetentionSettingsUpdatedMetaData {..} =
    Core.object
      ( Core.catMaybes
          [ ("initiator" Core..=) Core.<$> initiator,
            ("retentionSettings" Core..=)
              Core.<$> retentionSettings
          ]
      )

-- | Annotation metadata for a GsuiteIntegration artifact.
--
-- /See:/ 'newGsuiteIntegrationMetadata' smart constructor.
data GsuiteIntegrationMetadata = GsuiteIntegrationMetadata
  { -- |
    activityFeedData :: (Core.Maybe AppsDynamiteSharedActivityFeedAnnotationData),
    -- |
    assistantData :: (Core.Maybe AppsDynamiteSharedAssistantAnnotationData),
    -- |
    calendarEventData :: (Core.Maybe AppsDynamiteSharedCalendarEventAnnotationData),
    -- | Data used to render call artifacts.
    callData :: (Core.Maybe AppsDynamiteSharedCallAnnotationData),
    -- |
    clientType :: (Core.Maybe GsuiteIntegrationMetadata_ClientType),
    -- | A list of all strings that are to be indexed for this 1P chip. Each string in this list would be the contents of a single string field in the 1P chip. Eg. For Tasks[title = “hello world”, description = “good bye”]. If we want to index only the title, this would be set to [“hello world”]. If both title and description, then this would be [“hello world”, “good bye”]. Please make sure that the contents of this field is a subset of strings that are rendered as part of the 1P Chip.
    indexableTexts :: (Core.Maybe [Core.Text]),
    -- |
    tasksData :: (Core.Maybe AppsDynamiteSharedTasksAnnotationData)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'GsuiteIntegrationMetadata' with the minimum fields required to make a request.
newGsuiteIntegrationMetadata ::
  GsuiteIntegrationMetadata
newGsuiteIntegrationMetadata =
  GsuiteIntegrationMetadata
    { activityFeedData = Core.Nothing,
      assistantData = Core.Nothing,
      calendarEventData = Core.Nothing,
      callData = Core.Nothing,
      clientType = Core.Nothing,
      indexableTexts = Core.Nothing,
      tasksData = Core.Nothing
    }

instance Core.FromJSON GsuiteIntegrationMetadata where
  parseJSON =
    Core.withObject
      "GsuiteIntegrationMetadata"
      ( \o ->
          GsuiteIntegrationMetadata
            Core.<$> (o Core..:? "activityFeedData")
            Core.<*> (o Core..:? "assistantData")
            Core.<*> (o Core..:? "calendarEventData")
            Core.<*> (o Core..:? "callData")
            Core.<*> (o Core..:? "clientType")
            Core.<*> (o Core..:? "indexableTexts")
            Core.<*> (o Core..:? "tasksData")
      )

instance Core.ToJSON GsuiteIntegrationMetadata where
  toJSON GsuiteIntegrationMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("activityFeedData" Core..=)
              Core.<$> activityFeedData,
            ("assistantData" Core..=) Core.<$> assistantData,
            ("calendarEventData" Core..=)
              Core.<$> calendarEventData,
            ("callData" Core..=) Core.<$> callData,
            ("clientType" Core..=) Core.<$> clientType,
            ("indexableTexts" Core..=) Core.<$> indexableTexts,
            ("tasksData" Core..=) Core.<$> tasksData
          ]
      )

--
-- /See:/ 'newHangoutEvent' smart constructor.
data HangoutEvent = HangoutEvent
  { -- |
    hangoutDurationSecs :: (Core.Maybe Core.Int64),
    -- |
    mediaType :: (Core.Maybe HangoutEvent_MediaType),
    -- |
    participantId :: (Core.Maybe [StoredParticipantId]),
    -- |
    type' :: (Core.Maybe HangoutEvent_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'HangoutEvent' with the minimum fields required to make a request.
newHangoutEvent ::
  HangoutEvent
newHangoutEvent =
  HangoutEvent
    { hangoutDurationSecs = Core.Nothing,
      mediaType = Core.Nothing,
      participantId = Core.Nothing,
      type' = Core.Nothing
    }

instance Core.FromJSON HangoutEvent where
  parseJSON =
    Core.withObject
      "HangoutEvent"
      ( \o ->
          HangoutEvent
            Core.<$> ( o Core..:? "hangoutDurationSecs"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "mediaType")
            Core.<*> (o Core..:? "participantId")
            Core.<*> (o Core..:? "type")
      )

instance Core.ToJSON HangoutEvent where
  toJSON HangoutEvent {..} =
    Core.object
      ( Core.catMaybes
          [ ("hangoutDurationSecs" Core..=) Core.. Core.AsText
              Core.<$> hangoutDurationSecs,
            ("mediaType" Core..=) Core.<$> mediaType,
            ("participantId" Core..=) Core.<$> participantId,
            ("type" Core..=) Core.<$> type'
          ]
      )

-- | A message representing the Hangout video start\/end events in Babel
--
-- /See:/ 'newHangoutVideoEventMetadata' smart constructor.
newtype HangoutVideoEventMetadata = HangoutVideoEventMetadata
  { -- |
    hangoutVideoType :: (Core.Maybe HangoutVideoEventMetadata_HangoutVideoType)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'HangoutVideoEventMetadata' with the minimum fields required to make a request.
newHangoutVideoEventMetadata ::
  HangoutVideoEventMetadata
newHangoutVideoEventMetadata =
  HangoutVideoEventMetadata {hangoutVideoType = Core.Nothing}

instance Core.FromJSON HangoutVideoEventMetadata where
  parseJSON =
    Core.withObject
      "HangoutVideoEventMetadata"
      ( \o ->
          HangoutVideoEventMetadata
            Core.<$> (o Core..:? "hangoutVideoType")
      )

instance Core.ToJSON HangoutVideoEventMetadata where
  toJSON HangoutVideoEventMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("hangoutVideoType" Core..=)
              Core.<$> hangoutVideoType
          ]
      )

-- | Hashtag metadata, for HASHTAG segments. For a hashtag, the \"text\" field should contain the display text, and the search/text field should represent the topic being referenced, without the hash symbol; for example, we might have: text = \"#Google\" hashtag/data.search/text = \"Google\" Another example: text = \"#pikachu\" hashtag/data.search_text = \"Pokemon\" Both strings should be considered part of the searchable text. In go\/sbe, both are indexed and searchable.
--
-- /See:/ 'newHashtagData' smart constructor.
newtype HashtagData = HashtagData
  { -- |
    searchText :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'HashtagData' with the minimum fields required to make a request.
newHashtagData ::
  HashtagData
newHashtagData = HashtagData {searchText = Core.Nothing}

instance Core.FromJSON HashtagData where
  parseJSON =
    Core.withObject
      "HashtagData"
      ( \o ->
          HashtagData Core.<$> (o Core..:? "searchText")
      )

instance Core.ToJSON HashtagData where
  toJSON HashtagData {..} =
    Core.object
      ( Core.catMaybes
          [("searchText" Core..=) Core.<$> searchText]
      )

-- | The most recent history records associated with the item.
--
-- /See:/ 'newHistory' smart constructor.
newtype History = History
  { -- |
    record :: (Core.Maybe [HistoryRecord])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'History' with the minimum fields required to make a request.
newHistory ::
  History
newHistory = History {record = Core.Nothing}

instance Core.FromJSON History where
  parseJSON =
    Core.withObject
      "History"
      (\o -> History Core.<$> (o Core..:? "record"))

instance Core.ToJSON History where
  toJSON History {..} =
    Core.object
      (Core.catMaybes [("record" Core..=) Core.<$> record])

--
-- /See:/ 'newHistoryRecord' smart constructor.
data HistoryRecord = HistoryRecord
  { -- | This will almost always be set, but there are corner cases in which the information is not available, and thus applications must handle its absence appropriately.
    clientContext :: (Core.Maybe ClientContext),
    -- |
    filterUpdate :: (Core.Maybe FilterUpdate),
    -- |
    imapUpdate :: (Core.Maybe ImapUpdate),
    -- |
    labelUpdate :: (Core.Maybe LabelUpdate),
    -- |
    prefUpdate :: (Core.Maybe PrefUpdate),
    -- | Each HistoryRecord has a unique id. Ids are monotonically increasing, and not necessarily contiguous.
    recordId :: (Core.Maybe Core.Word64),
    -- |
    threadUpdate :: (Core.Maybe ThreadUpdate),
    -- | This will almost always be set, but there are corner cases in which the information is not available, and thus applications must handle its absence appropriately.
    transactionContext :: (Core.Maybe TransactionContext),
    -- |
    txnDebugInfo :: (Core.Maybe TransactionDebugInfo),
    -- |
    type' :: (Core.Maybe HistoryRecord_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'HistoryRecord' with the minimum fields required to make a request.
newHistoryRecord ::
  HistoryRecord
newHistoryRecord =
  HistoryRecord
    { clientContext = Core.Nothing,
      filterUpdate = Core.Nothing,
      imapUpdate = Core.Nothing,
      labelUpdate = Core.Nothing,
      prefUpdate = Core.Nothing,
      recordId = Core.Nothing,
      threadUpdate = Core.Nothing,
      transactionContext = Core.Nothing,
      txnDebugInfo = Core.Nothing,
      type' = Core.Nothing
    }

instance Core.FromJSON HistoryRecord where
  parseJSON =
    Core.withObject
      "HistoryRecord"
      ( \o ->
          HistoryRecord
            Core.<$> (o Core..:? "clientContext")
            Core.<*> (o Core..:? "filterUpdate")
            Core.<*> (o Core..:? "imapUpdate")
            Core.<*> (o Core..:? "labelUpdate")
            Core.<*> (o Core..:? "prefUpdate")
            Core.<*> ( o Core..:? "recordId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "threadUpdate")
            Core.<*> (o Core..:? "transactionContext")
            Core.<*> (o Core..:? "txnDebugInfo")
            Core.<*> (o Core..:? "type")
      )

instance Core.ToJSON HistoryRecord where
  toJSON HistoryRecord {..} =
    Core.object
      ( Core.catMaybes
          [ ("clientContext" Core..=) Core.<$> clientContext,
            ("filterUpdate" Core..=) Core.<$> filterUpdate,
            ("imapUpdate" Core..=) Core.<$> imapUpdate,
            ("labelUpdate" Core..=) Core.<$> labelUpdate,
            ("prefUpdate" Core..=) Core.<$> prefUpdate,
            ("recordId" Core..=) Core.. Core.AsText
              Core.<$> recordId,
            ("threadUpdate" Core..=) Core.<$> threadUpdate,
            ("transactionContext" Core..=)
              Core.<$> transactionContext,
            ("txnDebugInfo" Core..=) Core.<$> txnDebugInfo,
            ("type" Core..=) Core.<$> type'
          ]
      )

-- | Actions handled by individual host apps.
--
-- /See:/ 'newHostAppActionMarkup' smart constructor.
data HostAppActionMarkup = HostAppActionMarkup
  { -- | Actions handled by Calendar.
    calendarAction :: (Core.Maybe CalendarClientActionMarkup),
    -- | Actions handled by Chat.
    chatAction :: (Core.Maybe ChatClientActionMarkup),
    -- | Actions handled by Drive.
    driveAction :: (Core.Maybe DriveClientActionMarkup),
    -- | Actions handled by Docs, Sheets, or Slides.
    editorAction :: (Core.Maybe EditorClientActionMarkup),
    -- | Actions handled by Gmail.
    gmailAction :: (Core.Maybe GmailClientActionMarkup),
    -- | Actions handled by Sheets.
    sheetsAction :: (Core.Maybe SheetsClientActionMarkup)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'HostAppActionMarkup' with the minimum fields required to make a request.
newHostAppActionMarkup ::
  HostAppActionMarkup
newHostAppActionMarkup =
  HostAppActionMarkup
    { calendarAction = Core.Nothing,
      chatAction = Core.Nothing,
      driveAction = Core.Nothing,
      editorAction = Core.Nothing,
      gmailAction = Core.Nothing,
      sheetsAction = Core.Nothing
    }

instance Core.FromJSON HostAppActionMarkup where
  parseJSON =
    Core.withObject
      "HostAppActionMarkup"
      ( \o ->
          HostAppActionMarkup
            Core.<$> (o Core..:? "calendarAction")
            Core.<*> (o Core..:? "chatAction")
            Core.<*> (o Core..:? "driveAction")
            Core.<*> (o Core..:? "editorAction")
            Core.<*> (o Core..:? "gmailAction")
            Core.<*> (o Core..:? "sheetsAction")
      )

instance Core.ToJSON HostAppActionMarkup where
  toJSON HostAppActionMarkup {..} =
    Core.object
      ( Core.catMaybes
          [ ("calendarAction" Core..=) Core.<$> calendarAction,
            ("chatAction" Core..=) Core.<$> chatAction,
            ("driveAction" Core..=) Core.<$> driveAction,
            ("editorAction" Core..=) Core.<$> editorAction,
            ("gmailAction" Core..=) Core.<$> gmailAction,
            ("sheetsAction" Core..=) Core.<$> sheetsAction
          ]
      )

-- | Represents a single host. Optionally, the MDB owner of the host can be specified.
--
-- /See:/ 'newHostProto' smart constructor.
data HostProto = HostProto
  { -- | Lower-case, fully qualified hostname.
    hostName :: (Core.Maybe Core.Text),
    -- | If present, then any checks that compare this Principal to LOAS peer info must confirm the peer\'s machine owner is equal to \'host_owner\'. If absent, then any peer machine owner is acceptable.
    hostOwner :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'HostProto' with the minimum fields required to make a request.
newHostProto ::
  HostProto
newHostProto = HostProto {hostName = Core.Nothing, hostOwner = Core.Nothing}

instance Core.FromJSON HostProto where
  parseJSON =
    Core.withObject
      "HostProto"
      ( \o ->
          HostProto
            Core.<$> (o Core..:? "hostName")
            Core.<*> (o Core..:? "hostOwner")
      )

instance Core.ToJSON HostProto where
  toJSON HostProto {..} =
    Core.object
      ( Core.catMaybes
          [ ("hostName" Core..=) Core.<$> hostName,
            ("hostOwner" Core..=) Core.<$> hostOwner
          ]
      )

-- | Used to provide a search operator for html properties. This is optional. Search operators let users restrict the query to specific fields relevant to the type of item being searched.
--
-- /See:/ 'newHtmlOperatorOptions' smart constructor.
newtype HtmlOperatorOptions = HtmlOperatorOptions
  { -- | Indicates the operator name required in the query in order to isolate the html property. For example, if operatorName is /subject/ and the property\'s name is /subjectLine/, then queries like /subject:\<value>/ show results only where the value of the property named /subjectLine/ matches /\<value>/. By contrast, a search that uses the same /\<value>/ without an operator return all items where /\<value>/ matches the value of any html properties or text within the content field for the item. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.
    operatorName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'HtmlOperatorOptions' with the minimum fields required to make a request.
newHtmlOperatorOptions ::
  HtmlOperatorOptions
newHtmlOperatorOptions = HtmlOperatorOptions {operatorName = Core.Nothing}

instance Core.FromJSON HtmlOperatorOptions where
  parseJSON =
    Core.withObject
      "HtmlOperatorOptions"
      ( \o ->
          HtmlOperatorOptions
            Core.<$> (o Core..:? "operatorName")
      )

instance Core.ToJSON HtmlOperatorOptions where
  toJSON HtmlOperatorOptions {..} =
    Core.object
      ( Core.catMaybes
          [("operatorName" Core..=) Core.<$> operatorName]
      )

-- | The options for html properties.
--
-- /See:/ 'newHtmlPropertyOptions' smart constructor.
data HtmlPropertyOptions = HtmlPropertyOptions
  { -- | If set, describes how the property should be used as a search operator.
    operatorOptions :: (Core.Maybe HtmlOperatorOptions),
    -- | Indicates the search quality importance of the tokens within the field when used for retrieval. Can only be set to DEFAULT or NONE.
    retrievalImportance :: (Core.Maybe RetrievalImportance)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'HtmlPropertyOptions' with the minimum fields required to make a request.
newHtmlPropertyOptions ::
  HtmlPropertyOptions
newHtmlPropertyOptions =
  HtmlPropertyOptions
    { operatorOptions = Core.Nothing,
      retrievalImportance = Core.Nothing
    }

instance Core.FromJSON HtmlPropertyOptions where
  parseJSON =
    Core.withObject
      "HtmlPropertyOptions"
      ( \o ->
          HtmlPropertyOptions
            Core.<$> (o Core..:? "operatorOptions")
            Core.<*> (o Core..:? "retrievalImportance")
      )

instance Core.ToJSON HtmlPropertyOptions where
  toJSON HtmlPropertyOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("operatorOptions" Core..=)
              Core.<$> operatorOptions,
            ("retrievalImportance" Core..=)
              Core.<$> retrievalImportance
          ]
      )

-- | List of html values.
--
-- /See:/ 'newHtmlValues' smart constructor.
newtype HtmlValues = HtmlValues
  { -- | The maximum allowable length for html values is 2048 characters.
    values :: (Core.Maybe [Core.Text])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'HtmlValues' with the minimum fields required to make a request.
newHtmlValues ::
  HtmlValues
newHtmlValues = HtmlValues {values = Core.Nothing}

instance Core.FromJSON HtmlValues where
  parseJSON =
    Core.withObject
      "HtmlValues"
      (\o -> HtmlValues Core.<$> (o Core..:? "values"))

instance Core.ToJSON HtmlValues where
  toJSON HtmlValues {..} =
    Core.object
      (Core.catMaybes [("values" Core..=) Core.<$> values])

--
-- /See:/ 'newIconImage' smart constructor.
data IconImage = IconImage
  { -- | The alternative text of this icon_url which will be used for accessibility.
    altText :: (Core.Maybe Core.Text),
    -- |
    icon :: (Core.Maybe IconImage_Icon),
    -- |
    iconUrl :: (Core.Maybe Core.Text),
    -- | The image cropping style. Note that icons with a CIRCLE style are rendered larger than the default icon size.
    imageStyle :: (Core.Maybe IconImage_ImageStyle)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'IconImage' with the minimum fields required to make a request.
newIconImage ::
  IconImage
newIconImage =
  IconImage
    { altText = Core.Nothing,
      icon = Core.Nothing,
      iconUrl = Core.Nothing,
      imageStyle = Core.Nothing
    }

instance Core.FromJSON IconImage where
  parseJSON =
    Core.withObject
      "IconImage"
      ( \o ->
          IconImage
            Core.<$> (o Core..:? "altText")
            Core.<*> (o Core..:? "icon")
            Core.<*> (o Core..:? "iconUrl")
            Core.<*> (o Core..:? "imageStyle")
      )

instance Core.ToJSON IconImage where
  toJSON IconImage {..} =
    Core.object
      ( Core.catMaybes
          [ ("altText" Core..=) Core.<$> altText,
            ("icon" Core..=) Core.<$> icon,
            ("iconUrl" Core..=) Core.<$> iconUrl,
            ("imageStyle" Core..=) Core.<$> imageStyle
          ]
      )

-- | Identifies a particular object, including both Users and DirEntries. This Id is unique across the entire server instance, such as the production or qa instance.
--
-- /See:/ 'newId' smart constructor.
data Id = Id
  { -- | The User account in which the DirEntry was originally created. If name/space==GAIA, then it\'s the gaia/id of the user this id is referring to. This field should really be called the \"bucket ID\", not the creator ID. In some circumstances, such as copying a Google Docs file, a user can create an item in a different user\'s bucket, so it should not be relied upon for anything other than bucket location. To look up the requesting user who initially created item, use the @creator_id@ DirEntry field instead.
    creatorUserId :: (Core.Maybe Core.Word64),
    -- | The local identifier for the DirEntry (local to the creator\'s account). local/id + app/name is guaranteed to be unique within the creator account, but not across all User accounts. The string is case sensitive. Ignore if name/space==GAIA. NB For name/space==COSMO, all local_id\'s should be defined in google3\/java\/com\/google\/storage\/cosmo\/server\/api\/SpecialObjectIds.java as they have a special predefined meaning. See cosmo.client.CosmoIdFactory.createObjectId(long,String) for IMPORTANT recommendations when generating IDs.
    localId :: (Core.Maybe Core.Text),
    -- | The name space in which this id is unique (typically the application that created it). Values should be drawn from the above enum, but for experimentation, use values greater than 1000.
    nameSpace :: (Core.Maybe Core.Int32)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Id' with the minimum fields required to make a request.
newId ::
  Id
newId =
  Id
    { creatorUserId = Core.Nothing,
      localId = Core.Nothing,
      nameSpace = Core.Nothing
    }

instance Core.FromJSON Id where
  parseJSON =
    Core.withObject
      "Id"
      ( \o ->
          Id
            Core.<$> ( o Core..:? "creatorUserId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "localId")
            Core.<*> (o Core..:? "nameSpace")
      )

instance Core.ToJSON Id where
  toJSON Id {..} =
    Core.object
      ( Core.catMaybes
          [ ("creatorUserId" Core..=) Core.. Core.AsText
              Core.<$> creatorUserId,
            ("localId" Core..=) Core.<$> localId,
            ("nameSpace" Core..=) Core.<$> nameSpace
          ]
      )

--
-- /See:/ 'newImage' smart constructor.
data Image = Image
  { -- | The alternative text of this image which will be used for accessibility.
    altText :: (Core.Maybe Core.Text),
    -- | The aspect ratio of this image (width\/height).
    aspectRatio :: (Core.Maybe Core.Double),
    -- | Image url specified by developers. Server side, we will wrap with FIFE so client apps can configure size\/cropping\/etc.
    imageUrl :: (Core.Maybe Core.Text),
    -- |
    onClick :: (Core.Maybe OnClick)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Image' with the minimum fields required to make a request.
newImage ::
  Image
newImage =
  Image
    { altText = Core.Nothing,
      aspectRatio = Core.Nothing,
      imageUrl = Core.Nothing,
      onClick = Core.Nothing
    }

instance Core.FromJSON Image where
  parseJSON =
    Core.withObject
      "Image"
      ( \o ->
          Image
            Core.<$> (o Core..:? "altText")
            Core.<*> (o Core..:? "aspectRatio")
            Core.<*> (o Core..:? "imageUrl")
            Core.<*> (o Core..:? "onClick")
      )

instance Core.ToJSON Image where
  toJSON Image {..} =
    Core.object
      ( Core.catMaybes
          [ ("altText" Core..=) Core.<$> altText,
            ("aspectRatio" Core..=) Core.<$> aspectRatio,
            ("imageUrl" Core..=) Core.<$> imageUrl,
            ("onClick" Core..=) Core.<$> onClick
          ]
      )

--
-- /See:/ 'newImageButton' smart constructor.
data ImageButton = ImageButton
  { -- |
    icon :: (Core.Maybe ImageButton_Icon),
    -- |
    iconUrl :: (Core.Maybe Core.Text),
    -- |
    name :: (Core.Maybe Core.Text),
    -- |
    onClick :: (Core.Maybe OnClick)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ImageButton' with the minimum fields required to make a request.
newImageButton ::
  ImageButton
newImageButton =
  ImageButton
    { icon = Core.Nothing,
      iconUrl = Core.Nothing,
      name = Core.Nothing,
      onClick = Core.Nothing
    }

instance Core.FromJSON ImageButton where
  parseJSON =
    Core.withObject
      "ImageButton"
      ( \o ->
          ImageButton
            Core.<$> (o Core..:? "icon")
            Core.<*> (o Core..:? "iconUrl")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "onClick")
      )

instance Core.ToJSON ImageButton where
  toJSON ImageButton {..} =
    Core.object
      ( Core.catMaybes
          [ ("icon" Core..=) Core.<$> icon,
            ("iconUrl" Core..=) Core.<$> iconUrl,
            ("name" Core..=) Core.<$> name,
            ("onClick" Core..=) Core.<$> onClick
          ]
      )

-- | NOTE: Through future refactoring work, this image component will eventually be used in the Image widget, and will likely replace the Icon proto as well.
--
-- /See:/ 'newImageComponent' smart constructor.
data ImageComponent = ImageComponent
  { -- |
    altText :: (Core.Maybe Core.Text),
    -- |
    borderStyle :: (Core.Maybe BorderStyle),
    -- |
    cropStyle :: (Core.Maybe ImageCropStyle),
    -- |
    imageUrl :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ImageComponent' with the minimum fields required to make a request.
newImageComponent ::
  ImageComponent
newImageComponent =
  ImageComponent
    { altText = Core.Nothing,
      borderStyle = Core.Nothing,
      cropStyle = Core.Nothing,
      imageUrl = Core.Nothing
    }

instance Core.FromJSON ImageComponent where
  parseJSON =
    Core.withObject
      "ImageComponent"
      ( \o ->
          ImageComponent
            Core.<$> (o Core..:? "altText")
            Core.<*> (o Core..:? "borderStyle")
            Core.<*> (o Core..:? "cropStyle")
            Core.<*> (o Core..:? "imageUrl")
      )

instance Core.ToJSON ImageComponent where
  toJSON ImageComponent {..} =
    Core.object
      ( Core.catMaybes
          [ ("altText" Core..=) Core.<$> altText,
            ("borderStyle" Core..=) Core.<$> borderStyle,
            ("cropStyle" Core..=) Core.<$> cropStyle,
            ("imageUrl" Core..=) Core.<$> imageUrl
          ]
      )

-- | Represents a crop style that can be applied to an image.
--
-- /See:/ 'newImageCropStyle' smart constructor.
data ImageCropStyle = ImageCropStyle
  { -- | The aspect ratio to use if the crop type is RECTANGLE_CUSTOM.
    aspectRatio :: (Core.Maybe Core.Double),
    -- | The crop type.
    type' :: (Core.Maybe ImageCropStyle_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ImageCropStyle' with the minimum fields required to make a request.
newImageCropStyle ::
  ImageCropStyle
newImageCropStyle =
  ImageCropStyle {aspectRatio = Core.Nothing, type' = Core.Nothing}

instance Core.FromJSON ImageCropStyle where
  parseJSON =
    Core.withObject
      "ImageCropStyle"
      ( \o ->
          ImageCropStyle
            Core.<$> (o Core..:? "aspectRatio")
            Core.<*> (o Core..:? "type")
      )

instance Core.ToJSON ImageCropStyle where
  toJSON ImageCropStyle {..} =
    Core.object
      ( Core.catMaybes
          [ ("aspectRatio" Core..=) Core.<$> aspectRatio,
            ("type" Core..=) Core.<$> type'
          ]
      )

-- | This is deprecated and please use KeyValue.
--
-- /See:/ 'newImageKeyValue' smart constructor.
data ImageKeyValue = ImageKeyValue
  { -- |
    icon :: (Core.Maybe ImageKeyValue_Icon),
    -- |
    iconUrl :: (Core.Maybe Core.Text),
    -- |
    onClick :: (Core.Maybe OnClick),
    -- |
    text :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ImageKeyValue' with the minimum fields required to make a request.
newImageKeyValue ::
  ImageKeyValue
newImageKeyValue =
  ImageKeyValue
    { icon = Core.Nothing,
      iconUrl = Core.Nothing,
      onClick = Core.Nothing,
      text = Core.Nothing
    }

instance Core.FromJSON ImageKeyValue where
  parseJSON =
    Core.withObject
      "ImageKeyValue"
      ( \o ->
          ImageKeyValue
            Core.<$> (o Core..:? "icon")
            Core.<*> (o Core..:? "iconUrl")
            Core.<*> (o Core..:? "onClick")
            Core.<*> (o Core..:? "text")
      )

instance Core.ToJSON ImageKeyValue where
  toJSON ImageKeyValue {..} =
    Core.object
      ( Core.catMaybes
          [ ("icon" Core..=) Core.<$> icon,
            ("iconUrl" Core..=) Core.<$> iconUrl,
            ("onClick" Core..=) Core.<$> onClick,
            ("text" Core..=) Core.<$> text
          ]
      )

--
-- /See:/ 'newImapSessionContext' smart constructor.
data ImapSessionContext = ImapSessionContext
  { -- |
    app :: (Core.Maybe ImapSessionContext_App),
    -- | User agent information
    deviceType :: (Core.Maybe ImapSessionContext_DeviceType),
    -- | As agreed with Bond team, this holds the fingerprint of any \"aguid\" or \"guid\" provided by the ID command. The fingerprint should be calculated by fingerprint2011. Note that not all clients will provide aguid or guid through ID command.
    guidFingerprint :: (Core.Maybe Core.Word64),
    -- |
    os :: (Core.Maybe ImapSessionContext_Os),
    -- |
    osVersion :: (Core.Maybe OsVersion),
    -- |
    possiblyTrimmedModel :: (Core.Maybe PossiblyTrimmedModel)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ImapSessionContext' with the minimum fields required to make a request.
newImapSessionContext ::
  ImapSessionContext
newImapSessionContext =
  ImapSessionContext
    { app = Core.Nothing,
      deviceType = Core.Nothing,
      guidFingerprint = Core.Nothing,
      os = Core.Nothing,
      osVersion = Core.Nothing,
      possiblyTrimmedModel = Core.Nothing
    }

instance Core.FromJSON ImapSessionContext where
  parseJSON =
    Core.withObject
      "ImapSessionContext"
      ( \o ->
          ImapSessionContext
            Core.<$> (o Core..:? "app")
            Core.<*> (o Core..:? "deviceType")
            Core.<*> ( o Core..:? "guidFingerprint"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "os")
            Core.<*> (o Core..:? "osVersion")
            Core.<*> (o Core..:? "possiblyTrimmedModel")
      )

instance Core.ToJSON ImapSessionContext where
  toJSON ImapSessionContext {..} =
    Core.object
      ( Core.catMaybes
          [ ("app" Core..=) Core.<$> app,
            ("deviceType" Core..=) Core.<$> deviceType,
            ("guidFingerprint" Core..=) Core.. Core.AsText
              Core.<$> guidFingerprint,
            ("os" Core..=) Core.<$> os,
            ("osVersion" Core..=) Core.<$> osVersion,
            ("possiblyTrimmedModel" Core..=)
              Core.<$> possiblyTrimmedModel
          ]
      )

-- | Message delete history record extension that exports \/\/imapsync\/folder attribute of deleted messages which have ^is label.
--
-- /See:/ 'newImapSyncDelete' smart constructor.
data ImapSyncDelete = ImapSyncDelete
  { -- | Contains the value of \/\/imapsync\/folder attribute of deleted message.
    mappings :: (Core.Maybe FolderAttribute),
    -- |
    msgId :: (Core.Maybe Core.Word64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ImapSyncDelete' with the minimum fields required to make a request.
newImapSyncDelete ::
  ImapSyncDelete
newImapSyncDelete =
  ImapSyncDelete {mappings = Core.Nothing, msgId = Core.Nothing}

instance Core.FromJSON ImapSyncDelete where
  parseJSON =
    Core.withObject
      "ImapSyncDelete"
      ( \o ->
          ImapSyncDelete
            Core.<$> (o Core..:? "mappings")
            Core.<*> ( o Core..:? "msgId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON ImapSyncDelete where
  toJSON ImapSyncDelete {..} =
    Core.object
      ( Core.catMaybes
          [ ("mappings" Core..=) Core.<$> mappings,
            ("msgId" Core..=) Core.. Core.AsText Core.<$> msgId
          ]
      )

--
-- /See:/ 'newImapUidsReassign' smart constructor.
data ImapUidsReassign = ImapUidsReassign
  { -- | Label
    labelId :: (Core.Maybe Core.Text),
    -- | The message Ids
    messageId :: (Core.Maybe [Core.Word64])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ImapUidsReassign' with the minimum fields required to make a request.
newImapUidsReassign ::
  ImapUidsReassign
newImapUidsReassign =
  ImapUidsReassign {labelId = Core.Nothing, messageId = Core.Nothing}

instance Core.FromJSON ImapUidsReassign where
  parseJSON =
    Core.withObject
      "ImapUidsReassign"
      ( \o ->
          ImapUidsReassign
            Core.<$> (o Core..:? "labelId")
            Core.<*> ( o Core..:? "messageId"
                         Core.<&> Core.fmap (Core.fmap Core.fromAsText)
                     )
      )

instance Core.ToJSON ImapUidsReassign where
  toJSON ImapUidsReassign {..} =
    Core.object
      ( Core.catMaybes
          [ ("labelId" Core..=) Core.<$> labelId,
            ("messageId" Core..=) Core.. Core.fmap Core.AsText
              Core.<$> messageId
          ]
      )

-- | HistoryRecord for changes associated with IMAP, namely: IMAP/UIDS/REASSIGN
--
-- /See:/ 'newImapUpdate' smart constructor.
newtype ImapUpdate = ImapUpdate
  { -- |
    imapUidsReassign :: (Core.Maybe ImapUidsReassign)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ImapUpdate' with the minimum fields required to make a request.
newImapUpdate ::
  ImapUpdate
newImapUpdate = ImapUpdate {imapUidsReassign = Core.Nothing}

instance Core.FromJSON ImapUpdate where
  parseJSON =
    Core.withObject
      "ImapUpdate"
      ( \o ->
          ImapUpdate Core.<$> (o Core..:? "imapUidsReassign")
      )

instance Core.ToJSON ImapUpdate where
  toJSON ImapUpdate {..} =
    Core.object
      ( Core.catMaybes
          [ ("imapUidsReassign" Core..=)
              Core.<$> imapUidsReassign
          ]
      )

--
-- /See:/ 'newImapsyncFolderAttributeFolderMessage' smart constructor.
data ImapsyncFolderAttributeFolderMessage = ImapsyncFolderAttributeFolderMessage
  { -- | Flags of the message. Represents unseen and flagged state.
    flags :: (Core.Maybe ImapsyncFolderAttributeFolderMessageFlags),
    -- | UID of the message.
    uid :: (Core.Maybe Core.Word64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ImapsyncFolderAttributeFolderMessage' with the minimum fields required to make a request.
newImapsyncFolderAttributeFolderMessage ::
  ImapsyncFolderAttributeFolderMessage
newImapsyncFolderAttributeFolderMessage =
  ImapsyncFolderAttributeFolderMessage
    { flags = Core.Nothing,
      uid = Core.Nothing
    }

instance
  Core.FromJSON
    ImapsyncFolderAttributeFolderMessage
  where
  parseJSON =
    Core.withObject
      "ImapsyncFolderAttributeFolderMessage"
      ( \o ->
          ImapsyncFolderAttributeFolderMessage
            Core.<$> (o Core..:? "flags")
            Core.<*> ( o Core..:? "uid"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance
  Core.ToJSON
    ImapsyncFolderAttributeFolderMessage
  where
  toJSON ImapsyncFolderAttributeFolderMessage {..} =
    Core.object
      ( Core.catMaybes
          [ ("flags" Core..=) Core.<$> flags,
            ("uid" Core..=) Core.. Core.AsText Core.<$> uid
          ]
      )

--
-- /See:/ 'newImapsyncFolderAttributeFolderMessageFlags' smart constructor.
data ImapsyncFolderAttributeFolderMessageFlags = ImapsyncFolderAttributeFolderMessageFlags
  { -- | Flagged state of the message.
    flagged :: (Core.Maybe Core.Bool),
    -- | Seen state of the message.
    seen :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ImapsyncFolderAttributeFolderMessageFlags' with the minimum fields required to make a request.
newImapsyncFolderAttributeFolderMessageFlags ::
  ImapsyncFolderAttributeFolderMessageFlags
newImapsyncFolderAttributeFolderMessageFlags =
  ImapsyncFolderAttributeFolderMessageFlags
    { flagged = Core.Nothing,
      seen = Core.Nothing
    }

instance
  Core.FromJSON
    ImapsyncFolderAttributeFolderMessageFlags
  where
  parseJSON =
    Core.withObject
      "ImapsyncFolderAttributeFolderMessageFlags"
      ( \o ->
          ImapsyncFolderAttributeFolderMessageFlags
            Core.<$> (o Core..:? "flagged") Core.<*> (o Core..:? "seen")
      )

instance
  Core.ToJSON
    ImapsyncFolderAttributeFolderMessageFlags
  where
  toJSON ImapsyncFolderAttributeFolderMessageFlags {..} =
    Core.object
      ( Core.catMaybes
          [ ("flagged" Core..=) Core.<$> flagged,
            ("seen" Core..=) Core.<$> seen
          ]
      )

-- | Annotation metadata to display system messages for incoming webhook events. Next Tag: 7
--
-- /See:/ 'newIncomingWebhookChangedMetadata' smart constructor.
data IncomingWebhookChangedMetadata = IncomingWebhookChangedMetadata
  { -- | The webhook name at the time of the change. Used in Spanner storage, BE API responses and FE API responses.
    incomingWebhookName :: (Core.Maybe Core.Text),
    -- | The user id of the user whose action triggered this system message. Used in Spanner storage, BE API responses and FE API responses.
    initiatorId :: (Core.Maybe UserId),
    -- | Complete profile when ListTopicsRequest FetchOptions.USER is set. Otherwise, only the id will be filled in. Used in FE API responses.
    initiatorProfile :: (Core.Maybe User),
    -- | The webhook id of the incoming webhook in question. This field should not be used to load webhook information dynamically and is only present for debugging purposes. Used in Spanner storage, BE API responses and FE API responses.
    obfuscatedIncomingWebhookId :: (Core.Maybe Core.Text),
    -- | Only populated for UPDATED/NAME and UPDATED/NAME/AND/AVATAR events, where the webhook name was changed. Used in Spanner storage, BE API responses and FE API responses.
    oldIncomingWebhookName :: (Core.Maybe Core.Text),
    -- | Used in Spanner storage, BE API responses and FE API responses.
    type' :: (Core.Maybe IncomingWebhookChangedMetadata_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'IncomingWebhookChangedMetadata' with the minimum fields required to make a request.
newIncomingWebhookChangedMetadata ::
  IncomingWebhookChangedMetadata
newIncomingWebhookChangedMetadata =
  IncomingWebhookChangedMetadata
    { incomingWebhookName = Core.Nothing,
      initiatorId = Core.Nothing,
      initiatorProfile = Core.Nothing,
      obfuscatedIncomingWebhookId = Core.Nothing,
      oldIncomingWebhookName = Core.Nothing,
      type' = Core.Nothing
    }

instance Core.FromJSON IncomingWebhookChangedMetadata where
  parseJSON =
    Core.withObject
      "IncomingWebhookChangedMetadata"
      ( \o ->
          IncomingWebhookChangedMetadata
            Core.<$> (o Core..:? "incomingWebhookName")
            Core.<*> (o Core..:? "initiatorId")
            Core.<*> (o Core..:? "initiatorProfile")
            Core.<*> (o Core..:? "obfuscatedIncomingWebhookId")
            Core.<*> (o Core..:? "oldIncomingWebhookName")
            Core.<*> (o Core..:? "type")
      )

instance Core.ToJSON IncomingWebhookChangedMetadata where
  toJSON IncomingWebhookChangedMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("incomingWebhookName" Core..=)
              Core.<$> incomingWebhookName,
            ("initiatorId" Core..=) Core.<$> initiatorId,
            ("initiatorProfile" Core..=)
              Core.<$> initiatorProfile,
            ("obfuscatedIncomingWebhookId" Core..=)
              Core.<$> obfuscatedIncomingWebhookId,
            ("oldIncomingWebhookName" Core..=)
              Core.<$> oldIncomingWebhookName,
            ("type" Core..=) Core.<$> type'
          ]
      )

--
-- /See:/ 'newIndexItemOptions' smart constructor.
newtype IndexItemOptions = IndexItemOptions
  { -- | Specifies if the index request should allow Google Workspace principals that do not exist or are deleted.
    allowUnknownGsuitePrincipals :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'IndexItemOptions' with the minimum fields required to make a request.
newIndexItemOptions ::
  IndexItemOptions
newIndexItemOptions =
  IndexItemOptions {allowUnknownGsuitePrincipals = Core.Nothing}

instance Core.FromJSON IndexItemOptions where
  parseJSON =
    Core.withObject
      "IndexItemOptions"
      ( \o ->
          IndexItemOptions
            Core.<$> (o Core..:? "allowUnknownGsuitePrincipals")
      )

instance Core.ToJSON IndexItemOptions where
  toJSON IndexItemOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("allowUnknownGsuitePrincipals" Core..=)
              Core.<$> allowUnknownGsuitePrincipals
          ]
      )

--
-- /See:/ 'newIndexItemRequest' smart constructor.
data IndexItemRequest = IndexItemRequest
  { -- | The name of connector making this call. Format: datasources\/{source_id}\/connectors\/{ID}
    connectorName :: (Core.Maybe Core.Text),
    -- | Common debug options.
    debugOptions :: (Core.Maybe DebugOptions),
    -- |
    indexItemOptions :: (Core.Maybe IndexItemOptions),
    -- | The name of the item. Format: datasources\/{source/id}\/items\/{item/id}
    item :: (Core.Maybe Item),
    -- | Required. The RequestMode for this request.
    mode :: (Core.Maybe IndexItemRequest_Mode)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'IndexItemRequest' with the minimum fields required to make a request.
newIndexItemRequest ::
  IndexItemRequest
newIndexItemRequest =
  IndexItemRequest
    { connectorName = Core.Nothing,
      debugOptions = Core.Nothing,
      indexItemOptions = Core.Nothing,
      item = Core.Nothing,
      mode = Core.Nothing
    }

instance Core.FromJSON IndexItemRequest where
  parseJSON =
    Core.withObject
      "IndexItemRequest"
      ( \o ->
          IndexItemRequest
            Core.<$> (o Core..:? "connectorName")
            Core.<*> (o Core..:? "debugOptions")
            Core.<*> (o Core..:? "indexItemOptions")
            Core.<*> (o Core..:? "item")
            Core.<*> (o Core..:? "mode")
      )

instance Core.ToJSON IndexItemRequest where
  toJSON IndexItemRequest {..} =
    Core.object
      ( Core.catMaybes
          [ ("connectorName" Core..=) Core.<$> connectorName,
            ("debugOptions" Core..=) Core.<$> debugOptions,
            ("indexItemOptions" Core..=)
              Core.<$> indexItemOptions,
            ("item" Core..=) Core.<$> item,
            ("mode" Core..=) Core.<$> mode
          ]
      )

-- | Request message for @InitializeCustomer@ method.
--
-- /See:/ 'newInitializeCustomerRequest' smart constructor.
data InitializeCustomerRequest = InitializeCustomerRequest
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'InitializeCustomerRequest' with the minimum fields required to make a request.
newInitializeCustomerRequest ::
  InitializeCustomerRequest
newInitializeCustomerRequest = InitializeCustomerRequest

instance Core.FromJSON InitializeCustomerRequest where
  parseJSON =
    Core.withObject
      "InitializeCustomerRequest"
      (\o -> Core.pure InitializeCustomerRequest)

instance Core.ToJSON InitializeCustomerRequest where
  toJSON = Core.const Core.emptyObject

--
-- /See:/ 'newInsertContent' smart constructor.
data InsertContent = InsertContent
  { -- | The content to be inserted.
    content :: (Core.Maybe Core.Text),
    -- | The type of inserted content.
    contentType :: (Core.Maybe InsertContent_ContentType),
    -- |
    mimeType :: (Core.Maybe InsertContent_MimeType)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'InsertContent' with the minimum fields required to make a request.
newInsertContent ::
  InsertContent
newInsertContent =
  InsertContent
    { content = Core.Nothing,
      contentType = Core.Nothing,
      mimeType = Core.Nothing
    }

instance Core.FromJSON InsertContent where
  parseJSON =
    Core.withObject
      "InsertContent"
      ( \o ->
          InsertContent
            Core.<$> (o Core..:? "content")
            Core.<*> (o Core..:? "contentType")
            Core.<*> (o Core..:? "mimeType")
      )

instance Core.ToJSON InsertContent where
  toJSON InsertContent {..} =
    Core.object
      ( Core.catMaybes
          [ ("content" Core..=) Core.<$> content,
            ("contentType" Core..=) Core.<$> contentType,
            ("mimeType" Core..=) Core.<$> mimeType
          ]
      )

-- | Used to specify integer faceting options.
--
-- /See:/ 'newIntegerFacetingOptions' smart constructor.
newtype IntegerFacetingOptions = IntegerFacetingOptions
  { -- | Buckets for given integer values should be in strictly ascending order. For example, if values supplied are (1,5,10,100), the following facet buckets will be formed {\<1, [1,5), [5-10), [10-100), >=100}.
    integerBuckets :: (Core.Maybe [Core.Int64])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'IntegerFacetingOptions' with the minimum fields required to make a request.
newIntegerFacetingOptions ::
  IntegerFacetingOptions
newIntegerFacetingOptions =
  IntegerFacetingOptions {integerBuckets = Core.Nothing}

instance Core.FromJSON IntegerFacetingOptions where
  parseJSON =
    Core.withObject
      "IntegerFacetingOptions"
      ( \o ->
          IntegerFacetingOptions
            Core.<$> ( o Core..:? "integerBuckets"
                         Core.<&> Core.fmap (Core.fmap Core.fromAsText)
                     )
      )

instance Core.ToJSON IntegerFacetingOptions where
  toJSON IntegerFacetingOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("integerBuckets" Core..=)
              Core.. Core.fmap Core.AsText
              Core.<$> integerBuckets
          ]
      )

-- | Used to provide a search operator for integer properties. This is optional. Search operators let users restrict the query to specific fields relevant to the type of item being searched.
--
-- /See:/ 'newIntegerOperatorOptions' smart constructor.
data IntegerOperatorOptions = IntegerOperatorOptions
  { -- | Indicates the operator name required in the query in order to isolate the integer property using the greater-than operator. For example, if greaterThanOperatorName is /priorityabove/ and the property\'s name is /priorityVal/, then queries like /priorityabove:\<value>/ show results only where the value of the property named /priorityVal/ is greater than /\<value>/. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.
    greaterThanOperatorName :: (Core.Maybe Core.Text),
    -- | Indicates the operator name required in the query in order to isolate the integer property using the less-than operator. For example, if lessThanOperatorName is /prioritybelow/ and the property\'s name is /priorityVal/, then queries like /prioritybelow:\<value>/ show results only where the value of the property named /priorityVal/ is less than /\<value>/. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.
    lessThanOperatorName :: (Core.Maybe Core.Text),
    -- | Indicates the operator name required in the query in order to isolate the integer property. For example, if operatorName is /priority/ and the property\'s name is /priorityVal/, then queries like /priority:\<value>/ show results only where the value of the property named /priorityVal/ matches /\<value>/. By contrast, a search that uses the same /\<value>/ without an operator returns all items where /\<value>/ matches the value of any String properties or text within the content field for the item. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.
    operatorName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'IntegerOperatorOptions' with the minimum fields required to make a request.
newIntegerOperatorOptions ::
  IntegerOperatorOptions
newIntegerOperatorOptions =
  IntegerOperatorOptions
    { greaterThanOperatorName = Core.Nothing,
      lessThanOperatorName = Core.Nothing,
      operatorName = Core.Nothing
    }

instance Core.FromJSON IntegerOperatorOptions where
  parseJSON =
    Core.withObject
      "IntegerOperatorOptions"
      ( \o ->
          IntegerOperatorOptions
            Core.<$> (o Core..:? "greaterThanOperatorName")
            Core.<*> (o Core..:? "lessThanOperatorName")
            Core.<*> (o Core..:? "operatorName")
      )

instance Core.ToJSON IntegerOperatorOptions where
  toJSON IntegerOperatorOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("greaterThanOperatorName" Core..=)
              Core.<$> greaterThanOperatorName,
            ("lessThanOperatorName" Core..=)
              Core.<$> lessThanOperatorName,
            ("operatorName" Core..=) Core.<$> operatorName
          ]
      )

-- | The options for integer properties.
--
-- /See:/ 'newIntegerPropertyOptions' smart constructor.
data IntegerPropertyOptions = IntegerPropertyOptions
  { -- | If set, describes integer faceting options for the given integer property. The corresponding integer property should be marked isFacetable.
    integerFacetingOptions :: (Core.Maybe IntegerFacetingOptions),
    -- | The maximum value of the property. The minimum and maximum values for the property are used to rank results according to the ordered ranking. Indexing requests with values greater than the maximum are accepted and ranked with the same weight as items indexed with the maximum value.
    maximumValue :: (Core.Maybe Core.Int64),
    -- | The minimum value of the property. The minimum and maximum values for the property are used to rank results according to the ordered ranking. Indexing requests with values less than the minimum are accepted and ranked with the same weight as items indexed with the minimum value.
    minimumValue :: (Core.Maybe Core.Int64),
    -- | If set, describes how the integer should be used as a search operator.
    operatorOptions :: (Core.Maybe IntegerOperatorOptions),
    -- | Used to specify the ordered ranking for the integer. Can only be used if isRepeatable is false.
    orderedRanking :: (Core.Maybe IntegerPropertyOptions_OrderedRanking)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'IntegerPropertyOptions' with the minimum fields required to make a request.
newIntegerPropertyOptions ::
  IntegerPropertyOptions
newIntegerPropertyOptions =
  IntegerPropertyOptions
    { integerFacetingOptions = Core.Nothing,
      maximumValue = Core.Nothing,
      minimumValue = Core.Nothing,
      operatorOptions = Core.Nothing,
      orderedRanking = Core.Nothing
    }

instance Core.FromJSON IntegerPropertyOptions where
  parseJSON =
    Core.withObject
      "IntegerPropertyOptions"
      ( \o ->
          IntegerPropertyOptions
            Core.<$> (o Core..:? "integerFacetingOptions")
            Core.<*> ( o Core..:? "maximumValue"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> ( o Core..:? "minimumValue"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "operatorOptions")
            Core.<*> (o Core..:? "orderedRanking")
      )

instance Core.ToJSON IntegerPropertyOptions where
  toJSON IntegerPropertyOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("integerFacetingOptions" Core..=)
              Core.<$> integerFacetingOptions,
            ("maximumValue" Core..=) Core.. Core.AsText
              Core.<$> maximumValue,
            ("minimumValue" Core..=) Core.. Core.AsText
              Core.<$> minimumValue,
            ("operatorOptions" Core..=) Core.<$> operatorOptions,
            ("orderedRanking" Core..=) Core.<$> orderedRanking
          ]
      )

-- | List of integer values.
--
-- /See:/ 'newIntegerValues' smart constructor.
newtype IntegerValues = IntegerValues
  { -- |
    values :: (Core.Maybe [Core.Int64])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'IntegerValues' with the minimum fields required to make a request.
newIntegerValues ::
  IntegerValues
newIntegerValues = IntegerValues {values = Core.Nothing}

instance Core.FromJSON IntegerValues where
  parseJSON =
    Core.withObject
      "IntegerValues"
      ( \o ->
          IntegerValues
            Core.<$> ( o Core..:? "values"
                         Core.<&> Core.fmap (Core.fmap Core.fromAsText)
                     )
      )

instance Core.ToJSON IntegerValues where
  toJSON IntegerValues {..} =
    Core.object
      ( Core.catMaybes
          [ ("values" Core..=) Core.. Core.fmap Core.AsText
              Core.<$> values
          ]
      )

--
-- /See:/ 'newIntegrationConfigMutation' smart constructor.
data IntegrationConfigMutation = IntegrationConfigMutation
  { -- | Add an app using its identifier.
    addApp :: (Core.Maybe AppId),
    -- | Add a pinned tab using its identifier.
    addPinnedItem :: (Core.Maybe PinnedItemId),
    -- | Remove an active app using its identifier.
    removeApp :: (Core.Maybe AppId),
    -- | Remove an active pinned tab using its identifier.
    removePinnedItem :: (Core.Maybe PinnedItemId)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'IntegrationConfigMutation' with the minimum fields required to make a request.
newIntegrationConfigMutation ::
  IntegrationConfigMutation
newIntegrationConfigMutation =
  IntegrationConfigMutation
    { addApp = Core.Nothing,
      addPinnedItem = Core.Nothing,
      removeApp = Core.Nothing,
      removePinnedItem = Core.Nothing
    }

instance Core.FromJSON IntegrationConfigMutation where
  parseJSON =
    Core.withObject
      "IntegrationConfigMutation"
      ( \o ->
          IntegrationConfigMutation
            Core.<$> (o Core..:? "addApp")
            Core.<*> (o Core..:? "addPinnedItem")
            Core.<*> (o Core..:? "removeApp")
            Core.<*> (o Core..:? "removePinnedItem")
      )

instance Core.ToJSON IntegrationConfigMutation where
  toJSON IntegrationConfigMutation {..} =
    Core.object
      ( Core.catMaybes
          [ ("addApp" Core..=) Core.<$> addApp,
            ("addPinnedItem" Core..=) Core.<$> addPinnedItem,
            ("removeApp" Core..=) Core.<$> removeApp,
            ("removePinnedItem" Core..=)
              Core.<$> removePinnedItem
          ]
      )

-- | Annotation metadata to display system message for integration config updated event. This metadata is stored in spanner, and can be dispatched to clients without any field modification or transformation.
--
-- /See:/ 'newIntegrationConfigUpdatedMetadata' smart constructor.
data IntegrationConfigUpdatedMetadata = IntegrationConfigUpdatedMetadata
  { -- | The user whose action triggered this system message.
    initiatorId :: (Core.Maybe UserId),
    -- | A list of updates applied on the integration config.
    mutations :: (Core.Maybe [IntegrationConfigMutation])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'IntegrationConfigUpdatedMetadata' with the minimum fields required to make a request.
newIntegrationConfigUpdatedMetadata ::
  IntegrationConfigUpdatedMetadata
newIntegrationConfigUpdatedMetadata =
  IntegrationConfigUpdatedMetadata
    { initiatorId = Core.Nothing,
      mutations = Core.Nothing
    }

instance
  Core.FromJSON
    IntegrationConfigUpdatedMetadata
  where
  parseJSON =
    Core.withObject
      "IntegrationConfigUpdatedMetadata"
      ( \o ->
          IntegrationConfigUpdatedMetadata
            Core.<$> (o Core..:? "initiatorId")
            Core.<*> (o Core..:? "mutations")
      )

instance Core.ToJSON IntegrationConfigUpdatedMetadata where
  toJSON IntegrationConfigUpdatedMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("initiatorId" Core..=) Core.<$> initiatorId,
            ("mutations" Core..=) Core.<$> mutations
          ]
      )

-- | Represents an interaction between a user and an item.
--
-- /See:/ 'newInteraction' smart constructor.
data Interaction = Interaction
  { -- | The time when the user acted on the item. If multiple actions of the same type exist for a single user, only the most recent action is recorded.
    interactionTime :: (Core.Maybe Core.DateTime),
    -- | The user that acted on the item.
    principal :: (Core.Maybe Principal),
    -- |
    type' :: (Core.Maybe Interaction_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Interaction' with the minimum fields required to make a request.
newInteraction ::
  Interaction
newInteraction =
  Interaction
    { interactionTime = Core.Nothing,
      principal = Core.Nothing,
      type' = Core.Nothing
    }

instance Core.FromJSON Interaction where
  parseJSON =
    Core.withObject
      "Interaction"
      ( \o ->
          Interaction
            Core.<$> (o Core..:? "interactionTime")
            Core.<*> (o Core..:? "principal")
            Core.<*> (o Core..:? "type")
      )

instance Core.ToJSON Interaction where
  toJSON Interaction {..} =
    Core.object
      ( Core.catMaybes
          [ ("interactionTime" Core..=)
              Core.<$> interactionTime,
            ("principal" Core..=) Core.<$> principal,
            ("type" Core..=) Core.<$> type'
          ]
      )

-- | Interaction data for an annotation, which may be supplemental to the metadata oneof. For example, this will contain the fully built navigation target for smart chips. NEXT TAG: 2
--
-- /See:/ 'newInteractionData' smart constructor.
newtype InteractionData = InteractionData
  { -- | A general navigation target associated with the annotation this message is contained in. For smart chips, this will be the destination of the tap\/click target and will be returned by the server. For scenarios where the chip originated from a user-provided url, this value will be provided by clients; otherwise it will be built by the corresponding metadata parts.
    url :: (Core.Maybe SafeUrlProto)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'InteractionData' with the minimum fields required to make a request.
newInteractionData ::
  InteractionData
newInteractionData = InteractionData {url = Core.Nothing}

instance Core.FromJSON InteractionData where
  parseJSON =
    Core.withObject
      "InteractionData"
      (\o -> InteractionData Core.<$> (o Core..:? "url"))

instance Core.ToJSON InteractionData where
  toJSON InteractionData {..} =
    Core.object
      (Core.catMaybes [("url" Core..=) Core.<$> url])

--
-- /See:/ 'newInviteAcceptedEvent' smart constructor.
newtype InviteAcceptedEvent = InviteAcceptedEvent
  { -- |
    participantId :: (Core.Maybe [StoredParticipantId])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'InviteAcceptedEvent' with the minimum fields required to make a request.
newInviteAcceptedEvent ::
  InviteAcceptedEvent
newInviteAcceptedEvent = InviteAcceptedEvent {participantId = Core.Nothing}

instance Core.FromJSON InviteAcceptedEvent where
  parseJSON =
    Core.withObject
      "InviteAcceptedEvent"
      ( \o ->
          InviteAcceptedEvent
            Core.<$> (o Core..:? "participantId")
      )

instance Core.ToJSON InviteAcceptedEvent where
  toJSON InviteAcceptedEvent {..} =
    Core.object
      ( Core.catMaybes
          [("participantId" Core..=) Core.<$> participantId]
      )

-- | Invitee information from a Dynamite invitation. See go\/dynamite-invitee-mgmt.
--
-- /See:/ 'newInviteeInfo' smart constructor.
data InviteeInfo = InviteeInfo
  { -- | Email as typed by the user when invited to Room or DM. This value will be canonicalized and hashed before retained in storage.
    email :: (Core.Maybe Core.Text),
    -- | Unique, immutable ID of the User.
    userId :: (Core.Maybe UserId)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'InviteeInfo' with the minimum fields required to make a request.
newInviteeInfo ::
  InviteeInfo
newInviteeInfo = InviteeInfo {email = Core.Nothing, userId = Core.Nothing}

instance Core.FromJSON InviteeInfo where
  parseJSON =
    Core.withObject
      "InviteeInfo"
      ( \o ->
          InviteeInfo
            Core.<$> (o Core..:? "email") Core.<*> (o Core..:? "userId")
      )

instance Core.ToJSON InviteeInfo where
  toJSON InviteeInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("email" Core..=) Core.<$> email,
            ("userId" Core..=) Core.<$> userId
          ]
      )

-- | Represents a single object that is an item in the search index, such as a file, folder, or a database record.
--
-- /See:/ 'newItem' smart constructor.
data Item = Item
  { -- | Access control list for this item.
    acl :: (Core.Maybe ItemAcl),
    -- | Item content to be indexed and made text searchable.
    content :: (Core.Maybe ItemContent),
    -- | The type for this item.
    itemType :: (Core.Maybe Item_ItemType),
    -- | The metadata information.
    metadata :: (Core.Maybe ItemMetadata),
    -- | The name of the Item. Format: datasources\/{source/id}\/items\/{item/id} This is a required field. The maximum length is 1536 characters.
    name :: (Core.Maybe Core.Text),
    -- | Additional state connector can store for this item. The maximum length is 10000 bytes.
    payload :: (Core.Maybe Core.Base64),
    -- | Queue this item belongs to. The maximum length is 100 characters.
    queue :: (Core.Maybe Core.Text),
    -- | Status of the item. Output only field.
    status :: (Core.Maybe ItemStatus),
    -- | The structured data for the item that should conform to a registered object definition in the schema for the data source.
    structuredData :: (Core.Maybe ItemStructuredData),
    -- | Required. The indexing system stores the version from the datasource as a byte string and compares the Item version in the index to the version of the queued Item using lexical ordering. Cloud Search Indexing won\'t index or delete any queued item with a version value that is less than or equal to the version of the currently indexed item. The maximum length for this field is 1024 bytes. For information on how item version affects the deletion process, refer to <https://developers.google.com/cloud-search/docs/guides/operations Handle revisions after manual deletes>.
    version :: (Core.Maybe Core.Base64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Item' with the minimum fields required to make a request.
newItem ::
  Item
newItem =
  Item
    { acl = Core.Nothing,
      content = Core.Nothing,
      itemType = Core.Nothing,
      metadata = Core.Nothing,
      name = Core.Nothing,
      payload = Core.Nothing,
      queue = Core.Nothing,
      status = Core.Nothing,
      structuredData = Core.Nothing,
      version = Core.Nothing
    }

instance Core.FromJSON Item where
  parseJSON =
    Core.withObject
      "Item"
      ( \o ->
          Item
            Core.<$> (o Core..:? "acl")
            Core.<*> (o Core..:? "content")
            Core.<*> (o Core..:? "itemType")
            Core.<*> (o Core..:? "metadata")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "payload")
            Core.<*> (o Core..:? "queue")
            Core.<*> (o Core..:? "status")
            Core.<*> (o Core..:? "structuredData")
            Core.<*> (o Core..:? "version")
      )

instance Core.ToJSON Item where
  toJSON Item {..} =
    Core.object
      ( Core.catMaybes
          [ ("acl" Core..=) Core.<$> acl,
            ("content" Core..=) Core.<$> content,
            ("itemType" Core..=) Core.<$> itemType,
            ("metadata" Core..=) Core.<$> metadata,
            ("name" Core..=) Core.<$> name,
            ("payload" Core..=) Core.<$> payload,
            ("queue" Core..=) Core.<$> queue,
            ("status" Core..=) Core.<$> status,
            ("structuredData" Core..=) Core.<$> structuredData,
            ("version" Core..=) Core.<$> version
          ]
      )

-- | Access control list information for the item. For more information see <https://developers.google.com/cloud-search/docs/guides/acls Map ACLs>.
--
-- /See:/ 'newItemAcl' smart constructor.
data ItemAcl = ItemAcl
  { -- | Sets the type of access rules to apply when an item inherits its ACL from a parent. This should always be set in tandem with the inheritAclFrom field. Also, when the inheritAclFrom field is set, this field should be set to a valid AclInheritanceType.
    aclInheritanceType :: (Core.Maybe ItemAcl_AclInheritanceType),
    -- | List of principals who are explicitly denied access to the item in search results. While principals are denied access by default, use denied readers to handle exceptions and override the list allowed readers. The maximum number of elements is 100.
    deniedReaders :: (Core.Maybe [Principal]),
    -- | The name of the item to inherit the Access Permission List (ACL) from. Note: ACL inheritance /only/ provides access permissions to child items and does not define structural relationships, nor does it provide convenient ways to delete large groups of items. Deleting an ACL parent from the index only alters the access permissions of child items that reference the parent in the inheritAclFrom field. The item is still in the index, but may not visible in search results. By contrast, deletion of a container item also deletes all items that reference the container via the containerName field. The maximum length for this field is 1536 characters.
    inheritAclFrom :: (Core.Maybe Core.Text),
    -- | Optional. List of owners for the item. This field has no bearing on document access permissions. It does, however, offer a slight ranking boosts items where the querying user is an owner. The maximum number of elements is 5.
    owners :: (Core.Maybe [Principal]),
    -- | List of principals who are allowed to see the item in search results. Optional if inheriting permissions from another item or if the item is not intended to be visible, such as virtual containers. The maximum number of elements is 1000.
    readers :: (Core.Maybe [Principal])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ItemAcl' with the minimum fields required to make a request.
newItemAcl ::
  ItemAcl
newItemAcl =
  ItemAcl
    { aclInheritanceType = Core.Nothing,
      deniedReaders = Core.Nothing,
      inheritAclFrom = Core.Nothing,
      owners = Core.Nothing,
      readers = Core.Nothing
    }

instance Core.FromJSON ItemAcl where
  parseJSON =
    Core.withObject
      "ItemAcl"
      ( \o ->
          ItemAcl
            Core.<$> (o Core..:? "aclInheritanceType")
            Core.<*> (o Core..:? "deniedReaders")
            Core.<*> (o Core..:? "inheritAclFrom")
            Core.<*> (o Core..:? "owners")
            Core.<*> (o Core..:? "readers")
      )

instance Core.ToJSON ItemAcl where
  toJSON ItemAcl {..} =
    Core.object
      ( Core.catMaybes
          [ ("aclInheritanceType" Core..=)
              Core.<$> aclInheritanceType,
            ("deniedReaders" Core..=) Core.<$> deniedReaders,
            ("inheritAclFrom" Core..=) Core.<$> inheritAclFrom,
            ("owners" Core..=) Core.<$> owners,
            ("readers" Core..=) Core.<$> readers
          ]
      )

-- | Content of an item to be indexed and surfaced by Cloud Search. Only UTF-8 encoded strings are allowed as inlineContent. If the content is uploaded and not binary, it must be UTF-8 encoded.
--
-- /See:/ 'newItemContent' smart constructor.
data ItemContent = ItemContent
  { -- | Upload reference ID of a previously uploaded content via write method.
    contentDataRef :: (Core.Maybe UploadItemRef),
    -- |
    contentFormat :: (Core.Maybe ItemContent_ContentFormat),
    -- | Hashing info calculated and provided by the API client for content. Can be used with the items.push method to calculate modified state. The maximum length is 2048 characters.
    hash :: (Core.Maybe Core.Text),
    -- | Content that is supplied inlined within the update method. The maximum length is 102400 bytes (100 KiB).
    inlineContent :: (Core.Maybe Core.Base64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ItemContent' with the minimum fields required to make a request.
newItemContent ::
  ItemContent
newItemContent =
  ItemContent
    { contentDataRef = Core.Nothing,
      contentFormat = Core.Nothing,
      hash = Core.Nothing,
      inlineContent = Core.Nothing
    }

instance Core.FromJSON ItemContent where
  parseJSON =
    Core.withObject
      "ItemContent"
      ( \o ->
          ItemContent
            Core.<$> (o Core..:? "contentDataRef")
            Core.<*> (o Core..:? "contentFormat")
            Core.<*> (o Core..:? "hash")
            Core.<*> (o Core..:? "inlineContent")
      )

instance Core.ToJSON ItemContent where
  toJSON ItemContent {..} =
    Core.object
      ( Core.catMaybes
          [ ("contentDataRef" Core..=) Core.<$> contentDataRef,
            ("contentFormat" Core..=) Core.<$> contentFormat,
            ("hash" Core..=) Core.<$> hash,
            ("inlineContent" Core..=) Core.<$> inlineContent
          ]
      )

--
-- /See:/ 'newItemCountByStatus' smart constructor.
data ItemCountByStatus = ItemCountByStatus
  { -- | Number of items matching the status code.
    count :: (Core.Maybe Core.Int64),
    -- | Number of items matching the status code for which billing is done. This excludes virtual container items from the total count. This count would not be applicable for items with ERROR or NEW_ITEM status code.
    indexedItemsCount :: (Core.Maybe Core.Int64),
    -- | Status of the items.
    statusCode :: (Core.Maybe ItemCountByStatus_StatusCode)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ItemCountByStatus' with the minimum fields required to make a request.
newItemCountByStatus ::
  ItemCountByStatus
newItemCountByStatus =
  ItemCountByStatus
    { count = Core.Nothing,
      indexedItemsCount = Core.Nothing,
      statusCode = Core.Nothing
    }

instance Core.FromJSON ItemCountByStatus where
  parseJSON =
    Core.withObject
      "ItemCountByStatus"
      ( \o ->
          ItemCountByStatus
            Core.<$> ( o Core..:? "count"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> ( o Core..:? "indexedItemsCount"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "statusCode")
      )

instance Core.ToJSON ItemCountByStatus where
  toJSON ItemCountByStatus {..} =
    Core.object
      ( Core.catMaybes
          [ ("count" Core..=) Core.. Core.AsText Core.<$> count,
            ("indexedItemsCount" Core..=) Core.. Core.AsText
              Core.<$> indexedItemsCount,
            ("statusCode" Core..=) Core.<$> statusCode
          ]
      )

-- | Available metadata fields for the item.
--
-- /See:/ 'newItemMetadata' smart constructor.
data ItemMetadata = ItemMetadata
  { -- | The name of the container for this item. Deletion of the container item leads to automatic deletion of this item. Note: ACLs are not inherited from a container item. To provide ACL inheritance for an item, use the inheritAclFrom field. The maximum length is 1536 characters.
    containerName :: (Core.Maybe Core.Text),
    -- | The BCP-47 language code for the item, such as \"en-US\" or \"sr-Latn\". For more information, see http:\/\/www.unicode.org\/reports\/tr35\/#Unicode/locale/identifier. The maximum length is 32 characters.
    contentLanguage :: (Core.Maybe Core.Text),
    -- | A set of named attributes associated with the item. This can be used for influencing the ranking of the item based on the context in the request. The maximum number of elements is 10.
    contextAttributes :: (Core.Maybe [ContextAttribute]),
    -- | The time when the item was created in the source repository.
    createTime :: (Core.Maybe Core.DateTime),
    -- | Hashing value provided by the API caller. This can be used with the items.push method to calculate modified state. The maximum length is 2048 characters.
    hash :: (Core.Maybe Core.Text),
    -- | A list of interactions for the item. Interactions are used to improve Search quality, but are not exposed to end users. The maximum number of elements is 1000.
    interactions :: (Core.Maybe [Interaction]),
    -- | Additional keywords or phrases that should match the item. Used internally for user generated content. The maximum number of elements is 100. The maximum length is 8192 characters.
    keywords :: (Core.Maybe [Core.Text]),
    -- | The original mime-type of ItemContent.content in the source repository. The maximum length is 256 characters.
    mimeType :: (Core.Maybe Core.Text),
    -- | The type of the item. This should correspond to the name of an object definition in the schema registered for the data source. For example, if the schema for the data source contains an object definition with name \'document\', then item indexing requests for objects of that type should set objectType to \'document\'. The maximum length is 256 characters.
    objectType :: (Core.Maybe Core.Text),
    -- | Additional search quality metadata of the item
    searchQualityMetadata :: (Core.Maybe SearchQualityMetadata),
    -- | Link to the source repository serving the data. Seach results apply this link to the title. Whitespace or special characters may cause Cloud Seach result links to trigger a redirect notice; to avoid this, encode the URL. The maximum length is 2048 characters.
    sourceRepositoryUrl :: (Core.Maybe Core.Text),
    -- | The title of the item. If given, this will be the displayed title of the Search result. The maximum length is 2048 characters.
    title :: (Core.Maybe Core.Text),
    -- | The time when the item was last modified in the source repository.
    updateTime :: (Core.Maybe Core.DateTime)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ItemMetadata' with the minimum fields required to make a request.
newItemMetadata ::
  ItemMetadata
newItemMetadata =
  ItemMetadata
    { containerName = Core.Nothing,
      contentLanguage = Core.Nothing,
      contextAttributes = Core.Nothing,
      createTime = Core.Nothing,
      hash = Core.Nothing,
      interactions = Core.Nothing,
      keywords = Core.Nothing,
      mimeType = Core.Nothing,
      objectType = Core.Nothing,
      searchQualityMetadata = Core.Nothing,
      sourceRepositoryUrl = Core.Nothing,
      title = Core.Nothing,
      updateTime = Core.Nothing
    }

instance Core.FromJSON ItemMetadata where
  parseJSON =
    Core.withObject
      "ItemMetadata"
      ( \o ->
          ItemMetadata
            Core.<$> (o Core..:? "containerName")
            Core.<*> (o Core..:? "contentLanguage")
            Core.<*> (o Core..:? "contextAttributes")
            Core.<*> (o Core..:? "createTime")
            Core.<*> (o Core..:? "hash")
            Core.<*> (o Core..:? "interactions")
            Core.<*> (o Core..:? "keywords")
            Core.<*> (o Core..:? "mimeType")
            Core.<*> (o Core..:? "objectType")
            Core.<*> (o Core..:? "searchQualityMetadata")
            Core.<*> (o Core..:? "sourceRepositoryUrl")
            Core.<*> (o Core..:? "title")
            Core.<*> (o Core..:? "updateTime")
      )

instance Core.ToJSON ItemMetadata where
  toJSON ItemMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("containerName" Core..=) Core.<$> containerName,
            ("contentLanguage" Core..=) Core.<$> contentLanguage,
            ("contextAttributes" Core..=)
              Core.<$> contextAttributes,
            ("createTime" Core..=) Core.<$> createTime,
            ("hash" Core..=) Core.<$> hash,
            ("interactions" Core..=) Core.<$> interactions,
            ("keywords" Core..=) Core.<$> keywords,
            ("mimeType" Core..=) Core.<$> mimeType,
            ("objectType" Core..=) Core.<$> objectType,
            ("searchQualityMetadata" Core..=)
              Core.<$> searchQualityMetadata,
            ("sourceRepositoryUrl" Core..=)
              Core.<$> sourceRepositoryUrl,
            ("title" Core..=) Core.<$> title,
            ("updateTime" Core..=) Core.<$> updateTime
          ]
      )

-- | Container for type-specific extensions of an Item. This protobuf is defined in a separate file to allow types to reference\/extend the message without depending on other fusebox protobufs. See items.proto.
--
-- /See:/ 'newItemParts' smart constructor.
data ItemParts = ItemParts
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ItemParts' with the minimum fields required to make a request.
newItemParts ::
  ItemParts
newItemParts = ItemParts

instance Core.FromJSON ItemParts where
  parseJSON =
    Core.withObject
      "ItemParts"
      (\o -> Core.pure ItemParts)

instance Core.ToJSON ItemParts where
  toJSON = Core.const Core.emptyObject

-- | This contains item\'s status and any errors.
--
-- /See:/ 'newItemStatus' smart constructor.
data ItemStatus = ItemStatus
  { -- | Status code.
    code :: (Core.Maybe ItemStatus_Code),
    -- | Error details in case the item is in ERROR state.
    processingErrors :: (Core.Maybe [ProcessingError]),
    -- | Repository error reported by connector.
    repositoryErrors :: (Core.Maybe [RepositoryError])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ItemStatus' with the minimum fields required to make a request.
newItemStatus ::
  ItemStatus
newItemStatus =
  ItemStatus
    { code = Core.Nothing,
      processingErrors = Core.Nothing,
      repositoryErrors = Core.Nothing
    }

instance Core.FromJSON ItemStatus where
  parseJSON =
    Core.withObject
      "ItemStatus"
      ( \o ->
          ItemStatus
            Core.<$> (o Core..:? "code")
            Core.<*> (o Core..:? "processingErrors")
            Core.<*> (o Core..:? "repositoryErrors")
      )

instance Core.ToJSON ItemStatus where
  toJSON ItemStatus {..} =
    Core.object
      ( Core.catMaybes
          [ ("code" Core..=) Core.<$> code,
            ("processingErrors" Core..=)
              Core.<$> processingErrors,
            ("repositoryErrors" Core..=)
              Core.<$> repositoryErrors
          ]
      )

-- | Available structured data fields for the item.
--
-- /See:/ 'newItemStructuredData' smart constructor.
data ItemStructuredData = ItemStructuredData
  { -- | Hashing value provided by the API caller. This can be used with the items.push method to calculate modified state. The maximum length is 2048 characters.
    hash :: (Core.Maybe Core.Text),
    -- | The structured data object that should conform to a registered object definition in the schema for the data source.
    object :: (Core.Maybe StructuredDataObject)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ItemStructuredData' with the minimum fields required to make a request.
newItemStructuredData ::
  ItemStructuredData
newItemStructuredData =
  ItemStructuredData {hash = Core.Nothing, object = Core.Nothing}

instance Core.FromJSON ItemStructuredData where
  parseJSON =
    Core.withObject
      "ItemStructuredData"
      ( \o ->
          ItemStructuredData
            Core.<$> (o Core..:? "hash") Core.<*> (o Core..:? "object")
      )

instance Core.ToJSON ItemStructuredData where
  toJSON ItemStructuredData {..} =
    Core.object
      ( Core.catMaybes
          [ ("hash" Core..=) Core.<$> hash,
            ("object" Core..=) Core.<$> object
          ]
      )

-- | An ItemThread is an ordered list of Items. An ItemThread corresponds to a \"conversation\" in the context of mail. An Item belongs to exactly one ItemThread.
--
-- /See:/ 'newItemThread' smart constructor.
data ItemThread = ItemThread
  { -- |
    clusterInfo :: (Core.Maybe ClusterInfo),
    -- | The Items in the ItemThread. In the context of a search, the list of Items may be a subset of those that logically belong to the ItemThread. The details of which items are included are available in the ItemThreadView returned in the overall rpc response.
    item :: (Core.Maybe [FuseboxItem]),
    -- | The server id of the last item returned in the ItemThread. This can be deduced from the [item] list but is provided for convenience. When manually constructing an ItemThreadViewSpec to perform operations on the ItemThread, this value can be used as the [high/item/id_watermark].
    lastItemId :: (Core.Maybe Core.Word64),
    -- |
    matchInfo :: (Core.Maybe FuseboxItemThreadMatchInfo),
    -- | A snippet summarizing the thread. This field is only populated for searches.
    snippet :: (Core.Maybe Core.Text),
    -- | The MultiKey that identifies this thread. This value never changes, i.e. remains constant across modifications to the thread, including addition, relabeling, or deletion of contained Items. As such, the thread key may not necessarily correspond to the key of an contained Item. Legacy note: The \"server_id\" of the thread key is equivalent to the notion of the \"original thread id\" in the CSS API.
    threadKey :: (Core.Maybe MultiKey),
    -- | A base64 encoded and encrypted string generated from the Gaia Id and the thread id. Used to generate the permalink for this thread, exposed from Gmail API.
    threadLocator :: (Core.Maybe Core.Text),
    -- | Next available id : 10
    topicState :: (Core.Maybe TopicState),
    -- | The latest history operation id that resulted in a mutation of any item in the thread.
    version :: (Core.Maybe Core.Word64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ItemThread' with the minimum fields required to make a request.
newItemThread ::
  ItemThread
newItemThread =
  ItemThread
    { clusterInfo = Core.Nothing,
      item = Core.Nothing,
      lastItemId = Core.Nothing,
      matchInfo = Core.Nothing,
      snippet = Core.Nothing,
      threadKey = Core.Nothing,
      threadLocator = Core.Nothing,
      topicState = Core.Nothing,
      version = Core.Nothing
    }

instance Core.FromJSON ItemThread where
  parseJSON =
    Core.withObject
      "ItemThread"
      ( \o ->
          ItemThread
            Core.<$> (o Core..:? "clusterInfo")
            Core.<*> (o Core..:? "item")
            Core.<*> ( o Core..:? "lastItemId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "matchInfo")
            Core.<*> (o Core..:? "snippet")
            Core.<*> (o Core..:? "threadKey")
            Core.<*> (o Core..:? "threadLocator")
            Core.<*> (o Core..:? "topicState")
            Core.<*> ( o Core..:? "version"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON ItemThread where
  toJSON ItemThread {..} =
    Core.object
      ( Core.catMaybes
          [ ("clusterInfo" Core..=) Core.<$> clusterInfo,
            ("item" Core..=) Core.<$> item,
            ("lastItemId" Core..=) Core.. Core.AsText
              Core.<$> lastItemId,
            ("matchInfo" Core..=) Core.<$> matchInfo,
            ("snippet" Core..=) Core.<$> snippet,
            ("threadKey" Core..=) Core.<$> threadKey,
            ("threadLocator" Core..=) Core.<$> threadLocator,
            ("topicState" Core..=) Core.<$> topicState,
            ("version" Core..=) Core.. Core.AsText
              Core.<$> version
          ]
      )

-- | Identifies a jobsetted server as a target for Trigger dispatch.
--
-- /See:/ 'newJobsettedServerSpec' smart constructor.
data JobsettedServerSpec = JobsettedServerSpec
  { -- | E.g. \"gateway\", \"stubby\" etc. Leave unset to use the default unnamed port.
    portName :: (Core.Maybe Core.Text),
    -- | E.g. \"satellite-server\", \"bigtop-sync\", etc.
    serverName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'JobsettedServerSpec' with the minimum fields required to make a request.
newJobsettedServerSpec ::
  JobsettedServerSpec
newJobsettedServerSpec =
  JobsettedServerSpec {portName = Core.Nothing, serverName = Core.Nothing}

instance Core.FromJSON JobsettedServerSpec where
  parseJSON =
    Core.withObject
      "JobsettedServerSpec"
      ( \o ->
          JobsettedServerSpec
            Core.<$> (o Core..:? "portName")
            Core.<*> (o Core..:? "serverName")
      )

instance Core.ToJSON JobsettedServerSpec where
  toJSON JobsettedServerSpec {..} =
    Core.object
      ( Core.catMaybes
          [ ("portName" Core..=) Core.<$> portName,
            ("serverName" Core..=) Core.<$> serverName
          ]
      )

--
-- /See:/ 'newKeyValue' smart constructor.
data KeyValue = KeyValue
  { -- | Formatted text supported.
    bottomLabel :: (Core.Maybe Core.Text),
    -- |
    button :: (Core.Maybe Button),
    -- | Formatted text supported and always required.
    content :: (Core.Maybe Core.Text),
    -- |
    contentMultiline :: (Core.Maybe Core.Bool),
    -- |
    endIcon :: (Core.Maybe IconImage),
    -- |
    icon :: (Core.Maybe KeyValue_Icon),
    -- | The alternative text of this icon_url which will be used for accessibility.
    iconAltText :: (Core.Maybe Core.Text),
    -- |
    iconUrl :: (Core.Maybe Core.Text),
    -- |
    imageStyle :: (Core.Maybe KeyValue_ImageStyle),
    -- | Only the top\/bottom label + content region is clickable.
    onClick :: (Core.Maybe OnClick),
    -- | The optional icon to display before the text content.
    startIcon :: (Core.Maybe IconImage),
    -- |
    switchWidget :: (Core.Maybe SwitchWidget),
    -- | Formatted text supported.
    topLabel :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'KeyValue' with the minimum fields required to make a request.
newKeyValue ::
  KeyValue
newKeyValue =
  KeyValue
    { bottomLabel = Core.Nothing,
      button = Core.Nothing,
      content = Core.Nothing,
      contentMultiline = Core.Nothing,
      endIcon = Core.Nothing,
      icon = Core.Nothing,
      iconAltText = Core.Nothing,
      iconUrl = Core.Nothing,
      imageStyle = Core.Nothing,
      onClick = Core.Nothing,
      startIcon = Core.Nothing,
      switchWidget = Core.Nothing,
      topLabel = Core.Nothing
    }

instance Core.FromJSON KeyValue where
  parseJSON =
    Core.withObject
      "KeyValue"
      ( \o ->
          KeyValue
            Core.<$> (o Core..:? "bottomLabel")
            Core.<*> (o Core..:? "button")
            Core.<*> (o Core..:? "content")
            Core.<*> (o Core..:? "contentMultiline")
            Core.<*> (o Core..:? "endIcon")
            Core.<*> (o Core..:? "icon")
            Core.<*> (o Core..:? "iconAltText")
            Core.<*> (o Core..:? "iconUrl")
            Core.<*> (o Core..:? "imageStyle")
            Core.<*> (o Core..:? "onClick")
            Core.<*> (o Core..:? "startIcon")
            Core.<*> (o Core..:? "switchWidget")
            Core.<*> (o Core..:? "topLabel")
      )

instance Core.ToJSON KeyValue where
  toJSON KeyValue {..} =
    Core.object
      ( Core.catMaybes
          [ ("bottomLabel" Core..=) Core.<$> bottomLabel,
            ("button" Core..=) Core.<$> button,
            ("content" Core..=) Core.<$> content,
            ("contentMultiline" Core..=)
              Core.<$> contentMultiline,
            ("endIcon" Core..=) Core.<$> endIcon,
            ("icon" Core..=) Core.<$> icon,
            ("iconAltText" Core..=) Core.<$> iconAltText,
            ("iconUrl" Core..=) Core.<$> iconUrl,
            ("imageStyle" Core..=) Core.<$> imageStyle,
            ("onClick" Core..=) Core.<$> onClick,
            ("startIcon" Core..=) Core.<$> startIcon,
            ("switchWidget" Core..=) Core.<$> switchWidget,
            ("topLabel" Core..=) Core.<$> topLabel
          ]
      )

-- | A label was added to some (subset of the) messages in this thread.
--
-- /See:/ 'newLabelAdded' smart constructor.
data LabelAdded = LabelAdded
  { -- |
    labelId :: (Core.Maybe Core.Text),
    -- |
    labelName :: (Core.Maybe Core.Text),
    -- |
    messageKeys :: (Core.Maybe [MultiKey]),
    -- |
    syncId :: (Core.Maybe Core.Word32)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'LabelAdded' with the minimum fields required to make a request.
newLabelAdded ::
  LabelAdded
newLabelAdded =
  LabelAdded
    { labelId = Core.Nothing,
      labelName = Core.Nothing,
      messageKeys = Core.Nothing,
      syncId = Core.Nothing
    }

instance Core.FromJSON LabelAdded where
  parseJSON =
    Core.withObject
      "LabelAdded"
      ( \o ->
          LabelAdded
            Core.<$> (o Core..:? "labelId")
            Core.<*> (o Core..:? "labelName")
            Core.<*> (o Core..:? "messageKeys")
            Core.<*> (o Core..:? "syncId")
      )

instance Core.ToJSON LabelAdded where
  toJSON LabelAdded {..} =
    Core.object
      ( Core.catMaybes
          [ ("labelId" Core..=) Core.<$> labelId,
            ("labelName" Core..=) Core.<$> labelName,
            ("messageKeys" Core..=) Core.<$> messageKeys,
            ("syncId" Core..=) Core.<$> syncId
          ]
      )

-- | A label was created.
--
-- /See:/ 'newLabelCreated' smart constructor.
data LabelCreated = LabelCreated
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'LabelCreated' with the minimum fields required to make a request.
newLabelCreated ::
  LabelCreated
newLabelCreated = LabelCreated

instance Core.FromJSON LabelCreated where
  parseJSON =
    Core.withObject
      "LabelCreated"
      (\o -> Core.pure LabelCreated)

instance Core.ToJSON LabelCreated where
  toJSON = Core.const Core.emptyObject

-- | A label was deleted.
--
-- /See:/ 'newLabelDeleted' smart constructor.
data LabelDeleted = LabelDeleted
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'LabelDeleted' with the minimum fields required to make a request.
newLabelDeleted ::
  LabelDeleted
newLabelDeleted = LabelDeleted

instance Core.FromJSON LabelDeleted where
  parseJSON =
    Core.withObject
      "LabelDeleted"
      (\o -> Core.pure LabelDeleted)

instance Core.ToJSON LabelDeleted where
  toJSON = Core.const Core.emptyObject

-- | A label was removed from some (subset of the) messages in this thread.
--
-- /See:/ 'newLabelRemoved' smart constructor.
data LabelRemoved = LabelRemoved
  { -- |
    labelId :: (Core.Maybe Core.Text),
    -- |
    labelName :: (Core.Maybe Core.Text),
    -- |
    messageKeys :: (Core.Maybe [MultiKey]),
    -- |
    syncId :: (Core.Maybe Core.Word32)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'LabelRemoved' with the minimum fields required to make a request.
newLabelRemoved ::
  LabelRemoved
newLabelRemoved =
  LabelRemoved
    { labelId = Core.Nothing,
      labelName = Core.Nothing,
      messageKeys = Core.Nothing,
      syncId = Core.Nothing
    }

instance Core.FromJSON LabelRemoved where
  parseJSON =
    Core.withObject
      "LabelRemoved"
      ( \o ->
          LabelRemoved
            Core.<$> (o Core..:? "labelId")
            Core.<*> (o Core..:? "labelName")
            Core.<*> (o Core..:? "messageKeys")
            Core.<*> (o Core..:? "syncId")
      )

instance Core.ToJSON LabelRemoved where
  toJSON LabelRemoved {..} =
    Core.object
      ( Core.catMaybes
          [ ("labelId" Core..=) Core.<$> labelId,
            ("labelName" Core..=) Core.<$> labelName,
            ("messageKeys" Core..=) Core.<$> messageKeys,
            ("syncId" Core..=) Core.<$> syncId
          ]
      )

-- | A label was renamed.
--
-- /See:/ 'newLabelRenamed' smart constructor.
newtype LabelRenamed = LabelRenamed
  { -- |
    oldCanonicalName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'LabelRenamed' with the minimum fields required to make a request.
newLabelRenamed ::
  LabelRenamed
newLabelRenamed = LabelRenamed {oldCanonicalName = Core.Nothing}

instance Core.FromJSON LabelRenamed where
  parseJSON =
    Core.withObject
      "LabelRenamed"
      ( \o ->
          LabelRenamed
            Core.<$> (o Core..:? "oldCanonicalName")
      )

instance Core.ToJSON LabelRenamed where
  toJSON LabelRenamed {..} =
    Core.object
      ( Core.catMaybes
          [ ("oldCanonicalName" Core..=)
              Core.<$> oldCanonicalName
          ]
      )

-- | HistoryRecord for changes associated with a label, namely: LABEL/CREATED LABEL/DELETED LABEL/RENAMED LABEL/UPDATED
--
-- /See:/ 'newLabelUpdate' smart constructor.
data LabelUpdate = LabelUpdate
  { -- |
    canonicalName :: (Core.Maybe Core.Text),
    -- |
    labelCreated :: (Core.Maybe LabelCreated),
    -- |
    labelDeleted :: (Core.Maybe LabelDeleted),
    -- |
    labelId :: (Core.Maybe Core.Text),
    -- |
    labelRenamed :: (Core.Maybe LabelRenamed),
    -- |
    labelUpdated :: (Core.Maybe LabelUpdated),
    -- |
    syncId :: (Core.Maybe Core.Word32)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'LabelUpdate' with the minimum fields required to make a request.
newLabelUpdate ::
  LabelUpdate
newLabelUpdate =
  LabelUpdate
    { canonicalName = Core.Nothing,
      labelCreated = Core.Nothing,
      labelDeleted = Core.Nothing,
      labelId = Core.Nothing,
      labelRenamed = Core.Nothing,
      labelUpdated = Core.Nothing,
      syncId = Core.Nothing
    }

instance Core.FromJSON LabelUpdate where
  parseJSON =
    Core.withObject
      "LabelUpdate"
      ( \o ->
          LabelUpdate
            Core.<$> (o Core..:? "canonicalName")
            Core.<*> (o Core..:? "labelCreated")
            Core.<*> (o Core..:? "labelDeleted")
            Core.<*> (o Core..:? "labelId")
            Core.<*> (o Core..:? "labelRenamed")
            Core.<*> (o Core..:? "labelUpdated")
            Core.<*> (o Core..:? "syncId")
      )

instance Core.ToJSON LabelUpdate where
  toJSON LabelUpdate {..} =
    Core.object
      ( Core.catMaybes
          [ ("canonicalName" Core..=) Core.<$> canonicalName,
            ("labelCreated" Core..=) Core.<$> labelCreated,
            ("labelDeleted" Core..=) Core.<$> labelDeleted,
            ("labelId" Core..=) Core.<$> labelId,
            ("labelRenamed" Core..=) Core.<$> labelRenamed,
            ("labelUpdated" Core..=) Core.<$> labelUpdated,
            ("syncId" Core..=) Core.<$> syncId
          ]
      )

-- | A label pref was updated outside of a rename, create, or delete.
--
-- /See:/ 'newLabelUpdated' smart constructor.
data LabelUpdated = LabelUpdated
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'LabelUpdated' with the minimum fields required to make a request.
newLabelUpdated ::
  LabelUpdated
newLabelUpdated = LabelUpdated

instance Core.FromJSON LabelUpdated where
  parseJSON =
    Core.withObject
      "LabelUpdated"
      (\o -> Core.pure LabelUpdated)

instance Core.ToJSON LabelUpdated where
  toJSON = Core.const Core.emptyObject

--
-- /See:/ 'newLabels' smart constructor.
data Labels = Labels
  { -- | The display name of the labels. This is populated (instead of the id) when the request fetch/spec has LABEL/DISPLAY_NAMES.
    displayName :: (Core.Maybe [Core.Text]),
    -- | The ids of the labels attached to the Item, e.g. \"^i\", \"^x_1\"
    id :: (Core.Maybe [Core.Text])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Labels' with the minimum fields required to make a request.
newLabels ::
  Labels
newLabels = Labels {displayName = Core.Nothing, id = Core.Nothing}

instance Core.FromJSON Labels where
  parseJSON =
    Core.withObject
      "Labels"
      ( \o ->
          Labels
            Core.<$> (o Core..:? "displayName")
            Core.<*> (o Core..:? "id")
      )

instance Core.ToJSON Labels where
  toJSON Labels {..} =
    Core.object
      ( Core.catMaybes
          [ ("displayName" Core..=) Core.<$> displayName,
            ("id" Core..=) Core.<$> id
          ]
      )

-- | The language configuration for the session.
--
-- /See:/ 'newLanguageConfig' smart constructor.
newtype LanguageConfig = LanguageConfig
  { -- | The spoken language(s) in BCP47 language code.
    spokenLanguages :: (Core.Maybe [Core.Text])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'LanguageConfig' with the minimum fields required to make a request.
newLanguageConfig ::
  LanguageConfig
newLanguageConfig = LanguageConfig {spokenLanguages = Core.Nothing}

instance Core.FromJSON LanguageConfig where
  parseJSON =
    Core.withObject
      "LanguageConfig"
      ( \o ->
          LanguageConfig
            Core.<$> (o Core..:? "spokenLanguages")
      )

instance Core.ToJSON LanguageConfig where
  toJSON LanguageConfig {..} =
    Core.object
      ( Core.catMaybes
          [ ("spokenLanguages" Core..=)
              Core.<$> spokenLanguages
          ]
      )

--
-- /See:/ 'newLdapGroupProto' smart constructor.
newtype LdapGroupProto = LdapGroupProto
  { -- |
    groupName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'LdapGroupProto' with the minimum fields required to make a request.
newLdapGroupProto ::
  LdapGroupProto
newLdapGroupProto = LdapGroupProto {groupName = Core.Nothing}

instance Core.FromJSON LdapGroupProto where
  parseJSON =
    Core.withObject
      "LdapGroupProto"
      ( \o ->
          LdapGroupProto Core.<$> (o Core..:? "groupName")
      )

instance Core.ToJSON LdapGroupProto where
  toJSON LdapGroupProto {..} =
    Core.object
      ( Core.catMaybes
          [("groupName" Core..=) Core.<$> groupName]
      )

--
-- /See:/ 'newLdapUserProto' smart constructor.
newtype LdapUserProto = LdapUserProto
  { -- |
    userName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'LdapUserProto' with the minimum fields required to make a request.
newLdapUserProto ::
  LdapUserProto
newLdapUserProto = LdapUserProto {userName = Core.Nothing}

instance Core.FromJSON LdapUserProto where
  parseJSON =
    Core.withObject
      "LdapUserProto"
      ( \o ->
          LdapUserProto Core.<$> (o Core..:? "userName")
      )

instance Core.ToJSON LdapUserProto where
  toJSON LdapUserProto {..} =
    Core.object
      ( Core.catMaybes
          [("userName" Core..=) Core.<$> userName]
      )

-- | The original UploadMetadata that this DriveMetadata was converted from.
--
-- /See:/ 'newLegacyUploadMetadata' smart constructor.
data LegacyUploadMetadata = LegacyUploadMetadata
  { -- | A unique ID generated from legacy UploadMetadata. This is used for interopping URLs after uploading blob to shared drive. Links in Classic might break without this. go\/drive-file-attachment-interop-from-dynamite.
    legacyUniqueId :: (Core.Maybe Core.Text),
    -- | The blob in this UploadMetadata has been uploaded to shared drive. This UploadMetadata is no longer attached to a message. go\/shared-drive-data-migration.
    uploadMetadata :: (Core.Maybe UploadMetadata)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'LegacyUploadMetadata' with the minimum fields required to make a request.
newLegacyUploadMetadata ::
  LegacyUploadMetadata
newLegacyUploadMetadata =
  LegacyUploadMetadata
    { legacyUniqueId = Core.Nothing,
      uploadMetadata = Core.Nothing
    }

instance Core.FromJSON LegacyUploadMetadata where
  parseJSON =
    Core.withObject
      "LegacyUploadMetadata"
      ( \o ->
          LegacyUploadMetadata
            Core.<$> (o Core..:? "legacyUniqueId")
            Core.<*> (o Core..:? "uploadMetadata")
      )

instance Core.ToJSON LegacyUploadMetadata where
  toJSON LegacyUploadMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("legacyUniqueId" Core..=) Core.<$> legacyUniqueId,
            ("uploadMetadata" Core..=) Core.<$> uploadMetadata
          ]
      )

-- | Link metadata, for LINK segments. Anchor text should be stored in the \"text\" field of the Segment, which can also serve as a fallback.
--
-- /See:/ 'newLinkData' smart constructor.
data LinkData = LinkData
  { -- | An Attachment represents the structured entity to which we are linking. It contains an Embed (apps\/tacotown\/proto\/embeds\/embed/client.proto) with fields specific to the appropriate type of linked entity. For example, if we are linking to a photo album, the Embed may include the album ID and gaia ID of the creator. Clients that understand the Embed type within the Attachment may construct and\/or decorate their link appropriately e.g. to make use of type-specific functionality or first-party integrations. The link/target and (if appropriate) display/url fields must still be set even when an Attachment is present, so that clients who do not know how to interpret the Attachment can fall back to those fields, and render the Segment as an ordinary web link. N.B. Even when an Attachment is present, the intention of a \"LINK\" Segment is for the Segment to be presented inline with the rest of the text of a post or comment, with a clickable link or other UI suitable for inlining (though the client may modify the
    -- UI based on Attachment data, e.g. to add appropriate hovers, icons, etc.). When an entity is intended to be rendered separately from the main body of the post\/comment, a separate Attachment proto can be added outside the set of Segments. N.B. Within the Attachment, fields of EmbedClientItem have their own visibility annotations, which should be enforced separately from Segment visibility annotations. See: apps\/tacotown\/proto\/embeds\/embed/annotations.proto
    attachment :: (Core.Maybe SocialCommonAttachmentAttachment),
    -- | The hint to use when rendering the associated attachment. Ignored if there is no associated attachment.
    attachmentRenderHint :: (Core.Maybe LinkData_AttachmentRenderHint),
    -- | If we wish to show the user a different (e.g. shortened) version of the URL for display purposes, then that version should be set here. If this field isn\'t set, link_target will be used for both purposes.
    displayUrl :: (Core.Maybe Core.Text),
    -- | link_target is the URL to navigate to when clicked. This could be the original URL, or a URL signed by the GWS URL signing service.
    linkTarget :: (Core.Maybe Core.Text),
    -- | LinkType is an optional field that provides additional information regarding link target. For example, link type can be identified as the SELF_LINK when the request was executed from the same link as the link target.
    linkType :: (Core.Maybe LinkData_LinkType),
    -- | Title is an optional field that provides a short string that describes the link or its destination. User interfaces often use title as a tooltip or for accessibility purposes. However, they are of course free to present this data in any form. This field is plain text.
    title :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'LinkData' with the minimum fields required to make a request.
newLinkData ::
  LinkData
newLinkData =
  LinkData
    { attachment = Core.Nothing,
      attachmentRenderHint = Core.Nothing,
      displayUrl = Core.Nothing,
      linkTarget = Core.Nothing,
      linkType = Core.Nothing,
      title = Core.Nothing
    }

instance Core.FromJSON LinkData where
  parseJSON =
    Core.withObject
      "LinkData"
      ( \o ->
          LinkData
            Core.<$> (o Core..:? "attachment")
            Core.<*> (o Core..:? "attachmentRenderHint")
            Core.<*> (o Core..:? "displayUrl")
            Core.<*> (o Core..:? "linkTarget")
            Core.<*> (o Core..:? "linkType")
            Core.<*> (o Core..:? "title")
      )

instance Core.ToJSON LinkData where
  toJSON LinkData {..} =
    Core.object
      ( Core.catMaybes
          [ ("attachment" Core..=) Core.<$> attachment,
            ("attachmentRenderHint" Core..=)
              Core.<$> attachmentRenderHint,
            ("displayUrl" Core..=) Core.<$> displayUrl,
            ("linkTarget" Core..=) Core.<$> linkTarget,
            ("linkType" Core..=) Core.<$> linkType,
            ("title" Core..=) Core.<$> title
          ]
      )

--
-- /See:/ 'newListDataSourceResponse' smart constructor.
data ListDataSourceResponse = ListDataSourceResponse
  { -- | Token to retrieve the next page of results, or empty if there are no more results in the list.
    nextPageToken :: (Core.Maybe Core.Text),
    -- |
    sources :: (Core.Maybe [DataSource])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ListDataSourceResponse' with the minimum fields required to make a request.
newListDataSourceResponse ::
  ListDataSourceResponse
newListDataSourceResponse =
  ListDataSourceResponse {nextPageToken = Core.Nothing, sources = Core.Nothing}

instance Core.FromJSON ListDataSourceResponse where
  parseJSON =
    Core.withObject
      "ListDataSourceResponse"
      ( \o ->
          ListDataSourceResponse
            Core.<$> (o Core..:? "nextPageToken")
            Core.<*> (o Core..:? "sources")
      )

instance Core.ToJSON ListDataSourceResponse where
  toJSON ListDataSourceResponse {..} =
    Core.object
      ( Core.catMaybes
          [ ("nextPageToken" Core..=) Core.<$> nextPageToken,
            ("sources" Core..=) Core.<$> sources
          ]
      )

--
-- /See:/ 'newListItemNamesForUnmappedIdentityResponse' smart constructor.
data ListItemNamesForUnmappedIdentityResponse = ListItemNamesForUnmappedIdentityResponse
  { -- |
    itemNames :: (Core.Maybe [Core.Text]),
    -- | Token to retrieve the next page of results, or empty if there are no more results in the list.
    nextPageToken :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ListItemNamesForUnmappedIdentityResponse' with the minimum fields required to make a request.
newListItemNamesForUnmappedIdentityResponse ::
  ListItemNamesForUnmappedIdentityResponse
newListItemNamesForUnmappedIdentityResponse =
  ListItemNamesForUnmappedIdentityResponse
    { itemNames = Core.Nothing,
      nextPageToken = Core.Nothing
    }

instance
  Core.FromJSON
    ListItemNamesForUnmappedIdentityResponse
  where
  parseJSON =
    Core.withObject
      "ListItemNamesForUnmappedIdentityResponse"
      ( \o ->
          ListItemNamesForUnmappedIdentityResponse
            Core.<$> (o Core..:? "itemNames")
            Core.<*> (o Core..:? "nextPageToken")
      )

instance
  Core.ToJSON
    ListItemNamesForUnmappedIdentityResponse
  where
  toJSON ListItemNamesForUnmappedIdentityResponse {..} =
    Core.object
      ( Core.catMaybes
          [ ("itemNames" Core..=) Core.<$> itemNames,
            ("nextPageToken" Core..=) Core.<$> nextPageToken
          ]
      )

--
-- /See:/ 'newListItemsResponse' smart constructor.
data ListItemsResponse = ListItemsResponse
  { -- |
    items :: (Core.Maybe [Item]),
    -- | Token to retrieve the next page of results, or empty if there are no more results in the list.
    nextPageToken :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ListItemsResponse' with the minimum fields required to make a request.
newListItemsResponse ::
  ListItemsResponse
newListItemsResponse =
  ListItemsResponse {items = Core.Nothing, nextPageToken = Core.Nothing}

instance Core.FromJSON ListItemsResponse where
  parseJSON =
    Core.withObject
      "ListItemsResponse"
      ( \o ->
          ListItemsResponse
            Core.<$> (o Core..:? "items")
            Core.<*> (o Core..:? "nextPageToken")
      )

instance Core.ToJSON ListItemsResponse where
  toJSON ListItemsResponse {..} =
    Core.object
      ( Core.catMaybes
          [ ("items" Core..=) Core.<$> items,
            ("nextPageToken" Core..=) Core.<$> nextPageToken
          ]
      )

-- | The response message for Operations.ListOperations.
--
-- /See:/ 'newListOperationsResponse' smart constructor.
data ListOperationsResponse = ListOperationsResponse
  { -- | The standard List next-page token.
    nextPageToken :: (Core.Maybe Core.Text),
    -- | A list of operations that matches the specified filter in the request.
    operations :: (Core.Maybe [Operation])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ListOperationsResponse' with the minimum fields required to make a request.
newListOperationsResponse ::
  ListOperationsResponse
newListOperationsResponse =
  ListOperationsResponse
    { nextPageToken = Core.Nothing,
      operations = Core.Nothing
    }

instance Core.FromJSON ListOperationsResponse where
  parseJSON =
    Core.withObject
      "ListOperationsResponse"
      ( \o ->
          ListOperationsResponse
            Core.<$> (o Core..:? "nextPageToken")
            Core.<*> (o Core..:? "operations")
      )

instance Core.ToJSON ListOperationsResponse where
  toJSON ListOperationsResponse {..} =
    Core.object
      ( Core.catMaybes
          [ ("nextPageToken" Core..=) Core.<$> nextPageToken,
            ("operations" Core..=) Core.<$> operations
          ]
      )

-- | List sources response.
--
-- /See:/ 'newListQuerySourcesResponse' smart constructor.
data ListQuerySourcesResponse = ListQuerySourcesResponse
  { -- |
    nextPageToken :: (Core.Maybe Core.Text),
    -- |
    sources :: (Core.Maybe [QuerySource])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ListQuerySourcesResponse' with the minimum fields required to make a request.
newListQuerySourcesResponse ::
  ListQuerySourcesResponse
newListQuerySourcesResponse =
  ListQuerySourcesResponse
    { nextPageToken = Core.Nothing,
      sources = Core.Nothing
    }

instance Core.FromJSON ListQuerySourcesResponse where
  parseJSON =
    Core.withObject
      "ListQuerySourcesResponse"
      ( \o ->
          ListQuerySourcesResponse
            Core.<$> (o Core..:? "nextPageToken")
            Core.<*> (o Core..:? "sources")
      )

instance Core.ToJSON ListQuerySourcesResponse where
  toJSON ListQuerySourcesResponse {..} =
    Core.object
      ( Core.catMaybes
          [ ("nextPageToken" Core..=) Core.<$> nextPageToken,
            ("sources" Core..=) Core.<$> sources
          ]
      )

--
-- /See:/ 'newListSearchApplicationsResponse' smart constructor.
data ListSearchApplicationsResponse = ListSearchApplicationsResponse
  { -- | Token to retrieve the next page of results, or empty if there are no more results in the list.
    nextPageToken :: (Core.Maybe Core.Text),
    -- |
    searchApplications :: (Core.Maybe [SearchApplication])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ListSearchApplicationsResponse' with the minimum fields required to make a request.
newListSearchApplicationsResponse ::
  ListSearchApplicationsResponse
newListSearchApplicationsResponse =
  ListSearchApplicationsResponse
    { nextPageToken = Core.Nothing,
      searchApplications = Core.Nothing
    }

instance Core.FromJSON ListSearchApplicationsResponse where
  parseJSON =
    Core.withObject
      "ListSearchApplicationsResponse"
      ( \o ->
          ListSearchApplicationsResponse
            Core.<$> (o Core..:? "nextPageToken")
            Core.<*> (o Core..:? "searchApplications")
      )

instance Core.ToJSON ListSearchApplicationsResponse where
  toJSON ListSearchApplicationsResponse {..} =
    Core.object
      ( Core.catMaybes
          [ ("nextPageToken" Core..=) Core.<$> nextPageToken,
            ("searchApplications" Core..=)
              Core.<$> searchApplications
          ]
      )

--
-- /See:/ 'newListUnmappedIdentitiesResponse' smart constructor.
data ListUnmappedIdentitiesResponse = ListUnmappedIdentitiesResponse
  { -- | Token to retrieve the next page of results, or empty if there are no more results in the list.
    nextPageToken :: (Core.Maybe Core.Text),
    -- |
    unmappedIdentities :: (Core.Maybe [UnmappedIdentity])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ListUnmappedIdentitiesResponse' with the minimum fields required to make a request.
newListUnmappedIdentitiesResponse ::
  ListUnmappedIdentitiesResponse
newListUnmappedIdentitiesResponse =
  ListUnmappedIdentitiesResponse
    { nextPageToken = Core.Nothing,
      unmappedIdentities = Core.Nothing
    }

instance Core.FromJSON ListUnmappedIdentitiesResponse where
  parseJSON =
    Core.withObject
      "ListUnmappedIdentitiesResponse"
      ( \o ->
          ListUnmappedIdentitiesResponse
            Core.<$> (o Core..:? "nextPageToken")
            Core.<*> (o Core..:? "unmappedIdentities")
      )

instance Core.ToJSON ListUnmappedIdentitiesResponse where
  toJSON ListUnmappedIdentitiesResponse {..} =
    Core.object
      ( Core.catMaybes
          [ ("nextPageToken" Core..=) Core.<$> nextPageToken,
            ("unmappedIdentities" Core..=)
              Core.<$> unmappedIdentities
          ]
      )

--
-- /See:/ 'newMatchInfo' smart constructor.
newtype MatchInfo = MatchInfo
  { -- | Reference keys for image attachments that matches search query.
    matchingImageReferenceKey :: (Core.Maybe [Core.Text])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'MatchInfo' with the minimum fields required to make a request.
newMatchInfo ::
  MatchInfo
newMatchInfo = MatchInfo {matchingImageReferenceKey = Core.Nothing}

instance Core.FromJSON MatchInfo where
  parseJSON =
    Core.withObject
      "MatchInfo"
      ( \o ->
          MatchInfo
            Core.<$> (o Core..:? "matchingImageReferenceKey")
      )

instance Core.ToJSON MatchInfo where
  toJSON MatchInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("matchingImageReferenceKey" Core..=)
              Core.<$> matchingImageReferenceKey
          ]
      )

-- | Matched range of a snippet [start, end).
--
-- /See:/ 'newMatchRange' smart constructor.
data MatchRange = MatchRange
  { -- | End of the match in the snippet.
    end :: (Core.Maybe Core.Int32),
    -- | Starting position of the match in the snippet.
    start :: (Core.Maybe Core.Int32)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'MatchRange' with the minimum fields required to make a request.
newMatchRange ::
  MatchRange
newMatchRange = MatchRange {end = Core.Nothing, start = Core.Nothing}

instance Core.FromJSON MatchRange where
  parseJSON =
    Core.withObject
      "MatchRange"
      ( \o ->
          MatchRange
            Core.<$> (o Core..:? "end") Core.<*> (o Core..:? "start")
      )

instance Core.ToJSON MatchRange where
  toJSON MatchRange {..} =
    Core.object
      ( Core.catMaybes
          [ ("end" Core..=) Core.<$> end,
            ("start" Core..=) Core.<$> start
          ]
      )

-- | An entity from the MDB namespace that is to be interpreted as a group. If using this for authorization, you should do an exact match of the peer role against group/name or any of the names in the Chubby expansion of the MDB group named group/name.
--
-- /See:/ 'newMdbGroupProto' smart constructor.
newtype MdbGroupProto = MdbGroupProto
  { -- |
    groupName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'MdbGroupProto' with the minimum fields required to make a request.
newMdbGroupProto ::
  MdbGroupProto
newMdbGroupProto = MdbGroupProto {groupName = Core.Nothing}

instance Core.FromJSON MdbGroupProto where
  parseJSON =
    Core.withObject
      "MdbGroupProto"
      ( \o ->
          MdbGroupProto Core.<$> (o Core..:? "groupName")
      )

instance Core.ToJSON MdbGroupProto where
  toJSON MdbGroupProto {..} =
    Core.object
      ( Core.catMaybes
          [("groupName" Core..=) Core.<$> groupName]
      )

-- | An entity from the MDB namespace that is to be interpreted as a user. If using this for authorization, you should only do an exact match on the peer role against user_name.
--
-- /See:/ 'newMdbUserProto' smart constructor.
data MdbUserProto = MdbUserProto
  { -- | Do not set this field. Contact credentials-eng\@ if you believe you absolutely need to use it. This is the \@prod.google.com Gaia ID that corresponds to the MDB user, see go\/authn-merge for details. This field may always be safely ignored when performing an authorization check.
    gaiaId :: (Core.Maybe Core.Int64),
    -- |
    userName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'MdbUserProto' with the minimum fields required to make a request.
newMdbUserProto ::
  MdbUserProto
newMdbUserProto = MdbUserProto {gaiaId = Core.Nothing, userName = Core.Nothing}

instance Core.FromJSON MdbUserProto where
  parseJSON =
    Core.withObject
      "MdbUserProto"
      ( \o ->
          MdbUserProto
            Core.<$> ( o Core..:? "gaiaId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "userName")
      )

instance Core.ToJSON MdbUserProto where
  toJSON MdbUserProto {..} =
    Core.object
      ( Core.catMaybes
          [ ("gaiaId" Core..=) Core.. Core.AsText
              Core.<$> gaiaId,
            ("userName" Core..=) Core.<$> userName
          ]
      )

-- | Media resource.
--
-- /See:/ 'newMedia' smart constructor.
newtype Media = Media
  { -- | Name of the media resource.
    resourceName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Media' with the minimum fields required to make a request.
newMedia ::
  Media
newMedia = Media {resourceName = Core.Nothing}

instance Core.FromJSON Media where
  parseJSON =
    Core.withObject
      "Media"
      (\o -> Media Core.<$> (o Core..:? "resourceName"))

instance Core.ToJSON Media where
  toJSON Media {..} =
    Core.object
      ( Core.catMaybes
          [("resourceName" Core..=) Core.<$> resourceName]
      )

-- | A meeting space is a persistent object that is the context for one or more calls. The meeting space is what makes users find each other when they want to meet and to find shared resources. With two exceptions, all the fields in the meeting space resource are visible publicly to any client, even anonymous users. The exceptions are that * The call/info field is only visible to clients that have a device (as indicated by the meeting token) in the JOINED or HIDDEN state. * The meeting/alias field will only be set for users who are in the same domain as the meeting space. The meeting space resource (outside call_info) should only contain information necessary to join a call in the meeting space, and not any other metadata about the meeting space, such as what organization it belongs to or things related to ongoing calls.
--
-- /See:/ 'newMeetingSpace' smart constructor.
data MeetingSpace = MeetingSpace
  { -- | Which number classes are accepted by this meeting at the moment? When there is no ongoing conference, this field may change independent of the version number of the MeetingSpace. When a conference starts, this field will be locked to the value at that time, and then will be unlocked again at the end of the conference.
    acceptedNumberClass :: (Core.Maybe [MeetingSpace_AcceptedNumberClassItem]),
    -- | Broadcast access information for this meeting space.
    broadcastAccess :: (Core.Maybe BroadcastAccess),
    -- | Information relevant to an ongoing conference. This field will be set in responses if the client requesting the meeting space has a device in one of the JOINED, HIDDEN, or MISSING_PREREQUISITES states. The field will also be set without a created device if the client requesting the meeting space is eligible to directly create a device in the JOINED state without knocking, eg a same-domain joiner. Can also only be updated by clients with a device in the JOINED state.
    callInfo :: (Core.Maybe CallInfo),
    -- | The interop gateway access information for the meeting space. A gateway access can be used when joining conferences from non-Google equipment through an interop gateway.
    gatewayAccess :: (Core.Maybe GatewayAccess),
    -- | The SIP based access methods that can be used to join the conference.
    gatewaySipAccess :: (Core.Maybe [GatewaySipAccess]),
    -- | An optional alias for the meeting space. The alias can in some cases be resolved to the meeting space, similar to the meeting code. The limitation is that the user needs to be in the same meeting domain as the meeting space.
    meetingAlias :: (Core.Maybe Core.Text),
    -- | A meeting code is a globally unique code which points to a meeting space. Note: Meeting codes may be regenerated, which will cause old meeting codes to become invalid.
    meetingCode :: (Core.Maybe Core.Text),
    -- | A unique server-generated ID for the meeting space. This is the resource name of the meeting space resource and has the form @spaces\/@, where is a sequence of characters in the <https://tools.ietf.org/html/rfc4648#section-5 base64url set>, without any @=@ characters.
    meetingSpaceId :: (Core.Maybe Core.Text),
    -- | A URL to identify and access the meeting space. Output only.
    meetingUrl :: (Core.Maybe Core.Text),
    -- | Output only. A URL that clients (e.g. Calendar) can use to show the web page with all join methods available for this meeting space. This link is also used in iOS universal links and Android intents, used for opening the \"More ways to join\" view in the Meet mobile apps. Example: https:\/\/tel.meet\/mee-ting-cod?pin=1234567891011 Here, \"pin\" is the universal phone PIN. We include it explicitly to better support the offline case on the mobile. This is set when the meeting space has either a universal PIN or an interop PIN and clients who can show a \"more ways to join\" button should show it whenever this field is set.
    moreJoinUrl :: (Core.Maybe Core.Text),
    -- | All regional phone access methods for this meeting space. Can be empty.
    phoneAccess :: (Core.Maybe [PhoneAccess]),
    -- | Settings of the meeting space.
    settings :: (Core.Maybe Settings),
    -- | A universal phone access method for this meeting space. Can be unset.
    universalPhoneAccess :: (Core.Maybe UniversalPhoneAccess)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'MeetingSpace' with the minimum fields required to make a request.
newMeetingSpace ::
  MeetingSpace
newMeetingSpace =
  MeetingSpace
    { acceptedNumberClass = Core.Nothing,
      broadcastAccess = Core.Nothing,
      callInfo = Core.Nothing,
      gatewayAccess = Core.Nothing,
      gatewaySipAccess = Core.Nothing,
      meetingAlias = Core.Nothing,
      meetingCode = Core.Nothing,
      meetingSpaceId = Core.Nothing,
      meetingUrl = Core.Nothing,
      moreJoinUrl = Core.Nothing,
      phoneAccess = Core.Nothing,
      settings = Core.Nothing,
      universalPhoneAccess = Core.Nothing
    }

instance Core.FromJSON MeetingSpace where
  parseJSON =
    Core.withObject
      "MeetingSpace"
      ( \o ->
          MeetingSpace
            Core.<$> (o Core..:? "acceptedNumberClass")
            Core.<*> (o Core..:? "broadcastAccess")
            Core.<*> (o Core..:? "callInfo")
            Core.<*> (o Core..:? "gatewayAccess")
            Core.<*> (o Core..:? "gatewaySipAccess")
            Core.<*> (o Core..:? "meetingAlias")
            Core.<*> (o Core..:? "meetingCode")
            Core.<*> (o Core..:? "meetingSpaceId")
            Core.<*> (o Core..:? "meetingUrl")
            Core.<*> (o Core..:? "moreJoinUrl")
            Core.<*> (o Core..:? "phoneAccess")
            Core.<*> (o Core..:? "settings")
            Core.<*> (o Core..:? "universalPhoneAccess")
      )

instance Core.ToJSON MeetingSpace where
  toJSON MeetingSpace {..} =
    Core.object
      ( Core.catMaybes
          [ ("acceptedNumberClass" Core..=)
              Core.<$> acceptedNumberClass,
            ("broadcastAccess" Core..=) Core.<$> broadcastAccess,
            ("callInfo" Core..=) Core.<$> callInfo,
            ("gatewayAccess" Core..=) Core.<$> gatewayAccess,
            ("gatewaySipAccess" Core..=)
              Core.<$> gatewaySipAccess,
            ("meetingAlias" Core..=) Core.<$> meetingAlias,
            ("meetingCode" Core..=) Core.<$> meetingCode,
            ("meetingSpaceId" Core..=) Core.<$> meetingSpaceId,
            ("meetingUrl" Core..=) Core.<$> meetingUrl,
            ("moreJoinUrl" Core..=) Core.<$> moreJoinUrl,
            ("phoneAccess" Core..=) Core.<$> phoneAccess,
            ("settings" Core..=) Core.<$> settings,
            ("universalPhoneAccess" Core..=)
              Core.<$> universalPhoneAccess
          ]
      )

--
-- /See:/ 'newMember' smart constructor.
data Member = Member
  { -- |
    roster :: (Core.Maybe Roster),
    -- |
    user :: (Core.Maybe User)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Member' with the minimum fields required to make a request.
newMember ::
  Member
newMember = Member {roster = Core.Nothing, user = Core.Nothing}

instance Core.FromJSON Member where
  parseJSON =
    Core.withObject
      "Member"
      ( \o ->
          Member
            Core.<$> (o Core..:? "roster") Core.<*> (o Core..:? "user")
      )

instance Core.ToJSON Member where
  toJSON Member {..} =
    Core.object
      ( Core.catMaybes
          [ ("roster" Core..=) Core.<$> roster,
            ("user" Core..=) Core.<$> user
          ]
      )

-- | Eventually this can be updated to a oneOf User, Space (for nested spaces), Bots or Service, as and when these use cases come up.
--
-- /See:/ 'newMemberId' smart constructor.
data MemberId = MemberId
  { -- | Unique, immutable ID of the Roster.
    rosterId :: (Core.Maybe RosterId),
    -- | Unique, immutable ID of the User.
    userId :: (Core.Maybe UserId)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'MemberId' with the minimum fields required to make a request.
newMemberId ::
  MemberId
newMemberId = MemberId {rosterId = Core.Nothing, userId = Core.Nothing}

instance Core.FromJSON MemberId where
  parseJSON =
    Core.withObject
      "MemberId"
      ( \o ->
          MemberId
            Core.<$> (o Core..:? "rosterId")
            Core.<*> (o Core..:? "userId")
      )

instance Core.ToJSON MemberId where
  toJSON MemberId {..} =
    Core.object
      ( Core.catMaybes
          [ ("rosterId" Core..=) Core.<$> rosterId,
            ("userId" Core..=) Core.<$> userId
          ]
      )

--
-- /See:/ 'newMembershipChangeEvent' smart constructor.
data MembershipChangeEvent = MembershipChangeEvent
  { -- | This should only be set when MembershipChange type is LEAVE.
    leaveReason :: (Core.Maybe MembershipChangeEvent_LeaveReason),
    -- |
    participantId :: (Core.Maybe [StoredParticipantId]),
    -- |
    type' :: (Core.Maybe MembershipChangeEvent_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'MembershipChangeEvent' with the minimum fields required to make a request.
newMembershipChangeEvent ::
  MembershipChangeEvent
newMembershipChangeEvent =
  MembershipChangeEvent
    { leaveReason = Core.Nothing,
      participantId = Core.Nothing,
      type' = Core.Nothing
    }

instance Core.FromJSON MembershipChangeEvent where
  parseJSON =
    Core.withObject
      "MembershipChangeEvent"
      ( \o ->
          MembershipChangeEvent
            Core.<$> (o Core..:? "leaveReason")
            Core.<*> (o Core..:? "participantId")
            Core.<*> (o Core..:? "type")
      )

instance Core.ToJSON MembershipChangeEvent where
  toJSON MembershipChangeEvent {..} =
    Core.object
      ( Core.catMaybes
          [ ("leaveReason" Core..=) Core.<$> leaveReason,
            ("participantId" Core..=) Core.<$> participantId,
            ("type" Core..=) Core.<$> type'
          ]
      )

-- | Annotation metadata to display system messages for membership changes. Next Tag: 8
--
-- /See:/ 'newMembershipChangedMetadata' smart constructor.
data MembershipChangedMetadata = MembershipChangedMetadata
  { -- |
    affectedMemberProfiles :: (Core.Maybe [Member]),
    -- | List of users and rosters whose membership status changed.
    affectedMembers :: (Core.Maybe [MemberId]),
    -- |
    affectedMemberships :: (Core.Maybe [AffectedMembership]),
    -- | The user whose action triggered this system message.
    initiator :: (Core.Maybe UserId),
    -- | Complete member profiles, when ListTopicsRequest FetchOptions.USER is set. Otherwise, only the id will be filled in.
    initiatorProfile :: (Core.Maybe User),
    -- | The type of the user who initiated this membership change.
    initiatorType :: (Core.Maybe MembershipChangedMetadata_InitiatorType),
    -- |
    type' :: (Core.Maybe MembershipChangedMetadata_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'MembershipChangedMetadata' with the minimum fields required to make a request.
newMembershipChangedMetadata ::
  MembershipChangedMetadata
newMembershipChangedMetadata =
  MembershipChangedMetadata
    { affectedMemberProfiles = Core.Nothing,
      affectedMembers = Core.Nothing,
      affectedMemberships = Core.Nothing,
      initiator = Core.Nothing,
      initiatorProfile = Core.Nothing,
      initiatorType = Core.Nothing,
      type' = Core.Nothing
    }

instance Core.FromJSON MembershipChangedMetadata where
  parseJSON =
    Core.withObject
      "MembershipChangedMetadata"
      ( \o ->
          MembershipChangedMetadata
            Core.<$> (o Core..:? "affectedMemberProfiles")
            Core.<*> (o Core..:? "affectedMembers")
            Core.<*> (o Core..:? "affectedMemberships")
            Core.<*> (o Core..:? "initiator")
            Core.<*> (o Core..:? "initiatorProfile")
            Core.<*> (o Core..:? "initiatorType")
            Core.<*> (o Core..:? "type")
      )

instance Core.ToJSON MembershipChangedMetadata where
  toJSON MembershipChangedMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("affectedMemberProfiles" Core..=)
              Core.<$> affectedMemberProfiles,
            ("affectedMembers" Core..=) Core.<$> affectedMembers,
            ("affectedMemberships" Core..=)
              Core.<$> affectedMemberships,
            ("initiator" Core..=) Core.<$> initiator,
            ("initiatorProfile" Core..=)
              Core.<$> initiatorProfile,
            ("initiatorType" Core..=) Core.<$> initiatorType,
            ("type" Core..=) Core.<$> type'
          ]
      )

-- | This is deprecated and please use SelectionControl by setting type to DROPDOWN.
--
-- /See:/ 'newMenu' smart constructor.
data Menu = Menu
  { -- |
    items :: (Core.Maybe [MenuItem]),
    -- | Label used to be displayed ahead of the menu. It is optional.
    label :: (Core.Maybe Core.Text),
    -- | The name of the text field which is will be used in FormInput.
    name :: (Core.Maybe Core.Text),
    -- | If specified, form is submitted when selection changed. If not specified, developer will need to specify a separate button.
    onChange :: (Core.Maybe FormAction)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Menu' with the minimum fields required to make a request.
newMenu ::
  Menu
newMenu =
  Menu
    { items = Core.Nothing,
      label = Core.Nothing,
      name = Core.Nothing,
      onChange = Core.Nothing
    }

instance Core.FromJSON Menu where
  parseJSON =
    Core.withObject
      "Menu"
      ( \o ->
          Menu
            Core.<$> (o Core..:? "items")
            Core.<*> (o Core..:? "label")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "onChange")
      )

instance Core.ToJSON Menu where
  toJSON Menu {..} =
    Core.object
      ( Core.catMaybes
          [ ("items" Core..=) Core.<$> items,
            ("label" Core..=) Core.<$> label,
            ("name" Core..=) Core.<$> name,
            ("onChange" Core..=) Core.<$> onChange
          ]
      )

--
-- /See:/ 'newMenuItem' smart constructor.
data MenuItem = MenuItem
  { -- |
    selected :: (Core.Maybe Core.Bool),
    -- | The text to be displayed.
    text :: (Core.Maybe Core.Text),
    -- | The value associated with this item which will be sent back to app scripts. Client should use as a form input value.
    value :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'MenuItem' with the minimum fields required to make a request.
newMenuItem ::
  MenuItem
newMenuItem =
  MenuItem {selected = Core.Nothing, text = Core.Nothing, value = Core.Nothing}

instance Core.FromJSON MenuItem where
  parseJSON =
    Core.withObject
      "MenuItem"
      ( \o ->
          MenuItem
            Core.<$> (o Core..:? "selected")
            Core.<*> (o Core..:? "text")
            Core.<*> (o Core..:? "value")
      )

instance Core.ToJSON MenuItem where
  toJSON MenuItem {..} =
    Core.object
      ( Core.catMaybes
          [ ("selected" Core..=) Core.<$> selected,
            ("text" Core..=) Core.<$> text,
            ("value" Core..=) Core.<$> value
          ]
      )

-- | Message posted to a Space.
--
-- /See:/ 'newMessage' smart constructor.
data Message = Message
  { -- | Annotations parsed and extracted from the text body.
    annotations :: (Core.Maybe [Annotation]),
    -- | Custom display profile info for apps. Leave the field empty for real users.
    appProfile :: (Core.Maybe AppsDynamiteSharedAppProfile),
    -- | Attachments parsed from incoming webhooks
    attachments :: (Core.Maybe [Attachment]),
    -- | Lightweight message attributes which values are calculated and set in the servers.
    attributes :: (Core.Maybe MessageAttributes),
    -- | Responses from bots indicating if extra auth\/config is needed.
    botResponses :: (Core.Maybe [BotResponse]),
    -- | Communal labels associated with a message. These exist on the message itself regardless of which user fetches them. Order of entries is arbitrary and will not list duplicates of the same label_id. See go\/chat-labels-design for details.
    communalLabels :: (Core.Maybe [CommunalLabelTag]),
    -- |
    contentReportSummary :: (Core.Maybe ContentReportSummary),
    -- | Time when the Message was posted in microseconds.
    createTime :: (Core.Maybe Core.Int64),
    -- | ID of the User who posted the Message. This includes information to identify if this was posted by an App on behalf of a user.
    creatorId :: (Core.Maybe UserId),
    -- | Indicates who can delete the message. This field is set on the read path (e.g. ListTopics) but doesn’t have any effect on the write path (e.g. CreateMessageRequest).
    deletableBy :: (Core.Maybe Message_DeletableBy),
    -- | Time when the Message was deleted in microseconds. This field is set to nonzero value only for Messages deleted globally.
    deleteTime :: (Core.Maybe Core.Int64),
    -- | Time when the Message was per-user deleted by the message requester in microseconds. This field is set to nonzero value only for Message per-user deleted by the requester.
    deleteTimeForRequester :: (Core.Maybe Core.Int64),
    -- | Was this message deleted by Vault (Only used for Vault support) This is false if message is live or message was deleted by user.
    deletedByVault :: (Core.Maybe Core.Bool),
    -- | Data Loss Prevention scan information for this message. Messages are evaluated in the backend on create message\/topic and edit message actions. DEPRECATED: Use DATA/LOSS/PREVENTION Annotation.
    dlpScanSummary :: (Core.Maybe DlpScanSummary),
    -- | Indicates who can edit the message. This field is set on the read path (e.g. ListTopics) but doesn’t have any effect on the write path (e.g. CreateMessageRequest).
    editableBy :: (Core.Maybe Message_EditableBy),
    -- | A plain-text description of the attachment, used when clients cannot display formatted attachment (e.g. mobile push notifications).
    fallbackText :: (Core.Maybe Core.Text),
    -- | ID of the resource.
    id :: (Core.Maybe MessageId),
    -- | Whether the message is content purged. Content purged messages contain only data required for tombstone (see go\/chat-infinite-tombstone). This field is only used by Vault to display tombstone and should only be set to true if the message is a tombstone.
    isContentPurged :: (Core.Maybe Core.Bool),
    -- | Output only. Indicates if the message is an inline reply. Set to true only if the message\'s ParentPath is non-NULL. Currently, only inline replies have non-NULL ParentPath. See go\/chat-be-inline-reply-indicator.
    isInlineReply :: (Core.Maybe Core.Bool),
    -- | If the message was edited by a user, timestamp of the last edit, in microseconds.
    lastEditTime :: (Core.Maybe Core.Int64),
    -- | Time when the Message text was last updated in microseconds.
    lastUpdateTime :: (Core.Maybe Core.Int64),
    -- | A unique id specified on the client side.
    localId :: (Core.Maybe Core.Text),
    -- | An optional payload (restricted to 1P applications) that will be stored with this message. This can only be set by the 1P API and should be used to deliver additional data such a 1P sync version, 1P entity ID to the client for more advanced functionality [Eg. inform Group Tasks tab of new version while linking, fetch & render a live Task\/Meet call tile].
    messageIntegrationPayload :: (Core.Maybe AppsDynamiteSharedMessageIntegrationPayload),
    -- | Where the message was posted from
    messageOrigin :: (Core.Maybe Message_MessageOrigin),
    -- | State of the message, indicating whether the message is visible to all members in the group or is only visible to the sender only, or the private/message/viewer if it is set.
    messageState :: (Core.Maybe Message_MessageState),
    -- | Indicates if this message contains any suggestions that were provided by any Apps.
    originAppSuggestions :: (Core.Maybe [AppsDynamiteSharedOriginAppSuggestion]),
    -- | Personal labels associated with a message for the viewing user. Order of entries is arbitrary and will not list duplicates of the same label_id. See go\/chat-labels-design for details. NOTE: This will be unpopulated in the case of SpaceChangelog events.
    personalLabels :: (Core.Maybe [PersonalLabelTag]),
    -- | A list of per-user private information. This is deprecated, because we no longer plan to support partially private messages or private messages for multiple users. The message/state and private/message_viewer fields should be sufficient for this infrastructure.
    privateMessageInfos :: (Core.Maybe [PrivateMessageInfo]),
    -- | Should only be set if the Message State is PRIVATE. If set, the message content is only visible to this user (and any apps associated with the message), as well as the message creator. If unset, a private message is visible to the message creator only.
    privateMessageViewer :: (Core.Maybe UserId),
    -- | Contains additional (currently Hangouts Classic only) properties applicable to this message.
    props :: (Core.Maybe MessageProps),
    -- | Output only. Whether this message has been quoted by another message or not. Used by clients to handle message edit flows for messages that have been quoted.
    quotedByState :: (Core.Maybe Message_QuotedByState),
    -- | Output only. Metadata for a message that is quoted by this message.
    quotedMessageMetadata :: (Core.Maybe QuotedMessageMetadata),
    -- | A list of user reactions to this message. Ordered by the timestamp of the first reaction, ascending (oldest to newest).
    reactions :: (Core.Maybe [AppsDynamiteSharedReaction]),
    -- | Output only. Details of content reports. Set only when the request asks for it.
    reports :: (Core.Maybe [ContentReport]),
    -- | The retention settings of the message.
    retentionSettings :: (Core.Maybe AppsDynamiteSharedRetentionSettings),
    -- | Used by clients to correctly log format type for message creation due to complexity with client side optimistic update (see go\/content-metric-post-send-logging for details). Currently, only set by server in the message or topic creation path.
    richTextFormattingType :: (Core.Maybe Message_RichTextFormattingType),
    -- | A client-specified string that can be used to uniquely identify a message in a space, in lieu of @id.message_id@.
    secondaryMessageKey :: (Core.Maybe Core.Text),
    -- | Plaintext body of the Message.
    textBody :: (Core.Maybe Core.Text),
    -- | Information for the stoning of a Message.
    tombstoneMetadata :: (Core.Maybe TombstoneMetadata),
    -- | ID of the User who last updated (created\/edited\/deleted) the Message. This includes information to identify if this was updated by an App on behalf of a user.
    updaterId :: (Core.Maybe UserId),
    -- | UploadMetadata b\/36864213 is an ongoing effort to move UploadMetadata out of annotations field and save it to upload_metadata field only. After the migration, UploadMetadata will only be saved in this field.
    uploadMetadata :: (Core.Maybe [UploadMetadata])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Message' with the minimum fields required to make a request.
newMessage ::
  Message
newMessage =
  Message
    { annotations = Core.Nothing,
      appProfile = Core.Nothing,
      attachments = Core.Nothing,
      attributes = Core.Nothing,
      botResponses = Core.Nothing,
      communalLabels = Core.Nothing,
      contentReportSummary = Core.Nothing,
      createTime = Core.Nothing,
      creatorId = Core.Nothing,
      deletableBy = Core.Nothing,
      deleteTime = Core.Nothing,
      deleteTimeForRequester = Core.Nothing,
      deletedByVault = Core.Nothing,
      dlpScanSummary = Core.Nothing,
      editableBy = Core.Nothing,
      fallbackText = Core.Nothing,
      id = Core.Nothing,
      isContentPurged = Core.Nothing,
      isInlineReply = Core.Nothing,
      lastEditTime = Core.Nothing,
      lastUpdateTime = Core.Nothing,
      localId = Core.Nothing,
      messageIntegrationPayload = Core.Nothing,
      messageOrigin = Core.Nothing,
      messageState = Core.Nothing,
      originAppSuggestions = Core.Nothing,
      personalLabels = Core.Nothing,
      privateMessageInfos = Core.Nothing,
      privateMessageViewer = Core.Nothing,
      props = Core.Nothing,
      quotedByState = Core.Nothing,
      quotedMessageMetadata = Core.Nothing,
      reactions = Core.Nothing,
      reports = Core.Nothing,
      retentionSettings = Core.Nothing,
      richTextFormattingType = Core.Nothing,
      secondaryMessageKey = Core.Nothing,
      textBody = Core.Nothing,
      tombstoneMetadata = Core.Nothing,
      updaterId = Core.Nothing,
      uploadMetadata = Core.Nothing
    }

instance Core.FromJSON Message where
  parseJSON =
    Core.withObject
      "Message"
      ( \o ->
          Message
            Core.<$> (o Core..:? "annotations")
            Core.<*> (o Core..:? "appProfile")
            Core.<*> (o Core..:? "attachments")
            Core.<*> (o Core..:? "attributes")
            Core.<*> (o Core..:? "botResponses")
            Core.<*> (o Core..:? "communalLabels")
            Core.<*> (o Core..:? "contentReportSummary")
            Core.<*> ( o Core..:? "createTime"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "creatorId")
            Core.<*> (o Core..:? "deletableBy")
            Core.<*> ( o Core..:? "deleteTime"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> ( o Core..:? "deleteTimeForRequester"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "deletedByVault")
            Core.<*> (o Core..:? "dlpScanSummary")
            Core.<*> (o Core..:? "editableBy")
            Core.<*> (o Core..:? "fallbackText")
            Core.<*> (o Core..:? "id")
            Core.<*> (o Core..:? "isContentPurged")
            Core.<*> (o Core..:? "isInlineReply")
            Core.<*> ( o Core..:? "lastEditTime"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> ( o Core..:? "lastUpdateTime"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "localId")
            Core.<*> (o Core..:? "messageIntegrationPayload")
            Core.<*> (o Core..:? "messageOrigin")
            Core.<*> (o Core..:? "messageState")
            Core.<*> (o Core..:? "originAppSuggestions")
            Core.<*> (o Core..:? "personalLabels")
            Core.<*> (o Core..:? "privateMessageInfos")
            Core.<*> (o Core..:? "privateMessageViewer")
            Core.<*> (o Core..:? "props")
            Core.<*> (o Core..:? "quotedByState")
            Core.<*> (o Core..:? "quotedMessageMetadata")
            Core.<*> (o Core..:? "reactions")
            Core.<*> (o Core..:? "reports")
            Core.<*> (o Core..:? "retentionSettings")
            Core.<*> (o Core..:? "richTextFormattingType")
            Core.<*> (o Core..:? "secondaryMessageKey")
            Core.<*> (o Core..:? "textBody")
            Core.<*> (o Core..:? "tombstoneMetadata")
            Core.<*> (o Core..:? "updaterId")
            Core.<*> (o Core..:? "uploadMetadata")
      )

instance Core.ToJSON Message where
  toJSON Message {..} =
    Core.object
      ( Core.catMaybes
          [ ("annotations" Core..=) Core.<$> annotations,
            ("appProfile" Core..=) Core.<$> appProfile,
            ("attachments" Core..=) Core.<$> attachments,
            ("attributes" Core..=) Core.<$> attributes,
            ("botResponses" Core..=) Core.<$> botResponses,
            ("communalLabels" Core..=) Core.<$> communalLabels,
            ("contentReportSummary" Core..=)
              Core.<$> contentReportSummary,
            ("createTime" Core..=) Core.. Core.AsText
              Core.<$> createTime,
            ("creatorId" Core..=) Core.<$> creatorId,
            ("deletableBy" Core..=) Core.<$> deletableBy,
            ("deleteTime" Core..=) Core.. Core.AsText
              Core.<$> deleteTime,
            ("deleteTimeForRequester" Core..=) Core.. Core.AsText
              Core.<$> deleteTimeForRequester,
            ("deletedByVault" Core..=) Core.<$> deletedByVault,
            ("dlpScanSummary" Core..=) Core.<$> dlpScanSummary,
            ("editableBy" Core..=) Core.<$> editableBy,
            ("fallbackText" Core..=) Core.<$> fallbackText,
            ("id" Core..=) Core.<$> id,
            ("isContentPurged" Core..=) Core.<$> isContentPurged,
            ("isInlineReply" Core..=) Core.<$> isInlineReply,
            ("lastEditTime" Core..=) Core.. Core.AsText
              Core.<$> lastEditTime,
            ("lastUpdateTime" Core..=) Core.. Core.AsText
              Core.<$> lastUpdateTime,
            ("localId" Core..=) Core.<$> localId,
            ("messageIntegrationPayload" Core..=)
              Core.<$> messageIntegrationPayload,
            ("messageOrigin" Core..=) Core.<$> messageOrigin,
            ("messageState" Core..=) Core.<$> messageState,
            ("originAppSuggestions" Core..=)
              Core.<$> originAppSuggestions,
            ("personalLabels" Core..=) Core.<$> personalLabels,
            ("privateMessageInfos" Core..=)
              Core.<$> privateMessageInfos,
            ("privateMessageViewer" Core..=)
              Core.<$> privateMessageViewer,
            ("props" Core..=) Core.<$> props,
            ("quotedByState" Core..=) Core.<$> quotedByState,
            ("quotedMessageMetadata" Core..=)
              Core.<$> quotedMessageMetadata,
            ("reactions" Core..=) Core.<$> reactions,
            ("reports" Core..=) Core.<$> reports,
            ("retentionSettings" Core..=)
              Core.<$> retentionSettings,
            ("richTextFormattingType" Core..=)
              Core.<$> richTextFormattingType,
            ("secondaryMessageKey" Core..=)
              Core.<$> secondaryMessageKey,
            ("textBody" Core..=) Core.<$> textBody,
            ("tombstoneMetadata" Core..=)
              Core.<$> tombstoneMetadata,
            ("updaterId" Core..=) Core.<$> updaterId,
            ("uploadMetadata" Core..=) Core.<$> uploadMetadata
          ]
      )

-- | A message was added. Specifying id and initial labels.
--
-- /See:/ 'newMessageAdded' smart constructor.
data MessageAdded = MessageAdded
  { -- |
    attributeIds :: (Core.Maybe [Core.Text]),
    -- |
    labelIds :: (Core.Maybe [Core.Text]),
    -- |
    messageKey :: (Core.Maybe MultiKey),
    -- | Note that there can be fewer sync ids than label ids.
    syncIds :: (Core.Maybe [Core.Word32])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'MessageAdded' with the minimum fields required to make a request.
newMessageAdded ::
  MessageAdded
newMessageAdded =
  MessageAdded
    { attributeIds = Core.Nothing,
      labelIds = Core.Nothing,
      messageKey = Core.Nothing,
      syncIds = Core.Nothing
    }

instance Core.FromJSON MessageAdded where
  parseJSON =
    Core.withObject
      "MessageAdded"
      ( \o ->
          MessageAdded
            Core.<$> (o Core..:? "attributeIds")
            Core.<*> (o Core..:? "labelIds")
            Core.<*> (o Core..:? "messageKey")
            Core.<*> (o Core..:? "syncIds")
      )

instance Core.ToJSON MessageAdded where
  toJSON MessageAdded {..} =
    Core.object
      ( Core.catMaybes
          [ ("attributeIds" Core..=) Core.<$> attributeIds,
            ("labelIds" Core..=) Core.<$> labelIds,
            ("messageKey" Core..=) Core.<$> messageKey,
            ("syncIds" Core..=) Core.<$> syncIds
          ]
      )

-- | Stores tombstone message attributes: go\/tombstone-message-attributes-overview
--
-- /See:/ 'newMessageAttributes' smart constructor.
newtype MessageAttributes = MessageAttributes
  { -- | If true: message is a tombstone in the client. Default false.
    isTombstone :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'MessageAttributes' with the minimum fields required to make a request.
newMessageAttributes ::
  MessageAttributes
newMessageAttributes = MessageAttributes {isTombstone = Core.Nothing}

instance Core.FromJSON MessageAttributes where
  parseJSON =
    Core.withObject
      "MessageAttributes"
      ( \o ->
          MessageAttributes
            Core.<$> (o Core..:? "isTombstone")
      )

instance Core.ToJSON MessageAttributes where
  toJSON MessageAttributes {..} =
    Core.object
      ( Core.catMaybes
          [("isTombstone" Core..=) Core.<$> isTombstone]
      )

-- | Some (subset of the) messages in this thread were deleted.
--
-- /See:/ 'newMessageDeleted' smart constructor.
data MessageDeleted = MessageDeleted
  { -- | Value of coproc\'s message delete history record extension that exports \/imapsync\/folder attribute of deleted messages which have ^is label.
    imapSyncMappings :: (Core.Maybe [ImapSyncDelete]),
    -- |
    messageKeys :: (Core.Maybe [MultiKey]),
    -- | Value of coproc\'s message delete history record extension that exports \/wonder\/message/mapping\/{vertical} attribute of deleted messages which have smartmail label (eg. ^cob/sm_invoice, etc).
    wonderCardMappings :: (Core.Maybe [WonderCardDelete])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'MessageDeleted' with the minimum fields required to make a request.
newMessageDeleted ::
  MessageDeleted
newMessageDeleted =
  MessageDeleted
    { imapSyncMappings = Core.Nothing,
      messageKeys = Core.Nothing,
      wonderCardMappings = Core.Nothing
    }

instance Core.FromJSON MessageDeleted where
  parseJSON =
    Core.withObject
      "MessageDeleted"
      ( \o ->
          MessageDeleted
            Core.<$> (o Core..:? "imapSyncMappings")
            Core.<*> (o Core..:? "messageKeys")
            Core.<*> (o Core..:? "wonderCardMappings")
      )

instance Core.ToJSON MessageDeleted where
  toJSON MessageDeleted {..} =
    Core.object
      ( Core.catMaybes
          [ ("imapSyncMappings" Core..=)
              Core.<$> imapSyncMappings,
            ("messageKeys" Core..=) Core.<$> messageKeys,
            ("wonderCardMappings" Core..=)
              Core.<$> wonderCardMappings
          ]
      )

-- | Primary key for Message resource.
--
-- /See:/ 'newMessageId' smart constructor.
data MessageId = MessageId
  { -- | Opaque, server-assigned ID of the Message. While this ID is guaranteed to be unique within the Space, it\'s not guaranteed to be globally unique.
    messageId :: (Core.Maybe Core.Text),
    -- | ID of the Message\'s immediate parent.
    parentId :: (Core.Maybe MessageParentId)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'MessageId' with the minimum fields required to make a request.
newMessageId ::
  MessageId
newMessageId = MessageId {messageId = Core.Nothing, parentId = Core.Nothing}

instance Core.FromJSON MessageId where
  parseJSON =
    Core.withObject
      "MessageId"
      ( \o ->
          MessageId
            Core.<$> (o Core..:? "messageId")
            Core.<*> (o Core..:? "parentId")
      )

instance Core.ToJSON MessageId where
  toJSON MessageId {..} =
    Core.object
      ( Core.catMaybes
          [ ("messageId" Core..=) Core.<$> messageId,
            ("parentId" Core..=) Core.<$> parentId
          ]
      )

--
-- /See:/ 'newMessageInfo' smart constructor.
data MessageInfo = MessageInfo
  { -- | Message author’s user type (human\/bot).
    authorUserType :: (Core.Maybe MessageInfo_AuthorUserType),
    -- | The content of a matching message.
    message :: (Core.Maybe Message),
    -- | Searcher\'s membership state in the space where the message is posted.
    searcherMembershipState :: (Core.Maybe MessageInfo_SearcherMembershipState)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'MessageInfo' with the minimum fields required to make a request.
newMessageInfo ::
  MessageInfo
newMessageInfo =
  MessageInfo
    { authorUserType = Core.Nothing,
      message = Core.Nothing,
      searcherMembershipState = Core.Nothing
    }

instance Core.FromJSON MessageInfo where
  parseJSON =
    Core.withObject
      "MessageInfo"
      ( \o ->
          MessageInfo
            Core.<$> (o Core..:? "authorUserType")
            Core.<*> (o Core..:? "message")
            Core.<*> (o Core..:? "searcherMembershipState")
      )

instance Core.ToJSON MessageInfo where
  toJSON MessageInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("authorUserType" Core..=) Core.<$> authorUserType,
            ("message" Core..=) Core.<$> message,
            ("searcherMembershipState" Core..=)
              Core.<$> searcherMembershipState
          ]
      )

-- | Primary key identifying Message resource\'s immediate parent. For top-level Messages, either topic/id or chat/id is populated. For replies, message_id is populated with the topic Message\'s ID.
--
-- /See:/ 'newMessageParentId' smart constructor.
newtype MessageParentId = MessageParentId
  { -- | ID of the Topic this Message is posted to. NEXT TAG : 5
    topicId :: (Core.Maybe TopicId)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'MessageParentId' with the minimum fields required to make a request.
newMessageParentId ::
  MessageParentId
newMessageParentId = MessageParentId {topicId = Core.Nothing}

instance Core.FromJSON MessageParentId where
  parseJSON =
    Core.withObject
      "MessageParentId"
      ( \o ->
          MessageParentId Core.<$> (o Core..:? "topicId")
      )

instance Core.ToJSON MessageParentId where
  toJSON MessageParentId {..} =
    Core.object
      ( Core.catMaybes
          [("topicId" Core..=) Core.<$> topicId]
      )

-- | Container for storing properties applicable to messages. For now (until storage consolidation is complete), it will only be used for babel props. In the future it could be used to house Dynamite properties for experimenting\/rapid prototyping.
--
-- /See:/ 'newMessageProps' smart constructor.
newtype MessageProps = MessageProps
  { -- |
    babelProps :: (Core.Maybe BabelMessageProps)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'MessageProps' with the minimum fields required to make a request.
newMessageProps ::
  MessageProps
newMessageProps = MessageProps {babelProps = Core.Nothing}

instance Core.FromJSON MessageProps where
  parseJSON =
    Core.withObject
      "MessageProps"
      ( \o ->
          MessageProps Core.<$> (o Core..:? "babelProps")
      )

instance Core.ToJSON MessageProps where
  toJSON MessageProps {..} =
    Core.object
      ( Core.catMaybes
          [("babelProps" Core..=) Core.<$> babelProps]
      )

-- | This is proto2\'s version of MessageSet.
--
-- /See:/ 'newMessageSet' smart constructor.
data MessageSet = MessageSet
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'MessageSet' with the minimum fields required to make a request.
newMessageSet ::
  MessageSet
newMessageSet = MessageSet

instance Core.FromJSON MessageSet where
  parseJSON =
    Core.withObject
      "MessageSet"
      (\o -> Core.pure MessageSet)

instance Core.ToJSON MessageSet where
  toJSON = Core.const Core.emptyObject

-- | Metadata of a matched search result.
--
-- /See:/ 'newMetadata' smart constructor.
data Metadata = Metadata
  { -- | The creation time for this document or object in the search result.
    createTime :: (Core.Maybe Core.DateTime),
    -- | Options that specify how to display a structured data search result.
    displayOptions :: (Core.Maybe ResultDisplayMetadata),
    -- | Indexed fields in structured data, returned as a generic named property.
    fields :: (Core.Maybe [NamedProperty]),
    -- | Mime type of the search result.
    mimeType :: (Core.Maybe Core.Text),
    -- | Object type of the search result.
    objectType :: (Core.Maybe Core.Text),
    -- | Owner (usually creator) of the document or object of the search result.
    owner :: (Core.Maybe Person),
    -- | The named source for the result, such as Gmail.
    source :: (Core.Maybe Source),
    -- | The thumbnail URL of the result.
    thumbnailUrl :: (Core.Maybe Core.Text),
    -- | The last modified date for the object in the search result. If not set in the item, the value returned here is empty. When @updateTime@ is used for calculating freshness and is not set, this value defaults to 2 years from the current time.
    updateTime :: (Core.Maybe Core.DateTime)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Metadata' with the minimum fields required to make a request.
newMetadata ::
  Metadata
newMetadata =
  Metadata
    { createTime = Core.Nothing,
      displayOptions = Core.Nothing,
      fields = Core.Nothing,
      mimeType = Core.Nothing,
      objectType = Core.Nothing,
      owner = Core.Nothing,
      source = Core.Nothing,
      thumbnailUrl = Core.Nothing,
      updateTime = Core.Nothing
    }

instance Core.FromJSON Metadata where
  parseJSON =
    Core.withObject
      "Metadata"
      ( \o ->
          Metadata
            Core.<$> (o Core..:? "createTime")
            Core.<*> (o Core..:? "displayOptions")
            Core.<*> (o Core..:? "fields")
            Core.<*> (o Core..:? "mimeType")
            Core.<*> (o Core..:? "objectType")
            Core.<*> (o Core..:? "owner")
            Core.<*> (o Core..:? "source")
            Core.<*> (o Core..:? "thumbnailUrl")
            Core.<*> (o Core..:? "updateTime")
      )

instance Core.ToJSON Metadata where
  toJSON Metadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("createTime" Core..=) Core.<$> createTime,
            ("displayOptions" Core..=) Core.<$> displayOptions,
            ("fields" Core..=) Core.<$> fields,
            ("mimeType" Core..=) Core.<$> mimeType,
            ("objectType" Core..=) Core.<$> objectType,
            ("owner" Core..=) Core.<$> owner,
            ("source" Core..=) Core.<$> source,
            ("thumbnailUrl" Core..=) Core.<$> thumbnailUrl,
            ("updateTime" Core..=) Core.<$> updateTime
          ]
      )

-- | A metaline is a list of properties that are displayed along with the search result to provide context.
--
-- /See:/ 'newMetaline' smart constructor.
newtype Metaline = Metaline
  { -- | The list of displayed properties for the metaline. The maximum number of properties is 5.
    properties :: (Core.Maybe [DisplayedProperty])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Metaline' with the minimum fields required to make a request.
newMetaline ::
  Metaline
newMetaline = Metaline {properties = Core.Nothing}

instance Core.FromJSON Metaline where
  parseJSON =
    Core.withObject
      "Metaline"
      (\o -> Metaline Core.<$> (o Core..:? "properties"))

instance Core.ToJSON Metaline where
  toJSON Metaline {..} =
    Core.object
      ( Core.catMaybes
          [("properties" Core..=) Core.<$> properties]
      )

-- | A union-like type for identifiying an object in storage. MultiKeys contain multiple key fields, each in a separate key space. At least one key field must be set. More than one key field may be set as long as all key values refer to the same object. All objects in storage have unique server/id keys. All MultiKeys returned from storage to storage clients will always have the server/id field set. When creating an object, if a MultiKey without a server/id is supplied to storage, the storage system will auto-assign a server ID to the new object. For all other storage requests (i.e. those not creating new objects), clients may omit server/id (as long as they supply another key). Instead of server ids, clients can specify string based client/assigned/perm/id keys. Mail message drafts are a prime example of these kinds of objects. Each time a user saves a new version of a draft, the storage system needs to create a new object with the updated draft content and needs to delete the object containing the old content.
-- The new object gets a new SERVER/ID but should get the same CLIENT/ASSIGNED/PERM/ID as the now-deleted object containing the old content. Carrying forward the perm ID allows it to be used to consistently refer to the same logical object across revisions. These perm IDs save sync clients from having to deal with changing object IDs. For example, assume there\'s a mail message in storage with SERVER/ID = 123 and CLIENT/ASSIGNED/PERM/ID = \"foo\". The following are all valid ways of addressing the object using MultiKeys: 1) MultiKey { server/id = 123 } 2) MultiKey { server/id = 123, client/assigned/perm/id = \"foo\" } 3) MultiKey { client/assigned/perm_id = \"foo\" } Multikeys are never serialized in the storage. The individual keys are extracted and processed separately. Both the integer ids as well as string ids are indexed for efficient retrieval using the same fields in the backend. See go\/tingle-multikeys for more information on background and motivation.
--
-- /See:/ 'newMultiKey' smart constructor.
data MultiKey = MultiKey
  { -- | A client-assigned string based key.
    clientAssignedPermId :: (Core.Maybe Core.Text),
    -- | A server-assigned ID. This ID must be used only by Gmail and is constructed using millesecond ts \<\< 20 + randomness. The ID affects the sort order of the index.
    serverId :: (Core.Maybe Core.Word64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'MultiKey' with the minimum fields required to make a request.
newMultiKey ::
  MultiKey
newMultiKey =
  MultiKey {clientAssignedPermId = Core.Nothing, serverId = Core.Nothing}

instance Core.FromJSON MultiKey where
  parseJSON =
    Core.withObject
      "MultiKey"
      ( \o ->
          MultiKey
            Core.<$> (o Core..:? "clientAssignedPermId")
            Core.<*> ( o Core..:? "serverId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON MultiKey where
  toJSON MultiKey {..} =
    Core.object
      ( Core.catMaybes
          [ ("clientAssignedPermId" Core..=)
              Core.<$> clientAssignedPermId,
            ("serverId" Core..=) Core.. Core.AsText
              Core.<$> serverId
          ]
      )

-- | A person\'s name.
--
-- /See:/ 'newName' smart constructor.
newtype Name = Name
  { -- | The read-only display name formatted according to the locale specified by the viewer\'s account or the @Accept-Language@ HTTP header.
    displayName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Name' with the minimum fields required to make a request.
newName ::
  Name
newName = Name {displayName = Core.Nothing}

instance Core.FromJSON Name where
  parseJSON =
    Core.withObject
      "Name"
      (\o -> Name Core.<$> (o Core..:? "displayName"))

instance Core.ToJSON Name where
  toJSON Name {..} =
    Core.object
      ( Core.catMaybes
          [("displayName" Core..=) Core.<$> displayName]
      )

-- | A typed name-value pair for structured data. The type of the value should be the same as the registered type for the @name@ property in the object definition of @objectType@.
--
-- /See:/ 'newNamedProperty' smart constructor.
data NamedProperty = NamedProperty
  { -- |
    booleanValue :: (Core.Maybe Core.Bool),
    -- |
    dateValues :: (Core.Maybe DateValues),
    -- |
    doubleValues :: (Core.Maybe DoubleValues),
    -- |
    enumValues :: (Core.Maybe EnumValues),
    -- |
    htmlValues :: (Core.Maybe HtmlValues),
    -- |
    integerValues :: (Core.Maybe IntegerValues),
    -- | The name of the property. This name should correspond to the name of the property that was registered for object definition in the schema. The maximum allowable length for this property is 256 characters.
    name :: (Core.Maybe Core.Text),
    -- |
    objectValues :: (Core.Maybe ObjectValues),
    -- |
    textValues :: (Core.Maybe TextValues),
    -- |
    timestampValues :: (Core.Maybe TimestampValues)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'NamedProperty' with the minimum fields required to make a request.
newNamedProperty ::
  NamedProperty
newNamedProperty =
  NamedProperty
    { booleanValue = Core.Nothing,
      dateValues = Core.Nothing,
      doubleValues = Core.Nothing,
      enumValues = Core.Nothing,
      htmlValues = Core.Nothing,
      integerValues = Core.Nothing,
      name = Core.Nothing,
      objectValues = Core.Nothing,
      textValues = Core.Nothing,
      timestampValues = Core.Nothing
    }

instance Core.FromJSON NamedProperty where
  parseJSON =
    Core.withObject
      "NamedProperty"
      ( \o ->
          NamedProperty
            Core.<$> (o Core..:? "booleanValue")
            Core.<*> (o Core..:? "dateValues")
            Core.<*> (o Core..:? "doubleValues")
            Core.<*> (o Core..:? "enumValues")
            Core.<*> (o Core..:? "htmlValues")
            Core.<*> (o Core..:? "integerValues")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "objectValues")
            Core.<*> (o Core..:? "textValues")
            Core.<*> (o Core..:? "timestampValues")
      )

instance Core.ToJSON NamedProperty where
  toJSON NamedProperty {..} =
    Core.object
      ( Core.catMaybes
          [ ("booleanValue" Core..=) Core.<$> booleanValue,
            ("dateValues" Core..=) Core.<$> dateValues,
            ("doubleValues" Core..=) Core.<$> doubleValues,
            ("enumValues" Core..=) Core.<$> enumValues,
            ("htmlValues" Core..=) Core.<$> htmlValues,
            ("integerValues" Core..=) Core.<$> integerValues,
            ("name" Core..=) Core.<$> name,
            ("objectValues" Core..=) Core.<$> objectValues,
            ("textValues" Core..=) Core.<$> textValues,
            ("timestampValues" Core..=)
              Core.<$> timestampValues
          ]
      )

-- | Represents an OAuth consumer, a\/k\/a AuthSub target. These principals are identified by domain name (e.g., example.com). Historically, Dasher domain GAIA group IDs have been used instead, but that doesn\'t work: http:\/\/go\/tricky-gaia-ids
--
-- /See:/ 'newOAuthConsumerProto' smart constructor.
newtype OAuthConsumerProto = OAuthConsumerProto
  { -- |
    domain :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'OAuthConsumerProto' with the minimum fields required to make a request.
newOAuthConsumerProto ::
  OAuthConsumerProto
newOAuthConsumerProto = OAuthConsumerProto {domain = Core.Nothing}

instance Core.FromJSON OAuthConsumerProto where
  parseJSON =
    Core.withObject
      "OAuthConsumerProto"
      ( \o ->
          OAuthConsumerProto Core.<$> (o Core..:? "domain")
      )

instance Core.ToJSON OAuthConsumerProto where
  toJSON OAuthConsumerProto {..} =
    Core.object
      (Core.catMaybes [("domain" Core..=) Core.<$> domain])

-- | The definition for an object within a data source.
--
-- /See:/ 'newObjectDefinition' smart constructor.
data ObjectDefinition = ObjectDefinition
  { -- | The name for the object, which then defines its type. Item indexing requests should set the objectType field equal to this value. For example, if /name/ is /Document/, then indexing requests for items of type Document should set objectType equal to /Document/. Each object definition must be uniquely named within a schema. The name must start with a letter and can only contain letters (A-Z, a-z) or numbers (0-9). The maximum length is 256 characters.
    name :: (Core.Maybe Core.Text),
    -- | The optional object-specific options.
    options :: (Core.Maybe ObjectOptions),
    -- | The property definitions for the object. The maximum number of elements is 1000.
    propertyDefinitions :: (Core.Maybe [PropertyDefinition])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ObjectDefinition' with the minimum fields required to make a request.
newObjectDefinition ::
  ObjectDefinition
newObjectDefinition =
  ObjectDefinition
    { name = Core.Nothing,
      options = Core.Nothing,
      propertyDefinitions = Core.Nothing
    }

instance Core.FromJSON ObjectDefinition where
  parseJSON =
    Core.withObject
      "ObjectDefinition"
      ( \o ->
          ObjectDefinition
            Core.<$> (o Core..:? "name")
            Core.<*> (o Core..:? "options")
            Core.<*> (o Core..:? "propertyDefinitions")
      )

instance Core.ToJSON ObjectDefinition where
  toJSON ObjectDefinition {..} =
    Core.object
      ( Core.catMaybes
          [ ("name" Core..=) Core.<$> name,
            ("options" Core..=) Core.<$> options,
            ("propertyDefinitions" Core..=)
              Core.<$> propertyDefinitions
          ]
      )

-- | The display options for an object.
--
-- /See:/ 'newObjectDisplayOptions' smart constructor.
data ObjectDisplayOptions = ObjectDisplayOptions
  { -- | Defines the properties that are displayed in the metalines of the search results. The property values are displayed in the order given here. If a property holds multiple values, all of the values are displayed before the next properties. For this reason, it is a good practice to specify singular properties before repeated properties in this list. All of the properties must set is_returnable to true. The maximum number of metalines is 3.
    metalines :: (Core.Maybe [Metaline]),
    -- | The user friendly label to display in the search result to indicate the type of the item. This is OPTIONAL; if not provided, an object label isn\'t displayed on the context line of the search results. The maximum length is 64 characters.
    objectDisplayLabel :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ObjectDisplayOptions' with the minimum fields required to make a request.
newObjectDisplayOptions ::
  ObjectDisplayOptions
newObjectDisplayOptions =
  ObjectDisplayOptions
    { metalines = Core.Nothing,
      objectDisplayLabel = Core.Nothing
    }

instance Core.FromJSON ObjectDisplayOptions where
  parseJSON =
    Core.withObject
      "ObjectDisplayOptions"
      ( \o ->
          ObjectDisplayOptions
            Core.<$> (o Core..:? "metalines")
            Core.<*> (o Core..:? "objectDisplayLabel")
      )

instance Core.ToJSON ObjectDisplayOptions where
  toJSON ObjectDisplayOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("metalines" Core..=) Core.<$> metalines,
            ("objectDisplayLabel" Core..=)
              Core.<$> objectDisplayLabel
          ]
      )

-- | The options for an object.
--
-- /See:/ 'newObjectOptions' smart constructor.
data ObjectOptions = ObjectOptions
  { -- | The options that determine how the object is displayed in the Cloud Search results page.
    displayOptions :: (Core.Maybe ObjectDisplayOptions),
    -- | The freshness options for an object.
    freshnessOptions :: (Core.Maybe FreshnessOptions),
    -- | Operators that can be used to filter suggestions. For Suggest API, only operators mentioned here will be honored in the FilterOptions. Only TEXT and ENUM operators are supported. NOTE: \"objecttype\", \"type\" and \"mimetype\" are already supported. This property is to configure schema specific operators. Even though this is an array, only one operator can be specified. This is an array for future extensibility. Operators mapping to multiple properties within the same object are not supported. If the operator spans across different object types, this option has to be set once for each object definition.
    suggestionFilteringOperators :: (Core.Maybe [Core.Text])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ObjectOptions' with the minimum fields required to make a request.
newObjectOptions ::
  ObjectOptions
newObjectOptions =
  ObjectOptions
    { displayOptions = Core.Nothing,
      freshnessOptions = Core.Nothing,
      suggestionFilteringOperators = Core.Nothing
    }

instance Core.FromJSON ObjectOptions where
  parseJSON =
    Core.withObject
      "ObjectOptions"
      ( \o ->
          ObjectOptions
            Core.<$> (o Core..:? "displayOptions")
            Core.<*> (o Core..:? "freshnessOptions")
            Core.<*> (o Core..:? "suggestionFilteringOperators")
      )

instance Core.ToJSON ObjectOptions where
  toJSON ObjectOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("displayOptions" Core..=) Core.<$> displayOptions,
            ("freshnessOptions" Core..=)
              Core.<$> freshnessOptions,
            ("suggestionFilteringOperators" Core..=)
              Core.<$> suggestionFilteringOperators
          ]
      )

-- | The options for object properties.
--
-- /See:/ 'newObjectPropertyOptions' smart constructor.
newtype ObjectPropertyOptions = ObjectPropertyOptions
  { -- | The properties of the sub-object. These properties represent a nested object. For example, if this property represents a postal address, the subobjectProperties might be named /street/, /city/, and /state/. The maximum number of elements is 1000.
    subobjectProperties :: (Core.Maybe [PropertyDefinition])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ObjectPropertyOptions' with the minimum fields required to make a request.
newObjectPropertyOptions ::
  ObjectPropertyOptions
newObjectPropertyOptions =
  ObjectPropertyOptions {subobjectProperties = Core.Nothing}

instance Core.FromJSON ObjectPropertyOptions where
  parseJSON =
    Core.withObject
      "ObjectPropertyOptions"
      ( \o ->
          ObjectPropertyOptions
            Core.<$> (o Core..:? "subobjectProperties")
      )

instance Core.ToJSON ObjectPropertyOptions where
  toJSON ObjectPropertyOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("subobjectProperties" Core..=)
              Core.<$> subobjectProperties
          ]
      )

-- | List of object values.
--
-- /See:/ 'newObjectValues' smart constructor.
newtype ObjectValues = ObjectValues
  { -- |
    values :: (Core.Maybe [StructuredDataObject])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ObjectValues' with the minimum fields required to make a request.
newObjectValues ::
  ObjectValues
newObjectValues = ObjectValues {values = Core.Nothing}

instance Core.FromJSON ObjectValues where
  parseJSON =
    Core.withObject
      "ObjectValues"
      (\o -> ObjectValues Core.<$> (o Core..:? "values"))

instance Core.ToJSON ObjectValues where
  toJSON ObjectValues {..} =
    Core.object
      (Core.catMaybes [("values" Core..=) Core.<$> values])

--
-- /See:/ 'newOnClick' smart constructor.
data OnClick = OnClick
  { -- |
    action :: (Core.Maybe FormAction),
    -- | This can be used as a short form for OpenLink with the default OpenAs and OnClose. It may be undeprecated if this proves to be handy for developers.
    link :: (Core.Maybe Core.Text),
    -- |
    openLink :: (Core.Maybe OpenLink),
    -- | An add-on triggers this action when the form action needs to open a link. This differs from the open_link above in that this needs to talk to server to get the link. Thus some preparation work is required for web client to do before the open link action response comes back.
    openLinkAction :: (Core.Maybe FormAction)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'OnClick' with the minimum fields required to make a request.
newOnClick ::
  OnClick
newOnClick =
  OnClick
    { action = Core.Nothing,
      link = Core.Nothing,
      openLink = Core.Nothing,
      openLinkAction = Core.Nothing
    }

instance Core.FromJSON OnClick where
  parseJSON =
    Core.withObject
      "OnClick"
      ( \o ->
          OnClick
            Core.<$> (o Core..:? "action")
            Core.<*> (o Core..:? "link")
            Core.<*> (o Core..:? "openLink")
            Core.<*> (o Core..:? "openLinkAction")
      )

instance Core.ToJSON OnClick where
  toJSON OnClick {..} =
    Core.object
      ( Core.catMaybes
          [ ("action" Core..=) Core.<$> action,
            ("link" Core..=) Core.<$> link,
            ("openLink" Core..=) Core.<$> openLink,
            ("openLinkAction" Core..=) Core.<$> openLinkAction
          ]
      )

--
-- /See:/ 'newOpenCreatedDraftActionMarkup' smart constructor.
data OpenCreatedDraftActionMarkup = OpenCreatedDraftActionMarkup
  { -- | The ID of the newly created draft in the form \"r123\".
    draftId :: (Core.Maybe Core.Text),
    -- | The server storage ID in hex format, for example,\"15e9fa622ce1029d\".
    draftStorageId :: (Core.Maybe Core.Text),
    -- | The ID of the thread containing the newly created draft, for example, \"15e9fa622ce1029d\".
    draftThreadId :: (Core.Maybe Core.Text),
    -- | The server permanent ID for the draft\'s thread. This field isn\'t set anywhere, and it\'s ignored when processing OpenCreatedDraftActionMarkup. Supply and use draftThreadStorageId instead.
    draftThreadServerPermId :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'OpenCreatedDraftActionMarkup' with the minimum fields required to make a request.
newOpenCreatedDraftActionMarkup ::
  OpenCreatedDraftActionMarkup
newOpenCreatedDraftActionMarkup =
  OpenCreatedDraftActionMarkup
    { draftId = Core.Nothing,
      draftStorageId = Core.Nothing,
      draftThreadId = Core.Nothing,
      draftThreadServerPermId = Core.Nothing
    }

instance Core.FromJSON OpenCreatedDraftActionMarkup where
  parseJSON =
    Core.withObject
      "OpenCreatedDraftActionMarkup"
      ( \o ->
          OpenCreatedDraftActionMarkup
            Core.<$> (o Core..:? "draftId")
            Core.<*> (o Core..:? "draftStorageId")
            Core.<*> (o Core..:? "draftThreadId")
            Core.<*> (o Core..:? "draftThreadServerPermId")
      )

instance Core.ToJSON OpenCreatedDraftActionMarkup where
  toJSON OpenCreatedDraftActionMarkup {..} =
    Core.object
      ( Core.catMaybes
          [ ("draftId" Core..=) Core.<$> draftId,
            ("draftStorageId" Core..=) Core.<$> draftStorageId,
            ("draftThreadId" Core..=) Core.<$> draftThreadId,
            ("draftThreadServerPermId" Core..=)
              Core.<$> draftThreadServerPermId
          ]
      )

--
-- /See:/ 'newOpenLink' smart constructor.
data OpenLink = OpenLink
  { -- | Next available ID: 5
    loadIndicator :: (Core.Maybe OpenLink_LoadIndicator),
    -- |
    onClose :: (Core.Maybe OpenLink_OnClose),
    -- |
    openAs :: (Core.Maybe OpenLink_OpenAs),
    -- |
    url :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'OpenLink' with the minimum fields required to make a request.
newOpenLink ::
  OpenLink
newOpenLink =
  OpenLink
    { loadIndicator = Core.Nothing,
      onClose = Core.Nothing,
      openAs = Core.Nothing,
      url = Core.Nothing
    }

instance Core.FromJSON OpenLink where
  parseJSON =
    Core.withObject
      "OpenLink"
      ( \o ->
          OpenLink
            Core.<$> (o Core..:? "loadIndicator")
            Core.<*> (o Core..:? "onClose")
            Core.<*> (o Core..:? "openAs")
            Core.<*> (o Core..:? "url")
      )

instance Core.ToJSON OpenLink where
  toJSON OpenLink {..} =
    Core.object
      ( Core.catMaybes
          [ ("loadIndicator" Core..=) Core.<$> loadIndicator,
            ("onClose" Core..=) Core.<$> onClose,
            ("openAs" Core..=) Core.<$> openAs,
            ("url" Core..=) Core.<$> url
          ]
      )

-- | This resource represents a long-running operation that is the result of a network API call.
--
-- /See:/ 'newOperation' smart constructor.
data Operation = Operation
  { -- | If the value is @false@, it means the operation is still in progress. If @true@, the operation is completed, and either @error@ or @response@ is available.
    done :: (Core.Maybe Core.Bool),
    -- | The error result of the operation in case of failure or cancellation.
    error :: (Core.Maybe Status),
    -- | Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    metadata :: (Core.Maybe Operation_Metadata),
    -- | The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the @name@ should be a resource name ending with @operations\/{unique_id}@.
    name :: (Core.Maybe Core.Text),
    -- | The normal response of the operation in case of success. If the original method returns no data on success, such as @Delete@, the response is @google.protobuf.Empty@. If the original method is standard @Get@\/@Create@\/@Update@, the response should be the resource. For other methods, the response should have the type @XxxResponse@, where @Xxx@ is the original method name. For example, if the original method name is @TakeSnapshot()@, the inferred response type is @TakeSnapshotResponse@.
    response :: (Core.Maybe Operation_Response)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Operation' with the minimum fields required to make a request.
newOperation ::
  Operation
newOperation =
  Operation
    { done = Core.Nothing,
      error = Core.Nothing,
      metadata = Core.Nothing,
      name = Core.Nothing,
      response = Core.Nothing
    }

instance Core.FromJSON Operation where
  parseJSON =
    Core.withObject
      "Operation"
      ( \o ->
          Operation
            Core.<$> (o Core..:? "done")
            Core.<*> (o Core..:? "error")
            Core.<*> (o Core..:? "metadata")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "response")
      )

instance Core.ToJSON Operation where
  toJSON Operation {..} =
    Core.object
      ( Core.catMaybes
          [ ("done" Core..=) Core.<$> done,
            ("error" Core..=) Core.<$> error,
            ("metadata" Core..=) Core.<$> metadata,
            ("name" Core..=) Core.<$> name,
            ("response" Core..=) Core.<$> response
          ]
      )

-- | Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
--
-- /See:/ 'newOperation_Metadata' smart constructor.
newtype Operation_Metadata = Operation_Metadata
  { -- | Properties of the object. Contains field \@type with type URL.
    additional :: (Core.HashMap Core.Text Core.Value)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Operation_Metadata' with the minimum fields required to make a request.
newOperation_Metadata ::
  -- |  Properties of the object. Contains field \@type with type URL. See 'additional'.
  Core.HashMap Core.Text Core.Value ->
  Operation_Metadata
newOperation_Metadata additional = Operation_Metadata {additional = additional}

instance Core.FromJSON Operation_Metadata where
  parseJSON =
    Core.withObject
      "Operation_Metadata"
      ( \o ->
          Operation_Metadata Core.<$> (Core.parseJSONObject o)
      )

instance Core.ToJSON Operation_Metadata where
  toJSON Operation_Metadata {..} =
    Core.toJSON additional

-- | The normal response of the operation in case of success. If the original method returns no data on success, such as @Delete@, the response is @google.protobuf.Empty@. If the original method is standard @Get@\/@Create@\/@Update@, the response should be the resource. For other methods, the response should have the type @XxxResponse@, where @Xxx@ is the original method name. For example, if the original method name is @TakeSnapshot()@, the inferred response type is @TakeSnapshotResponse@.
--
-- /See:/ 'newOperation_Response' smart constructor.
newtype Operation_Response = Operation_Response
  { -- | Properties of the object. Contains field \@type with type URL.
    additional :: (Core.HashMap Core.Text Core.Value)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Operation_Response' with the minimum fields required to make a request.
newOperation_Response ::
  -- |  Properties of the object. Contains field \@type with type URL. See 'additional'.
  Core.HashMap Core.Text Core.Value ->
  Operation_Response
newOperation_Response additional = Operation_Response {additional = additional}

instance Core.FromJSON Operation_Response where
  parseJSON =
    Core.withObject
      "Operation_Response"
      ( \o ->
          Operation_Response Core.<$> (Core.parseJSONObject o)
      )

instance Core.ToJSON Operation_Response where
  toJSON Operation_Response {..} =
    Core.toJSON additional

--
-- /See:/ 'newOsVersion' smart constructor.
data OsVersion = OsVersion
  { -- |
    majorVersion :: (Core.Maybe Core.Int32),
    -- |
    minorVersion :: (Core.Maybe Core.Int32),
    -- |
    tertiaryVersion :: (Core.Maybe Core.Int32)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'OsVersion' with the minimum fields required to make a request.
newOsVersion ::
  OsVersion
newOsVersion =
  OsVersion
    { majorVersion = Core.Nothing,
      minorVersion = Core.Nothing,
      tertiaryVersion = Core.Nothing
    }

instance Core.FromJSON OsVersion where
  parseJSON =
    Core.withObject
      "OsVersion"
      ( \o ->
          OsVersion
            Core.<$> (o Core..:? "majorVersion")
            Core.<*> (o Core..:? "minorVersion")
            Core.<*> (o Core..:? "tertiaryVersion")
      )

instance Core.ToJSON OsVersion where
  toJSON OsVersion {..} =
    Core.object
      ( Core.catMaybes
          [ ("majorVersion" Core..=) Core.<$> majorVersion,
            ("minorVersion" Core..=) Core.<$> minorVersion,
            ("tertiaryVersion" Core..=)
              Core.<$> tertiaryVersion
          ]
      )

--
-- /See:/ 'newOtrChatMessageEvent' smart constructor.
data OtrChatMessageEvent = OtrChatMessageEvent
  { -- |
    expirationTimestampUsec :: (Core.Maybe Core.Int64),
    -- |
    kansasRowId :: (Core.Maybe Core.Text),
    -- |
    kansasVersionInfo :: (Core.Maybe Core.Text),
    -- |
    messageOtrStatus :: (Core.Maybe OtrChatMessageEvent_MessageOtrStatus)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'OtrChatMessageEvent' with the minimum fields required to make a request.
newOtrChatMessageEvent ::
  OtrChatMessageEvent
newOtrChatMessageEvent =
  OtrChatMessageEvent
    { expirationTimestampUsec = Core.Nothing,
      kansasRowId = Core.Nothing,
      kansasVersionInfo = Core.Nothing,
      messageOtrStatus = Core.Nothing
    }

instance Core.FromJSON OtrChatMessageEvent where
  parseJSON =
    Core.withObject
      "OtrChatMessageEvent"
      ( \o ->
          OtrChatMessageEvent
            Core.<$> ( o Core..:? "expirationTimestampUsec"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "kansasRowId")
            Core.<*> (o Core..:? "kansasVersionInfo")
            Core.<*> (o Core..:? "messageOtrStatus")
      )

instance Core.ToJSON OtrChatMessageEvent where
  toJSON OtrChatMessageEvent {..} =
    Core.object
      ( Core.catMaybes
          [ ("expirationTimestampUsec" Core..=)
              Core.. Core.AsText
              Core.<$> expirationTimestampUsec,
            ("kansasRowId" Core..=) Core.<$> kansasRowId,
            ("kansasVersionInfo" Core..=)
              Core.<$> kansasVersionInfo,
            ("messageOtrStatus" Core..=)
              Core.<$> messageOtrStatus
          ]
      )

--
-- /See:/ 'newOtrModificationEvent' smart constructor.
data OtrModificationEvent = OtrModificationEvent
  { -- |
    newOtrStatus' :: (Core.Maybe OtrModificationEvent_NewOtrStatus),
    -- |
    newOtrToggle' :: (Core.Maybe OtrModificationEvent_NewOtrToggle),
    -- |
    oldOtrStatus :: (Core.Maybe OtrModificationEvent_OldOtrStatus),
    -- |
    oldOtrToggle :: (Core.Maybe OtrModificationEvent_OldOtrToggle)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'OtrModificationEvent' with the minimum fields required to make a request.
newOtrModificationEvent ::
  OtrModificationEvent
newOtrModificationEvent =
  OtrModificationEvent
    { newOtrStatus' = Core.Nothing,
      newOtrToggle' = Core.Nothing,
      oldOtrStatus = Core.Nothing,
      oldOtrToggle = Core.Nothing
    }

instance Core.FromJSON OtrModificationEvent where
  parseJSON =
    Core.withObject
      "OtrModificationEvent"
      ( \o ->
          OtrModificationEvent
            Core.<$> (o Core..:? "newOtrStatus")
            Core.<*> (o Core..:? "newOtrToggle")
            Core.<*> (o Core..:? "oldOtrStatus")
            Core.<*> (o Core..:? "oldOtrToggle")
      )

instance Core.ToJSON OtrModificationEvent where
  toJSON OtrModificationEvent {..} =
    Core.object
      ( Core.catMaybes
          [ ("newOtrStatus" Core..=) Core.<$> newOtrStatus',
            ("newOtrToggle" Core..=) Core.<$> newOtrToggle',
            ("oldOtrStatus" Core..=) Core.<$> oldOtrStatus,
            ("oldOtrToggle" Core..=) Core.<$> oldOtrToggle
          ]
      )

-- | Developers register a client in Google API Console to get the deep-linking feature on Google+ posts or frames about their apps. The client data is stored in this proto.
--
-- /See:/ 'newPackagingServiceClient' smart constructor.
data PackagingServiceClient = PackagingServiceClient
  { -- | Android app\'s package name to generate the deep-link URI.
    androidPackageName :: (Core.Maybe Core.Text),
    -- | iOS app\'s App Store ID to generate the App Store URL when app is not installed on device.
    iosAppStoreId :: (Core.Maybe Core.Text),
    -- | iOS app\'s bundle ID to generate the deep-link URI.
    iosBundleId :: (Core.Maybe Core.Text),
    -- | Type of Google API Console client.
    type' :: (Core.Maybe PackagingServiceClient_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'PackagingServiceClient' with the minimum fields required to make a request.
newPackagingServiceClient ::
  PackagingServiceClient
newPackagingServiceClient =
  PackagingServiceClient
    { androidPackageName = Core.Nothing,
      iosAppStoreId = Core.Nothing,
      iosBundleId = Core.Nothing,
      type' = Core.Nothing
    }

instance Core.FromJSON PackagingServiceClient where
  parseJSON =
    Core.withObject
      "PackagingServiceClient"
      ( \o ->
          PackagingServiceClient
            Core.<$> (o Core..:? "androidPackageName")
            Core.<*> (o Core..:? "iosAppStoreId")
            Core.<*> (o Core..:? "iosBundleId")
            Core.<*> (o Core..:? "type")
      )

instance Core.ToJSON PackagingServiceClient where
  toJSON PackagingServiceClient {..} =
    Core.object
      ( Core.catMaybes
          [ ("androidPackageName" Core..=)
              Core.<$> androidPackageName,
            ("iosAppStoreId" Core..=) Core.<$> iosAppStoreId,
            ("iosBundleId" Core..=) Core.<$> iosBundleId,
            ("type" Core..=) Core.<$> type'
          ]
      )

-- | Information provided to clients so that they can show upgrade promos and warnings on call ending early (for non-paying users).
--
-- /See:/ 'newPaygateInfo' smart constructor.
data PaygateInfo = PaygateInfo
  { -- | Time when client should show message that the call is ending soon.
    callEndingSoonWarningTime :: (Core.Maybe Core.DateTime),
    -- | Time when the call will end if the user does not upgrade (after in-call upgrade support check has been implemented).
    callEndingTime :: (Core.Maybe Core.DateTime),
    -- | This boolean is used by clients to decide whether the user should be shown promos to upgrade.
    showUpgradePromos :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'PaygateInfo' with the minimum fields required to make a request.
newPaygateInfo ::
  PaygateInfo
newPaygateInfo =
  PaygateInfo
    { callEndingSoonWarningTime = Core.Nothing,
      callEndingTime = Core.Nothing,
      showUpgradePromos = Core.Nothing
    }

instance Core.FromJSON PaygateInfo where
  parseJSON =
    Core.withObject
      "PaygateInfo"
      ( \o ->
          PaygateInfo
            Core.<$> (o Core..:? "callEndingSoonWarningTime")
            Core.<*> (o Core..:? "callEndingTime")
            Core.<*> (o Core..:? "showUpgradePromos")
      )

instance Core.ToJSON PaygateInfo where
  toJSON PaygateInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("callEndingSoonWarningTime" Core..=)
              Core.<$> callEndingSoonWarningTime,
            ("callEndingTime" Core..=) Core.<$> callEndingTime,
            ("showUpgradePromos" Core..=)
              Core.<$> showUpgradePromos
          ]
      )

-- | This field contains information about the person being suggested.
--
-- /See:/ 'newPeopleSuggestion' smart constructor.
newtype PeopleSuggestion = PeopleSuggestion
  { -- | Suggested person. All fields of the person object might not be populated.
    person :: (Core.Maybe Person)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'PeopleSuggestion' with the minimum fields required to make a request.
newPeopleSuggestion ::
  PeopleSuggestion
newPeopleSuggestion = PeopleSuggestion {person = Core.Nothing}

instance Core.FromJSON PeopleSuggestion where
  parseJSON =
    Core.withObject
      "PeopleSuggestion"
      ( \o ->
          PeopleSuggestion Core.<$> (o Core..:? "person")
      )

instance Core.ToJSON PeopleSuggestion where
  toJSON PeopleSuggestion {..} =
    Core.object
      (Core.catMaybes [("person" Core..=) Core.<$> person])

-- | Object to represent a person.
--
-- /See:/ 'newPerson' smart constructor.
data Person = Person
  { -- | The person\'s email addresses
    emailAddresses :: (Core.Maybe [EmailAddress]),
    -- | The resource name of the person to provide information about. See <https://developers.google.com/people/api/rest/v1/people/get People.get> from the Google People API.
    name :: (Core.Maybe Core.Text),
    -- | Obfuscated ID of a person.
    obfuscatedId :: (Core.Maybe Core.Text),
    -- | The person\'s name
    personNames :: (Core.Maybe [Name]),
    -- | The person\'s phone numbers
    phoneNumbers :: (Core.Maybe [PhoneNumber]),
    -- | A person\'s read-only photo. A picture shown next to the person\'s name to help others recognize the person in search results.
    photos :: (Core.Maybe [Photo])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Person' with the minimum fields required to make a request.
newPerson ::
  Person
newPerson =
  Person
    { emailAddresses = Core.Nothing,
      name = Core.Nothing,
      obfuscatedId = Core.Nothing,
      personNames = Core.Nothing,
      phoneNumbers = Core.Nothing,
      photos = Core.Nothing
    }

instance Core.FromJSON Person where
  parseJSON =
    Core.withObject
      "Person"
      ( \o ->
          Person
            Core.<$> (o Core..:? "emailAddresses")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "obfuscatedId")
            Core.<*> (o Core..:? "personNames")
            Core.<*> (o Core..:? "phoneNumbers")
            Core.<*> (o Core..:? "photos")
      )

instance Core.ToJSON Person where
  toJSON Person {..} =
    Core.object
      ( Core.catMaybes
          [ ("emailAddresses" Core..=) Core.<$> emailAddresses,
            ("name" Core..=) Core.<$> name,
            ("obfuscatedId" Core..=) Core.<$> obfuscatedId,
            ("personNames" Core..=) Core.<$> personNames,
            ("phoneNumbers" Core..=) Core.<$> phoneNumbers,
            ("photos" Core..=) Core.<$> photos
          ]
      )

-- | An individual instance (or \"tag\") of a label configured as a personal type that\'s associated with a message.
--
-- /See:/ 'newPersonalLabelTag' smart constructor.
newtype PersonalLabelTag = PersonalLabelTag
  { -- | A string ID representing the label. Possible ID values are documented at go\/chat-labels-howto:ids. Examples: \"^t\" for \"Starred\", \"^nu\" for \"Nudged\".
    labelId :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'PersonalLabelTag' with the minimum fields required to make a request.
newPersonalLabelTag ::
  PersonalLabelTag
newPersonalLabelTag = PersonalLabelTag {labelId = Core.Nothing}

instance Core.FromJSON PersonalLabelTag where
  parseJSON =
    Core.withObject
      "PersonalLabelTag"
      ( \o ->
          PersonalLabelTag Core.<$> (o Core..:? "labelId")
      )

instance Core.ToJSON PersonalLabelTag where
  toJSON PersonalLabelTag {..} =
    Core.object
      ( Core.catMaybes
          [("labelId" Core..=) Core.<$> labelId]
      )

-- | Phone access contains information required to dial into a conference using a regional phone number and a PIN that is specific to that phone number.
--
-- /See:/ 'newPhoneAccess' smart constructor.
data PhoneAccess = PhoneAccess
  { -- | The phone number to dial for this meeting space in INTERNATIONAL format. Full phone number with a leading \'+\' character and whitespace separations.
    formattedPhoneNumber :: (Core.Maybe Core.Text),
    -- | The BCP 47\/LDML language code for the language associated with this phone access. To be parsed by the i18n LanguageCode utility. Examples: \"es-419\" for Latin American Spanish, \"fr-CA\" for Canadian French.
    languageCode :: (Core.Maybe Core.Text),
    -- | The phone number to dial for this meeting space in E.164 format. Full phone number with a leading \'+\' character.
    phoneNumber :: (Core.Maybe Core.Text),
    -- | The PIN that users must enter after dialing the given number. The PIN consists of only decimal digits and the length may vary.
    pin :: (Core.Maybe Core.Text),
    -- | The CLDR\/ISO 3166 region code for the country associated with this phone access. To be parsed by the i18n RegionCode utility. Example: \"SE\" for Sweden.
    regionCode :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'PhoneAccess' with the minimum fields required to make a request.
newPhoneAccess ::
  PhoneAccess
newPhoneAccess =
  PhoneAccess
    { formattedPhoneNumber = Core.Nothing,
      languageCode = Core.Nothing,
      phoneNumber = Core.Nothing,
      pin = Core.Nothing,
      regionCode = Core.Nothing
    }

instance Core.FromJSON PhoneAccess where
  parseJSON =
    Core.withObject
      "PhoneAccess"
      ( \o ->
          PhoneAccess
            Core.<$> (o Core..:? "formattedPhoneNumber")
            Core.<*> (o Core..:? "languageCode")
            Core.<*> (o Core..:? "phoneNumber")
            Core.<*> (o Core..:? "pin")
            Core.<*> (o Core..:? "regionCode")
      )

instance Core.ToJSON PhoneAccess where
  toJSON PhoneAccess {..} =
    Core.object
      ( Core.catMaybes
          [ ("formattedPhoneNumber" Core..=)
              Core.<$> formattedPhoneNumber,
            ("languageCode" Core..=) Core.<$> languageCode,
            ("phoneNumber" Core..=) Core.<$> phoneNumber,
            ("pin" Core..=) Core.<$> pin,
            ("regionCode" Core..=) Core.<$> regionCode
          ]
      )

-- | A person\'s Phone Number
--
-- /See:/ 'newPhoneNumber' smart constructor.
data PhoneNumber = PhoneNumber
  { -- | The phone number of the person.
    phoneNumber :: (Core.Maybe Core.Text),
    -- |
    type' :: (Core.Maybe PhoneNumber_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'PhoneNumber' with the minimum fields required to make a request.
newPhoneNumber ::
  PhoneNumber
newPhoneNumber = PhoneNumber {phoneNumber = Core.Nothing, type' = Core.Nothing}

instance Core.FromJSON PhoneNumber where
  parseJSON =
    Core.withObject
      "PhoneNumber"
      ( \o ->
          PhoneNumber
            Core.<$> (o Core..:? "phoneNumber")
            Core.<*> (o Core..:? "type")
      )

instance Core.ToJSON PhoneNumber where
  toJSON PhoneNumber {..} =
    Core.object
      ( Core.catMaybes
          [ ("phoneNumber" Core..=) Core.<$> phoneNumber,
            ("type" Core..=) Core.<$> type'
          ]
      )

-- | A person\'s photo.
--
-- /See:/ 'newPhoto' smart constructor.
newtype Photo = Photo
  { -- | The URL of the photo.
    url :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Photo' with the minimum fields required to make a request.
newPhoto ::
  Photo
newPhoto = Photo {url = Core.Nothing}

instance Core.FromJSON Photo where
  parseJSON =
    Core.withObject
      "Photo"
      (\o -> Photo Core.<$> (o Core..:? "url"))

instance Core.ToJSON Photo where
  toJSON Photo {..} =
    Core.object
      (Core.catMaybes [("url" Core..=) Core.<$> url])

--
-- /See:/ 'newPinnedItemId' smart constructor.
newtype PinnedItemId = PinnedItemId
  { -- | Identifier for a Drive file (e.g. Docs, Sheets, Slides).
    driveId :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'PinnedItemId' with the minimum fields required to make a request.
newPinnedItemId ::
  PinnedItemId
newPinnedItemId = PinnedItemId {driveId = Core.Nothing}

instance Core.FromJSON PinnedItemId where
  parseJSON =
    Core.withObject
      "PinnedItemId"
      (\o -> PinnedItemId Core.<$> (o Core..:? "driveId"))

instance Core.ToJSON PinnedItemId where
  toJSON PinnedItemId {..} =
    Core.object
      ( Core.catMaybes
          [("driveId" Core..=) Core.<$> driveId]
      )

--
-- /See:/ 'newPollItemsRequest' smart constructor.
data PollItemsRequest = PollItemsRequest
  { -- | The name of connector making this call. Format: datasources\/{source_id}\/connectors\/{ID}
    connectorName :: (Core.Maybe Core.Text),
    -- | Common debug options.
    debugOptions :: (Core.Maybe DebugOptions),
    -- | Maximum number of items to return. The maximum value is 100 and the default value is 20.
    limit :: (Core.Maybe Core.Int32),
    -- | Queue name to fetch items from. If unspecified, PollItems will fetch from \'default\' queue. The maximum length is 100 characters.
    queue :: (Core.Maybe Core.Text),
    -- | Limit the items polled to the ones with these statuses.
    statusCodes :: (Core.Maybe [PollItemsRequest_StatusCodesItem])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'PollItemsRequest' with the minimum fields required to make a request.
newPollItemsRequest ::
  PollItemsRequest
newPollItemsRequest =
  PollItemsRequest
    { connectorName = Core.Nothing,
      debugOptions = Core.Nothing,
      limit = Core.Nothing,
      queue = Core.Nothing,
      statusCodes = Core.Nothing
    }

instance Core.FromJSON PollItemsRequest where
  parseJSON =
    Core.withObject
      "PollItemsRequest"
      ( \o ->
          PollItemsRequest
            Core.<$> (o Core..:? "connectorName")
            Core.<*> (o Core..:? "debugOptions")
            Core.<*> (o Core..:? "limit")
            Core.<*> (o Core..:? "queue")
            Core.<*> (o Core..:? "statusCodes")
      )

instance Core.ToJSON PollItemsRequest where
  toJSON PollItemsRequest {..} =
    Core.object
      ( Core.catMaybes
          [ ("connectorName" Core..=) Core.<$> connectorName,
            ("debugOptions" Core..=) Core.<$> debugOptions,
            ("limit" Core..=) Core.<$> limit,
            ("queue" Core..=) Core.<$> queue,
            ("statusCodes" Core..=) Core.<$> statusCodes
          ]
      )

--
-- /See:/ 'newPollItemsResponse' smart constructor.
newtype PollItemsResponse = PollItemsResponse
  { -- | Set of items from the queue available for connector to process. These items have the following subset of fields populated: version metadata.hash structured_data.hash content.hash payload status queue
    items :: (Core.Maybe [Item])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'PollItemsResponse' with the minimum fields required to make a request.
newPollItemsResponse ::
  PollItemsResponse
newPollItemsResponse = PollItemsResponse {items = Core.Nothing}

instance Core.FromJSON PollItemsResponse where
  parseJSON =
    Core.withObject
      "PollItemsResponse"
      ( \o ->
          PollItemsResponse Core.<$> (o Core..:? "items")
      )

instance Core.ToJSON PollItemsResponse where
  toJSON PollItemsResponse {..} =
    Core.object
      (Core.catMaybes [("items" Core..=) Core.<$> items])

-- | This message contains either the device model, or a prefix of the device model (AKA a trimmed device model). The \"is_trimmed\" field indicates which one it is.
--
-- /See:/ 'newPossiblyTrimmedModel' smart constructor.
data PossiblyTrimmedModel = PossiblyTrimmedModel
  { -- |
    isTrimmed :: (Core.Maybe Core.Bool),
    -- |
    model :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'PossiblyTrimmedModel' with the minimum fields required to make a request.
newPossiblyTrimmedModel ::
  PossiblyTrimmedModel
newPossiblyTrimmedModel =
  PossiblyTrimmedModel {isTrimmed = Core.Nothing, model = Core.Nothing}

instance Core.FromJSON PossiblyTrimmedModel where
  parseJSON =
    Core.withObject
      "PossiblyTrimmedModel"
      ( \o ->
          PossiblyTrimmedModel
            Core.<$> (o Core..:? "isTrimmed")
            Core.<*> (o Core..:? "model")
      )

instance Core.ToJSON PossiblyTrimmedModel where
  toJSON PossiblyTrimmedModel {..} =
    Core.object
      ( Core.catMaybes
          [ ("isTrimmed" Core..=) Core.<$> isTrimmed,
            ("model" Core..=) Core.<$> model
          ]
      )

-- | See http:\/\/s\/?fileprint=\/\/depot\/google3\/security\/authentication\/postini\/auth_token.proto
--
-- /See:/ 'newPostiniUserProto' smart constructor.
newtype PostiniUserProto = PostiniUserProto
  { -- |
    postiniUserId :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'PostiniUserProto' with the minimum fields required to make a request.
newPostiniUserProto ::
  PostiniUserProto
newPostiniUserProto = PostiniUserProto {postiniUserId = Core.Nothing}

instance Core.FromJSON PostiniUserProto where
  parseJSON =
    Core.withObject
      "PostiniUserProto"
      ( \o ->
          PostiniUserProto
            Core.<$> ( o Core..:? "postiniUserId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON PostiniUserProto where
  toJSON PostiniUserProto {..} =
    Core.object
      ( Core.catMaybes
          [ ("postiniUserId" Core..=) Core.. Core.AsText
              Core.<$> postiniUserId
          ]
      )

-- | State of the thread previous to the update. This really just describes the label state of all messages before the update.
--
-- /See:/ 'newPreState' smart constructor.
data PreState = PreState
  { -- |
    labelIds :: (Core.Maybe [Core.Text]),
    -- |
    messageKey :: (Core.Maybe MultiKey),
    -- | Note that there can be fewer sync ids than label ids.
    syncIds :: (Core.Maybe [Core.Word32]),
    -- |
    threadKey :: (Core.Maybe MultiKey)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'PreState' with the minimum fields required to make a request.
newPreState ::
  PreState
newPreState =
  PreState
    { labelIds = Core.Nothing,
      messageKey = Core.Nothing,
      syncIds = Core.Nothing,
      threadKey = Core.Nothing
    }

instance Core.FromJSON PreState where
  parseJSON =
    Core.withObject
      "PreState"
      ( \o ->
          PreState
            Core.<$> (o Core..:? "labelIds")
            Core.<*> (o Core..:? "messageKey")
            Core.<*> (o Core..:? "syncIds")
            Core.<*> (o Core..:? "threadKey")
      )

instance Core.ToJSON PreState where
  toJSON PreState {..} =
    Core.object
      ( Core.catMaybes
          [ ("labelIds" Core..=) Core.<$> labelIds,
            ("messageKey" Core..=) Core.<$> messageKey,
            ("syncIds" Core..=) Core.<$> syncIds,
            ("threadKey" Core..=) Core.<$> threadKey
          ]
      )

-- | PREF_DELETED
--
-- /See:/ 'newPrefDeleted' smart constructor.
data PrefDeleted = PrefDeleted
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'PrefDeleted' with the minimum fields required to make a request.
newPrefDeleted ::
  PrefDeleted
newPrefDeleted = PrefDeleted

instance Core.FromJSON PrefDeleted where
  parseJSON =
    Core.withObject
      "PrefDeleted"
      (\o -> Core.pure PrefDeleted)

instance Core.ToJSON PrefDeleted where
  toJSON = Core.const Core.emptyObject

-- | HistoryRecord for changes associated with prefs, namely: PREF/WRITTEN PREF/DELETED
--
-- /See:/ 'newPrefUpdate' smart constructor.
data PrefUpdate = PrefUpdate
  { -- | Name of the affected preference.
    name :: (Core.Maybe Core.Text),
    -- |
    preState :: (Core.Maybe FuseboxPrefUpdatePreState),
    -- |
    prefDeleted :: (Core.Maybe PrefDeleted),
    -- |
    prefWritten :: (Core.Maybe PrefWritten)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'PrefUpdate' with the minimum fields required to make a request.
newPrefUpdate ::
  PrefUpdate
newPrefUpdate =
  PrefUpdate
    { name = Core.Nothing,
      preState = Core.Nothing,
      prefDeleted = Core.Nothing,
      prefWritten = Core.Nothing
    }

instance Core.FromJSON PrefUpdate where
  parseJSON =
    Core.withObject
      "PrefUpdate"
      ( \o ->
          PrefUpdate
            Core.<$> (o Core..:? "name")
            Core.<*> (o Core..:? "preState")
            Core.<*> (o Core..:? "prefDeleted")
            Core.<*> (o Core..:? "prefWritten")
      )

instance Core.ToJSON PrefUpdate where
  toJSON PrefUpdate {..} =
    Core.object
      ( Core.catMaybes
          [ ("name" Core..=) Core.<$> name,
            ("preState" Core..=) Core.<$> preState,
            ("prefDeleted" Core..=) Core.<$> prefDeleted,
            ("prefWritten" Core..=) Core.<$> prefWritten
          ]
      )

-- | PREF_WRITTEN
--
-- /See:/ 'newPrefWritten' smart constructor.
newtype PrefWritten = PrefWritten
  { -- |
    value :: (Core.Maybe Core.Base64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'PrefWritten' with the minimum fields required to make a request.
newPrefWritten ::
  PrefWritten
newPrefWritten = PrefWritten {value = Core.Nothing}

instance Core.FromJSON PrefWritten where
  parseJSON =
    Core.withObject
      "PrefWritten"
      (\o -> PrefWritten Core.<$> (o Core..:? "value"))

instance Core.ToJSON PrefWritten where
  toJSON PrefWritten {..} =
    Core.object
      (Core.catMaybes [("value" Core..=) Core.<$> value])

-- | Presenter contains information about which device is currently presenting as well as which device requested the presenter to be set.
--
-- /See:/ 'newPresenter' smart constructor.
data Presenter = Presenter
  { -- | The device resource name of the device which requested the current presenter to be set. This field can not be modified by clients.
    byDeviceId :: (Core.Maybe Core.Text),
    -- | The device resource names of other devices which can control the current presentation.
    copresenterDeviceIds :: (Core.Maybe [Core.Text]),
    -- | The device resource name of the currently presenting device.
    presenterDeviceId :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Presenter' with the minimum fields required to make a request.
newPresenter ::
  Presenter
newPresenter =
  Presenter
    { byDeviceId = Core.Nothing,
      copresenterDeviceIds = Core.Nothing,
      presenterDeviceId = Core.Nothing
    }

instance Core.FromJSON Presenter where
  parseJSON =
    Core.withObject
      "Presenter"
      ( \o ->
          Presenter
            Core.<$> (o Core..:? "byDeviceId")
            Core.<*> (o Core..:? "copresenterDeviceIds")
            Core.<*> (o Core..:? "presenterDeviceId")
      )

instance Core.ToJSON Presenter where
  toJSON Presenter {..} =
    Core.object
      ( Core.catMaybes
          [ ("byDeviceId" Core..=) Core.<$> byDeviceId,
            ("copresenterDeviceIds" Core..=)
              Core.<$> copresenterDeviceIds,
            ("presenterDeviceId" Core..=)
              Core.<$> presenterDeviceId
          ]
      )

-- | Reference to a user, group, or domain.
--
-- /See:/ 'newPrincipal' smart constructor.
data Principal = Principal
  { -- | This principal is a group identified using an external identity. The name field must specify the group resource name with this format: identitysources\/{source_id}\/groups\/{ID}
    groupResourceName :: (Core.Maybe Core.Text),
    -- | This principal is a Google Workspace user, group or domain.
    gsuitePrincipal :: (Core.Maybe GSuitePrincipal),
    -- | This principal is a user identified using an external identity. The name field must specify the user resource name with this format: identitysources\/{source_id}\/users\/{ID}
    userResourceName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Principal' with the minimum fields required to make a request.
newPrincipal ::
  Principal
newPrincipal =
  Principal
    { groupResourceName = Core.Nothing,
      gsuitePrincipal = Core.Nothing,
      userResourceName = Core.Nothing
    }

instance Core.FromJSON Principal where
  parseJSON =
    Core.withObject
      "Principal"
      ( \o ->
          Principal
            Core.<$> (o Core..:? "groupResourceName")
            Core.<*> (o Core..:? "gsuitePrincipal")
            Core.<*> (o Core..:? "userResourceName")
      )

instance Core.ToJSON Principal where
  toJSON Principal {..} =
    Core.object
      ( Core.catMaybes
          [ ("groupResourceName" Core..=)
              Core.<$> groupResourceName,
            ("gsuitePrincipal" Core..=) Core.<$> gsuitePrincipal,
            ("userResourceName" Core..=)
              Core.<$> userResourceName
          ]
      )

-- | A Principal represents something to which permissions are assigned, often but not always a user or group of some kind. It is most appropriate for use in ACLs and authorization checks. Callers should prefer to use the wrapper classes in google3\/security\/credentials\/public\/principal.h google3\/java\/com\/google\/security\/credentials\/Principal.java google3\/security\/credentials\/go\/principal.go unless direct proto access is essential. If you update this protocol buffer, please update the wrapper classes as well. LINT.IfChange
--
-- /See:/ 'newPrincipalProto' smart constructor.
data PrincipalProto = PrincipalProto
  { -- | scope = ALL/AUTHENTICATED/USERS
    allAuthenticatedUsers :: (Core.Maybe AllAuthenticatedUsersProto),
    -- | scope = CAP/TOKEN/HOLDER
    capTokenHolder :: (Core.Maybe CapTokenHolderProto),
    -- | scope = CHAT
    chat :: (Core.Maybe ChatProto),
    -- | scope = CIRCLE
    circle :: (Core.Maybe CircleProto),
    -- | scope = CLOUD_PRINCIPAL
    cloudPrincipal :: (Core.Maybe CloudPrincipalProto),
    -- | scope = CONTACT_GROUP
    contactGroup :: (Core.Maybe ContactGroupProto),
    -- | scope = EMAIL_OWNER
    emailOwner :: (Core.Maybe EmailOwnerProto),
    -- | scope = EVENT
    event :: (Core.Maybe EventProto),
    -- | scope = GAIA_GROUP
    gaiaGroup :: (Core.Maybe GaiaGroupProto),
    -- | scope = GAIA_USER
    gaiaUser :: (Core.Maybe GaiaUserProto),
    -- | scope = HOST
    host :: (Core.Maybe HostProto),
    -- | scope = LDAP_GROUP
    ldapGroup :: (Core.Maybe LdapGroupProto),
    -- | scope = LDAP_USER
    ldapUser :: (Core.Maybe LdapUserProto),
    -- | scope = MDB_GROUP
    mdbGroup :: (Core.Maybe MdbGroupProto),
    -- | scope = MDB_USER
    mdbUser :: (Core.Maybe MdbUserProto),
    -- | scope = OAUTH_CONSUMER;
    oauthConsumer :: (Core.Maybe OAuthConsumerProto),
    -- | scope = POSTINI_USER
    postiniUser :: (Core.Maybe PostiniUserProto),
    -- | scope = RBAC_ROLE
    rbacRole :: (Core.Maybe RbacRoleProto),
    -- | scope = RBAC_SUBJECT
    rbacSubject :: (Core.Maybe RbacSubjectProto),
    -- | scope = RESOURCE_ROLE
    resourceRole :: (Core.Maybe ResourceRoleProto),
    -- | This is only optional because required enums cannot be extended. Currently required.
    scope :: (Core.Maybe PrincipalProto_Scope),
    -- | scope = SIGNING/KEY/POSSESSOR
    signingKeyPossessor :: (Core.Maybe SigningKeyPossessorProto),
    -- | scope = SIMPLE/SECRET/HOLDER
    simpleSecretHolder :: (Core.Maybe SimpleSecretHolderProto),
    -- | scope = SOCIAL/GRAPH/NODE
    socialGraphNode :: (Core.Maybe SocialGraphNodeProto),
    -- | scope = SQUARE
    square :: (Core.Maybe SquareProto),
    -- | scope = YOUTUBE_USER
    youtubeUser :: (Core.Maybe YoutubeUserProto),
    -- | scope = ZWIEBACK_SESSION
    zwiebackSession :: (Core.Maybe ZwiebackSessionProto)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'PrincipalProto' with the minimum fields required to make a request.
newPrincipalProto ::
  PrincipalProto
newPrincipalProto =
  PrincipalProto
    { allAuthenticatedUsers = Core.Nothing,
      capTokenHolder = Core.Nothing,
      chat = Core.Nothing,
      circle = Core.Nothing,
      cloudPrincipal = Core.Nothing,
      contactGroup = Core.Nothing,
      emailOwner = Core.Nothing,
      event = Core.Nothing,
      gaiaGroup = Core.Nothing,
      gaiaUser = Core.Nothing,
      host = Core.Nothing,
      ldapGroup = Core.Nothing,
      ldapUser = Core.Nothing,
      mdbGroup = Core.Nothing,
      mdbUser = Core.Nothing,
      oauthConsumer = Core.Nothing,
      postiniUser = Core.Nothing,
      rbacRole = Core.Nothing,
      rbacSubject = Core.Nothing,
      resourceRole = Core.Nothing,
      scope = Core.Nothing,
      signingKeyPossessor = Core.Nothing,
      simpleSecretHolder = Core.Nothing,
      socialGraphNode = Core.Nothing,
      square = Core.Nothing,
      youtubeUser = Core.Nothing,
      zwiebackSession = Core.Nothing
    }

instance Core.FromJSON PrincipalProto where
  parseJSON =
    Core.withObject
      "PrincipalProto"
      ( \o ->
          PrincipalProto
            Core.<$> (o Core..:? "allAuthenticatedUsers")
            Core.<*> (o Core..:? "capTokenHolder")
            Core.<*> (o Core..:? "chat")
            Core.<*> (o Core..:? "circle")
            Core.<*> (o Core..:? "cloudPrincipal")
            Core.<*> (o Core..:? "contactGroup")
            Core.<*> (o Core..:? "emailOwner")
            Core.<*> (o Core..:? "event")
            Core.<*> (o Core..:? "gaiaGroup")
            Core.<*> (o Core..:? "gaiaUser")
            Core.<*> (o Core..:? "host")
            Core.<*> (o Core..:? "ldapGroup")
            Core.<*> (o Core..:? "ldapUser")
            Core.<*> (o Core..:? "mdbGroup")
            Core.<*> (o Core..:? "mdbUser")
            Core.<*> (o Core..:? "oauthConsumer")
            Core.<*> (o Core..:? "postiniUser")
            Core.<*> (o Core..:? "rbacRole")
            Core.<*> (o Core..:? "rbacSubject")
            Core.<*> (o Core..:? "resourceRole")
            Core.<*> (o Core..:? "scope")
            Core.<*> (o Core..:? "signingKeyPossessor")
            Core.<*> (o Core..:? "simpleSecretHolder")
            Core.<*> (o Core..:? "socialGraphNode")
            Core.<*> (o Core..:? "square")
            Core.<*> (o Core..:? "youtubeUser")
            Core.<*> (o Core..:? "zwiebackSession")
      )

instance Core.ToJSON PrincipalProto where
  toJSON PrincipalProto {..} =
    Core.object
      ( Core.catMaybes
          [ ("allAuthenticatedUsers" Core..=)
              Core.<$> allAuthenticatedUsers,
            ("capTokenHolder" Core..=) Core.<$> capTokenHolder,
            ("chat" Core..=) Core.<$> chat,
            ("circle" Core..=) Core.<$> circle,
            ("cloudPrincipal" Core..=) Core.<$> cloudPrincipal,
            ("contactGroup" Core..=) Core.<$> contactGroup,
            ("emailOwner" Core..=) Core.<$> emailOwner,
            ("event" Core..=) Core.<$> event,
            ("gaiaGroup" Core..=) Core.<$> gaiaGroup,
            ("gaiaUser" Core..=) Core.<$> gaiaUser,
            ("host" Core..=) Core.<$> host,
            ("ldapGroup" Core..=) Core.<$> ldapGroup,
            ("ldapUser" Core..=) Core.<$> ldapUser,
            ("mdbGroup" Core..=) Core.<$> mdbGroup,
            ("mdbUser" Core..=) Core.<$> mdbUser,
            ("oauthConsumer" Core..=) Core.<$> oauthConsumer,
            ("postiniUser" Core..=) Core.<$> postiniUser,
            ("rbacRole" Core..=) Core.<$> rbacRole,
            ("rbacSubject" Core..=) Core.<$> rbacSubject,
            ("resourceRole" Core..=) Core.<$> resourceRole,
            ("scope" Core..=) Core.<$> scope,
            ("signingKeyPossessor" Core..=)
              Core.<$> signingKeyPossessor,
            ("simpleSecretHolder" Core..=)
              Core.<$> simpleSecretHolder,
            ("socialGraphNode" Core..=) Core.<$> socialGraphNode,
            ("square" Core..=) Core.<$> square,
            ("youtubeUser" Core..=) Core.<$> youtubeUser,
            ("zwiebackSession" Core..=)
              Core.<$> zwiebackSession
          ]
      )

-- | Private message information specific to a given user. DEPRECATED: Use the privateMessageViewer field in CreateMessageInfo instead.
--
-- /See:/ 'newPrivateMessageInfo' smart constructor.
data PrivateMessageInfo = PrivateMessageInfo
  { -- | Annotations private to {\@code userId}.
    annotations :: (Core.Maybe [Annotation]),
    -- | Attachments private to {\@code userId}.
    attachments :: (Core.Maybe [Attachment]),
    -- |
    contextualAddOnMarkup :: (Core.Maybe [GoogleChatV1ContextualAddOnMarkup]),
    -- |
    gsuiteIntegrationMetadata :: (Core.Maybe [GsuiteIntegrationMetadata]),
    -- | Text private to {\@code user_id}. Initial restriction: Only one of public text or private text is rendered on the client. So if public text is set, private text is ignored.
    text :: (Core.Maybe Core.Text),
    -- | Required. The elements in this struct are visible to this user.
    userId :: (Core.Maybe UserId)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'PrivateMessageInfo' with the minimum fields required to make a request.
newPrivateMessageInfo ::
  PrivateMessageInfo
newPrivateMessageInfo =
  PrivateMessageInfo
    { annotations = Core.Nothing,
      attachments = Core.Nothing,
      contextualAddOnMarkup = Core.Nothing,
      gsuiteIntegrationMetadata = Core.Nothing,
      text = Core.Nothing,
      userId = Core.Nothing
    }

instance Core.FromJSON PrivateMessageInfo where
  parseJSON =
    Core.withObject
      "PrivateMessageInfo"
      ( \o ->
          PrivateMessageInfo
            Core.<$> (o Core..:? "annotations")
            Core.<*> (o Core..:? "attachments")
            Core.<*> (o Core..:? "contextualAddOnMarkup")
            Core.<*> (o Core..:? "gsuiteIntegrationMetadata")
            Core.<*> (o Core..:? "text")
            Core.<*> (o Core..:? "userId")
      )

instance Core.ToJSON PrivateMessageInfo where
  toJSON PrivateMessageInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("annotations" Core..=) Core.<$> annotations,
            ("attachments" Core..=) Core.<$> attachments,
            ("contextualAddOnMarkup" Core..=)
              Core.<$> contextualAddOnMarkup,
            ("gsuiteIntegrationMetadata" Core..=)
              Core.<$> gsuiteIntegrationMetadata,
            ("text" Core..=) Core.<$> text,
            ("userId" Core..=) Core.<$> userId
          ]
      )

--
-- /See:/ 'newProcessingError' smart constructor.
data ProcessingError = ProcessingError
  { -- | Error code indicating the nature of the error.
    code :: (Core.Maybe ProcessingError_Code),
    -- | The description of the error.
    errorMessage :: (Core.Maybe Core.Text),
    -- | In case the item fields are invalid, this field contains the details about the validation errors.
    fieldViolations :: (Core.Maybe [FieldViolation])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ProcessingError' with the minimum fields required to make a request.
newProcessingError ::
  ProcessingError
newProcessingError =
  ProcessingError
    { code = Core.Nothing,
      errorMessage = Core.Nothing,
      fieldViolations = Core.Nothing
    }

instance Core.FromJSON ProcessingError where
  parseJSON =
    Core.withObject
      "ProcessingError"
      ( \o ->
          ProcessingError
            Core.<$> (o Core..:? "code")
            Core.<*> (o Core..:? "errorMessage")
            Core.<*> (o Core..:? "fieldViolations")
      )

instance Core.ToJSON ProcessingError where
  toJSON ProcessingError {..} =
    Core.object
      ( Core.catMaybes
          [ ("code" Core..=) Core.<$> code,
            ("errorMessage" Core..=) Core.<$> errorMessage,
            ("fieldViolations" Core..=)
              Core.<$> fieldViolations
          ]
      )

-- | The definition of a property within an object.
--
-- /See:/ 'newPropertyDefinition' smart constructor.
data PropertyDefinition = PropertyDefinition
  { -- |
    booleanPropertyOptions :: (Core.Maybe BooleanPropertyOptions),
    -- |
    datePropertyOptions :: (Core.Maybe DatePropertyOptions),
    -- | The options that determine how the property is displayed in the Cloud Search results page if it\'s specified to be displayed in the object\'s display options.
    displayOptions :: (Core.Maybe PropertyDisplayOptions),
    -- |
    doublePropertyOptions :: (Core.Maybe DoublePropertyOptions),
    -- |
    enumPropertyOptions :: (Core.Maybe EnumPropertyOptions),
    -- |
    htmlPropertyOptions :: (Core.Maybe HtmlPropertyOptions),
    -- |
    integerPropertyOptions :: (Core.Maybe IntegerPropertyOptions),
    -- | Indicates that the property can be used for generating facets. Cannot be true for properties whose type is object. IsReturnable must be true to set this option. Only supported for boolean, enum, integer, and text properties.
    isFacetable :: (Core.Maybe Core.Bool),
    -- | Indicates that multiple values are allowed for the property. For example, a document only has one description but can have multiple comments. Cannot be true for properties whose type is a boolean. If set to false, properties that contain more than one value cause the indexing request for that item to be rejected.
    isRepeatable :: (Core.Maybe Core.Bool),
    -- | Indicates that the property identifies data that should be returned in search results via the Query API. If set to /true/, indicates that Query API users can use matching property fields in results. However, storing fields requires more space allocation and uses more bandwidth for search queries, which impacts performance over large datasets. Set to /true/ here only if the field is needed for search results. Cannot be true for properties whose type is an object.
    isReturnable :: (Core.Maybe Core.Bool),
    -- | Indicates that the property can be used for sorting. Cannot be true for properties that are repeatable. Cannot be true for properties whose type is object. IsReturnable must be true to set this option. Only supported for boolean, date, double, integer, and timestamp properties.
    isSortable :: (Core.Maybe Core.Bool),
    -- | Indicates that the property can be used for generating query suggestions.
    isSuggestable :: (Core.Maybe Core.Bool),
    -- | Indicates that users can perform wildcard search for this property. Only supported for Text properties. IsReturnable must be true to set this option. In a given datasource maximum of 5 properties can be marked as is/wildcard/searchable. For more details, see <https://developers.google.com/cloud-search/docs/guides/schema-guide#properties Define object properties>
    isWildcardSearchable :: (Core.Maybe Core.Bool),
    -- | The name of the property. Item indexing requests sent to the Indexing API should set the property name equal to this value. For example, if name is /subject/line/, then indexing requests for document items with subject fields should set the name for that field equal to /subject/line/. Use the name as the identifier for the object property. Once registered as a property for an object, you cannot re-use this name for another property within that object. The name must start with a letter and can only contain letters (A-Z, a-z) or numbers (0-9). The maximum length is 256 characters.
    name :: (Core.Maybe Core.Text),
    -- |
    objectPropertyOptions :: (Core.Maybe ObjectPropertyOptions),
    -- |
    textPropertyOptions :: (Core.Maybe TextPropertyOptions),
    -- |
    timestampPropertyOptions :: (Core.Maybe TimestampPropertyOptions)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'PropertyDefinition' with the minimum fields required to make a request.
newPropertyDefinition ::
  PropertyDefinition
newPropertyDefinition =
  PropertyDefinition
    { booleanPropertyOptions = Core.Nothing,
      datePropertyOptions = Core.Nothing,
      displayOptions = Core.Nothing,
      doublePropertyOptions = Core.Nothing,
      enumPropertyOptions = Core.Nothing,
      htmlPropertyOptions = Core.Nothing,
      integerPropertyOptions = Core.Nothing,
      isFacetable = Core.Nothing,
      isRepeatable = Core.Nothing,
      isReturnable = Core.Nothing,
      isSortable = Core.Nothing,
      isSuggestable = Core.Nothing,
      isWildcardSearchable = Core.Nothing,
      name = Core.Nothing,
      objectPropertyOptions = Core.Nothing,
      textPropertyOptions = Core.Nothing,
      timestampPropertyOptions = Core.Nothing
    }

instance Core.FromJSON PropertyDefinition where
  parseJSON =
    Core.withObject
      "PropertyDefinition"
      ( \o ->
          PropertyDefinition
            Core.<$> (o Core..:? "booleanPropertyOptions")
            Core.<*> (o Core..:? "datePropertyOptions")
            Core.<*> (o Core..:? "displayOptions")
            Core.<*> (o Core..:? "doublePropertyOptions")
            Core.<*> (o Core..:? "enumPropertyOptions")
            Core.<*> (o Core..:? "htmlPropertyOptions")
            Core.<*> (o Core..:? "integerPropertyOptions")
            Core.<*> (o Core..:? "isFacetable")
            Core.<*> (o Core..:? "isRepeatable")
            Core.<*> (o Core..:? "isReturnable")
            Core.<*> (o Core..:? "isSortable")
            Core.<*> (o Core..:? "isSuggestable")
            Core.<*> (o Core..:? "isWildcardSearchable")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "objectPropertyOptions")
            Core.<*> (o Core..:? "textPropertyOptions")
            Core.<*> (o Core..:? "timestampPropertyOptions")
      )

instance Core.ToJSON PropertyDefinition where
  toJSON PropertyDefinition {..} =
    Core.object
      ( Core.catMaybes
          [ ("booleanPropertyOptions" Core..=)
              Core.<$> booleanPropertyOptions,
            ("datePropertyOptions" Core..=)
              Core.<$> datePropertyOptions,
            ("displayOptions" Core..=) Core.<$> displayOptions,
            ("doublePropertyOptions" Core..=)
              Core.<$> doublePropertyOptions,
            ("enumPropertyOptions" Core..=)
              Core.<$> enumPropertyOptions,
            ("htmlPropertyOptions" Core..=)
              Core.<$> htmlPropertyOptions,
            ("integerPropertyOptions" Core..=)
              Core.<$> integerPropertyOptions,
            ("isFacetable" Core..=) Core.<$> isFacetable,
            ("isRepeatable" Core..=) Core.<$> isRepeatable,
            ("isReturnable" Core..=) Core.<$> isReturnable,
            ("isSortable" Core..=) Core.<$> isSortable,
            ("isSuggestable" Core..=) Core.<$> isSuggestable,
            ("isWildcardSearchable" Core..=)
              Core.<$> isWildcardSearchable,
            ("name" Core..=) Core.<$> name,
            ("objectPropertyOptions" Core..=)
              Core.<$> objectPropertyOptions,
            ("textPropertyOptions" Core..=)
              Core.<$> textPropertyOptions,
            ("timestampPropertyOptions" Core..=)
              Core.<$> timestampPropertyOptions
          ]
      )

-- | The display options for a property.
--
-- /See:/ 'newPropertyDisplayOptions' smart constructor.
newtype PropertyDisplayOptions = PropertyDisplayOptions
  { -- | The user friendly label for the property that is used if the property is specified to be displayed in ObjectDisplayOptions. If provided, the display label is shown in front of the property values when the property is part of the object display options. For example, if the property value is \'1\', the value by itself may not be useful context for the user. If the display name given was \'priority\', then the user sees \'priority : 1\' in the search results which provides clear context to search users. This is OPTIONAL; if not given, only the property values are displayed. The maximum length is 64 characters.
    displayLabel :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'PropertyDisplayOptions' with the minimum fields required to make a request.
newPropertyDisplayOptions ::
  PropertyDisplayOptions
newPropertyDisplayOptions = PropertyDisplayOptions {displayLabel = Core.Nothing}

instance Core.FromJSON PropertyDisplayOptions where
  parseJSON =
    Core.withObject
      "PropertyDisplayOptions"
      ( \o ->
          PropertyDisplayOptions
            Core.<$> (o Core..:? "displayLabel")
      )

instance Core.ToJSON PropertyDisplayOptions where
  toJSON PropertyDisplayOptions {..} =
    Core.object
      ( Core.catMaybes
          [("displayLabel" Core..=) Core.<$> displayLabel]
      )

-- | This field records where the ItemScope was retrieved, if it was created via a web fetch.
--
-- /See:/ 'newProvenance' smart constructor.
data Provenance = Provenance
  { -- | Annotation blob from Annotation Service.
    annotationBlob :: (Core.Maybe Core.Base64),
    -- | Canonical url of the retrieved_url, if one was resolved during retrieval, for example, if a rel=\"canonical\" link tag was provided in the retrieved web page.
    canonicalUrl :: (Core.Maybe Core.Text),
    -- | The url originally passed in the PRS request, which should be used to re-discover the content. Note that this URL may be a forwarding service or link shortener (bit.ly), so it should not be assumed to be canonical, but should be used for navigation back to the original source of the itemscope.
    inputUrl :: (Core.Maybe Core.Text),
    -- | Contains exact types as parsed, whether or not we recognized that type at parse time. If an itemscope is created by merging SchemaOrg markup and open graph markup then the first itemtype would be schemaorg type, the second would be open graph and so on. example: http:\/\/schema.org\/VideoObject, og:video.movie Plain text; usually a URL
    itemtype :: (Core.Maybe [Core.Text]),
    -- | The server retrieved timestamp (in msec).
    retrievedTimestampMsec :: (Core.Maybe Core.Word64),
    -- | The final URL that was the actual source of the itemscope, after any redirects.
    retrievedUrl :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Provenance' with the minimum fields required to make a request.
newProvenance ::
  Provenance
newProvenance =
  Provenance
    { annotationBlob = Core.Nothing,
      canonicalUrl = Core.Nothing,
      inputUrl = Core.Nothing,
      itemtype = Core.Nothing,
      retrievedTimestampMsec = Core.Nothing,
      retrievedUrl = Core.Nothing
    }

instance Core.FromJSON Provenance where
  parseJSON =
    Core.withObject
      "Provenance"
      ( \o ->
          Provenance
            Core.<$> (o Core..:? "annotationBlob")
            Core.<*> (o Core..:? "canonicalUrl")
            Core.<*> (o Core..:? "inputUrl")
            Core.<*> (o Core..:? "itemtype")
            Core.<*> ( o Core..:? "retrievedTimestampMsec"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "retrievedUrl")
      )

instance Core.ToJSON Provenance where
  toJSON Provenance {..} =
    Core.object
      ( Core.catMaybes
          [ ("annotationBlob" Core..=) Core.<$> annotationBlob,
            ("canonicalUrl" Core..=) Core.<$> canonicalUrl,
            ("inputUrl" Core..=) Core.<$> inputUrl,
            ("itemtype" Core..=) Core.<$> itemtype,
            ("retrievedTimestampMsec" Core..=) Core.. Core.AsText
              Core.<$> retrievedTimestampMsec,
            ("retrievedUrl" Core..=) Core.<$> retrievedUrl
          ]
      )

-- | Represents an item to be pushed to the indexing queue.
--
-- /See:/ 'newPushItem' smart constructor.
data PushItem = PushItem
  { -- | Content hash of the item according to the repository. If specified, this is used to determine how to modify this item\'s status. Setting this field and the type field results in argument error. The maximum length is 2048 characters.
    contentHash :: (Core.Maybe Core.Text),
    -- | The metadata hash of the item according to the repository. If specified, this is used to determine how to modify this item\'s status. Setting this field and the type field results in argument error. The maximum length is 2048 characters.
    metadataHash :: (Core.Maybe Core.Text),
    -- | Provides additional document state information for the connector, such as an alternate repository ID and other metadata. The maximum length is 8192 bytes.
    payload :: (Core.Maybe Core.Base64),
    -- | Queue to which this item belongs. The @default@ queue is chosen if this field is not specified. The maximum length is 512 characters.
    queue :: (Core.Maybe Core.Text),
    -- | Populate this field to store Connector or repository error details. This information is displayed in the Admin Console. This field may only be populated when the Type is REPOSITORY_ERROR.
    repositoryError :: (Core.Maybe RepositoryError),
    -- | Structured data hash of the item according to the repository. If specified, this is used to determine how to modify this item\'s status. Setting this field and the type field results in argument error. The maximum length is 2048 characters.
    structuredDataHash :: (Core.Maybe Core.Text),
    -- | The type of the push operation that defines the push behavior.
    type' :: (Core.Maybe PushItem_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'PushItem' with the minimum fields required to make a request.
newPushItem ::
  PushItem
newPushItem =
  PushItem
    { contentHash = Core.Nothing,
      metadataHash = Core.Nothing,
      payload = Core.Nothing,
      queue = Core.Nothing,
      repositoryError = Core.Nothing,
      structuredDataHash = Core.Nothing,
      type' = Core.Nothing
    }

instance Core.FromJSON PushItem where
  parseJSON =
    Core.withObject
      "PushItem"
      ( \o ->
          PushItem
            Core.<$> (o Core..:? "contentHash")
            Core.<*> (o Core..:? "metadataHash")
            Core.<*> (o Core..:? "payload")
            Core.<*> (o Core..:? "queue")
            Core.<*> (o Core..:? "repositoryError")
            Core.<*> (o Core..:? "structuredDataHash")
            Core.<*> (o Core..:? "type")
      )

instance Core.ToJSON PushItem where
  toJSON PushItem {..} =
    Core.object
      ( Core.catMaybes
          [ ("contentHash" Core..=) Core.<$> contentHash,
            ("metadataHash" Core..=) Core.<$> metadataHash,
            ("payload" Core..=) Core.<$> payload,
            ("queue" Core..=) Core.<$> queue,
            ("repositoryError" Core..=) Core.<$> repositoryError,
            ("structuredDataHash" Core..=)
              Core.<$> structuredDataHash,
            ("type" Core..=) Core.<$> type'
          ]
      )

--
-- /See:/ 'newPushItemRequest' smart constructor.
data PushItemRequest = PushItemRequest
  { -- | The name of connector making this call. Format: datasources\/{source_id}\/connectors\/{ID}
    connectorName :: (Core.Maybe Core.Text),
    -- | Common debug options.
    debugOptions :: (Core.Maybe DebugOptions),
    -- | Item to push onto the queue.
    item :: (Core.Maybe PushItem)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'PushItemRequest' with the minimum fields required to make a request.
newPushItemRequest ::
  PushItemRequest
newPushItemRequest =
  PushItemRequest
    { connectorName = Core.Nothing,
      debugOptions = Core.Nothing,
      item = Core.Nothing
    }

instance Core.FromJSON PushItemRequest where
  parseJSON =
    Core.withObject
      "PushItemRequest"
      ( \o ->
          PushItemRequest
            Core.<$> (o Core..:? "connectorName")
            Core.<*> (o Core..:? "debugOptions")
            Core.<*> (o Core..:? "item")
      )

instance Core.ToJSON PushItemRequest where
  toJSON PushItemRequest {..} =
    Core.object
      ( Core.catMaybes
          [ ("connectorName" Core..=) Core.<$> connectorName,
            ("debugOptions" Core..=) Core.<$> debugOptions,
            ("item" Core..=) Core.<$> item
          ]
      )

--
-- /See:/ 'newQueryCountByStatus' smart constructor.
data QueryCountByStatus = QueryCountByStatus
  { -- |
    count :: (Core.Maybe Core.Int64),
    -- | This represents the http status code.
    statusCode :: (Core.Maybe Core.Int32)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'QueryCountByStatus' with the minimum fields required to make a request.
newQueryCountByStatus ::
  QueryCountByStatus
newQueryCountByStatus =
  QueryCountByStatus {count = Core.Nothing, statusCode = Core.Nothing}

instance Core.FromJSON QueryCountByStatus where
  parseJSON =
    Core.withObject
      "QueryCountByStatus"
      ( \o ->
          QueryCountByStatus
            Core.<$> ( o Core..:? "count"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "statusCode")
      )

instance Core.ToJSON QueryCountByStatus where
  toJSON QueryCountByStatus {..} =
    Core.object
      ( Core.catMaybes
          [ ("count" Core..=) Core.. Core.AsText Core.<$> count,
            ("statusCode" Core..=) Core.<$> statusCode
          ]
      )

--
-- /See:/ 'newQueryInterpretation' smart constructor.
data QueryInterpretation = QueryInterpretation
  { -- |
    interpretationType :: (Core.Maybe QueryInterpretation_InterpretationType),
    -- | The interpretation of the query used in search. For example, queries with natural language intent like \"email from john\" will be interpreted as \"from:john source:mail\". This field will not be filled when the reason is NOT/ENOUGH/RESULTS/FOUND/FOR/USER/QUERY.
    interpretedQuery :: (Core.Maybe Core.Text),
    -- | The reason for interpretation of the query. This field will not be UNSPECIFIED if the interpretation type is not NONE.
    reason :: (Core.Maybe QueryInterpretation_Reason)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'QueryInterpretation' with the minimum fields required to make a request.
newQueryInterpretation ::
  QueryInterpretation
newQueryInterpretation =
  QueryInterpretation
    { interpretationType = Core.Nothing,
      interpretedQuery = Core.Nothing,
      reason = Core.Nothing
    }

instance Core.FromJSON QueryInterpretation where
  parseJSON =
    Core.withObject
      "QueryInterpretation"
      ( \o ->
          QueryInterpretation
            Core.<$> (o Core..:? "interpretationType")
            Core.<*> (o Core..:? "interpretedQuery")
            Core.<*> (o Core..:? "reason")
      )

instance Core.ToJSON QueryInterpretation where
  toJSON QueryInterpretation {..} =
    Core.object
      ( Core.catMaybes
          [ ("interpretationType" Core..=)
              Core.<$> interpretationType,
            ("interpretedQuery" Core..=)
              Core.<$> interpretedQuery,
            ("reason" Core..=) Core.<$> reason
          ]
      )

-- | Default options to interpret user query.
--
-- /See:/ 'newQueryInterpretationConfig' smart constructor.
data QueryInterpretationConfig = QueryInterpretationConfig
  { -- | Set this flag to disable supplemental results retrieval, setting a flag here will not retrieve supplemental results for queries associated with a given search application. If this flag is set to True, it will take precedence over the option set at Query level. For the default value of False, query level flag will set the correct interpretation for supplemental results.
    forceDisableSupplementalResults :: (Core.Maybe Core.Bool),
    -- | Enable this flag to turn off all internal optimizations like natural language (NL) interpretation of queries, supplemental results retrieval, and usage of synonyms including custom ones. If this flag is set to True, it will take precedence over the option set at Query level. For the default value of False, query level flag will set the correct interpretation for verbatim mode.
    forceVerbatimMode :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'QueryInterpretationConfig' with the minimum fields required to make a request.
newQueryInterpretationConfig ::
  QueryInterpretationConfig
newQueryInterpretationConfig =
  QueryInterpretationConfig
    { forceDisableSupplementalResults = Core.Nothing,
      forceVerbatimMode = Core.Nothing
    }

instance Core.FromJSON QueryInterpretationConfig where
  parseJSON =
    Core.withObject
      "QueryInterpretationConfig"
      ( \o ->
          QueryInterpretationConfig
            Core.<$> (o Core..:? "forceDisableSupplementalResults")
            Core.<*> (o Core..:? "forceVerbatimMode")
      )

instance Core.ToJSON QueryInterpretationConfig where
  toJSON QueryInterpretationConfig {..} =
    Core.object
      ( Core.catMaybes
          [ ("forceDisableSupplementalResults" Core..=)
              Core.<$> forceDisableSupplementalResults,
            ("forceVerbatimMode" Core..=)
              Core.<$> forceVerbatimMode
          ]
      )

-- | Options to interpret user query.
--
-- /See:/ 'newQueryInterpretationOptions' smart constructor.
data QueryInterpretationOptions = QueryInterpretationOptions
  { -- | Flag to disable natural language (NL) interpretation of queries. Default is false, Set to true to disable natural language interpretation. NL interpretation only applies to predefined datasources.
    disableNlInterpretation :: (Core.Maybe Core.Bool),
    -- | Use this flag to disable supplemental results for a query. Supplemental results setting chosen at SearchApplication level will take precedence if set to True.
    disableSupplementalResults :: (Core.Maybe Core.Bool),
    -- | Enable this flag to turn off all internal optimizations like natural language (NL) interpretation of queries, supplemental result retrieval, and usage of synonyms including custom ones. Nl interpretation will be disabled if either one of the two flags is true.
    enableVerbatimMode :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'QueryInterpretationOptions' with the minimum fields required to make a request.
newQueryInterpretationOptions ::
  QueryInterpretationOptions
newQueryInterpretationOptions =
  QueryInterpretationOptions
    { disableNlInterpretation = Core.Nothing,
      disableSupplementalResults = Core.Nothing,
      enableVerbatimMode = Core.Nothing
    }

instance Core.FromJSON QueryInterpretationOptions where
  parseJSON =
    Core.withObject
      "QueryInterpretationOptions"
      ( \o ->
          QueryInterpretationOptions
            Core.<$> (o Core..:? "disableNlInterpretation")
            Core.<*> (o Core..:? "disableSupplementalResults")
            Core.<*> (o Core..:? "enableVerbatimMode")
      )

instance Core.ToJSON QueryInterpretationOptions where
  toJSON QueryInterpretationOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("disableNlInterpretation" Core..=)
              Core.<$> disableNlInterpretation,
            ("disableSupplementalResults" Core..=)
              Core.<$> disableSupplementalResults,
            ("enableVerbatimMode" Core..=)
              Core.<$> enableVerbatimMode
          ]
      )

-- | Information relevant only to a query entry.
--
-- /See:/ 'newQueryItem' smart constructor.
newtype QueryItem = QueryItem
  { -- | True if the text was generated by means other than a previous user search.
    isSynthetic :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'QueryItem' with the minimum fields required to make a request.
newQueryItem ::
  QueryItem
newQueryItem = QueryItem {isSynthetic = Core.Nothing}

instance Core.FromJSON QueryItem where
  parseJSON =
    Core.withObject
      "QueryItem"
      ( \o ->
          QueryItem Core.<$> (o Core..:? "isSynthetic")
      )

instance Core.ToJSON QueryItem where
  toJSON QueryItem {..} =
    Core.object
      ( Core.catMaybes
          [("isSynthetic" Core..=) Core.<$> isSynthetic]
      )

-- | The definition of a operator that can be used in a Search\/Suggest request.
--
-- /See:/ 'newQueryOperator' smart constructor.
data QueryOperator = QueryOperator
  { -- | Display name of the operator
    displayName :: (Core.Maybe Core.Text),
    -- | Potential list of values for the opeatror field. This field is only filled when we can safely enumerate all the possible values of this operator.
    enumValues :: (Core.Maybe [Core.Text]),
    -- | Indicates the operator name that can be used to isolate the property using the greater-than operator.
    greaterThanOperatorName :: (Core.Maybe Core.Text),
    -- | Can this operator be used to get facets.
    isFacetable :: (Core.Maybe Core.Bool),
    -- | Indicates if multiple values can be set for this property.
    isRepeatable :: (Core.Maybe Core.Bool),
    -- | Will the property associated with this facet be returned as part of search results.
    isReturnable :: (Core.Maybe Core.Bool),
    -- | Can this operator be used to sort results.
    isSortable :: (Core.Maybe Core.Bool),
    -- | Can get suggestions for this field.
    isSuggestable :: (Core.Maybe Core.Bool),
    -- | Indicates the operator name that can be used to isolate the property using the less-than operator.
    lessThanOperatorName :: (Core.Maybe Core.Text),
    -- | The name of the object corresponding to the operator. This field is only filled for schema-specific operators, and is unset for common operators.
    objectType :: (Core.Maybe Core.Text),
    -- | The name of the operator.
    operatorName :: (Core.Maybe Core.Text),
    -- | The type of the operator.
    type' :: (Core.Maybe QueryOperator_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'QueryOperator' with the minimum fields required to make a request.
newQueryOperator ::
  QueryOperator
newQueryOperator =
  QueryOperator
    { displayName = Core.Nothing,
      enumValues = Core.Nothing,
      greaterThanOperatorName = Core.Nothing,
      isFacetable = Core.Nothing,
      isRepeatable = Core.Nothing,
      isReturnable = Core.Nothing,
      isSortable = Core.Nothing,
      isSuggestable = Core.Nothing,
      lessThanOperatorName = Core.Nothing,
      objectType = Core.Nothing,
      operatorName = Core.Nothing,
      type' = Core.Nothing
    }

instance Core.FromJSON QueryOperator where
  parseJSON =
    Core.withObject
      "QueryOperator"
      ( \o ->
          QueryOperator
            Core.<$> (o Core..:? "displayName")
            Core.<*> (o Core..:? "enumValues")
            Core.<*> (o Core..:? "greaterThanOperatorName")
            Core.<*> (o Core..:? "isFacetable")
            Core.<*> (o Core..:? "isRepeatable")
            Core.<*> (o Core..:? "isReturnable")
            Core.<*> (o Core..:? "isSortable")
            Core.<*> (o Core..:? "isSuggestable")
            Core.<*> (o Core..:? "lessThanOperatorName")
            Core.<*> (o Core..:? "objectType")
            Core.<*> (o Core..:? "operatorName")
            Core.<*> (o Core..:? "type")
      )

instance Core.ToJSON QueryOperator where
  toJSON QueryOperator {..} =
    Core.object
      ( Core.catMaybes
          [ ("displayName" Core..=) Core.<$> displayName,
            ("enumValues" Core..=) Core.<$> enumValues,
            ("greaterThanOperatorName" Core..=)
              Core.<$> greaterThanOperatorName,
            ("isFacetable" Core..=) Core.<$> isFacetable,
            ("isRepeatable" Core..=) Core.<$> isRepeatable,
            ("isReturnable" Core..=) Core.<$> isReturnable,
            ("isSortable" Core..=) Core.<$> isSortable,
            ("isSuggestable" Core..=) Core.<$> isSuggestable,
            ("lessThanOperatorName" Core..=)
              Core.<$> lessThanOperatorName,
            ("objectType" Core..=) Core.<$> objectType,
            ("operatorName" Core..=) Core.<$> operatorName,
            ("type" Core..=) Core.<$> type'
          ]
      )

-- | List of sources that the user can search using the query API.
--
-- /See:/ 'newQuerySource' smart constructor.
data QuerySource = QuerySource
  { -- | Display name of the data source.
    displayName :: (Core.Maybe Core.Text),
    -- | List of all operators applicable for this source.
    operators :: (Core.Maybe [QueryOperator]),
    -- | A short name or alias for the source. This value can be used with the \'source\' operator.
    shortName :: (Core.Maybe Core.Text),
    -- | The name of the source
    source :: (Core.Maybe Source)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'QuerySource' with the minimum fields required to make a request.
newQuerySource ::
  QuerySource
newQuerySource =
  QuerySource
    { displayName = Core.Nothing,
      operators = Core.Nothing,
      shortName = Core.Nothing,
      source = Core.Nothing
    }

instance Core.FromJSON QuerySource where
  parseJSON =
    Core.withObject
      "QuerySource"
      ( \o ->
          QuerySource
            Core.<$> (o Core..:? "displayName")
            Core.<*> (o Core..:? "operators")
            Core.<*> (o Core..:? "shortName")
            Core.<*> (o Core..:? "source")
      )

instance Core.ToJSON QuerySource where
  toJSON QuerySource {..} =
    Core.object
      ( Core.catMaybes
          [ ("displayName" Core..=) Core.<$> displayName,
            ("operators" Core..=) Core.<$> operators,
            ("shortName" Core..=) Core.<$> shortName,
            ("source" Core..=) Core.<$> source
          ]
      )

-- | This field does not contain anything as of now and is just used as an indicator that the suggest result was a phrase completion.
--
-- /See:/ 'newQuerySuggestion' smart constructor.
data QuerySuggestion = QuerySuggestion
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'QuerySuggestion' with the minimum fields required to make a request.
newQuerySuggestion ::
  QuerySuggestion
newQuerySuggestion = QuerySuggestion

instance Core.FromJSON QuerySuggestion where
  parseJSON =
    Core.withObject
      "QuerySuggestion"
      (\o -> Core.pure QuerySuggestion)

instance Core.ToJSON QuerySuggestion where
  toJSON = Core.const Core.emptyObject

-- | Quote metadata: go\/message-quoting-be-dd-v2. This proto is only used on the read path. For the request proto, refer to @QuotedMessagePayload@. Fields are either derived from storage directly from the Item this metadata belongs to, or is hydrated at read time from another Item read. Note: QuotedMessageMetadata proto is similar to Message proto with less field. Reasons to differtiate QuotedMessageMetadata from Message are: 1. Not all fields for original message is applicable for quoted message. (E.g. reactions, is/inline/reply, etc.), thus separting out for confusion. 2. We don\'t support nested message quoting. For more detailed discussion, please see http:\/\/shortn\/_VsSXQb2C7P. For future reference: if your new feature\/field will be supported in message quoting feature (go\/chat-quoting-prd), you will need to add that field within QuotedMessageMetadata
--
-- /See:/ 'newQuotedMessageMetadata' smart constructor.
data QuotedMessageMetadata = QuotedMessageMetadata
  { -- | Output only. Snapshot of the annotations of the quoted message.
    annotations :: (Core.Maybe [Annotation]),
    -- | Output only. Custom display profile info for apps. Will be empty for real users.
    appProfile :: (Core.Maybe AppsDynamiteSharedAppProfile),
    -- | Output only. The bot attachment state of the quoted message. Used by clients to display a bot attachment indicator in the UI.
    botAttachmentState :: (Core.Maybe QuotedMessageMetadata_BotAttachmentState),
    -- | Output only. Time when the quoted message was posted in microseconds.
    createTimeMicros :: (Core.Maybe Core.Int64),
    -- | Output only. ID of the User who posted the quoted message. This includes information to identify if the quoted message was posted by an App on behalf of a user.
    creatorId :: (Core.Maybe UserId),
    -- | Output only. Time when the quoted message was last edited by a user at the time when quoting action happens. Time is in microseconds.
    lastEditTimeMicros :: (Core.Maybe Core.Int64),
    -- | The @last_update_time@ of the original message when the client initiated the quote creation. This is derived from the request payload passed from clients. Used to fetch the quoted message contents at a specific time on the read path. This field is populated from storage directly.
    lastUpdateTimeWhenQuotedMicros :: (Core.Maybe Core.Int64),
    -- | MessageId of the original message that is being quoted. This is derived from the request payload passed from clients. This field is populated from storage directly.
    messageId :: (Core.Maybe MessageId),
    -- | Output only. The state of the quoted message. Used by clients to display tombstones for quotes that reference a deleted message.
    messageState :: (Core.Maybe QuotedMessageMetadata_MessageState),
    -- | Output only. The retention (OTR) settings of the quoted message.
    retentionSettings :: (Core.Maybe AppsDynamiteSharedRetentionSettings),
    -- | Output only. Snapshot of the text body of the quoted message.
    textBody :: (Core.Maybe Core.Text),
    -- | Output only. ID of the User who last updated (created\/edited\/deleted) the quoted message at the time when quoting action happens. This includes information to identify if the quoted message was posted by an App on behalf of a user.
    updaterId :: (Core.Maybe UserId),
    -- | Output only. Upload metadata of the quoted message.
    uploadMetadata :: (Core.Maybe [UploadMetadata])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'QuotedMessageMetadata' with the minimum fields required to make a request.
newQuotedMessageMetadata ::
  QuotedMessageMetadata
newQuotedMessageMetadata =
  QuotedMessageMetadata
    { annotations = Core.Nothing,
      appProfile = Core.Nothing,
      botAttachmentState = Core.Nothing,
      createTimeMicros = Core.Nothing,
      creatorId = Core.Nothing,
      lastEditTimeMicros = Core.Nothing,
      lastUpdateTimeWhenQuotedMicros = Core.Nothing,
      messageId = Core.Nothing,
      messageState = Core.Nothing,
      retentionSettings = Core.Nothing,
      textBody = Core.Nothing,
      updaterId = Core.Nothing,
      uploadMetadata = Core.Nothing
    }

instance Core.FromJSON QuotedMessageMetadata where
  parseJSON =
    Core.withObject
      "QuotedMessageMetadata"
      ( \o ->
          QuotedMessageMetadata
            Core.<$> (o Core..:? "annotations")
            Core.<*> (o Core..:? "appProfile")
            Core.<*> (o Core..:? "botAttachmentState")
            Core.<*> ( o Core..:? "createTimeMicros"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "creatorId")
            Core.<*> ( o Core..:? "lastEditTimeMicros"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> ( o Core..:? "lastUpdateTimeWhenQuotedMicros"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "messageId")
            Core.<*> (o Core..:? "messageState")
            Core.<*> (o Core..:? "retentionSettings")
            Core.<*> (o Core..:? "textBody")
            Core.<*> (o Core..:? "updaterId")
            Core.<*> (o Core..:? "uploadMetadata")
      )

instance Core.ToJSON QuotedMessageMetadata where
  toJSON QuotedMessageMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("annotations" Core..=) Core.<$> annotations,
            ("appProfile" Core..=) Core.<$> appProfile,
            ("botAttachmentState" Core..=)
              Core.<$> botAttachmentState,
            ("createTimeMicros" Core..=) Core.. Core.AsText
              Core.<$> createTimeMicros,
            ("creatorId" Core..=) Core.<$> creatorId,
            ("lastEditTimeMicros" Core..=) Core.. Core.AsText
              Core.<$> lastEditTimeMicros,
            ("lastUpdateTimeWhenQuotedMicros" Core..=)
              Core.. Core.AsText
              Core.<$> lastUpdateTimeWhenQuotedMicros,
            ("messageId" Core..=) Core.<$> messageId,
            ("messageState" Core..=) Core.<$> messageState,
            ("retentionSettings" Core..=)
              Core.<$> retentionSettings,
            ("textBody" Core..=) Core.<$> textBody,
            ("updaterId" Core..=) Core.<$> updaterId,
            ("uploadMetadata" Core..=) Core.<$> uploadMetadata
          ]
      )

-- | The rank contains a tuple of numbers which may be used as a general sort order. The rank should be treated as an ordered set of numbers, where the ordering is done in descending order of the most significant rank member. For example, given the following ranks described as (primary, secondary): (1,1), (1,2), (2,2) (2,1) The descending rank-order is: (2,2) > (2,1) > (1,2) > (1,1)
--
-- /See:/ 'newRank' smart constructor.
data Rank = Rank
  { -- | The primary rank is the most significant rank member. This rank element should always be present. Items with higher primary rank are always considered of higher rank than those of lower primary rank.
    primary :: (Core.Maybe Core.Int64),
    -- | The secondary rank may be used to rank items of identical primary rank. This rank element should always be present.
    secondary :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Rank' with the minimum fields required to make a request.
newRank ::
  Rank
newRank = Rank {primary = Core.Nothing, secondary = Core.Nothing}

instance Core.FromJSON Rank where
  parseJSON =
    Core.withObject
      "Rank"
      ( \o ->
          Rank
            Core.<$> ( o Core..:? "primary"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> ( o Core..:? "secondary"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON Rank where
  toJSON Rank {..} =
    Core.object
      ( Core.catMaybes
          [ ("primary" Core..=) Core.. Core.AsText
              Core.<$> primary,
            ("secondary" Core..=) Core.. Core.AsText
              Core.<$> secondary
          ]
      )

-- | Principal associated with a given RBAC role. This principal is used by Sphinx Provisioning Service for RBAC provisionable (go\/sphinx-rbacz).
--
-- /See:/ 'newRbacRoleProto' smart constructor.
data RbacRoleProto = RbacRoleProto
  { -- |
    name :: (Core.Maybe Core.Text),
    -- |
    objectId :: (Core.Maybe Core.Text),
    -- | DEPRECATED as of 01.11.2019
    rbacNamespace :: (Core.Maybe Core.Text),
    -- | Format: \"role\/z?\" - \"role\" is the Sphinx globally unique name of the Sphinx role that provisions the RBAC role. - \"\/z?\" suffix indicates which Zanzibar environment stores the role membership data (\"\/zd\": dev, \"\/zs\": staging, \"\/zp\": prod, \"\/zt\": local test instance). Example: \"mysystem_myrole\/zp\"
    rbacRoleName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'RbacRoleProto' with the minimum fields required to make a request.
newRbacRoleProto ::
  RbacRoleProto
newRbacRoleProto =
  RbacRoleProto
    { name = Core.Nothing,
      objectId = Core.Nothing,
      rbacNamespace = Core.Nothing,
      rbacRoleName = Core.Nothing
    }

instance Core.FromJSON RbacRoleProto where
  parseJSON =
    Core.withObject
      "RbacRoleProto"
      ( \o ->
          RbacRoleProto
            Core.<$> (o Core..:? "name")
            Core.<*> (o Core..:? "objectId")
            Core.<*> (o Core..:? "rbacNamespace")
            Core.<*> (o Core..:? "rbacRoleName")
      )

instance Core.ToJSON RbacRoleProto where
  toJSON RbacRoleProto {..} =
    Core.object
      ( Core.catMaybes
          [ ("name" Core..=) Core.<$> name,
            ("objectId" Core..=) Core.<$> objectId,
            ("rbacNamespace" Core..=) Core.<$> rbacNamespace,
            ("rbacRoleName" Core..=) Core.<$> rbacRoleName
          ]
      )

-- | Principal associated with a given RBAC subject. This principal is used by Sphinx Provisioning Service for RBAC provisionable (go\/sphinx-rbacz).
--
-- /See:/ 'newRbacSubjectProto' smart constructor.
newtype RbacSubjectProto = RbacSubjectProto
  { -- | Format \"username\" without \"\@domain\", e.g., \"bogdand\".
    username :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'RbacSubjectProto' with the minimum fields required to make a request.
newRbacSubjectProto ::
  RbacSubjectProto
newRbacSubjectProto = RbacSubjectProto {username = Core.Nothing}

instance Core.FromJSON RbacSubjectProto where
  parseJSON =
    Core.withObject
      "RbacSubjectProto"
      ( \o ->
          RbacSubjectProto Core.<$> (o Core..:? "username")
      )

instance Core.ToJSON RbacSubjectProto where
  toJSON RbacSubjectProto {..} =
    Core.object
      ( Core.catMaybes
          [("username" Core..=) Core.<$> username]
      )

-- | Contains information about an emoji reaction.
--
-- /See:/ 'newReactionInfo' smart constructor.
newtype ReactionInfo = ReactionInfo
  { -- | Unicode string representing a single emoji.
    emoji :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ReactionInfo' with the minimum fields required to make a request.
newReactionInfo ::
  ReactionInfo
newReactionInfo = ReactionInfo {emoji = Core.Nothing}

instance Core.FromJSON ReactionInfo where
  parseJSON =
    Core.withObject
      "ReactionInfo"
      (\o -> ReactionInfo Core.<$> (o Core..:? "emoji"))

instance Core.ToJSON ReactionInfo where
  toJSON ReactionInfo {..} =
    Core.object
      (Core.catMaybes [("emoji" Core..=) Core.<$> emoji])

--
-- /See:/ 'newReadReceiptsSettingsUpdatedMetadata' smart constructor.
newtype ReadReceiptsSettingsUpdatedMetadata = ReadReceiptsSettingsUpdatedMetadata
  { -- | The new read receipts state.
    readReceiptsEnabled :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ReadReceiptsSettingsUpdatedMetadata' with the minimum fields required to make a request.
newReadReceiptsSettingsUpdatedMetadata ::
  ReadReceiptsSettingsUpdatedMetadata
newReadReceiptsSettingsUpdatedMetadata =
  ReadReceiptsSettingsUpdatedMetadata {readReceiptsEnabled = Core.Nothing}

instance
  Core.FromJSON
    ReadReceiptsSettingsUpdatedMetadata
  where
  parseJSON =
    Core.withObject
      "ReadReceiptsSettingsUpdatedMetadata"
      ( \o ->
          ReadReceiptsSettingsUpdatedMetadata
            Core.<$> (o Core..:? "readReceiptsEnabled")
      )

instance
  Core.ToJSON
    ReadReceiptsSettingsUpdatedMetadata
  where
  toJSON ReadReceiptsSettingsUpdatedMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("readReceiptsEnabled" Core..=)
              Core.<$> readReceiptsEnabled
          ]
      )

--
-- /See:/ 'newRecipient' smart constructor.
newtype Recipient = Recipient
  { -- |
    email :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Recipient' with the minimum fields required to make a request.
newRecipient ::
  Recipient
newRecipient = Recipient {email = Core.Nothing}

instance Core.FromJSON Recipient where
  parseJSON =
    Core.withObject
      "Recipient"
      (\o -> Recipient Core.<$> (o Core..:? "email"))

instance Core.ToJSON Recipient where
  toJSON Recipient {..} =
    Core.object
      (Core.catMaybes [("email" Core..=) Core.<$> email])

-- | A recording event is something that happens to the recording in a conference.
--
-- /See:/ 'newRecordingEvent' smart constructor.
data RecordingEvent = RecordingEvent
  { -- | The initiator of the latest event of the recording. It will be set for all user events (@type@ is 100-199) and unset for all server events (@type@ is 200-299).
    deviceId :: (Core.Maybe Core.Text),
    -- | The type of event.
    type' :: (Core.Maybe RecordingEvent_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'RecordingEvent' with the minimum fields required to make a request.
newRecordingEvent ::
  RecordingEvent
newRecordingEvent =
  RecordingEvent {deviceId = Core.Nothing, type' = Core.Nothing}

instance Core.FromJSON RecordingEvent where
  parseJSON =
    Core.withObject
      "RecordingEvent"
      ( \o ->
          RecordingEvent
            Core.<$> (o Core..:? "deviceId") Core.<*> (o Core..:? "type")
      )

instance Core.ToJSON RecordingEvent where
  toJSON RecordingEvent {..} =
    Core.object
      ( Core.catMaybes
          [ ("deviceId" Core..=) Core.<$> deviceId,
            ("type" Core..=) Core.<$> type'
          ]
      )

-- | This message is deprecated, please use RecordingSessionInfo instead. Information about recording in the current conference.
--
-- /See:/ 'newRecordingInfo' smart constructor.
data RecordingInfo = RecordingInfo
  { -- | The latest recording event. This can be used by clients to help explain what is going on, why recording stopped, etc. This will always be set if there is or was an active recording, which means there can be latest event when recording is INACTIVE.
    latestRecordingEvent :: (Core.Maybe RecordingEvent),
    -- | The display name of the owner of the recording output. Email notifications about uploaded recordings will also be sent to this owner.
    ownerDisplayName :: (Core.Maybe Core.Text),
    -- | The device resource name of the producer device for the currently active recording. Note that, after the producer drops\/leaves the conference, this field will be cleaned up by the server after a delay.
    producerDeviceId :: (Core.Maybe Core.Text),
    -- | The application type of the current active recording. @RECORDING_APPLICATION_TYPE_UNSPECIFIED@ if @recording_status@ is inactive.
    recordingApplicationType :: (Core.Maybe RecordingInfo_RecordingApplicationType),
    -- | An identifier for the current recording, if any. This is returned whenever recording_status is either @RECORDING_STARTING@ or @RECORDING_STARTED@.
    recordingId :: (Core.Maybe Core.Text),
    -- | The current status of the recording. This can be used by clients to show a recording dot or similar to indicated to the user that a recording is taking place.
    recordingStatus :: (Core.Maybe RecordingInfo_RecordingStatus)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'RecordingInfo' with the minimum fields required to make a request.
newRecordingInfo ::
  RecordingInfo
newRecordingInfo =
  RecordingInfo
    { latestRecordingEvent = Core.Nothing,
      ownerDisplayName = Core.Nothing,
      producerDeviceId = Core.Nothing,
      recordingApplicationType = Core.Nothing,
      recordingId = Core.Nothing,
      recordingStatus = Core.Nothing
    }

instance Core.FromJSON RecordingInfo where
  parseJSON =
    Core.withObject
      "RecordingInfo"
      ( \o ->
          RecordingInfo
            Core.<$> (o Core..:? "latestRecordingEvent")
            Core.<*> (o Core..:? "ownerDisplayName")
            Core.<*> (o Core..:? "producerDeviceId")
            Core.<*> (o Core..:? "recordingApplicationType")
            Core.<*> (o Core..:? "recordingId")
            Core.<*> (o Core..:? "recordingStatus")
      )

instance Core.ToJSON RecordingInfo where
  toJSON RecordingInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("latestRecordingEvent" Core..=)
              Core.<$> latestRecordingEvent,
            ("ownerDisplayName" Core..=)
              Core.<$> ownerDisplayName,
            ("producerDeviceId" Core..=)
              Core.<$> producerDeviceId,
            ("recordingApplicationType" Core..=)
              Core.<$> recordingApplicationType,
            ("recordingId" Core..=) Core.<$> recordingId,
            ("recordingStatus" Core..=)
              Core.<$> recordingStatus
          ]
      )

-- | Information about a recording session.
--
-- /See:/ 'newRecordingSessionInfo' smart constructor.
data RecordingSessionInfo = RecordingSessionInfo
  { -- | Input only. Deprecated field, should not be used.
    ownerEmail :: (Core.Maybe Core.Text),
    -- | A unique server-generated ID for the recording session.
    recordingSessionId :: (Core.Maybe Core.Text),
    -- | Recording session\'s state information.
    sessionStateInfo :: (Core.Maybe SessionStateInfo)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'RecordingSessionInfo' with the minimum fields required to make a request.
newRecordingSessionInfo ::
  RecordingSessionInfo
newRecordingSessionInfo =
  RecordingSessionInfo
    { ownerEmail = Core.Nothing,
      recordingSessionId = Core.Nothing,
      sessionStateInfo = Core.Nothing
    }

instance Core.FromJSON RecordingSessionInfo where
  parseJSON =
    Core.withObject
      "RecordingSessionInfo"
      ( \o ->
          RecordingSessionInfo
            Core.<$> (o Core..:? "ownerEmail")
            Core.<*> (o Core..:? "recordingSessionId")
            Core.<*> (o Core..:? "sessionStateInfo")
      )

instance Core.ToJSON RecordingSessionInfo where
  toJSON RecordingSessionInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("ownerEmail" Core..=) Core.<$> ownerEmail,
            ("recordingSessionId" Core..=)
              Core.<$> recordingSessionId,
            ("sessionStateInfo" Core..=)
              Core.<$> sessionStateInfo
          ]
      )

-- | All fields in this proto are now columns in spanner see google3\/storage\/slice\/production\/gmail\/user/data/tables.pi for documentation.
--
-- /See:/ 'newReference' smart constructor.
data Reference = Reference
  { -- |
    blobId :: (Core.Maybe Core.Text),
    -- |
    contentType :: (Core.Maybe Core.Text),
    -- |
    hash :: (Core.Maybe Core.Text),
    -- | LINT.IfChange
    key :: (Core.Maybe Core.Text),
    -- | LINT.ThenChange(\/\/depot\/google3\/storage\/slice\/production\/gmail\/ user/data/tables.pi)
    name :: (Core.Maybe Core.Text),
    -- |
    size :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Reference' with the minimum fields required to make a request.
newReference ::
  Reference
newReference =
  Reference
    { blobId = Core.Nothing,
      contentType = Core.Nothing,
      hash = Core.Nothing,
      key = Core.Nothing,
      name = Core.Nothing,
      size = Core.Nothing
    }

instance Core.FromJSON Reference where
  parseJSON =
    Core.withObject
      "Reference"
      ( \o ->
          Reference
            Core.<$> (o Core..:? "blobId")
            Core.<*> (o Core..:? "contentType")
            Core.<*> (o Core..:? "hash")
            Core.<*> (o Core..:? "key")
            Core.<*> (o Core..:? "name")
            Core.<*> ( o Core..:? "size"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON Reference where
  toJSON Reference {..} =
    Core.object
      ( Core.catMaybes
          [ ("blobId" Core..=) Core.<$> blobId,
            ("contentType" Core..=) Core.<$> contentType,
            ("hash" Core..=) Core.<$> hash,
            ("key" Core..=) Core.<$> key,
            ("name" Core..=) Core.<$> name,
            ("size" Core..=) Core.. Core.AsText Core.<$> size
          ]
      )

--
-- /See:/ 'newReferences' smart constructor.
newtype References = References
  { -- |
    references :: (Core.Maybe [Reference])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'References' with the minimum fields required to make a request.
newReferences ::
  References
newReferences = References {references = Core.Nothing}

instance Core.FromJSON References where
  parseJSON =
    Core.withObject
      "References"
      ( \o ->
          References Core.<$> (o Core..:? "references")
      )

instance Core.ToJSON References where
  toJSON References {..} =
    Core.object
      ( Core.catMaybes
          [("references" Core..=) Core.<$> references]
      )

--
-- /See:/ 'newRenameEvent' smart constructor.
data RenameEvent = RenameEvent
  { -- |
    newName' :: (Core.Maybe Core.Text),
    -- |
    originalName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'RenameEvent' with the minimum fields required to make a request.
newRenameEvent ::
  RenameEvent
newRenameEvent =
  RenameEvent {newName' = Core.Nothing, originalName = Core.Nothing}

instance Core.FromJSON RenameEvent where
  parseJSON =
    Core.withObject
      "RenameEvent"
      ( \o ->
          RenameEvent
            Core.<$> (o Core..:? "newName")
            Core.<*> (o Core..:? "originalName")
      )

instance Core.ToJSON RenameEvent where
  toJSON RenameEvent {..} =
    Core.object
      ( Core.catMaybes
          [ ("newName" Core..=) Core.<$> newName',
            ("originalName" Core..=) Core.<$> originalName
          ]
      )

-- | Errors when the connector is communicating to the source repository.
--
-- /See:/ 'newRepositoryError' smart constructor.
data RepositoryError = RepositoryError
  { -- | Message that describes the error. The maximum allowable length of the message is 8192 characters.
    errorMessage :: (Core.Maybe Core.Text),
    -- | Error codes. Matches the definition of HTTP status codes.
    httpStatusCode :: (Core.Maybe Core.Int32),
    -- | The type of error.
    type' :: (Core.Maybe RepositoryError_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'RepositoryError' with the minimum fields required to make a request.
newRepositoryError ::
  RepositoryError
newRepositoryError =
  RepositoryError
    { errorMessage = Core.Nothing,
      httpStatusCode = Core.Nothing,
      type' = Core.Nothing
    }

instance Core.FromJSON RepositoryError where
  parseJSON =
    Core.withObject
      "RepositoryError"
      ( \o ->
          RepositoryError
            Core.<$> (o Core..:? "errorMessage")
            Core.<*> (o Core..:? "httpStatusCode")
            Core.<*> (o Core..:? "type")
      )

instance Core.ToJSON RepositoryError where
  toJSON RepositoryError {..} =
    Core.object
      ( Core.catMaybes
          [ ("errorMessage" Core..=) Core.<$> errorMessage,
            ("httpStatusCode" Core..=) Core.<$> httpStatusCode,
            ("type" Core..=) Core.<$> type'
          ]
      )

--
-- /See:/ 'newRequestFileScope' smart constructor.
newtype RequestFileScope = RequestFileScope
  { -- |
    itemId :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'RequestFileScope' with the minimum fields required to make a request.
newRequestFileScope ::
  RequestFileScope
newRequestFileScope = RequestFileScope {itemId = Core.Nothing}

instance Core.FromJSON RequestFileScope where
  parseJSON =
    Core.withObject
      "RequestFileScope"
      ( \o ->
          RequestFileScope Core.<$> (o Core..:? "itemId")
      )

instance Core.ToJSON RequestFileScope where
  toJSON RequestFileScope {..} =
    Core.object
      (Core.catMaybes [("itemId" Core..=) Core.<$> itemId])

--
-- /See:/ 'newRequestFileScopeForActiveDocument' smart constructor.
data RequestFileScopeForActiveDocument = RequestFileScopeForActiveDocument
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'RequestFileScopeForActiveDocument' with the minimum fields required to make a request.
newRequestFileScopeForActiveDocument ::
  RequestFileScopeForActiveDocument
newRequestFileScopeForActiveDocument = RequestFileScopeForActiveDocument

instance
  Core.FromJSON
    RequestFileScopeForActiveDocument
  where
  parseJSON =
    Core.withObject
      "RequestFileScopeForActiveDocument"
      (\o -> Core.pure RequestFileScopeForActiveDocument)

instance
  Core.ToJSON
    RequestFileScopeForActiveDocument
  where
  toJSON = Core.const Core.emptyObject

-- | Shared request options for all RPC methods.
--
-- /See:/ 'newRequestOptions' smart constructor.
data RequestOptions = RequestOptions
  { -- | Debug options of the request
    debugOptions :: (Core.Maybe DebugOptions),
    -- | The BCP-47 language code, such as \"en-US\" or \"sr-Latn\". For more information, see http:\/\/www.unicode.org\/reports\/tr35\/#Unicode/locale/identifier. For translations. Set this field using the language set in browser or for the page. In the event that the user\'s language preference is known, set this field to the known user language. When specified, the documents in search results are biased towards the specified language. From Suggest API perspective, for 3p suggest this is used as a hint while making predictions to add language boosting.
    languageCode :: (Core.Maybe Core.Text),
    -- | The ID generated when you create a search application using the <https://support.google.com/a/answer/9043922 admin console>.
    searchApplicationId :: (Core.Maybe Core.Text),
    -- | Current user\'s time zone id, such as \"America\/Los_Angeles\" or \"Australia\/Sydney\". These IDs are defined by <http://cldr.unicode.org/ Unicode Common Locale Data Repository (CLDR)> project, and currently available in the file <http://unicode.org/repos/cldr/trunk/common/bcp47/timezone.xml timezone.xml>. This field is used to correctly interpret date and time queries. If this field is not specified, the default time zone (UTC) is used.
    timeZone :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'RequestOptions' with the minimum fields required to make a request.
newRequestOptions ::
  RequestOptions
newRequestOptions =
  RequestOptions
    { debugOptions = Core.Nothing,
      languageCode = Core.Nothing,
      searchApplicationId = Core.Nothing,
      timeZone = Core.Nothing
    }

instance Core.FromJSON RequestOptions where
  parseJSON =
    Core.withObject
      "RequestOptions"
      ( \o ->
          RequestOptions
            Core.<$> (o Core..:? "debugOptions")
            Core.<*> (o Core..:? "languageCode")
            Core.<*> (o Core..:? "searchApplicationId")
            Core.<*> (o Core..:? "timeZone")
      )

instance Core.ToJSON RequestOptions where
  toJSON RequestOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("debugOptions" Core..=) Core.<$> debugOptions,
            ("languageCode" Core..=) Core.<$> languageCode,
            ("searchApplicationId" Core..=)
              Core.<$> searchApplicationId,
            ("timeZone" Core..=) Core.<$> timeZone
          ]
      )

-- | A list of capabilities that are used in this message.
--
-- /See:/ 'newRequiredMessageFeaturesMetadata' smart constructor.
newtype RequiredMessageFeaturesMetadata = RequiredMessageFeaturesMetadata
  { -- |
    requiredFeatures :: (Core.Maybe [RequiredMessageFeaturesMetadata_RequiredFeaturesItem])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'RequiredMessageFeaturesMetadata' with the minimum fields required to make a request.
newRequiredMessageFeaturesMetadata ::
  RequiredMessageFeaturesMetadata
newRequiredMessageFeaturesMetadata =
  RequiredMessageFeaturesMetadata {requiredFeatures = Core.Nothing}

instance
  Core.FromJSON
    RequiredMessageFeaturesMetadata
  where
  parseJSON =
    Core.withObject
      "RequiredMessageFeaturesMetadata"
      ( \o ->
          RequiredMessageFeaturesMetadata
            Core.<$> (o Core..:? "requiredFeatures")
      )

instance Core.ToJSON RequiredMessageFeaturesMetadata where
  toJSON RequiredMessageFeaturesMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("requiredFeatures" Core..=)
              Core.<$> requiredFeatures
          ]
      )

--
-- /See:/ 'newResetSearchApplicationRequest' smart constructor.
newtype ResetSearchApplicationRequest = ResetSearchApplicationRequest
  { -- | Common debug options.
    debugOptions :: (Core.Maybe DebugOptions)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ResetSearchApplicationRequest' with the minimum fields required to make a request.
newResetSearchApplicationRequest ::
  ResetSearchApplicationRequest
newResetSearchApplicationRequest =
  ResetSearchApplicationRequest {debugOptions = Core.Nothing}

instance Core.FromJSON ResetSearchApplicationRequest where
  parseJSON =
    Core.withObject
      "ResetSearchApplicationRequest"
      ( \o ->
          ResetSearchApplicationRequest
            Core.<$> (o Core..:? "debugOptions")
      )

instance Core.ToJSON ResetSearchApplicationRequest where
  toJSON ResetSearchApplicationRequest {..} =
    Core.object
      ( Core.catMaybes
          [("debugOptions" Core..=) Core.<$> debugOptions]
      )

-- | A type of sharing target that points to some resource\'s ACL. Used to refer to the set of Principals that have the given privilege (\'role/id\') for the given resource (\'application/id\', \'object/id\', \'object/part\'). The meaning of \'role/id\' is interpreted only by implementations of AclRpcService and is usually dependent on \'application/id\' All fields except object/part are required. If present, object/part must be non-empty.
--
-- /See:/ 'newResourceRoleProto' smart constructor.
data ResourceRoleProto = ResourceRoleProto
  { -- |
    applicationId :: (Core.Maybe Core.Text),
    -- |
    objectId :: (Core.Maybe Core.Text),
    -- |
    objectPart :: (Core.Maybe Core.Text),
    -- |
    roleId :: (Core.Maybe Core.Int32)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ResourceRoleProto' with the minimum fields required to make a request.
newResourceRoleProto ::
  ResourceRoleProto
newResourceRoleProto =
  ResourceRoleProto
    { applicationId = Core.Nothing,
      objectId = Core.Nothing,
      objectPart = Core.Nothing,
      roleId = Core.Nothing
    }

instance Core.FromJSON ResourceRoleProto where
  parseJSON =
    Core.withObject
      "ResourceRoleProto"
      ( \o ->
          ResourceRoleProto
            Core.<$> (o Core..:? "applicationId")
            Core.<*> (o Core..:? "objectId")
            Core.<*> (o Core..:? "objectPart")
            Core.<*> (o Core..:? "roleId")
      )

instance Core.ToJSON ResourceRoleProto where
  toJSON ResourceRoleProto {..} =
    Core.object
      ( Core.catMaybes
          [ ("applicationId" Core..=) Core.<$> applicationId,
            ("objectId" Core..=) Core.<$> objectId,
            ("objectPart" Core..=) Core.<$> objectPart,
            ("roleId" Core..=) Core.<$> roleId
          ]
      )

-- | Debugging information about the response.
--
-- /See:/ 'newResponseDebugInfo' smart constructor.
newtype ResponseDebugInfo = ResponseDebugInfo
  { -- | General debug info formatted for display.
    formattedDebugInfo :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ResponseDebugInfo' with the minimum fields required to make a request.
newResponseDebugInfo ::
  ResponseDebugInfo
newResponseDebugInfo = ResponseDebugInfo {formattedDebugInfo = Core.Nothing}

instance Core.FromJSON ResponseDebugInfo where
  parseJSON =
    Core.withObject
      "ResponseDebugInfo"
      ( \o ->
          ResponseDebugInfo
            Core.<$> (o Core..:? "formattedDebugInfo")
      )

instance Core.ToJSON ResponseDebugInfo where
  toJSON ResponseDebugInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("formattedDebugInfo" Core..=)
              Core.<$> formattedDebugInfo
          ]
      )

-- | Information relevant only to a restrict entry. NextId: 12
--
-- /See:/ 'newRestrictItem' smart constructor.
data RestrictItem = RestrictItem
  { -- |
    driveFollowUpRestrict :: (Core.Maybe DriveFollowUpRestrict),
    -- |
    driveLocationRestrict :: (Core.Maybe DriveLocationRestrict),
    -- | Drive Types.
    driveMimeTypeRestrict :: (Core.Maybe DriveMimeTypeRestrict),
    -- |
    driveTimeSpanRestrict :: (Core.Maybe DriveTimeSpanRestrict),
    -- | The search restrict (e.g. \"after:2017-09-11 before:2017-09-12\").
    searchOperator :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'RestrictItem' with the minimum fields required to make a request.
newRestrictItem ::
  RestrictItem
newRestrictItem =
  RestrictItem
    { driveFollowUpRestrict = Core.Nothing,
      driveLocationRestrict = Core.Nothing,
      driveMimeTypeRestrict = Core.Nothing,
      driveTimeSpanRestrict = Core.Nothing,
      searchOperator = Core.Nothing
    }

instance Core.FromJSON RestrictItem where
  parseJSON =
    Core.withObject
      "RestrictItem"
      ( \o ->
          RestrictItem
            Core.<$> (o Core..:? "driveFollowUpRestrict")
            Core.<*> (o Core..:? "driveLocationRestrict")
            Core.<*> (o Core..:? "driveMimeTypeRestrict")
            Core.<*> (o Core..:? "driveTimeSpanRestrict")
            Core.<*> (o Core..:? "searchOperator")
      )

instance Core.ToJSON RestrictItem where
  toJSON RestrictItem {..} =
    Core.object
      ( Core.catMaybes
          [ ("driveFollowUpRestrict" Core..=)
              Core.<$> driveFollowUpRestrict,
            ("driveLocationRestrict" Core..=)
              Core.<$> driveLocationRestrict,
            ("driveMimeTypeRestrict" Core..=)
              Core.<$> driveMimeTypeRestrict,
            ("driveTimeSpanRestrict" Core..=)
              Core.<$> driveTimeSpanRestrict,
            ("searchOperator" Core..=) Core.<$> searchOperator
          ]
      )

-- | Result count information
--
-- /See:/ 'newResultCounts' smart constructor.
newtype ResultCounts = ResultCounts
  { -- | Result count information for each source with results.
    sourceResultCounts :: (Core.Maybe [SourceResultCount])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ResultCounts' with the minimum fields required to make a request.
newResultCounts ::
  ResultCounts
newResultCounts = ResultCounts {sourceResultCounts = Core.Nothing}

instance Core.FromJSON ResultCounts where
  parseJSON =
    Core.withObject
      "ResultCounts"
      ( \o ->
          ResultCounts
            Core.<$> (o Core..:? "sourceResultCounts")
      )

instance Core.ToJSON ResultCounts where
  toJSON ResultCounts {..} =
    Core.object
      ( Core.catMaybes
          [ ("sourceResultCounts" Core..=)
              Core.<$> sourceResultCounts
          ]
      )

-- | Debugging information about the result.
--
-- /See:/ 'newResultDebugInfo' smart constructor.
newtype ResultDebugInfo = ResultDebugInfo
  { -- | General debug info formatted for display.
    formattedDebugInfo :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ResultDebugInfo' with the minimum fields required to make a request.
newResultDebugInfo ::
  ResultDebugInfo
newResultDebugInfo = ResultDebugInfo {formattedDebugInfo = Core.Nothing}

instance Core.FromJSON ResultDebugInfo where
  parseJSON =
    Core.withObject
      "ResultDebugInfo"
      ( \o ->
          ResultDebugInfo
            Core.<$> (o Core..:? "formattedDebugInfo")
      )

instance Core.ToJSON ResultDebugInfo where
  toJSON ResultDebugInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("formattedDebugInfo" Core..=)
              Core.<$> formattedDebugInfo
          ]
      )

-- | Display Fields for Search Results
--
-- /See:/ 'newResultDisplayField' smart constructor.
data ResultDisplayField = ResultDisplayField
  { -- | The display label for the property.
    label :: (Core.Maybe Core.Text),
    -- | The operator name of the property.
    operatorName :: (Core.Maybe Core.Text),
    -- | The name value pair for the property.
    property :: (Core.Maybe NamedProperty)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ResultDisplayField' with the minimum fields required to make a request.
newResultDisplayField ::
  ResultDisplayField
newResultDisplayField =
  ResultDisplayField
    { label = Core.Nothing,
      operatorName = Core.Nothing,
      property = Core.Nothing
    }

instance Core.FromJSON ResultDisplayField where
  parseJSON =
    Core.withObject
      "ResultDisplayField"
      ( \o ->
          ResultDisplayField
            Core.<$> (o Core..:? "label")
            Core.<*> (o Core..:? "operatorName")
            Core.<*> (o Core..:? "property")
      )

instance Core.ToJSON ResultDisplayField where
  toJSON ResultDisplayField {..} =
    Core.object
      ( Core.catMaybes
          [ ("label" Core..=) Core.<$> label,
            ("operatorName" Core..=) Core.<$> operatorName,
            ("property" Core..=) Core.<$> property
          ]
      )

-- | The collection of fields that make up a displayed line
--
-- /See:/ 'newResultDisplayLine' smart constructor.
newtype ResultDisplayLine = ResultDisplayLine
  { -- |
    fields :: (Core.Maybe [ResultDisplayField])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ResultDisplayLine' with the minimum fields required to make a request.
newResultDisplayLine ::
  ResultDisplayLine
newResultDisplayLine = ResultDisplayLine {fields = Core.Nothing}

instance Core.FromJSON ResultDisplayLine where
  parseJSON =
    Core.withObject
      "ResultDisplayLine"
      ( \o ->
          ResultDisplayLine Core.<$> (o Core..:? "fields")
      )

instance Core.ToJSON ResultDisplayLine where
  toJSON ResultDisplayLine {..} =
    Core.object
      (Core.catMaybes [("fields" Core..=) Core.<$> fields])

--
-- /See:/ 'newResultDisplayMetadata' smart constructor.
data ResultDisplayMetadata = ResultDisplayMetadata
  { -- | The metalines content to be displayed with the result.
    metalines :: (Core.Maybe [ResultDisplayLine]),
    -- | The display label for the object.
    objectTypeLabel :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ResultDisplayMetadata' with the minimum fields required to make a request.
newResultDisplayMetadata ::
  ResultDisplayMetadata
newResultDisplayMetadata =
  ResultDisplayMetadata
    { metalines = Core.Nothing,
      objectTypeLabel = Core.Nothing
    }

instance Core.FromJSON ResultDisplayMetadata where
  parseJSON =
    Core.withObject
      "ResultDisplayMetadata"
      ( \o ->
          ResultDisplayMetadata
            Core.<$> (o Core..:? "metalines")
            Core.<*> (o Core..:? "objectTypeLabel")
      )

instance Core.ToJSON ResultDisplayMetadata where
  toJSON ResultDisplayMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("metalines" Core..=) Core.<$> metalines,
            ("objectTypeLabel" Core..=)
              Core.<$> objectTypeLabel
          ]
      )

--
-- /See:/ 'newRetrievalImportance' smart constructor.
newtype RetrievalImportance = RetrievalImportance
  { -- | Indicates the ranking importance given to property when it is matched during retrieval. Once set, the token importance of a property cannot be changed.
    importance :: (Core.Maybe RetrievalImportance_Importance)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'RetrievalImportance' with the minimum fields required to make a request.
newRetrievalImportance ::
  RetrievalImportance
newRetrievalImportance = RetrievalImportance {importance = Core.Nothing}

instance Core.FromJSON RetrievalImportance where
  parseJSON =
    Core.withObject
      "RetrievalImportance"
      ( \o ->
          RetrievalImportance
            Core.<$> (o Core..:? "importance")
      )

instance Core.ToJSON RetrievalImportance where
  toJSON RetrievalImportance {..} =
    Core.object
      ( Core.catMaybes
          [("importance" Core..=) Core.<$> importance]
      )

--
-- /See:/ 'newRoomRenameMetadata' smart constructor.
data RoomRenameMetadata = RoomRenameMetadata
  { -- |
    newName' :: (Core.Maybe Core.Text),
    -- | NEXT_TAG: 3
    prevName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'RoomRenameMetadata' with the minimum fields required to make a request.
newRoomRenameMetadata ::
  RoomRenameMetadata
newRoomRenameMetadata =
  RoomRenameMetadata {newName' = Core.Nothing, prevName = Core.Nothing}

instance Core.FromJSON RoomRenameMetadata where
  parseJSON =
    Core.withObject
      "RoomRenameMetadata"
      ( \o ->
          RoomRenameMetadata
            Core.<$> (o Core..:? "newName")
            Core.<*> (o Core..:? "prevName")
      )

instance Core.ToJSON RoomRenameMetadata where
  toJSON RoomRenameMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("newName" Core..=) Core.<$> newName',
            ("prevName" Core..=) Core.<$> prevName
          ]
      )

--
-- /See:/ 'newRoomUpdatedMetadata' smart constructor.
data RoomUpdatedMetadata = RoomUpdatedMetadata
  { -- |
    groupDetailsMetadata :: (Core.Maybe GroupDetailsUpdatedMetadata),
    -- |
    groupLinkSharingEnabled :: (Core.Maybe Core.Bool),
    -- | The user who initiated this room update. Complete member profiles, when ListTopicsRequest FetchOptions.USER is set. Otherwise, only the id will be filled in.
    initiator :: (Core.Maybe User),
    -- | The type of the user who initiated this room update.
    initiatorType :: (Core.Maybe RoomUpdatedMetadata_InitiatorType),
    -- | What was updated in the room.
    name :: (Core.Maybe Core.Text),
    -- |
    renameMetadata :: (Core.Maybe RoomRenameMetadata),
    -- | DEPRECATED: See GroupVisibility proto definition.
    visibility :: (Core.Maybe AppsDynamiteSharedGroupVisibility)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'RoomUpdatedMetadata' with the minimum fields required to make a request.
newRoomUpdatedMetadata ::
  RoomUpdatedMetadata
newRoomUpdatedMetadata =
  RoomUpdatedMetadata
    { groupDetailsMetadata = Core.Nothing,
      groupLinkSharingEnabled = Core.Nothing,
      initiator = Core.Nothing,
      initiatorType = Core.Nothing,
      name = Core.Nothing,
      renameMetadata = Core.Nothing,
      visibility = Core.Nothing
    }

instance Core.FromJSON RoomUpdatedMetadata where
  parseJSON =
    Core.withObject
      "RoomUpdatedMetadata"
      ( \o ->
          RoomUpdatedMetadata
            Core.<$> (o Core..:? "groupDetailsMetadata")
            Core.<*> (o Core..:? "groupLinkSharingEnabled")
            Core.<*> (o Core..:? "initiator")
            Core.<*> (o Core..:? "initiatorType")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "renameMetadata")
            Core.<*> (o Core..:? "visibility")
      )

instance Core.ToJSON RoomUpdatedMetadata where
  toJSON RoomUpdatedMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("groupDetailsMetadata" Core..=)
              Core.<$> groupDetailsMetadata,
            ("groupLinkSharingEnabled" Core..=)
              Core.<$> groupLinkSharingEnabled,
            ("initiator" Core..=) Core.<$> initiator,
            ("initiatorType" Core..=) Core.<$> initiatorType,
            ("name" Core..=) Core.<$> name,
            ("renameMetadata" Core..=) Core.<$> renameMetadata,
            ("visibility" Core..=) Core.<$> visibility
          ]
      )

-- | Roster profile information.
--
-- /See:/ 'newRoster' smart constructor.
data Roster = Roster
  { -- |
    avatarUrl :: (Core.Maybe Core.Text),
    -- |
    id :: (Core.Maybe RosterId),
    -- | Whether caller has visibility into members of the roster.
    isMembershipVisibleToCaller :: (Core.Maybe Core.Bool),
    -- |
    membershipCount :: (Core.Maybe Core.Int32),
    -- |
    name :: (Core.Maybe Core.Text),
    -- | Roster gaia key, usually an email address. Set in looking up rosters response.
    rosterGaiaKey :: (Core.Maybe Core.Text),
    -- | Roster deletion state - considered active unless set to deleted
    rosterState :: (Core.Maybe Roster_RosterState),
    -- | Roster membership count. May contain counts based on member type and membership state.
    segmentedMembershipCounts :: (Core.Maybe AppsDynamiteSharedSegmentedMembershipCounts)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Roster' with the minimum fields required to make a request.
newRoster ::
  Roster
newRoster =
  Roster
    { avatarUrl = Core.Nothing,
      id = Core.Nothing,
      isMembershipVisibleToCaller = Core.Nothing,
      membershipCount = Core.Nothing,
      name = Core.Nothing,
      rosterGaiaKey = Core.Nothing,
      rosterState = Core.Nothing,
      segmentedMembershipCounts = Core.Nothing
    }

instance Core.FromJSON Roster where
  parseJSON =
    Core.withObject
      "Roster"
      ( \o ->
          Roster
            Core.<$> (o Core..:? "avatarUrl")
            Core.<*> (o Core..:? "id")
            Core.<*> (o Core..:? "isMembershipVisibleToCaller")
            Core.<*> (o Core..:? "membershipCount")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "rosterGaiaKey")
            Core.<*> (o Core..:? "rosterState")
            Core.<*> (o Core..:? "segmentedMembershipCounts")
      )

instance Core.ToJSON Roster where
  toJSON Roster {..} =
    Core.object
      ( Core.catMaybes
          [ ("avatarUrl" Core..=) Core.<$> avatarUrl,
            ("id" Core..=) Core.<$> id,
            ("isMembershipVisibleToCaller" Core..=)
              Core.<$> isMembershipVisibleToCaller,
            ("membershipCount" Core..=) Core.<$> membershipCount,
            ("name" Core..=) Core.<$> name,
            ("rosterGaiaKey" Core..=) Core.<$> rosterGaiaKey,
            ("rosterState" Core..=) Core.<$> rosterState,
            ("segmentedMembershipCounts" Core..=)
              Core.<$> segmentedMembershipCounts
          ]
      )

-- | Primary key for Roster resource.
--
-- /See:/ 'newRosterId' smart constructor.
newtype RosterId = RosterId
  { -- | Opaque, server-assigned ID of the Roster.
    id :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'RosterId' with the minimum fields required to make a request.
newRosterId ::
  RosterId
newRosterId = RosterId {id = Core.Nothing}

instance Core.FromJSON RosterId where
  parseJSON =
    Core.withObject
      "RosterId"
      (\o -> RosterId Core.<$> (o Core..:? "id"))

instance Core.ToJSON RosterId where
  toJSON RosterId {..} =
    Core.object
      (Core.catMaybes [("id" Core..=) Core.<$> id])

-- | Options for Triggers dispatched via RPC.
--
-- /See:/ 'newRpcOptions' smart constructor.
newtype RpcOptions = RpcOptions
  { -- | The RPC\'s request extensions (i.e. RPC::request/extensions(), a.k.a. the Stubby side channel) will be merged with the specified [request/extensions]. When Triggers are batched, the RPC\'s request extensions will be merged with all of the [request_extensions] of the Triggers in the batch. Note that merging of request extensions follows standard protocol buffer semantics; values of singular fields override previous values, and values of repeated fields are appended (In the case of Triggers, Triggers with later fire times will be merged after Triggers with earlier fire times in the same batch). It is not advised to specify extensions with repeated fields on batchable Triggers.
    requestExtensions :: (Core.Maybe MessageSet)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'RpcOptions' with the minimum fields required to make a request.
newRpcOptions ::
  RpcOptions
newRpcOptions = RpcOptions {requestExtensions = Core.Nothing}

instance Core.FromJSON RpcOptions where
  parseJSON =
    Core.withObject
      "RpcOptions"
      ( \o ->
          RpcOptions Core.<$> (o Core..:? "requestExtensions")
      )

instance Core.ToJSON RpcOptions where
  toJSON RpcOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("requestExtensions" Core..=)
              Core.<$> requestExtensions
          ]
      )

-- | Message containing a string that is safe to use in URL contexts in DOM APIs and HTML documents, where the URL context does not refer to a resource that loads code.
--
-- /See:/ 'newSafeUrlProto' smart constructor.
newtype SafeUrlProto = SafeUrlProto
  { -- | IMPORTANT: Never set or read this field, even from tests, it is private. See documentation at the top of .proto file for programming language packages with which to create or read this message.
    privateDoNotAccessOrElseSafeUrlWrappedValue :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SafeUrlProto' with the minimum fields required to make a request.
newSafeUrlProto ::
  SafeUrlProto
newSafeUrlProto =
  SafeUrlProto {privateDoNotAccessOrElseSafeUrlWrappedValue = Core.Nothing}

instance Core.FromJSON SafeUrlProto where
  parseJSON =
    Core.withObject
      "SafeUrlProto"
      ( \o ->
          SafeUrlProto
            Core.<$> ( o
                         Core..:? "privateDoNotAccessOrElseSafeUrlWrappedValue"
                     )
      )

instance Core.ToJSON SafeUrlProto where
  toJSON SafeUrlProto {..} =
    Core.object
      ( Core.catMaybes
          [ ( "privateDoNotAccessOrElseSafeUrlWrappedValue"
                Core..=
            )
              Core.<$> privateDoNotAccessOrElseSafeUrlWrappedValue
          ]
      )

-- | The schema definition for a data source.
--
-- /See:/ 'newSchema' smart constructor.
data Schema = Schema
  { -- | The list of top-level objects for the data source. The maximum number of elements is 10.
    objectDefinitions :: (Core.Maybe [ObjectDefinition]),
    -- | IDs of the Long Running Operations (LROs) currently running for this schema. After modifying the schema, wait for operations to complete before indexing additional content.
    operationIds :: (Core.Maybe [Core.Text])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Schema' with the minimum fields required to make a request.
newSchema ::
  Schema
newSchema =
  Schema {objectDefinitions = Core.Nothing, operationIds = Core.Nothing}

instance Core.FromJSON Schema where
  parseJSON =
    Core.withObject
      "Schema"
      ( \o ->
          Schema
            Core.<$> (o Core..:? "objectDefinitions")
            Core.<*> (o Core..:? "operationIds")
      )

instance Core.ToJSON Schema where
  toJSON Schema {..} =
    Core.object
      ( Core.catMaybes
          [ ("objectDefinitions" Core..=)
              Core.<$> objectDefinitions,
            ("operationIds" Core..=) Core.<$> operationIds
          ]
      )

-- | Scoring configurations for a source while processing a Search or Suggest request.
--
-- /See:/ 'newScoringConfig' smart constructor.
data ScoringConfig = ScoringConfig
  { -- | Whether to use freshness as a ranking signal. By default, freshness is used as a ranking signal. Note that this setting is not available in the Admin UI.
    disableFreshness :: (Core.Maybe Core.Bool),
    -- | Whether to personalize the results. By default, personal signals will be used to boost results.
    disablePersonalization :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ScoringConfig' with the minimum fields required to make a request.
newScoringConfig ::
  ScoringConfig
newScoringConfig =
  ScoringConfig
    { disableFreshness = Core.Nothing,
      disablePersonalization = Core.Nothing
    }

instance Core.FromJSON ScoringConfig where
  parseJSON =
    Core.withObject
      "ScoringConfig"
      ( \o ->
          ScoringConfig
            Core.<$> (o Core..:? "disableFreshness")
            Core.<*> (o Core..:? "disablePersonalization")
      )

instance Core.ToJSON ScoringConfig where
  toJSON ScoringConfig {..} =
    Core.object
      ( Core.catMaybes
          [ ("disableFreshness" Core..=)
              Core.<$> disableFreshness,
            ("disablePersonalization" Core..=)
              Core.<$> disablePersonalization
          ]
      )

-- | SearchApplication
--
-- /See:/ 'newSearchApplication' smart constructor.
data SearchApplication = SearchApplication
  { -- | Retrictions applied to the configurations. The maximum number of elements is 10.
    dataSourceRestrictions :: (Core.Maybe [DataSourceRestriction]),
    -- | The default fields for returning facet results. The sources specified here also have been included in data/source/restrictions above.
    defaultFacetOptions :: (Core.Maybe [FacetOptions]),
    -- | The default options for sorting the search results
    defaultSortOptions :: (Core.Maybe SortOptions),
    -- | Display name of the Search Application. The maximum length is 300 characters.
    displayName :: (Core.Maybe Core.Text),
    -- | Indicates whether audit logging is on\/off for requests made for the search application in query APIs.
    enableAuditLog :: (Core.Maybe Core.Bool),
    -- | The name of the Search Application. Format: searchapplications\/{application_id}.
    name :: (Core.Maybe Core.Text),
    -- | Output only. IDs of the Long Running Operations (LROs) currently running for this schema. Output only field.
    operationIds :: (Core.Maybe [Core.Text]),
    -- | The default options for query interpretation
    queryInterpretationConfig :: (Core.Maybe QueryInterpretationConfig),
    -- | With each result we should return the URI for its thumbnail (when applicable)
    returnResultThumbnailUrls :: (Core.Maybe Core.Bool),
    -- | Configuration for ranking results.
    scoringConfig :: (Core.Maybe ScoringConfig),
    -- | Configuration for a sources specified in data/source/restrictions.
    sourceConfig :: (Core.Maybe [SourceConfig])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SearchApplication' with the minimum fields required to make a request.
newSearchApplication ::
  SearchApplication
newSearchApplication =
  SearchApplication
    { dataSourceRestrictions = Core.Nothing,
      defaultFacetOptions = Core.Nothing,
      defaultSortOptions = Core.Nothing,
      displayName = Core.Nothing,
      enableAuditLog = Core.Nothing,
      name = Core.Nothing,
      operationIds = Core.Nothing,
      queryInterpretationConfig = Core.Nothing,
      returnResultThumbnailUrls = Core.Nothing,
      scoringConfig = Core.Nothing,
      sourceConfig = Core.Nothing
    }

instance Core.FromJSON SearchApplication where
  parseJSON =
    Core.withObject
      "SearchApplication"
      ( \o ->
          SearchApplication
            Core.<$> (o Core..:? "dataSourceRestrictions")
            Core.<*> (o Core..:? "defaultFacetOptions")
            Core.<*> (o Core..:? "defaultSortOptions")
            Core.<*> (o Core..:? "displayName")
            Core.<*> (o Core..:? "enableAuditLog")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "operationIds")
            Core.<*> (o Core..:? "queryInterpretationConfig")
            Core.<*> (o Core..:? "returnResultThumbnailUrls")
            Core.<*> (o Core..:? "scoringConfig")
            Core.<*> (o Core..:? "sourceConfig")
      )

instance Core.ToJSON SearchApplication where
  toJSON SearchApplication {..} =
    Core.object
      ( Core.catMaybes
          [ ("dataSourceRestrictions" Core..=)
              Core.<$> dataSourceRestrictions,
            ("defaultFacetOptions" Core..=)
              Core.<$> defaultFacetOptions,
            ("defaultSortOptions" Core..=)
              Core.<$> defaultSortOptions,
            ("displayName" Core..=) Core.<$> displayName,
            ("enableAuditLog" Core..=) Core.<$> enableAuditLog,
            ("name" Core..=) Core.<$> name,
            ("operationIds" Core..=) Core.<$> operationIds,
            ("queryInterpretationConfig" Core..=)
              Core.<$> queryInterpretationConfig,
            ("returnResultThumbnailUrls" Core..=)
              Core.<$> returnResultThumbnailUrls,
            ("scoringConfig" Core..=) Core.<$> scoringConfig,
            ("sourceConfig" Core..=) Core.<$> sourceConfig
          ]
      )

-- | Search application level query stats per date
--
-- /See:/ 'newSearchApplicationQueryStats' smart constructor.
data SearchApplicationQueryStats = SearchApplicationQueryStats
  { -- | The date for which query stats were calculated. Stats calculated on the next day close to midnight are returned.
    date :: (Core.Maybe Date),
    -- |
    queryCountByStatus :: (Core.Maybe [QueryCountByStatus])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SearchApplicationQueryStats' with the minimum fields required to make a request.
newSearchApplicationQueryStats ::
  SearchApplicationQueryStats
newSearchApplicationQueryStats =
  SearchApplicationQueryStats
    { date = Core.Nothing,
      queryCountByStatus = Core.Nothing
    }

instance Core.FromJSON SearchApplicationQueryStats where
  parseJSON =
    Core.withObject
      "SearchApplicationQueryStats"
      ( \o ->
          SearchApplicationQueryStats
            Core.<$> (o Core..:? "date")
            Core.<*> (o Core..:? "queryCountByStatus")
      )

instance Core.ToJSON SearchApplicationQueryStats where
  toJSON SearchApplicationQueryStats {..} =
    Core.object
      ( Core.catMaybes
          [ ("date" Core..=) Core.<$> date,
            ("queryCountByStatus" Core..=)
              Core.<$> queryCountByStatus
          ]
      )

--
-- /See:/ 'newSearchApplicationSessionStats' smart constructor.
data SearchApplicationSessionStats = SearchApplicationSessionStats
  { -- | The date for which session stats were calculated. Stats are calculated on the following day, close to midnight PST, and then returned.
    date :: (Core.Maybe Date),
    -- | The count of search sessions on the day
    searchSessionsCount :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SearchApplicationSessionStats' with the minimum fields required to make a request.
newSearchApplicationSessionStats ::
  SearchApplicationSessionStats
newSearchApplicationSessionStats =
  SearchApplicationSessionStats
    { date = Core.Nothing,
      searchSessionsCount = Core.Nothing
    }

instance Core.FromJSON SearchApplicationSessionStats where
  parseJSON =
    Core.withObject
      "SearchApplicationSessionStats"
      ( \o ->
          SearchApplicationSessionStats
            Core.<$> (o Core..:? "date")
            Core.<*> ( o Core..:? "searchSessionsCount"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON SearchApplicationSessionStats where
  toJSON SearchApplicationSessionStats {..} =
    Core.object
      ( Core.catMaybes
          [ ("date" Core..=) Core.<$> date,
            ("searchSessionsCount" Core..=) Core.. Core.AsText
              Core.<$> searchSessionsCount
          ]
      )

--
-- /See:/ 'newSearchApplicationUserStats' smart constructor.
data SearchApplicationUserStats = SearchApplicationUserStats
  { -- | The date for which session stats were calculated. Stats calculated on the next day close to midnight are returned.
    date :: (Core.Maybe Date),
    -- | The count of unique active users in the past one day
    oneDayActiveUsersCount :: (Core.Maybe Core.Int64),
    -- | The count of unique active users in the past seven days
    sevenDaysActiveUsersCount :: (Core.Maybe Core.Int64),
    -- | The count of unique active users in the past thirty days
    thirtyDaysActiveUsersCount :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SearchApplicationUserStats' with the minimum fields required to make a request.
newSearchApplicationUserStats ::
  SearchApplicationUserStats
newSearchApplicationUserStats =
  SearchApplicationUserStats
    { date = Core.Nothing,
      oneDayActiveUsersCount = Core.Nothing,
      sevenDaysActiveUsersCount = Core.Nothing,
      thirtyDaysActiveUsersCount = Core.Nothing
    }

instance Core.FromJSON SearchApplicationUserStats where
  parseJSON =
    Core.withObject
      "SearchApplicationUserStats"
      ( \o ->
          SearchApplicationUserStats
            Core.<$> (o Core..:? "date")
            Core.<*> ( o Core..:? "oneDayActiveUsersCount"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> ( o Core..:? "sevenDaysActiveUsersCount"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> ( o Core..:? "thirtyDaysActiveUsersCount"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON SearchApplicationUserStats where
  toJSON SearchApplicationUserStats {..} =
    Core.object
      ( Core.catMaybes
          [ ("date" Core..=) Core.<$> date,
            ("oneDayActiveUsersCount" Core..=) Core.. Core.AsText
              Core.<$> oneDayActiveUsersCount,
            ("sevenDaysActiveUsersCount" Core..=)
              Core.. Core.AsText
              Core.<$> sevenDaysActiveUsersCount,
            ("thirtyDaysActiveUsersCount" Core..=)
              Core.. Core.AsText
              Core.<$> thirtyDaysActiveUsersCount
          ]
      )

--
-- /See:/ 'newSearchItemsByViewUrlRequest' smart constructor.
data SearchItemsByViewUrlRequest = SearchItemsByViewUrlRequest
  { -- | Common debug options.
    debugOptions :: (Core.Maybe DebugOptions),
    -- | The next/page/token value returned from a previous request, if any.
    pageToken :: (Core.Maybe Core.Text),
    -- | Specify the full view URL to find the corresponding item. The maximum length is 2048 characters.
    viewUrl :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SearchItemsByViewUrlRequest' with the minimum fields required to make a request.
newSearchItemsByViewUrlRequest ::
  SearchItemsByViewUrlRequest
newSearchItemsByViewUrlRequest =
  SearchItemsByViewUrlRequest
    { debugOptions = Core.Nothing,
      pageToken = Core.Nothing,
      viewUrl = Core.Nothing
    }

instance Core.FromJSON SearchItemsByViewUrlRequest where
  parseJSON =
    Core.withObject
      "SearchItemsByViewUrlRequest"
      ( \o ->
          SearchItemsByViewUrlRequest
            Core.<$> (o Core..:? "debugOptions")
            Core.<*> (o Core..:? "pageToken")
            Core.<*> (o Core..:? "viewUrl")
      )

instance Core.ToJSON SearchItemsByViewUrlRequest where
  toJSON SearchItemsByViewUrlRequest {..} =
    Core.object
      ( Core.catMaybes
          [ ("debugOptions" Core..=) Core.<$> debugOptions,
            ("pageToken" Core..=) Core.<$> pageToken,
            ("viewUrl" Core..=) Core.<$> viewUrl
          ]
      )

--
-- /See:/ 'newSearchItemsByViewUrlResponse' smart constructor.
data SearchItemsByViewUrlResponse = SearchItemsByViewUrlResponse
  { -- |
    items :: (Core.Maybe [Item]),
    -- | Token to retrieve the next page of results, or empty if there are no more results in the list.
    nextPageToken :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SearchItemsByViewUrlResponse' with the minimum fields required to make a request.
newSearchItemsByViewUrlResponse ::
  SearchItemsByViewUrlResponse
newSearchItemsByViewUrlResponse =
  SearchItemsByViewUrlResponse
    { items = Core.Nothing,
      nextPageToken = Core.Nothing
    }

instance Core.FromJSON SearchItemsByViewUrlResponse where
  parseJSON =
    Core.withObject
      "SearchItemsByViewUrlResponse"
      ( \o ->
          SearchItemsByViewUrlResponse
            Core.<$> (o Core..:? "items")
            Core.<*> (o Core..:? "nextPageToken")
      )

instance Core.ToJSON SearchItemsByViewUrlResponse where
  toJSON SearchItemsByViewUrlResponse {..} =
    Core.object
      ( Core.catMaybes
          [ ("items" Core..=) Core.<$> items,
            ("nextPageToken" Core..=) Core.<$> nextPageToken
          ]
      )

-- | Additional search quality metadata of the item.
--
-- /See:/ 'newSearchQualityMetadata' smart constructor.
newtype SearchQualityMetadata = SearchQualityMetadata
  { -- | An indication of the quality of the item, used to influence search quality. Value should be between 0.0 (lowest quality) and 1.0 (highest quality). The default value is 0.0.
    quality :: (Core.Maybe Core.Double)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SearchQualityMetadata' with the minimum fields required to make a request.
newSearchQualityMetadata ::
  SearchQualityMetadata
newSearchQualityMetadata = SearchQualityMetadata {quality = Core.Nothing}

instance Core.FromJSON SearchQualityMetadata where
  parseJSON =
    Core.withObject
      "SearchQualityMetadata"
      ( \o ->
          SearchQualityMetadata
            Core.<$> (o Core..:? "quality")
      )

instance Core.ToJSON SearchQualityMetadata where
  toJSON SearchQualityMetadata {..} =
    Core.object
      ( Core.catMaybes
          [("quality" Core..=) Core.<$> quality]
      )

-- | The search API request.
--
-- /See:/ 'newSearchRequest' smart constructor.
data SearchRequest = SearchRequest
  { -- | Context attributes for the request which will be used to adjust ranking of search results. The maximum number of elements is 10.
    contextAttributes :: (Core.Maybe [ContextAttribute]),
    -- | The sources to use for querying. If not specified, all data sources from the current search application are used.
    dataSourceRestrictions :: (Core.Maybe [DataSourceRestriction]),
    -- |
    facetOptions :: (Core.Maybe [FacetOptions]),
    -- | Maximum number of search results to return in one page. Valid values are between 1 and 100, inclusive. Default value is 10. Minimum value is 50 when results beyond 2000 are requested.
    pageSize :: (Core.Maybe Core.Int32),
    -- | The raw query string. See supported search operators in the <https://support.google.com/cloudsearch/answer/6172299 Narrow your search with operators>
    query :: (Core.Maybe Core.Text),
    -- | Options to interpret the user query.
    queryInterpretationOptions :: (Core.Maybe QueryInterpretationOptions),
    -- | Request options, such as the search application and user timezone.
    requestOptions :: (Core.Maybe RequestOptions),
    -- | The options for sorting the search results
    sortOptions :: (Core.Maybe SortOptions),
    -- | Starting index of the results.
    start :: (Core.Maybe Core.Int32)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SearchRequest' with the minimum fields required to make a request.
newSearchRequest ::
  SearchRequest
newSearchRequest =
  SearchRequest
    { contextAttributes = Core.Nothing,
      dataSourceRestrictions = Core.Nothing,
      facetOptions = Core.Nothing,
      pageSize = Core.Nothing,
      query = Core.Nothing,
      queryInterpretationOptions = Core.Nothing,
      requestOptions = Core.Nothing,
      sortOptions = Core.Nothing,
      start = Core.Nothing
    }

instance Core.FromJSON SearchRequest where
  parseJSON =
    Core.withObject
      "SearchRequest"
      ( \o ->
          SearchRequest
            Core.<$> (o Core..:? "contextAttributes")
            Core.<*> (o Core..:? "dataSourceRestrictions")
            Core.<*> (o Core..:? "facetOptions")
            Core.<*> (o Core..:? "pageSize")
            Core.<*> (o Core..:? "query")
            Core.<*> (o Core..:? "queryInterpretationOptions")
            Core.<*> (o Core..:? "requestOptions")
            Core.<*> (o Core..:? "sortOptions")
            Core.<*> (o Core..:? "start")
      )

instance Core.ToJSON SearchRequest where
  toJSON SearchRequest {..} =
    Core.object
      ( Core.catMaybes
          [ ("contextAttributes" Core..=)
              Core.<$> contextAttributes,
            ("dataSourceRestrictions" Core..=)
              Core.<$> dataSourceRestrictions,
            ("facetOptions" Core..=) Core.<$> facetOptions,
            ("pageSize" Core..=) Core.<$> pageSize,
            ("query" Core..=) Core.<$> query,
            ("queryInterpretationOptions" Core..=)
              Core.<$> queryInterpretationOptions,
            ("requestOptions" Core..=) Core.<$> requestOptions,
            ("sortOptions" Core..=) Core.<$> sortOptions,
            ("start" Core..=) Core.<$> start
          ]
      )

-- | The search API response.
--
-- /See:/ 'newSearchResponse' smart constructor.
data SearchResponse = SearchResponse
  { -- | Debugging information about the response.
    debugInfo :: (Core.Maybe ResponseDebugInfo),
    -- | Error information about the response.
    errorInfo :: (Core.Maybe ErrorInfo),
    -- | Repeated facet results.
    facetResults :: (Core.Maybe [FacetResult]),
    -- | Whether there are more search results matching the query.
    hasMoreResults :: (Core.Maybe Core.Bool),
    -- | Query interpretation result for user query. Empty if query interpretation is disabled.
    queryInterpretation :: (Core.Maybe QueryInterpretation),
    -- | The estimated result count for this query.
    resultCountEstimate :: (Core.Maybe Core.Int64),
    -- | The exact result count for this query.
    resultCountExact :: (Core.Maybe Core.Int64),
    -- | Expanded result count information.
    resultCounts :: (Core.Maybe ResultCounts),
    -- | Results from a search query.
    results :: (Core.Maybe [SearchResult]),
    -- | Suggested spelling for the query.
    spellResults :: (Core.Maybe [SpellResult]),
    -- | Structured results for the user query. These results are not counted against the page_size.
    structuredResults :: (Core.Maybe [StructuredResult])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SearchResponse' with the minimum fields required to make a request.
newSearchResponse ::
  SearchResponse
newSearchResponse =
  SearchResponse
    { debugInfo = Core.Nothing,
      errorInfo = Core.Nothing,
      facetResults = Core.Nothing,
      hasMoreResults = Core.Nothing,
      queryInterpretation = Core.Nothing,
      resultCountEstimate = Core.Nothing,
      resultCountExact = Core.Nothing,
      resultCounts = Core.Nothing,
      results = Core.Nothing,
      spellResults = Core.Nothing,
      structuredResults = Core.Nothing
    }

instance Core.FromJSON SearchResponse where
  parseJSON =
    Core.withObject
      "SearchResponse"
      ( \o ->
          SearchResponse
            Core.<$> (o Core..:? "debugInfo")
            Core.<*> (o Core..:? "errorInfo")
            Core.<*> (o Core..:? "facetResults")
            Core.<*> (o Core..:? "hasMoreResults")
            Core.<*> (o Core..:? "queryInterpretation")
            Core.<*> ( o Core..:? "resultCountEstimate"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> ( o Core..:? "resultCountExact"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "resultCounts")
            Core.<*> (o Core..:? "results")
            Core.<*> (o Core..:? "spellResults")
            Core.<*> (o Core..:? "structuredResults")
      )

instance Core.ToJSON SearchResponse where
  toJSON SearchResponse {..} =
    Core.object
      ( Core.catMaybes
          [ ("debugInfo" Core..=) Core.<$> debugInfo,
            ("errorInfo" Core..=) Core.<$> errorInfo,
            ("facetResults" Core..=) Core.<$> facetResults,
            ("hasMoreResults" Core..=) Core.<$> hasMoreResults,
            ("queryInterpretation" Core..=)
              Core.<$> queryInterpretation,
            ("resultCountEstimate" Core..=) Core.. Core.AsText
              Core.<$> resultCountEstimate,
            ("resultCountExact" Core..=) Core.. Core.AsText
              Core.<$> resultCountExact,
            ("resultCounts" Core..=) Core.<$> resultCounts,
            ("results" Core..=) Core.<$> results,
            ("spellResults" Core..=) Core.<$> spellResults,
            ("structuredResults" Core..=)
              Core.<$> structuredResults
          ]
      )

-- | Results containing indexed information for a document.
--
-- /See:/ 'newSearchResult' smart constructor.
data SearchResult = SearchResult
  { -- | If source is clustered, provide list of clustered results. There will only be one level of clustered results. If current source is not enabled for clustering, this field will be empty.
    clusteredResults :: (Core.Maybe [SearchResult]),
    -- | Debugging information about this search result.
    debugInfo :: (Core.Maybe ResultDebugInfo),
    -- | Metadata of the search result.
    metadata :: (Core.Maybe Metadata),
    -- | The concatenation of all snippets (summaries) available for this result.
    snippet :: (Core.Maybe Snippet),
    -- | Title of the search result.
    title :: (Core.Maybe Core.Text),
    -- | The URL of the search result. The URL contains a Google redirect to the actual item. This URL is signed and shouldn\'t be changed.
    url :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SearchResult' with the minimum fields required to make a request.
newSearchResult ::
  SearchResult
newSearchResult =
  SearchResult
    { clusteredResults = Core.Nothing,
      debugInfo = Core.Nothing,
      metadata = Core.Nothing,
      snippet = Core.Nothing,
      title = Core.Nothing,
      url = Core.Nothing
    }

instance Core.FromJSON SearchResult where
  parseJSON =
    Core.withObject
      "SearchResult"
      ( \o ->
          SearchResult
            Core.<$> (o Core..:? "clusteredResults")
            Core.<*> (o Core..:? "debugInfo")
            Core.<*> (o Core..:? "metadata")
            Core.<*> (o Core..:? "snippet")
            Core.<*> (o Core..:? "title")
            Core.<*> (o Core..:? "url")
      )

instance Core.ToJSON SearchResult where
  toJSON SearchResult {..} =
    Core.object
      ( Core.catMaybes
          [ ("clusteredResults" Core..=)
              Core.<$> clusteredResults,
            ("debugInfo" Core..=) Core.<$> debugInfo,
            ("metadata" Core..=) Core.<$> metadata,
            ("snippet" Core..=) Core.<$> snippet,
            ("title" Core..=) Core.<$> title,
            ("url" Core..=) Core.<$> url
          ]
      )

-- | Sections are separated by a line divider. They contain a collection of widgets that are rendered (vertically) in the order that they are specified. Across all platforms, AddOns have a narrow fixed width, so there is currently no need for layout properties (e.g. float).
--
-- /See:/ 'newSection' smart constructor.
data Section = Section
  { -- | Indicating whether this section is collapsable. If a section is collapsable, the description must be given.
    collapsable :: (Core.Maybe Core.Bool),
    -- | The header of the section, text formatted supported.
    description :: (Core.Maybe Core.Text),
    -- | The number of uncollapsable widgets. For example, when a section contains 5 widgets and the num/uncollapsable/widget are set to be 2, The first 2 widgets will always shown and the last 3 is collapsed as default. Only when collapsable is set to be true, the num/uncollapsable/widget will be taken into account.
    numUncollapsableWidgets :: (Core.Maybe Core.Int32),
    -- | A section must contain at least 1 widget.
    widgets :: (Core.Maybe [WidgetMarkup])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Section' with the minimum fields required to make a request.
newSection ::
  Section
newSection =
  Section
    { collapsable = Core.Nothing,
      description = Core.Nothing,
      numUncollapsableWidgets = Core.Nothing,
      widgets = Core.Nothing
    }

instance Core.FromJSON Section where
  parseJSON =
    Core.withObject
      "Section"
      ( \o ->
          Section
            Core.<$> (o Core..:? "collapsable")
            Core.<*> (o Core..:? "description")
            Core.<*> (o Core..:? "numUncollapsableWidgets")
            Core.<*> (o Core..:? "widgets")
      )

instance Core.ToJSON Section where
  toJSON Section {..} =
    Core.object
      ( Core.catMaybes
          [ ("collapsable" Core..=) Core.<$> collapsable,
            ("description" Core..=) Core.<$> description,
            ("numUncollapsableWidgets" Core..=)
              Core.<$> numUncollapsableWidgets,
            ("widgets" Core..=) Core.<$> widgets
          ]
      )

--
-- /See:/ 'newSegment' smart constructor.
data Segment = Segment
  { -- | Formatting to be applied when rendering the Segment. For all segment types, this is the standard way of representing that the Segment should be rendered in bold, italics, etc.
    formatting :: (Core.Maybe Formatting),
    -- | For HASHTAG type:
    hashtagData :: (Core.Maybe HashtagData),
    -- | Type-specific metadata. At most one of these should be populated, and the one that is populated should correspond to the type of the Segment. For LINK type:
    linkData :: (Core.Maybe LinkData),
    -- | Text content of the Segment. As a general rule, this field should contain the actual text that should be rendered in the UI. Thus, for a hashtag, it should be \"#Foo\", and for a link, it should be the display text. Clients that do not understand a particular segment type may use this text, along with the Formatting info below, as a fallback for display. The field is not required -- if all relevant information is carried in other metadata fields and there is no need for a fallback, or it is not practical for a fallback to be provided for any other reason, the field may be left blank. A standard example would be a user reference being transmitted between server layers, where a gaia-ID representation may be sufficient and there is no need for a textual fallback. In such a case, it would be valid and useful - though not required - for servers to compute and populate a fallback on the serving path.
    text :: (Core.Maybe Core.Text),
    -- | Type of Segment.
    type' :: (Core.Maybe Segment_Type),
    -- | For USER_MENTION type:
    userMentionData :: (Core.Maybe UserMentionData)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Segment' with the minimum fields required to make a request.
newSegment ::
  Segment
newSegment =
  Segment
    { formatting = Core.Nothing,
      hashtagData = Core.Nothing,
      linkData = Core.Nothing,
      text = Core.Nothing,
      type' = Core.Nothing,
      userMentionData = Core.Nothing
    }

instance Core.FromJSON Segment where
  parseJSON =
    Core.withObject
      "Segment"
      ( \o ->
          Segment
            Core.<$> (o Core..:? "formatting")
            Core.<*> (o Core..:? "hashtagData")
            Core.<*> (o Core..:? "linkData")
            Core.<*> (o Core..:? "text")
            Core.<*> (o Core..:? "type")
            Core.<*> (o Core..:? "userMentionData")
      )

instance Core.ToJSON Segment where
  toJSON Segment {..} =
    Core.object
      ( Core.catMaybes
          [ ("formatting" Core..=) Core.<$> formatting,
            ("hashtagData" Core..=) Core.<$> hashtagData,
            ("linkData" Core..=) Core.<$> linkData,
            ("text" Core..=) Core.<$> text,
            ("type" Core..=) Core.<$> type',
            ("userMentionData" Core..=)
              Core.<$> userMentionData
          ]
      )

--
-- /See:/ 'newSelectionControl' smart constructor.
data SelectionControl = SelectionControl
  { -- | For radio button, at most one of the items will be selected.
    items :: (Core.Maybe [SelectionItem]),
    -- | Label used to be displayed ahead of the selection control. It is optional.
    label :: (Core.Maybe Core.Text),
    -- | The name of the text field which is will be used in FormInput.
    name :: (Core.Maybe Core.Text),
    -- | If specified, form is submitted when selection changed. If not specified, developer will need to specify a separate button.
    onChange :: (Core.Maybe FormAction),
    -- |
    type' :: (Core.Maybe SelectionControl_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SelectionControl' with the minimum fields required to make a request.
newSelectionControl ::
  SelectionControl
newSelectionControl =
  SelectionControl
    { items = Core.Nothing,
      label = Core.Nothing,
      name = Core.Nothing,
      onChange = Core.Nothing,
      type' = Core.Nothing
    }

instance Core.FromJSON SelectionControl where
  parseJSON =
    Core.withObject
      "SelectionControl"
      ( \o ->
          SelectionControl
            Core.<$> (o Core..:? "items")
            Core.<*> (o Core..:? "label")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "onChange")
            Core.<*> (o Core..:? "type")
      )

instance Core.ToJSON SelectionControl where
  toJSON SelectionControl {..} =
    Core.object
      ( Core.catMaybes
          [ ("items" Core..=) Core.<$> items,
            ("label" Core..=) Core.<$> label,
            ("name" Core..=) Core.<$> name,
            ("onChange" Core..=) Core.<$> onChange,
            ("type" Core..=) Core.<$> type'
          ]
      )

--
-- /See:/ 'newSelectionItem' smart constructor.
data SelectionItem = SelectionItem
  { -- | If more than one items are selected for RADIO_BUTTON and DROPDOWN, the first selected item is treated as sElected and the after ones are all ignored.
    selected :: (Core.Maybe Core.Bool),
    -- | The text to be displayed.
    text :: (Core.Maybe Core.Text),
    -- | The value associated with this item which will be sent back to app scripts. Client should use as a form input value.
    value :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SelectionItem' with the minimum fields required to make a request.
newSelectionItem ::
  SelectionItem
newSelectionItem =
  SelectionItem
    { selected = Core.Nothing,
      text = Core.Nothing,
      value = Core.Nothing
    }

instance Core.FromJSON SelectionItem where
  parseJSON =
    Core.withObject
      "SelectionItem"
      ( \o ->
          SelectionItem
            Core.<$> (o Core..:? "selected")
            Core.<*> (o Core..:? "text")
            Core.<*> (o Core..:? "value")
      )

instance Core.ToJSON SelectionItem where
  toJSON SelectionItem {..} =
    Core.object
      ( Core.catMaybes
          [ ("selected" Core..=) Core.<$> selected,
            ("text" Core..=) Core.<$> text,
            ("value" Core..=) Core.<$> value
          ]
      )

--
-- /See:/ 'newSessionContext' smart constructor.
data SessionContext = SessionContext
  { -- | Time at which this activity\'s session was authenticated, in seconds since the epoch.
    authTime :: (Core.Maybe Core.Int64),
    -- | Gaia ID of the authenticated user when delegate access is active. In such sessions the main gaia ID is that of the delegator, i.e. the account being accessed.
    delegateUserId :: (Core.Maybe Core.Int64),
    -- | Device User Session ID, see go\/dusi.
    dusi :: (Core.Maybe Core.Text),
    -- | Imap session context for Bond\/Gmail integration
    imapSessionContext :: (Core.Maybe ImapSessionContext),
    -- | OAuth login ID.
    oauthLoginId :: (Core.Maybe Core.Int32),
    -- | The devconsole project ID of the developer who authenticated with OAuth.
    oauthProjectId :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SessionContext' with the minimum fields required to make a request.
newSessionContext ::
  SessionContext
newSessionContext =
  SessionContext
    { authTime = Core.Nothing,
      delegateUserId = Core.Nothing,
      dusi = Core.Nothing,
      imapSessionContext = Core.Nothing,
      oauthLoginId = Core.Nothing,
      oauthProjectId = Core.Nothing
    }

instance Core.FromJSON SessionContext where
  parseJSON =
    Core.withObject
      "SessionContext"
      ( \o ->
          SessionContext
            Core.<$> ( o Core..:? "authTime"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> ( o Core..:? "delegateUserId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "dusi")
            Core.<*> (o Core..:? "imapSessionContext")
            Core.<*> (o Core..:? "oauthLoginId")
            Core.<*> ( o Core..:? "oauthProjectId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON SessionContext where
  toJSON SessionContext {..} =
    Core.object
      ( Core.catMaybes
          [ ("authTime" Core..=) Core.. Core.AsText
              Core.<$> authTime,
            ("delegateUserId" Core..=) Core.. Core.AsText
              Core.<$> delegateUserId,
            ("dusi" Core..=) Core.<$> dusi,
            ("imapSessionContext" Core..=)
              Core.<$> imapSessionContext,
            ("oauthLoginId" Core..=) Core.<$> oauthLoginId,
            ("oauthProjectId" Core..=) Core.. Core.AsText
              Core.<$> oauthProjectId
          ]
      )

-- | A session event is something that happens to the streaming session in a conference.
--
-- /See:/ 'newSessionEvent' smart constructor.
data SessionEvent = SessionEvent
  { -- | The initiator of the latest event of the streaming session. It will be set for all user events (@type@ is 100-199) and unset for all server events(@type@ is 200-299).
    deviceId :: (Core.Maybe Core.Text),
    -- | The type of event.
    type' :: (Core.Maybe SessionEvent_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SessionEvent' with the minimum fields required to make a request.
newSessionEvent ::
  SessionEvent
newSessionEvent = SessionEvent {deviceId = Core.Nothing, type' = Core.Nothing}

instance Core.FromJSON SessionEvent where
  parseJSON =
    Core.withObject
      "SessionEvent"
      ( \o ->
          SessionEvent
            Core.<$> (o Core..:? "deviceId") Core.<*> (o Core..:? "type")
      )

instance Core.ToJSON SessionEvent where
  toJSON SessionEvent {..} =
    Core.object
      ( Core.catMaybes
          [ ("deviceId" Core..=) Core.<$> deviceId,
            ("type" Core..=) Core.<$> type'
          ]
      )

-- | Information about the state of a (recording, broadcast, transcription...) session in a conference.
--
-- /See:/ 'newSessionStateInfo' smart constructor.
data SessionStateInfo = SessionStateInfo
  { -- | Output only. The ack info of the session.
    ackInfo :: (Core.Maybe AckInfo),
    -- | Immutable. The language configuration used by this session. When empty, captions will be disabled. It\'s a required field for transcription sessions.
    languageConfig :: (Core.Maybe LanguageConfig),
    -- | Output only. The device id of the actor is set if the current state is a result of a user action, is empty otherwise.
    lastActorDeviceId :: (Core.Maybe Core.Text),
    -- | Output only. The max end time of the session, at this time the session will be force stopped\/terminated. Clients are expected to use this timestamp to warn users about the force stop.
    maxEndTime :: (Core.Maybe Core.DateTime),
    -- | State of the session.
    sessionState :: (Core.Maybe SessionStateInfo_SessionState),
    -- | Output only. The reason the session was transitioned to STOPPED state.
    sessionStopReason :: (Core.Maybe SessionStateInfo_SessionStopReason)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SessionStateInfo' with the minimum fields required to make a request.
newSessionStateInfo ::
  SessionStateInfo
newSessionStateInfo =
  SessionStateInfo
    { ackInfo = Core.Nothing,
      languageConfig = Core.Nothing,
      lastActorDeviceId = Core.Nothing,
      maxEndTime = Core.Nothing,
      sessionState = Core.Nothing,
      sessionStopReason = Core.Nothing
    }

instance Core.FromJSON SessionStateInfo where
  parseJSON =
    Core.withObject
      "SessionStateInfo"
      ( \o ->
          SessionStateInfo
            Core.<$> (o Core..:? "ackInfo")
            Core.<*> (o Core..:? "languageConfig")
            Core.<*> (o Core..:? "lastActorDeviceId")
            Core.<*> (o Core..:? "maxEndTime")
            Core.<*> (o Core..:? "sessionState")
            Core.<*> (o Core..:? "sessionStopReason")
      )

instance Core.ToJSON SessionStateInfo where
  toJSON SessionStateInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("ackInfo" Core..=) Core.<$> ackInfo,
            ("languageConfig" Core..=) Core.<$> languageConfig,
            ("lastActorDeviceId" Core..=)
              Core.<$> lastActorDeviceId,
            ("maxEndTime" Core..=) Core.<$> maxEndTime,
            ("sessionState" Core..=) Core.<$> sessionState,
            ("sessionStopReason" Core..=)
              Core.<$> sessionStopReason
          ]
      )

-- | Settings of a meeting space that can be edited by users with corresponding manage privilege. These settings are always populated in responses.
--
-- /See:/ 'newSettings' smart constructor.
data Settings = Settings
  { -- | The access lock of the meeting space that lets hosts control who can join the meeting.
    accessLock :: (Core.Maybe Core.Bool),
    -- | The access type of the meeting space.
    accessType :: (Core.Maybe Settings_AccessType),
    -- | Whether users can join before host in the conferences of this meeting space.
    allowJoiningBeforeHost :: (Core.Maybe Core.Bool),
    -- | Whether attendance report is enabled for the meeting space.
    attendanceReportEnabled :: (Core.Maybe Core.Bool),
    -- | The chat lock of the meeting space that lets owner control whether the participants can send chat messages.
    chatLock :: (Core.Maybe Core.Bool),
    -- | Whether meeting artifacts will be shared with cohosts.
    cohostArtifactSharingEnabled :: (Core.Maybe Core.Bool),
    -- | Whether Client-side Encryption is enabled for the meeting space.
    cseEnabled :: (Core.Maybe Core.Bool),
    -- | Whether the default role is viewer or not.
    defaultAsViewer :: (Core.Maybe Core.Bool),
    -- | Indicates whether the meeting space is moderated.
    moderationEnabled :: (Core.Maybe Core.Bool),
    -- | The present lock of the meeting space that lets owner control whether the participants can present their screen.
    presentLock :: (Core.Maybe Core.Bool),
    -- | The reactions lock of the meeting space that lets owner control whether the participants can send reactions.
    reactionsLock :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Settings' with the minimum fields required to make a request.
newSettings ::
  Settings
newSettings =
  Settings
    { accessLock = Core.Nothing,
      accessType = Core.Nothing,
      allowJoiningBeforeHost = Core.Nothing,
      attendanceReportEnabled = Core.Nothing,
      chatLock = Core.Nothing,
      cohostArtifactSharingEnabled = Core.Nothing,
      cseEnabled = Core.Nothing,
      defaultAsViewer = Core.Nothing,
      moderationEnabled = Core.Nothing,
      presentLock = Core.Nothing,
      reactionsLock = Core.Nothing
    }

instance Core.FromJSON Settings where
  parseJSON =
    Core.withObject
      "Settings"
      ( \o ->
          Settings
            Core.<$> (o Core..:? "accessLock")
            Core.<*> (o Core..:? "accessType")
            Core.<*> (o Core..:? "allowJoiningBeforeHost")
            Core.<*> (o Core..:? "attendanceReportEnabled")
            Core.<*> (o Core..:? "chatLock")
            Core.<*> (o Core..:? "cohostArtifactSharingEnabled")
            Core.<*> (o Core..:? "cseEnabled")
            Core.<*> (o Core..:? "defaultAsViewer")
            Core.<*> (o Core..:? "moderationEnabled")
            Core.<*> (o Core..:? "presentLock")
            Core.<*> (o Core..:? "reactionsLock")
      )

instance Core.ToJSON Settings where
  toJSON Settings {..} =
    Core.object
      ( Core.catMaybes
          [ ("accessLock" Core..=) Core.<$> accessLock,
            ("accessType" Core..=) Core.<$> accessType,
            ("allowJoiningBeforeHost" Core..=)
              Core.<$> allowJoiningBeforeHost,
            ("attendanceReportEnabled" Core..=)
              Core.<$> attendanceReportEnabled,
            ("chatLock" Core..=) Core.<$> chatLock,
            ("cohostArtifactSharingEnabled" Core..=)
              Core.<$> cohostArtifactSharingEnabled,
            ("cseEnabled" Core..=) Core.<$> cseEnabled,
            ("defaultAsViewer" Core..=) Core.<$> defaultAsViewer,
            ("moderationEnabled" Core..=)
              Core.<$> moderationEnabled,
            ("presentLock" Core..=) Core.<$> presentLock,
            ("reactionsLock" Core..=) Core.<$> reactionsLock
          ]
      )

--
-- /See:/ 'newShareScope' smart constructor.
data ShareScope = ShareScope
  { -- | If scope is DOMAIN, this field contains the dasher domain, for example \"google.com\".
    domain :: (Core.Maybe Core.Text),
    -- | The scope to which the content was shared.
    scope :: (Core.Maybe ShareScope_Scope)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ShareScope' with the minimum fields required to make a request.
newShareScope ::
  ShareScope
newShareScope = ShareScope {domain = Core.Nothing, scope = Core.Nothing}

instance Core.FromJSON ShareScope where
  parseJSON =
    Core.withObject
      "ShareScope"
      ( \o ->
          ShareScope
            Core.<$> (o Core..:? "domain") Core.<*> (o Core..:? "scope")
      )

instance Core.ToJSON ShareScope where
  toJSON ShareScope {..} =
    Core.object
      ( Core.catMaybes
          [ ("domain" Core..=) Core.<$> domain,
            ("scope" Core..=) Core.<$> scope
          ]
      )

--
-- /See:/ 'newSheetsClientActionMarkup' smart constructor.
newtype SheetsClientActionMarkup = SheetsClientActionMarkup
  { -- |
    customFunctionReturnValueMarkup :: (Core.Maybe CustomFunctionReturnValueMarkup)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SheetsClientActionMarkup' with the minimum fields required to make a request.
newSheetsClientActionMarkup ::
  SheetsClientActionMarkup
newSheetsClientActionMarkup =
  SheetsClientActionMarkup {customFunctionReturnValueMarkup = Core.Nothing}

instance Core.FromJSON SheetsClientActionMarkup where
  parseJSON =
    Core.withObject
      "SheetsClientActionMarkup"
      ( \o ->
          SheetsClientActionMarkup
            Core.<$> (o Core..:? "customFunctionReturnValueMarkup")
      )

instance Core.ToJSON SheetsClientActionMarkup where
  toJSON SheetsClientActionMarkup {..} =
    Core.object
      ( Core.catMaybes
          [ ("customFunctionReturnValueMarkup" Core..=)
              Core.<$> customFunctionReturnValueMarkup
          ]
      )

-- | Represents a principal who possesses a signing key corresponding to the verification key or keyset described here.
--
-- /See:/ 'newSigningKeyPossessorProto' smart constructor.
data SigningKeyPossessorProto = SigningKeyPossessorProto
  { -- | This value must be from the KeyMetadata.Type enum in keymaster.proto.
    keymasterKeyType :: (Core.Maybe Core.Int32),
    -- | The actual verification key bytes corresponding to the above type.
    serializedVerificationKey :: (Core.Maybe Core.Base64),
    -- | The binary serialized Keymaster SerializedReader of a public keyset. The keyset must contain exactly one key. N.B.: If this field is populated, serialized/verification/key should be set to the empty string and keymaster/key/type should be set to zero.
    serializedVerificationKeyset :: (Core.Maybe Core.Base64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SigningKeyPossessorProto' with the minimum fields required to make a request.
newSigningKeyPossessorProto ::
  SigningKeyPossessorProto
newSigningKeyPossessorProto =
  SigningKeyPossessorProto
    { keymasterKeyType = Core.Nothing,
      serializedVerificationKey = Core.Nothing,
      serializedVerificationKeyset = Core.Nothing
    }

instance Core.FromJSON SigningKeyPossessorProto where
  parseJSON =
    Core.withObject
      "SigningKeyPossessorProto"
      ( \o ->
          SigningKeyPossessorProto
            Core.<$> (o Core..:? "keymasterKeyType")
            Core.<*> (o Core..:? "serializedVerificationKey")
            Core.<*> (o Core..:? "serializedVerificationKeyset")
      )

instance Core.ToJSON SigningKeyPossessorProto where
  toJSON SigningKeyPossessorProto {..} =
    Core.object
      ( Core.catMaybes
          [ ("keymasterKeyType" Core..=)
              Core.<$> keymasterKeyType,
            ("serializedVerificationKey" Core..=)
              Core.<$> serializedVerificationKey,
            ("serializedVerificationKeyset" Core..=)
              Core.<$> serializedVerificationKeyset
          ]
      )

-- | Represents a principal which possesses a particular, presumably secret, string. Useful for things like \"auth keys,\" used for anonymous sharing. Since representing this principal with the actual secret included reveals the secret, it\'s best if the requisite condition is enforced in some other way, for example via Keystore wrapping attributes (Keystore will unwrap only if the specified secret, aka \"attribute\", is presented). All that\'s stored here is an identifying label.
--
-- /See:/ 'newSimpleSecretHolderProto' smart constructor.
newtype SimpleSecretHolderProto = SimpleSecretHolderProto
  { -- | A descriptive label to help identify a relevant ACL entry or otherwise disambiguate this instance.
    label :: (Core.Maybe SimpleSecretLabelProto)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SimpleSecretHolderProto' with the minimum fields required to make a request.
newSimpleSecretHolderProto ::
  SimpleSecretHolderProto
newSimpleSecretHolderProto = SimpleSecretHolderProto {label = Core.Nothing}

instance Core.FromJSON SimpleSecretHolderProto where
  parseJSON =
    Core.withObject
      "SimpleSecretHolderProto"
      ( \o ->
          SimpleSecretHolderProto
            Core.<$> (o Core..:? "label")
      )

instance Core.ToJSON SimpleSecretHolderProto where
  toJSON SimpleSecretHolderProto {..} =
    Core.object
      (Core.catMaybes [("label" Core..=) Core.<$> label])

-- | SimpleSecretProto (in authenticator.proto) and SimpleSecretHolderProto (below) share the notion of a \"label\", which identifies a particular secret without (hopefully) revealing the secret. Note that a SimpleSecretLabel only disambiguates between secrets used to get access to some particular object. Two different secrets that apply to two different objects could have the same label. For example, in the common sharing model, each object has no more than one \"auth key\". Therefore, the label for an auth key simply has type = AUTH_KEY with no additional information. In theory, we could add some sort of resource ID to SimpleSecretLabel to make it more explicit. However, in practice, this is never really needed. A SimpleSecret for one object is never used to authorize a request on some other object, so there is no ambiguity. Also, since SimpleSecrets must obviously be unguessable, there is no risk that a SimpleSecret intended for one object will accidentally grant access to another.
--
-- /See:/ 'newSimpleSecretLabelProto' smart constructor.
data SimpleSecretLabelProto = SimpleSecretLabelProto
  { -- | __/DEPRECATED (3-Oct-2011) /__ This field should be deleted when code stops using CAP/TOKEN labels. Used when type = CAP/TOKEN. When a CAP/TOKEN label appears in a SimpleSecretHolder Principal, |capability/id| must be filled in to identify one of the capabilities on the ACL. When a CAP/TOKEN label appears in a SimpleSecret Authenticator, it is NOT necessary to fill in |capability/id| -- ACL Service will find the ID by searching all capabilities on the ACL for one associated with the token given by the SimpleSecret\'s secret data. If |capability_id| is specified, though, then the Authenticator will only be accepted if it actually matches that particular token ID.
    capabilityId :: (Core.Maybe Core.Int32),
    -- | Used when type = GENERIC_SECRET
    genericLabel :: (Core.Maybe Core.Base64),
    -- | Used when type == INVITE.
    inviteId :: (Core.Maybe Core.Int64),
    -- | This is optional because required enums cannot be extended.
    type' :: (Core.Maybe SimpleSecretLabelProto_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SimpleSecretLabelProto' with the minimum fields required to make a request.
newSimpleSecretLabelProto ::
  SimpleSecretLabelProto
newSimpleSecretLabelProto =
  SimpleSecretLabelProto
    { capabilityId = Core.Nothing,
      genericLabel = Core.Nothing,
      inviteId = Core.Nothing,
      type' = Core.Nothing
    }

instance Core.FromJSON SimpleSecretLabelProto where
  parseJSON =
    Core.withObject
      "SimpleSecretLabelProto"
      ( \o ->
          SimpleSecretLabelProto
            Core.<$> (o Core..:? "capabilityId")
            Core.<*> (o Core..:? "genericLabel")
            Core.<*> ( o Core..:? "inviteId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "type")
      )

instance Core.ToJSON SimpleSecretLabelProto where
  toJSON SimpleSecretLabelProto {..} =
    Core.object
      ( Core.catMaybes
          [ ("capabilityId" Core..=) Core.<$> capabilityId,
            ("genericLabel" Core..=) Core.<$> genericLabel,
            ("inviteId" Core..=) Core.. Core.AsText
              Core.<$> inviteId,
            ("type" Core..=) Core.<$> type'
          ]
      )

-- | Annotation metadata for slash commands (\/).
--
-- /See:/ 'newSlashCommandMetadata' smart constructor.
data SlashCommandMetadata = SlashCommandMetadata
  { -- | Hint string for the arguments expected by the slash command.
    argumentsHint :: (Core.Maybe Core.Text),
    -- | Unique id for the slash command.
    commandId :: (Core.Maybe Core.Int64),
    -- | Name of the slash command.
    commandName :: (Core.Maybe Core.Text),
    -- | ID of the bot which owns the slash command.
    id :: (Core.Maybe UserId),
    -- | Whether or not this slash command should trigger a dialog.
    triggersDialog :: (Core.Maybe Core.Bool),
    -- |
    type' :: (Core.Maybe SlashCommandMetadata_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SlashCommandMetadata' with the minimum fields required to make a request.
newSlashCommandMetadata ::
  SlashCommandMetadata
newSlashCommandMetadata =
  SlashCommandMetadata
    { argumentsHint = Core.Nothing,
      commandId = Core.Nothing,
      commandName = Core.Nothing,
      id = Core.Nothing,
      triggersDialog = Core.Nothing,
      type' = Core.Nothing
    }

instance Core.FromJSON SlashCommandMetadata where
  parseJSON =
    Core.withObject
      "SlashCommandMetadata"
      ( \o ->
          SlashCommandMetadata
            Core.<$> (o Core..:? "argumentsHint")
            Core.<*> ( o Core..:? "commandId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "commandName")
            Core.<*> (o Core..:? "id")
            Core.<*> (o Core..:? "triggersDialog")
            Core.<*> (o Core..:? "type")
      )

instance Core.ToJSON SlashCommandMetadata where
  toJSON SlashCommandMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("argumentsHint" Core..=) Core.<$> argumentsHint,
            ("commandId" Core..=) Core.. Core.AsText
              Core.<$> commandId,
            ("commandName" Core..=) Core.<$> commandName,
            ("id" Core..=) Core.<$> id,
            ("triggersDialog" Core..=) Core.<$> triggersDialog,
            ("type" Core..=) Core.<$> type'
          ]
      )

-- | Snippet of the search result, which summarizes the content of the resulting page.
--
-- /See:/ 'newSnippet' smart constructor.
data Snippet = Snippet
  { -- | The matched ranges in the snippet.
    matchRanges :: (Core.Maybe [MatchRange]),
    -- | The snippet of the document. The snippet of the document. May contain escaped HTML character that should be unescaped prior to rendering.
    snippet :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Snippet' with the minimum fields required to make a request.
newSnippet ::
  Snippet
newSnippet = Snippet {matchRanges = Core.Nothing, snippet = Core.Nothing}

instance Core.FromJSON Snippet where
  parseJSON =
    Core.withObject
      "Snippet"
      ( \o ->
          Snippet
            Core.<$> (o Core..:? "matchRanges")
            Core.<*> (o Core..:? "snippet")
      )

instance Core.ToJSON Snippet where
  toJSON Snippet {..} =
    Core.object
      ( Core.catMaybes
          [ ("matchRanges" Core..=) Core.<$> matchRanges,
            ("snippet" Core..=) Core.<$> snippet
          ]
      )

-- | An Attachment represents a linked entity associated with a piece of social content. This may be a 1st-party or 3rd-party entity. In the Papyrus context, an Attachment is part of a Cent, and sits alongside the main content of the cent, which is represented as a sequence of Segments. Right now an Attachment is just a wrapper around an Embed, but we provide the extra layer of abstraction since, as Embeds move to separate storage in Briefcase, we may want to add additional fields that are not part of the Embed proper, but that (for example) relate to the usage of the linked content within the particular post\/cent.
--
-- /See:/ 'newSocialCommonAttachmentAttachment' smart constructor.
data SocialCommonAttachmentAttachment = SocialCommonAttachmentAttachment
  { -- | An embed represents an external entity. See go\/es-embeds.
    embedItem :: (Core.Maybe EmbedClientItem),
    -- | An id to uniquely identify an attachment when several attachments are in a collection.
    id :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SocialCommonAttachmentAttachment' with the minimum fields required to make a request.
newSocialCommonAttachmentAttachment ::
  SocialCommonAttachmentAttachment
newSocialCommonAttachmentAttachment =
  SocialCommonAttachmentAttachment {embedItem = Core.Nothing, id = Core.Nothing}

instance
  Core.FromJSON
    SocialCommonAttachmentAttachment
  where
  parseJSON =
    Core.withObject
      "SocialCommonAttachmentAttachment"
      ( \o ->
          SocialCommonAttachmentAttachment
            Core.<$> (o Core..:? "embedItem") Core.<*> (o Core..:? "id")
      )

instance Core.ToJSON SocialCommonAttachmentAttachment where
  toJSON SocialCommonAttachmentAttachment {..} =
    Core.object
      ( Core.catMaybes
          [ ("embedItem" Core..=) Core.<$> embedItem,
            ("id" Core..=) Core.<$> id
          ]
      )

-- | Represents a user pseudonym. Pseudonyms are linked accounts on Google and third-party services (e.g. YouTube or Twitter) and are described by a Social Graph Node.
--
-- /See:/ 'newSocialGraphNodeProto' smart constructor.
data SocialGraphNodeProto = SocialGraphNodeProto
  { -- | The fields from ccc\/socialgraph\/socialgraphnode.proto:SgnNode that uniquely identify a social graph node. The \'ident\' field is not included here because its value can be changed.
    sgnDomain :: (Core.Maybe Core.Text),
    -- |
    sgnPk :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SocialGraphNodeProto' with the minimum fields required to make a request.
newSocialGraphNodeProto ::
  SocialGraphNodeProto
newSocialGraphNodeProto =
  SocialGraphNodeProto {sgnDomain = Core.Nothing, sgnPk = Core.Nothing}

instance Core.FromJSON SocialGraphNodeProto where
  parseJSON =
    Core.withObject
      "SocialGraphNodeProto"
      ( \o ->
          SocialGraphNodeProto
            Core.<$> (o Core..:? "sgnDomain")
            Core.<*> (o Core..:? "sgnPk")
      )

instance Core.ToJSON SocialGraphNodeProto where
  toJSON SocialGraphNodeProto {..} =
    Core.object
      ( Core.catMaybes
          [ ("sgnDomain" Core..=) Core.<$> sgnDomain,
            ("sgnPk" Core..=) Core.<$> sgnPk
          ]
      )

--
-- /See:/ 'newSortOptions' smart constructor.
data SortOptions = SortOptions
  { -- | The name of the operator corresponding to the field to sort on. The corresponding property must be marked as sortable.
    operatorName :: (Core.Maybe Core.Text),
    -- | Ascending is the default sort order
    sortOrder :: (Core.Maybe SortOptions_SortOrder)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SortOptions' with the minimum fields required to make a request.
newSortOptions ::
  SortOptions
newSortOptions =
  SortOptions {operatorName = Core.Nothing, sortOrder = Core.Nothing}

instance Core.FromJSON SortOptions where
  parseJSON =
    Core.withObject
      "SortOptions"
      ( \o ->
          SortOptions
            Core.<$> (o Core..:? "operatorName")
            Core.<*> (o Core..:? "sortOrder")
      )

instance Core.ToJSON SortOptions where
  toJSON SortOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("operatorName" Core..=) Core.<$> operatorName,
            ("sortOrder" Core..=) Core.<$> sortOrder
          ]
      )

-- | Defines sources for the suggest\/search APIs.
--
-- /See:/ 'newSource' smart constructor.
data Source = Source
  { -- | Source name for content indexed by the Indexing API.
    name :: (Core.Maybe Core.Text),
    -- | Predefined content source for Google Apps.
    predefinedSource :: (Core.Maybe Source_PredefinedSource)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Source' with the minimum fields required to make a request.
newSource ::
  Source
newSource = Source {name = Core.Nothing, predefinedSource = Core.Nothing}

instance Core.FromJSON Source where
  parseJSON =
    Core.withObject
      "Source"
      ( \o ->
          Source
            Core.<$> (o Core..:? "name")
            Core.<*> (o Core..:? "predefinedSource")
      )

instance Core.ToJSON Source where
  toJSON Source {..} =
    Core.object
      ( Core.catMaybes
          [ ("name" Core..=) Core.<$> name,
            ("predefinedSource" Core..=)
              Core.<$> predefinedSource
          ]
      )

-- | Configurations for a source while processing a Search or Suggest request.
--
-- /See:/ 'newSourceConfig' smart constructor.
data SourceConfig = SourceConfig
  { -- | The crowding configuration for the source.
    crowdingConfig :: (Core.Maybe SourceCrowdingConfig),
    -- | The scoring configuration for the source.
    scoringConfig :: (Core.Maybe SourceScoringConfig),
    -- | The source for which this configuration is to be used.
    source :: (Core.Maybe Source)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SourceConfig' with the minimum fields required to make a request.
newSourceConfig ::
  SourceConfig
newSourceConfig =
  SourceConfig
    { crowdingConfig = Core.Nothing,
      scoringConfig = Core.Nothing,
      source = Core.Nothing
    }

instance Core.FromJSON SourceConfig where
  parseJSON =
    Core.withObject
      "SourceConfig"
      ( \o ->
          SourceConfig
            Core.<$> (o Core..:? "crowdingConfig")
            Core.<*> (o Core..:? "scoringConfig")
            Core.<*> (o Core..:? "source")
      )

instance Core.ToJSON SourceConfig where
  toJSON SourceConfig {..} =
    Core.object
      ( Core.catMaybes
          [ ("crowdingConfig" Core..=) Core.<$> crowdingConfig,
            ("scoringConfig" Core..=) Core.<$> scoringConfig,
            ("source" Core..=) Core.<$> source
          ]
      )

-- | Set search results crowding limits. Crowding is a situation in which multiple results from the same source or host \"crowd out\" other results, diminishing the quality of search for users. To foster better search quality and source diversity in search results, you can set a condition to reduce repetitive results by source.
--
-- /See:/ 'newSourceCrowdingConfig' smart constructor.
data SourceCrowdingConfig = SourceCrowdingConfig
  { -- | Maximum number of results allowed from a datasource in a result page as long as results from other sources are not exhausted. Value specified must not be negative. A default value is used if this value is equal to 0. To disable crowding, set the value greater than 100.
    numResults :: (Core.Maybe Core.Int32),
    -- | Maximum number of suggestions allowed from a source. No limits will be set on results if this value is less than or equal to 0.
    numSuggestions :: (Core.Maybe Core.Int32)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SourceCrowdingConfig' with the minimum fields required to make a request.
newSourceCrowdingConfig ::
  SourceCrowdingConfig
newSourceCrowdingConfig =
  SourceCrowdingConfig
    { numResults = Core.Nothing,
      numSuggestions = Core.Nothing
    }

instance Core.FromJSON SourceCrowdingConfig where
  parseJSON =
    Core.withObject
      "SourceCrowdingConfig"
      ( \o ->
          SourceCrowdingConfig
            Core.<$> (o Core..:? "numResults")
            Core.<*> (o Core..:? "numSuggestions")
      )

instance Core.ToJSON SourceCrowdingConfig where
  toJSON SourceCrowdingConfig {..} =
    Core.object
      ( Core.catMaybes
          [ ("numResults" Core..=) Core.<$> numResults,
            ("numSuggestions" Core..=) Core.<$> numSuggestions
          ]
      )

-- | Per source result count information.
--
-- /See:/ 'newSourceResultCount' smart constructor.
data SourceResultCount = SourceResultCount
  { -- | Whether there are more search results for this source.
    hasMoreResults :: (Core.Maybe Core.Bool),
    -- | The estimated result count for this source.
    resultCountEstimate :: (Core.Maybe Core.Int64),
    -- | The exact result count for this source.
    resultCountExact :: (Core.Maybe Core.Int64),
    -- | The source the result count information is associated with.
    source :: (Core.Maybe Source)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SourceResultCount' with the minimum fields required to make a request.
newSourceResultCount ::
  SourceResultCount
newSourceResultCount =
  SourceResultCount
    { hasMoreResults = Core.Nothing,
      resultCountEstimate = Core.Nothing,
      resultCountExact = Core.Nothing,
      source = Core.Nothing
    }

instance Core.FromJSON SourceResultCount where
  parseJSON =
    Core.withObject
      "SourceResultCount"
      ( \o ->
          SourceResultCount
            Core.<$> (o Core..:? "hasMoreResults")
            Core.<*> ( o Core..:? "resultCountEstimate"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> ( o Core..:? "resultCountExact"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "source")
      )

instance Core.ToJSON SourceResultCount where
  toJSON SourceResultCount {..} =
    Core.object
      ( Core.catMaybes
          [ ("hasMoreResults" Core..=) Core.<$> hasMoreResults,
            ("resultCountEstimate" Core..=) Core.. Core.AsText
              Core.<$> resultCountEstimate,
            ("resultCountExact" Core..=) Core.. Core.AsText
              Core.<$> resultCountExact,
            ("source" Core..=) Core.<$> source
          ]
      )

-- | Set the scoring configuration. This allows modifying the ranking of results for a source.
--
-- /See:/ 'newSourceScoringConfig' smart constructor.
newtype SourceScoringConfig = SourceScoringConfig
  { -- | Importance of the source.
    sourceImportance :: (Core.Maybe SourceScoringConfig_SourceImportance)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SourceScoringConfig' with the minimum fields required to make a request.
newSourceScoringConfig ::
  SourceScoringConfig
newSourceScoringConfig = SourceScoringConfig {sourceImportance = Core.Nothing}

instance Core.FromJSON SourceScoringConfig where
  parseJSON =
    Core.withObject
      "SourceScoringConfig"
      ( \o ->
          SourceScoringConfig
            Core.<$> (o Core..:? "sourceImportance")
      )

instance Core.ToJSON SourceScoringConfig where
  toJSON SourceScoringConfig {..} =
    Core.object
      ( Core.catMaybes
          [ ("sourceImportance" Core..=)
              Core.<$> sourceImportance
          ]
      )

-- | Primary key for Space resource.
--
-- /See:/ 'newSpaceId' smart constructor.
newtype SpaceId = SpaceId
  { -- | Unique, immutable ID of the Space
    spaceId :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SpaceId' with the minimum fields required to make a request.
newSpaceId ::
  SpaceId
newSpaceId = SpaceId {spaceId = Core.Nothing}

instance Core.FromJSON SpaceId where
  parseJSON =
    Core.withObject
      "SpaceId"
      (\o -> SpaceId Core.<$> (o Core..:? "spaceId"))

instance Core.ToJSON SpaceId where
  toJSON SpaceId {..} =
    Core.object
      ( Core.catMaybes
          [("spaceId" Core..=) Core.<$> spaceId]
      )

--
-- /See:/ 'newSpellResult' smart constructor.
newtype SpellResult = SpellResult
  { -- | The suggested spelling of the query.
    suggestedQuery :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SpellResult' with the minimum fields required to make a request.
newSpellResult ::
  SpellResult
newSpellResult = SpellResult {suggestedQuery = Core.Nothing}

instance Core.FromJSON SpellResult where
  parseJSON =
    Core.withObject
      "SpellResult"
      ( \o ->
          SpellResult Core.<$> (o Core..:? "suggestedQuery")
      )

instance Core.ToJSON SpellResult where
  toJSON SpellResult {..} =
    Core.object
      ( Core.catMaybes
          [("suggestedQuery" Core..=) Core.<$> suggestedQuery]
      )

-- | Represents the set of members (of a given type) in a Google+ Square (see http:\/\/go\/squares). A Square with default member_type is currently (1\/2012) identical to the GaiaGroup with the same ID, but that is expected to change soon (see http:\/\/go\/superglue). Support for this principal type is currently (1\/2012) incomplete -- e.g., Keystore does not support it yet (see b\/5703421).
--
-- /See:/ 'newSquareProto' smart constructor.
data SquareProto = SquareProto
  { -- | The type of Square members to consider, e.g. \"all members\" vs. \"owners\" vs. \"admins\". These are defined by legacy/relation/id values in social.graph.storage.EdgeTypeEnum.EdgeType enum options in social\/graph\/storage\/proto\/id.proto. See square.pb (defined in production\/config\/cdd\/socialgraph\/mixer/config\/prod\/node/type_config) for all valid edge types associated with square. Currently required.
    memberType :: (Core.Maybe Core.Int32),
    -- | Currently required.
    squareId :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SquareProto' with the minimum fields required to make a request.
newSquareProto ::
  SquareProto
newSquareProto =
  SquareProto {memberType = Core.Nothing, squareId = Core.Nothing}

instance Core.FromJSON SquareProto where
  parseJSON =
    Core.withObject
      "SquareProto"
      ( \o ->
          SquareProto
            Core.<$> (o Core..:? "memberType")
            Core.<*> ( o Core..:? "squareId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON SquareProto where
  toJSON SquareProto {..} =
    Core.object
      ( Core.catMaybes
          [ ("memberType" Core..=) Core.<$> memberType,
            ("squareId" Core..=) Core.. Core.AsText
              Core.<$> squareId
          ]
      )

-- | Start upload file request.
--
-- /See:/ 'newStartUploadItemRequest' smart constructor.
data StartUploadItemRequest = StartUploadItemRequest
  { -- | The name of connector making this call. Format: datasources\/{source_id}\/connectors\/{ID}
    connectorName :: (Core.Maybe Core.Text),
    -- | Common debug options.
    debugOptions :: (Core.Maybe DebugOptions)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'StartUploadItemRequest' with the minimum fields required to make a request.
newStartUploadItemRequest ::
  StartUploadItemRequest
newStartUploadItemRequest =
  StartUploadItemRequest
    { connectorName = Core.Nothing,
      debugOptions = Core.Nothing
    }

instance Core.FromJSON StartUploadItemRequest where
  parseJSON =
    Core.withObject
      "StartUploadItemRequest"
      ( \o ->
          StartUploadItemRequest
            Core.<$> (o Core..:? "connectorName")
            Core.<*> (o Core..:? "debugOptions")
      )

instance Core.ToJSON StartUploadItemRequest where
  toJSON StartUploadItemRequest {..} =
    Core.object
      ( Core.catMaybes
          [ ("connectorName" Core..=) Core.<$> connectorName,
            ("debugOptions" Core..=) Core.<$> debugOptions
          ]
      )

-- | The @Status@ type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by <https://github.com/grpc gRPC>. Each @Status@ message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the <https://cloud.google.com/apis/design/errors API Design Guide>.
--
-- /See:/ 'newStatus' smart constructor.
data Status = Status
  { -- | The status code, which should be an enum value of google.rpc.Code.
    code :: (Core.Maybe Core.Int32),
    -- | A list of messages that carry the error details. There is a common set of message types for APIs to use.
    details :: (Core.Maybe [Status_DetailsItem]),
    -- | A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
    message :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Status' with the minimum fields required to make a request.
newStatus ::
  Status
newStatus =
  Status {code = Core.Nothing, details = Core.Nothing, message = Core.Nothing}

instance Core.FromJSON Status where
  parseJSON =
    Core.withObject
      "Status"
      ( \o ->
          Status
            Core.<$> (o Core..:? "code")
            Core.<*> (o Core..:? "details")
            Core.<*> (o Core..:? "message")
      )

instance Core.ToJSON Status where
  toJSON Status {..} =
    Core.object
      ( Core.catMaybes
          [ ("code" Core..=) Core.<$> code,
            ("details" Core..=) Core.<$> details,
            ("message" Core..=) Core.<$> message
          ]
      )

--
-- /See:/ 'newStatus_DetailsItem' smart constructor.
newtype Status_DetailsItem = Status_DetailsItem
  { -- | Properties of the object. Contains field \@type with type URL.
    additional :: (Core.HashMap Core.Text Core.Value)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Status_DetailsItem' with the minimum fields required to make a request.
newStatus_DetailsItem ::
  -- |  Properties of the object. Contains field \@type with type URL. See 'additional'.
  Core.HashMap Core.Text Core.Value ->
  Status_DetailsItem
newStatus_DetailsItem additional = Status_DetailsItem {additional = additional}

instance Core.FromJSON Status_DetailsItem where
  parseJSON =
    Core.withObject
      "Status_DetailsItem"
      ( \o ->
          Status_DetailsItem Core.<$> (Core.parseJSONObject o)
      )

instance Core.ToJSON Status_DetailsItem where
  toJSON Status_DetailsItem {..} =
    Core.toJSON additional

--
-- /See:/ 'newStoredParticipantId' smart constructor.
newtype StoredParticipantId = StoredParticipantId
  { -- |
    gaiaId :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'StoredParticipantId' with the minimum fields required to make a request.
newStoredParticipantId ::
  StoredParticipantId
newStoredParticipantId = StoredParticipantId {gaiaId = Core.Nothing}

instance Core.FromJSON StoredParticipantId where
  parseJSON =
    Core.withObject
      "StoredParticipantId"
      ( \o ->
          StoredParticipantId
            Core.<$> ( o Core..:? "gaiaId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON StoredParticipantId where
  toJSON StoredParticipantId {..} =
    Core.object
      ( Core.catMaybes
          [ ("gaiaId" Core..=) Core.. Core.AsText
              Core.<$> gaiaId
          ]
      )

-- | Information about viewers of the stream.
--
-- /See:/ 'newStreamViewerStats' smart constructor.
newtype StreamViewerStats = StreamViewerStats
  { -- | The estimate of the current viewer count.
    estimatedViewerCount :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'StreamViewerStats' with the minimum fields required to make a request.
newStreamViewerStats ::
  StreamViewerStats
newStreamViewerStats = StreamViewerStats {estimatedViewerCount = Core.Nothing}

instance Core.FromJSON StreamViewerStats where
  parseJSON =
    Core.withObject
      "StreamViewerStats"
      ( \o ->
          StreamViewerStats
            Core.<$> ( o Core..:? "estimatedViewerCount"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON StreamViewerStats where
  toJSON StreamViewerStats {..} =
    Core.object
      ( Core.catMaybes
          [ ("estimatedViewerCount" Core..=) Core.. Core.AsText
              Core.<$> estimatedViewerCount
          ]
      )

-- | Information about a streaming session in conference.
--
-- /See:/ 'newStreamingSessionInfo' smart constructor.
data StreamingSessionInfo = StreamingSessionInfo
  { -- | The application type of the current streaming session.
    applicationType :: (Core.Maybe StreamingSessionInfo_ApplicationType),
    -- | The latest streaming session event. This can be used by clients to help explain what is going on, why recording stopped, etc. This will always be set to a valid event and consistent with the status. It can be set when current session is inactive to indicate latest event that makes current session to become inactive.
    latestSessionEvent :: (Core.Maybe SessionEvent),
    -- | The display name of the owner of the recording output. It\'s only set when there will be uploaded recordings. Currently, it\'s only set when application type is RECORDING or GLIVE_STREAM.
    ownerDisplayName :: (Core.Maybe Core.Text),
    -- | This is the REST name and unique identifier of this streaming session and has the form @spaces\/\/recordings\/@ This is returned whenever status is either @STARTING@ or @STARTED@.
    sessionId :: (Core.Maybe Core.Text),
    -- | The current status of this streaming session. This can be used by clients to show session status indicator and\/or notification.
    status :: (Core.Maybe StreamingSessionInfo_Status),
    -- | When true, this recording may be used for training new transcription models.
    trainingEnabled :: (Core.Maybe Core.Bool),
    -- | The policy that controls who can view the broadcast. This setting applies for broadcast session.
    viewerAccessPolicy :: (Core.Maybe StreamingSessionInfo_ViewerAccessPolicy),
    -- | Contains information about viewers of the livestream. It is only set when application type is BROADCAST.
    viewerStats :: (Core.Maybe StreamViewerStats)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'StreamingSessionInfo' with the minimum fields required to make a request.
newStreamingSessionInfo ::
  StreamingSessionInfo
newStreamingSessionInfo =
  StreamingSessionInfo
    { applicationType = Core.Nothing,
      latestSessionEvent = Core.Nothing,
      ownerDisplayName = Core.Nothing,
      sessionId = Core.Nothing,
      status = Core.Nothing,
      trainingEnabled = Core.Nothing,
      viewerAccessPolicy = Core.Nothing,
      viewerStats = Core.Nothing
    }

instance Core.FromJSON StreamingSessionInfo where
  parseJSON =
    Core.withObject
      "StreamingSessionInfo"
      ( \o ->
          StreamingSessionInfo
            Core.<$> (o Core..:? "applicationType")
            Core.<*> (o Core..:? "latestSessionEvent")
            Core.<*> (o Core..:? "ownerDisplayName")
            Core.<*> (o Core..:? "sessionId")
            Core.<*> (o Core..:? "status")
            Core.<*> (o Core..:? "trainingEnabled")
            Core.<*> (o Core..:? "viewerAccessPolicy")
            Core.<*> (o Core..:? "viewerStats")
      )

instance Core.ToJSON StreamingSessionInfo where
  toJSON StreamingSessionInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("applicationType" Core..=)
              Core.<$> applicationType,
            ("latestSessionEvent" Core..=)
              Core.<$> latestSessionEvent,
            ("ownerDisplayName" Core..=)
              Core.<$> ownerDisplayName,
            ("sessionId" Core..=) Core.<$> sessionId,
            ("status" Core..=) Core.<$> status,
            ("trainingEnabled" Core..=) Core.<$> trainingEnabled,
            ("viewerAccessPolicy" Core..=)
              Core.<$> viewerAccessPolicy,
            ("viewerStats" Core..=) Core.<$> viewerStats
          ]
      )

-- | A structured data object consisting of named properties.
--
-- /See:/ 'newStructuredDataObject' smart constructor.
newtype StructuredDataObject = StructuredDataObject
  { -- | The properties for the object. The maximum number of elements is 1000.
    properties :: (Core.Maybe [NamedProperty])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'StructuredDataObject' with the minimum fields required to make a request.
newStructuredDataObject ::
  StructuredDataObject
newStructuredDataObject = StructuredDataObject {properties = Core.Nothing}

instance Core.FromJSON StructuredDataObject where
  parseJSON =
    Core.withObject
      "StructuredDataObject"
      ( \o ->
          StructuredDataObject
            Core.<$> (o Core..:? "properties")
      )

instance Core.ToJSON StructuredDataObject where
  toJSON StructuredDataObject {..} =
    Core.object
      ( Core.catMaybes
          [("properties" Core..=) Core.<$> properties]
      )

-- | Structured results that are returned as part of search request.
--
-- /See:/ 'newStructuredResult' smart constructor.
newtype StructuredResult = StructuredResult
  { -- | Representation of a person
    person :: (Core.Maybe Person)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'StructuredResult' with the minimum fields required to make a request.
newStructuredResult ::
  StructuredResult
newStructuredResult = StructuredResult {person = Core.Nothing}

instance Core.FromJSON StructuredResult where
  parseJSON =
    Core.withObject
      "StructuredResult"
      ( \o ->
          StructuredResult Core.<$> (o Core..:? "person")
      )

instance Core.ToJSON StructuredResult where
  toJSON StructuredResult {..} =
    Core.object
      (Core.catMaybes [("person" Core..=) Core.<$> person])

-- | Request of suggest API.
--
-- /See:/ 'newSuggestRequest' smart constructor.
data SuggestRequest = SuggestRequest
  { -- | The sources to use for suggestions. If not specified, the data sources are taken from the current search application. NOTE: Suggestions are only supported for the following sources: * Third-party data sources * PredefinedSource.PERSON * PredefinedSource.GOOGLE_DRIVE
    dataSourceRestrictions :: (Core.Maybe [DataSourceRestriction]),
    -- | Partial query for which autocomplete suggestions will be shown. For example, if the query is \"sea\", then the server might return \"season\", \"search\", \"seagull\" and so on.
    query :: (Core.Maybe Core.Text),
    -- | Request options, such as the search application and user timezone.
    requestOptions :: (Core.Maybe RequestOptions)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SuggestRequest' with the minimum fields required to make a request.
newSuggestRequest ::
  SuggestRequest
newSuggestRequest =
  SuggestRequest
    { dataSourceRestrictions = Core.Nothing,
      query = Core.Nothing,
      requestOptions = Core.Nothing
    }

instance Core.FromJSON SuggestRequest where
  parseJSON =
    Core.withObject
      "SuggestRequest"
      ( \o ->
          SuggestRequest
            Core.<$> (o Core..:? "dataSourceRestrictions")
            Core.<*> (o Core..:? "query")
            Core.<*> (o Core..:? "requestOptions")
      )

instance Core.ToJSON SuggestRequest where
  toJSON SuggestRequest {..} =
    Core.object
      ( Core.catMaybes
          [ ("dataSourceRestrictions" Core..=)
              Core.<$> dataSourceRestrictions,
            ("query" Core..=) Core.<$> query,
            ("requestOptions" Core..=) Core.<$> requestOptions
          ]
      )

-- | Response of the suggest API.
--
-- /See:/ 'newSuggestResponse' smart constructor.
newtype SuggestResponse = SuggestResponse
  { -- | List of suggestions.
    suggestResults :: (Core.Maybe [SuggestResult])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SuggestResponse' with the minimum fields required to make a request.
newSuggestResponse ::
  SuggestResponse
newSuggestResponse = SuggestResponse {suggestResults = Core.Nothing}

instance Core.FromJSON SuggestResponse where
  parseJSON =
    Core.withObject
      "SuggestResponse"
      ( \o ->
          SuggestResponse
            Core.<$> (o Core..:? "suggestResults")
      )

instance Core.ToJSON SuggestResponse where
  toJSON SuggestResponse {..} =
    Core.object
      ( Core.catMaybes
          [("suggestResults" Core..=) Core.<$> suggestResults]
      )

-- | One suggestion result.
--
-- /See:/ 'newSuggestResult' smart constructor.
data SuggestResult = SuggestResult
  { -- | This is present when the suggestion indicates a person. It contains more information about the person - like their email ID, name etc.
    peopleSuggestion :: (Core.Maybe PeopleSuggestion),
    -- | This field will be present if the suggested query is a word\/phrase completion.
    querySuggestion :: (Core.Maybe QuerySuggestion),
    -- | The source of the suggestion.
    source :: (Core.Maybe Source),
    -- | The suggested query that will be used for search, when the user clicks on the suggestion
    suggestedQuery :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SuggestResult' with the minimum fields required to make a request.
newSuggestResult ::
  SuggestResult
newSuggestResult =
  SuggestResult
    { peopleSuggestion = Core.Nothing,
      querySuggestion = Core.Nothing,
      source = Core.Nothing,
      suggestedQuery = Core.Nothing
    }

instance Core.FromJSON SuggestResult where
  parseJSON =
    Core.withObject
      "SuggestResult"
      ( \o ->
          SuggestResult
            Core.<$> (o Core..:? "peopleSuggestion")
            Core.<*> (o Core..:? "querySuggestion")
            Core.<*> (o Core..:? "source")
            Core.<*> (o Core..:? "suggestedQuery")
      )

instance Core.ToJSON SuggestResult where
  toJSON SuggestResult {..} =
    Core.object
      ( Core.catMaybes
          [ ("peopleSuggestion" Core..=)
              Core.<$> peopleSuggestion,
            ("querySuggestion" Core..=) Core.<$> querySuggestion,
            ("source" Core..=) Core.<$> source,
            ("suggestedQuery" Core..=) Core.<$> suggestedQuery
          ]
      )

-- | Urls with additional bot related information.
--
-- /See:/ 'newSupportUrls' smart constructor.
data SupportUrls = SupportUrls
  { -- | Link to the admin configuration webpage for the bot. Configured by Pantheon, may be empty.
    adminConfigUrl :: (Core.Maybe Core.Text),
    -- | Link to the deletion policy webpage for the bot. Configured by Pantheon, may be empty.
    deletionPolicyUrl :: (Core.Maybe Core.Text),
    -- | Link to GWM page of the app. May be empty.
    gwmUrl :: (Core.Maybe Core.Text),
    -- | Link to the privacy policy webpage for the bot. May be empty.
    privacyPolicyUrl :: (Core.Maybe Core.Text),
    -- | Link to the setup webpage for the bot. Configured by Pantheon, may be empty.
    setupUrl :: (Core.Maybe Core.Text),
    -- | Link to the support webpage for the developer of the bot. May be empty.
    supportUrl :: (Core.Maybe Core.Text),
    -- | Link to the terms of service webpage for the bot. May be empty.
    tosUrl :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SupportUrls' with the minimum fields required to make a request.
newSupportUrls ::
  SupportUrls
newSupportUrls =
  SupportUrls
    { adminConfigUrl = Core.Nothing,
      deletionPolicyUrl = Core.Nothing,
      gwmUrl = Core.Nothing,
      privacyPolicyUrl = Core.Nothing,
      setupUrl = Core.Nothing,
      supportUrl = Core.Nothing,
      tosUrl = Core.Nothing
    }

instance Core.FromJSON SupportUrls where
  parseJSON =
    Core.withObject
      "SupportUrls"
      ( \o ->
          SupportUrls
            Core.<$> (o Core..:? "adminConfigUrl")
            Core.<*> (o Core..:? "deletionPolicyUrl")
            Core.<*> (o Core..:? "gwmUrl")
            Core.<*> (o Core..:? "privacyPolicyUrl")
            Core.<*> (o Core..:? "setupUrl")
            Core.<*> (o Core..:? "supportUrl")
            Core.<*> (o Core..:? "tosUrl")
      )

instance Core.ToJSON SupportUrls where
  toJSON SupportUrls {..} =
    Core.object
      ( Core.catMaybes
          [ ("adminConfigUrl" Core..=) Core.<$> adminConfigUrl,
            ("deletionPolicyUrl" Core..=)
              Core.<$> deletionPolicyUrl,
            ("gwmUrl" Core..=) Core.<$> gwmUrl,
            ("privacyPolicyUrl" Core..=)
              Core.<$> privacyPolicyUrl,
            ("setupUrl" Core..=) Core.<$> setupUrl,
            ("supportUrl" Core..=) Core.<$> supportUrl,
            ("tosUrl" Core..=) Core.<$> tosUrl
          ]
      )

--
-- /See:/ 'newSwitchWidget' smart constructor.
data SwitchWidget = SwitchWidget
  { -- |
    controlType :: (Core.Maybe SwitchWidget_ControlType),
    -- | The name of the switch widget which is will be used in FormInput.
    name :: (Core.Maybe Core.Text),
    -- |
    onChange :: (Core.Maybe FormAction),
    -- |
    selected :: (Core.Maybe Core.Bool),
    -- | The value is what is passed back in apps script callback.
    value :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'SwitchWidget' with the minimum fields required to make a request.
newSwitchWidget ::
  SwitchWidget
newSwitchWidget =
  SwitchWidget
    { controlType = Core.Nothing,
      name = Core.Nothing,
      onChange = Core.Nothing,
      selected = Core.Nothing,
      value = Core.Nothing
    }

instance Core.FromJSON SwitchWidget where
  parseJSON =
    Core.withObject
      "SwitchWidget"
      ( \o ->
          SwitchWidget
            Core.<$> (o Core..:? "controlType")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "onChange")
            Core.<*> (o Core..:? "selected")
            Core.<*> (o Core..:? "value")
      )

instance Core.ToJSON SwitchWidget where
  toJSON SwitchWidget {..} =
    Core.object
      ( Core.catMaybes
          [ ("controlType" Core..=) Core.<$> controlType,
            ("name" Core..=) Core.<$> name,
            ("onChange" Core..=) Core.<$> onChange,
            ("selected" Core..=) Core.<$> selected,
            ("value" Core..=) Core.<$> value
          ]
      )

--
-- /See:/ 'newTaskActionMarkup' smart constructor.
newtype TaskActionMarkup = TaskActionMarkup
  { -- |
    reloadTasks :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'TaskActionMarkup' with the minimum fields required to make a request.
newTaskActionMarkup ::
  TaskActionMarkup
newTaskActionMarkup = TaskActionMarkup {reloadTasks = Core.Nothing}

instance Core.FromJSON TaskActionMarkup where
  parseJSON =
    Core.withObject
      "TaskActionMarkup"
      ( \o ->
          TaskActionMarkup Core.<$> (o Core..:? "reloadTasks")
      )

instance Core.ToJSON TaskActionMarkup where
  toJSON TaskActionMarkup {..} =
    Core.object
      ( Core.catMaybes
          [("reloadTasks" Core..=) Core.<$> reloadTasks]
      )

--
-- /See:/ 'newTextButton' smart constructor.
data TextButton = TextButton
  { -- | The alternative text used for accessibility Next field number: 7.
    altText :: (Core.Maybe Core.Text),
    -- | Optional color of the button\'s background in RAISE mode. The default is the secondary color from addon\'s manifest.
    backgroundColor :: (Core.Maybe Core.Text),
    -- |
    disabled :: (Core.Maybe Core.Bool),
    -- |
    onClick :: (Core.Maybe OnClick),
    -- |
    style :: (Core.Maybe TextButton_Style),
    -- | Text color can be set via HTML markup.
    text :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'TextButton' with the minimum fields required to make a request.
newTextButton ::
  TextButton
newTextButton =
  TextButton
    { altText = Core.Nothing,
      backgroundColor = Core.Nothing,
      disabled = Core.Nothing,
      onClick = Core.Nothing,
      style = Core.Nothing,
      text = Core.Nothing
    }

instance Core.FromJSON TextButton where
  parseJSON =
    Core.withObject
      "TextButton"
      ( \o ->
          TextButton
            Core.<$> (o Core..:? "altText")
            Core.<*> (o Core..:? "backgroundColor")
            Core.<*> (o Core..:? "disabled")
            Core.<*> (o Core..:? "onClick")
            Core.<*> (o Core..:? "style")
            Core.<*> (o Core..:? "text")
      )

instance Core.ToJSON TextButton where
  toJSON TextButton {..} =
    Core.object
      ( Core.catMaybes
          [ ("altText" Core..=) Core.<$> altText,
            ("backgroundColor" Core..=) Core.<$> backgroundColor,
            ("disabled" Core..=) Core.<$> disabled,
            ("onClick" Core..=) Core.<$> onClick,
            ("style" Core..=) Core.<$> style,
            ("text" Core..=) Core.<$> text
          ]
      )

--
-- /See:/ 'newTextField' smart constructor.
data TextField = TextField
  { -- | The initial set of auto complete items without any user input.
    autoComplete :: (Core.Maybe AutoComplete),
    -- | The refresh function which returns AutoComplete based on the user\'s input text. If the callback is not specified, auto complete will be purely done in client side based on the auto_complete items.
    autoCompleteCallback :: (Core.Maybe FormAction),
    -- | When set to true, a user can input multiple auto-complet items.
    autoCompleteMultipleSelections :: (Core.Maybe Core.Bool),
    -- |
    hintText :: (Core.Maybe Core.Text),
    -- | One of label or hint_text is required to be specified by the developers.
    label :: (Core.Maybe Core.Text),
    -- |
    maxLines :: (Core.Maybe Core.Int32),
    -- | The name of the text field which is will be used in FormInput.
    name :: (Core.Maybe Core.Text),
    -- |
    onChange :: (Core.Maybe FormAction),
    -- |
    type' :: (Core.Maybe TextField_Type),
    -- | The default value when no input from user.
    value :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'TextField' with the minimum fields required to make a request.
newTextField ::
  TextField
newTextField =
  TextField
    { autoComplete = Core.Nothing,
      autoCompleteCallback = Core.Nothing,
      autoCompleteMultipleSelections = Core.Nothing,
      hintText = Core.Nothing,
      label = Core.Nothing,
      maxLines = Core.Nothing,
      name = Core.Nothing,
      onChange = Core.Nothing,
      type' = Core.Nothing,
      value = Core.Nothing
    }

instance Core.FromJSON TextField where
  parseJSON =
    Core.withObject
      "TextField"
      ( \o ->
          TextField
            Core.<$> (o Core..:? "autoComplete")
            Core.<*> (o Core..:? "autoCompleteCallback")
            Core.<*> (o Core..:? "autoCompleteMultipleSelections")
            Core.<*> (o Core..:? "hintText")
            Core.<*> (o Core..:? "label")
            Core.<*> (o Core..:? "maxLines")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "onChange")
            Core.<*> (o Core..:? "type")
            Core.<*> (o Core..:? "value")
      )

instance Core.ToJSON TextField where
  toJSON TextField {..} =
    Core.object
      ( Core.catMaybes
          [ ("autoComplete" Core..=) Core.<$> autoComplete,
            ("autoCompleteCallback" Core..=)
              Core.<$> autoCompleteCallback,
            ("autoCompleteMultipleSelections" Core..=)
              Core.<$> autoCompleteMultipleSelections,
            ("hintText" Core..=) Core.<$> hintText,
            ("label" Core..=) Core.<$> label,
            ("maxLines" Core..=) Core.<$> maxLines,
            ("name" Core..=) Core.<$> name,
            ("onChange" Core..=) Core.<$> onChange,
            ("type" Core..=) Core.<$> type',
            ("value" Core..=) Core.<$> value
          ]
      )

-- | This is deprecated and please use KeyValue.
--
-- /See:/ 'newTextKeyValue' smart constructor.
data TextKeyValue = TextKeyValue
  { -- |
    key :: (Core.Maybe Core.Text),
    -- |
    onClick :: (Core.Maybe OnClick),
    -- |
    text :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'TextKeyValue' with the minimum fields required to make a request.
newTextKeyValue ::
  TextKeyValue
newTextKeyValue =
  TextKeyValue {key = Core.Nothing, onClick = Core.Nothing, text = Core.Nothing}

instance Core.FromJSON TextKeyValue where
  parseJSON =
    Core.withObject
      "TextKeyValue"
      ( \o ->
          TextKeyValue
            Core.<$> (o Core..:? "key")
            Core.<*> (o Core..:? "onClick")
            Core.<*> (o Core..:? "text")
      )

instance Core.ToJSON TextKeyValue where
  toJSON TextKeyValue {..} =
    Core.object
      ( Core.catMaybes
          [ ("key" Core..=) Core.<$> key,
            ("onClick" Core..=) Core.<$> onClick,
            ("text" Core..=) Core.<$> text
          ]
      )

-- | Used to provide a search operator for text properties. This is optional. Search operators let users restrict the query to specific fields relevant to the type of item being searched.
--
-- /See:/ 'newTextOperatorOptions' smart constructor.
data TextOperatorOptions = TextOperatorOptions
  { -- | If true, the text value is tokenized as one atomic value in operator searches and facet matches. For example, if the operator name is \"genre\" and the value is \"science-fiction\" the query restrictions \"genre:science\" and \"genre:fiction\" doesn\'t match the item; \"genre:science-fiction\" does. Text value matching is case-sensitive and does not remove special characters. If false, the text is tokenized. For example, if the value is \"science-fiction\" the queries \"genre:science\" and \"genre:fiction\" matches the item.
    exactMatchWithOperator :: (Core.Maybe Core.Bool),
    -- | Indicates the operator name required in the query in order to isolate the text property. For example, if operatorName is /subject/ and the property\'s name is /subjectLine/, then queries like /subject:\<value>/ show results only where the value of the property named /subjectLine/ matches /\<value>/. By contrast, a search that uses the same /\<value>/ without an operator returns all items where /\<value>/ matches the value of any text properties or text within the content field for the item. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.
    operatorName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'TextOperatorOptions' with the minimum fields required to make a request.
newTextOperatorOptions ::
  TextOperatorOptions
newTextOperatorOptions =
  TextOperatorOptions
    { exactMatchWithOperator = Core.Nothing,
      operatorName = Core.Nothing
    }

instance Core.FromJSON TextOperatorOptions where
  parseJSON =
    Core.withObject
      "TextOperatorOptions"
      ( \o ->
          TextOperatorOptions
            Core.<$> (o Core..:? "exactMatchWithOperator")
            Core.<*> (o Core..:? "operatorName")
      )

instance Core.ToJSON TextOperatorOptions where
  toJSON TextOperatorOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("exactMatchWithOperator" Core..=)
              Core.<$> exactMatchWithOperator,
            ("operatorName" Core..=) Core.<$> operatorName
          ]
      )

--
-- /See:/ 'newTextParagraph' smart constructor.
newtype TextParagraph = TextParagraph
  { -- |
    text :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'TextParagraph' with the minimum fields required to make a request.
newTextParagraph ::
  TextParagraph
newTextParagraph = TextParagraph {text = Core.Nothing}

instance Core.FromJSON TextParagraph where
  parseJSON =
    Core.withObject
      "TextParagraph"
      (\o -> TextParagraph Core.<$> (o Core..:? "text"))

instance Core.ToJSON TextParagraph where
  toJSON TextParagraph {..} =
    Core.object
      (Core.catMaybes [("text" Core..=) Core.<$> text])

-- | The options for text properties.
--
-- /See:/ 'newTextPropertyOptions' smart constructor.
data TextPropertyOptions = TextPropertyOptions
  { -- | If set, describes how the property should be used as a search operator.
    operatorOptions :: (Core.Maybe TextOperatorOptions),
    -- | Indicates the search quality importance of the tokens within the field when used for retrieval.
    retrievalImportance :: (Core.Maybe RetrievalImportance)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'TextPropertyOptions' with the minimum fields required to make a request.
newTextPropertyOptions ::
  TextPropertyOptions
newTextPropertyOptions =
  TextPropertyOptions
    { operatorOptions = Core.Nothing,
      retrievalImportance = Core.Nothing
    }

instance Core.FromJSON TextPropertyOptions where
  parseJSON =
    Core.withObject
      "TextPropertyOptions"
      ( \o ->
          TextPropertyOptions
            Core.<$> (o Core..:? "operatorOptions")
            Core.<*> (o Core..:? "retrievalImportance")
      )

instance Core.ToJSON TextPropertyOptions where
  toJSON TextPropertyOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("operatorOptions" Core..=)
              Core.<$> operatorOptions,
            ("retrievalImportance" Core..=)
              Core.<$> retrievalImportance
          ]
      )

-- | List of text values.
--
-- /See:/ 'newTextValues' smart constructor.
newtype TextValues = TextValues
  { -- | The maximum allowable length for text values is 2048 characters.
    values :: (Core.Maybe [Core.Text])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'TextValues' with the minimum fields required to make a request.
newTextValues ::
  TextValues
newTextValues = TextValues {values = Core.Nothing}

instance Core.FromJSON TextValues where
  parseJSON =
    Core.withObject
      "TextValues"
      (\o -> TextValues Core.<$> (o Core..:? "values"))

instance Core.ToJSON TextValues where
  toJSON TextValues {..} =
    Core.object
      (Core.catMaybes [("values" Core..=) Core.<$> values])

-- | The ThreadKey was set on some (subset of the) messages in this thread.
--
-- /See:/ 'newThreadKeySet' smart constructor.
data ThreadKeySet = ThreadKeySet
  { -- | Messages on which the thread_key was changed.
    messageKeys :: (Core.Maybe [MultiKey]),
    -- | The new thread_key for this thread
    newThreadKey' :: (Core.Maybe MultiKey)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ThreadKeySet' with the minimum fields required to make a request.
newThreadKeySet ::
  ThreadKeySet
newThreadKeySet =
  ThreadKeySet {messageKeys = Core.Nothing, newThreadKey' = Core.Nothing}

instance Core.FromJSON ThreadKeySet where
  parseJSON =
    Core.withObject
      "ThreadKeySet"
      ( \o ->
          ThreadKeySet
            Core.<$> (o Core..:? "messageKeys")
            Core.<*> (o Core..:? "newThreadKey")
      )

instance Core.ToJSON ThreadKeySet where
  toJSON ThreadKeySet {..} =
    Core.object
      ( Core.catMaybes
          [ ("messageKeys" Core..=) Core.<$> messageKeys,
            ("newThreadKey" Core..=) Core.<$> newThreadKey'
          ]
      )

-- | HistoryRecord for changes associated with a thread, namely: MESSAGE/ADDED MESSAGE/DELETED LABEL/ADDED LABEL/REMOVED ATTRIBUTE/SET ATTRIBUTE/REMOVED THREAD/KEY/SET All label/ids refer to the (unchanging) value as defined by the Label.id field in labels.proto. In particular, it is /not/ the canonical/name.
--
-- /See:/ 'newThreadUpdate' smart constructor.
data ThreadUpdate = ThreadUpdate
  { -- |
    attributeRemoved :: (Core.Maybe AttributeRemoved),
    -- |
    attributeSet :: (Core.Maybe AttributeSet),
    -- |
    labelAdded :: (Core.Maybe LabelAdded),
    -- |
    labelRemoved :: (Core.Maybe LabelRemoved),
    -- | Indicates the record id of the last operation that modified this thread.
    lastHistoryRecordId :: (Core.Maybe Core.Word64),
    -- |
    messageAdded :: (Core.Maybe MessageAdded),
    -- |
    messageDeleted :: (Core.Maybe MessageDeleted),
    -- | The first non-empty thread-key on any message in the thread (including deleted messages). This field has been introduced to maintain backward compatibility for clients that are not subthread aware.
    originalThreadKey :: (Core.Maybe MultiKey),
    -- | The PreStates of all messages before the transaction. These are suppressed if the client requested that prestates not be included in the output of the GetHistoryRequest.
    preState :: (Core.Maybe [PreState]),
    -- | Affected thread
    threadKey :: (Core.Maybe MultiKey),
    -- |
    threadKeySet :: (Core.Maybe ThreadKeySet),
    -- | Thread PLID
    threadLocator :: (Core.Maybe Core.Text),
    -- |
    topicStateUpdate :: (Core.Maybe TopicStateUpdate)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ThreadUpdate' with the minimum fields required to make a request.
newThreadUpdate ::
  ThreadUpdate
newThreadUpdate =
  ThreadUpdate
    { attributeRemoved = Core.Nothing,
      attributeSet = Core.Nothing,
      labelAdded = Core.Nothing,
      labelRemoved = Core.Nothing,
      lastHistoryRecordId = Core.Nothing,
      messageAdded = Core.Nothing,
      messageDeleted = Core.Nothing,
      originalThreadKey = Core.Nothing,
      preState = Core.Nothing,
      threadKey = Core.Nothing,
      threadKeySet = Core.Nothing,
      threadLocator = Core.Nothing,
      topicStateUpdate = Core.Nothing
    }

instance Core.FromJSON ThreadUpdate where
  parseJSON =
    Core.withObject
      "ThreadUpdate"
      ( \o ->
          ThreadUpdate
            Core.<$> (o Core..:? "attributeRemoved")
            Core.<*> (o Core..:? "attributeSet")
            Core.<*> (o Core..:? "labelAdded")
            Core.<*> (o Core..:? "labelRemoved")
            Core.<*> ( o Core..:? "lastHistoryRecordId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "messageAdded")
            Core.<*> (o Core..:? "messageDeleted")
            Core.<*> (o Core..:? "originalThreadKey")
            Core.<*> (o Core..:? "preState")
            Core.<*> (o Core..:? "threadKey")
            Core.<*> (o Core..:? "threadKeySet")
            Core.<*> (o Core..:? "threadLocator")
            Core.<*> (o Core..:? "topicStateUpdate")
      )

instance Core.ToJSON ThreadUpdate where
  toJSON ThreadUpdate {..} =
    Core.object
      ( Core.catMaybes
          [ ("attributeRemoved" Core..=)
              Core.<$> attributeRemoved,
            ("attributeSet" Core..=) Core.<$> attributeSet,
            ("labelAdded" Core..=) Core.<$> labelAdded,
            ("labelRemoved" Core..=) Core.<$> labelRemoved,
            ("lastHistoryRecordId" Core..=) Core.. Core.AsText
              Core.<$> lastHistoryRecordId,
            ("messageAdded" Core..=) Core.<$> messageAdded,
            ("messageDeleted" Core..=) Core.<$> messageDeleted,
            ("originalThreadKey" Core..=)
              Core.<$> originalThreadKey,
            ("preState" Core..=) Core.<$> preState,
            ("threadKey" Core..=) Core.<$> threadKey,
            ("threadKeySet" Core..=) Core.<$> threadKeySet,
            ("threadLocator" Core..=) Core.<$> threadLocator,
            ("topicStateUpdate" Core..=)
              Core.<$> topicStateUpdate
          ]
      )

-- | Used to provide a search operator for timestamp properties. This is optional. Search operators let users restrict the query to specific fields relevant to the type of item being searched.
--
-- /See:/ 'newTimestampOperatorOptions' smart constructor.
data TimestampOperatorOptions = TimestampOperatorOptions
  { -- | Indicates the operator name required in the query in order to isolate the timestamp property using the greater-than operator. For example, if greaterThanOperatorName is /closedafter/ and the property\'s name is /closeDate/, then queries like /closedafter:\<value>/ show results only where the value of the property named /closeDate/ is later than /\<value>/. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.
    greaterThanOperatorName :: (Core.Maybe Core.Text),
    -- | Indicates the operator name required in the query in order to isolate the timestamp property using the less-than operator. For example, if lessThanOperatorName is /closedbefore/ and the property\'s name is /closeDate/, then queries like /closedbefore:\<value>/ show results only where the value of the property named /closeDate/ is earlier than /\<value>/. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.
    lessThanOperatorName :: (Core.Maybe Core.Text),
    -- | Indicates the operator name required in the query in order to isolate the timestamp property. For example, if operatorName is /closedon/ and the property\'s name is /closeDate/, then queries like /closedon:\<value>/ show results only where the value of the property named /closeDate/ matches /\<value>/. By contrast, a search that uses the same /\<value>/ without an operator returns all items where /\<value>/ matches the value of any String properties or text within the content field for the item. The operator name can only contain lowercase letters (a-z). The maximum length is 32 characters.
    operatorName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'TimestampOperatorOptions' with the minimum fields required to make a request.
newTimestampOperatorOptions ::
  TimestampOperatorOptions
newTimestampOperatorOptions =
  TimestampOperatorOptions
    { greaterThanOperatorName = Core.Nothing,
      lessThanOperatorName = Core.Nothing,
      operatorName = Core.Nothing
    }

instance Core.FromJSON TimestampOperatorOptions where
  parseJSON =
    Core.withObject
      "TimestampOperatorOptions"
      ( \o ->
          TimestampOperatorOptions
            Core.<$> (o Core..:? "greaterThanOperatorName")
            Core.<*> (o Core..:? "lessThanOperatorName")
            Core.<*> (o Core..:? "operatorName")
      )

instance Core.ToJSON TimestampOperatorOptions where
  toJSON TimestampOperatorOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("greaterThanOperatorName" Core..=)
              Core.<$> greaterThanOperatorName,
            ("lessThanOperatorName" Core..=)
              Core.<$> lessThanOperatorName,
            ("operatorName" Core..=) Core.<$> operatorName
          ]
      )

-- | The options for timestamp properties.
--
-- /See:/ 'newTimestampPropertyOptions' smart constructor.
newtype TimestampPropertyOptions = TimestampPropertyOptions
  { -- | If set, describes how the timestamp should be used as a search operator.
    operatorOptions :: (Core.Maybe TimestampOperatorOptions)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'TimestampPropertyOptions' with the minimum fields required to make a request.
newTimestampPropertyOptions ::
  TimestampPropertyOptions
newTimestampPropertyOptions =
  TimestampPropertyOptions {operatorOptions = Core.Nothing}

instance Core.FromJSON TimestampPropertyOptions where
  parseJSON =
    Core.withObject
      "TimestampPropertyOptions"
      ( \o ->
          TimestampPropertyOptions
            Core.<$> (o Core..:? "operatorOptions")
      )

instance Core.ToJSON TimestampPropertyOptions where
  toJSON TimestampPropertyOptions {..} =
    Core.object
      ( Core.catMaybes
          [ ("operatorOptions" Core..=)
              Core.<$> operatorOptions
          ]
      )

-- | List of timestamp values.
--
-- /See:/ 'newTimestampValues' smart constructor.
newtype TimestampValues = TimestampValues
  { -- |
    values :: (Core.Maybe [Core.DateTime])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'TimestampValues' with the minimum fields required to make a request.
newTimestampValues ::
  TimestampValues
newTimestampValues = TimestampValues {values = Core.Nothing}

instance Core.FromJSON TimestampValues where
  parseJSON =
    Core.withObject
      "TimestampValues"
      ( \o ->
          TimestampValues Core.<$> (o Core..:? "values")
      )

instance Core.ToJSON TimestampValues where
  toJSON TimestampValues {..} =
    Core.object
      (Core.catMaybes [("values" Core..=) Core.<$> values])

-- | Tombstoning is the act of leaving a contextual trace when deleting a message. See more: go\/tombstone-prd, go\/hub-dynamite-tombstones-server-design-v2.
--
-- /See:/ 'newTombstoneMetadata' smart constructor.
newtype TombstoneMetadata = TombstoneMetadata
  { -- | Indicates the type of Tombstone.
    tombstoneType :: (Core.Maybe TombstoneMetadata_TombstoneType)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'TombstoneMetadata' with the minimum fields required to make a request.
newTombstoneMetadata ::
  TombstoneMetadata
newTombstoneMetadata = TombstoneMetadata {tombstoneType = Core.Nothing}

instance Core.FromJSON TombstoneMetadata where
  parseJSON =
    Core.withObject
      "TombstoneMetadata"
      ( \o ->
          TombstoneMetadata
            Core.<$> (o Core..:? "tombstoneType")
      )

instance Core.ToJSON TombstoneMetadata where
  toJSON TombstoneMetadata {..} =
    Core.object
      ( Core.catMaybes
          [("tombstoneType" Core..=) Core.<$> tombstoneType]
      )

-- | The Toolbar markup has been deprecated. The information is now specified in the manifest.
--
-- /See:/ 'newToolbar' smart constructor.
data Toolbar = Toolbar
  { -- | Background color of the toolbar in RBG hex representation.
    color :: (Core.Maybe Core.Text),
    -- |
    iconUrl :: (Core.Maybe Core.Text),
    -- |
    name :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Toolbar' with the minimum fields required to make a request.
newToolbar ::
  Toolbar
newToolbar =
  Toolbar {color = Core.Nothing, iconUrl = Core.Nothing, name = Core.Nothing}

instance Core.FromJSON Toolbar where
  parseJSON =
    Core.withObject
      "Toolbar"
      ( \o ->
          Toolbar
            Core.<$> (o Core..:? "color")
            Core.<*> (o Core..:? "iconUrl")
            Core.<*> (o Core..:? "name")
      )

instance Core.ToJSON Toolbar where
  toJSON Toolbar {..} =
    Core.object
      ( Core.catMaybes
          [ ("color" Core..=) Core.<$> color,
            ("iconUrl" Core..=) Core.<$> iconUrl,
            ("name" Core..=) Core.<$> name
          ]
      )

--
-- /See:/ 'newTopicId' smart constructor.
data TopicId = TopicId
  { -- | The Space or DM that the topic belongs to.
    groupId :: (Core.Maybe GroupId),
    -- | Opaque, server-assigned ID of the Topic. While this ID is guaranteed to be unique within the Space, it\'s not guaranteed to be globally unique. Internal usage: this field can be empty in the following cases: 1. To create the first message in a topic. 2. To list last N messages of a Space (regardless of topic).
    topicId :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'TopicId' with the minimum fields required to make a request.
newTopicId ::
  TopicId
newTopicId = TopicId {groupId = Core.Nothing, topicId = Core.Nothing}

instance Core.FromJSON TopicId where
  parseJSON =
    Core.withObject
      "TopicId"
      ( \o ->
          TopicId
            Core.<$> (o Core..:? "groupId")
            Core.<*> (o Core..:? "topicId")
      )

instance Core.ToJSON TopicId where
  toJSON TopicId {..} =
    Core.object
      ( Core.catMaybes
          [ ("groupId" Core..=) Core.<$> groupId,
            ("topicId" Core..=) Core.<$> topicId
          ]
      )

-- | State of an topic thread as maintained within Tingle.
--
-- /See:/ 'newTopicState' smart constructor.
data TopicState = TopicState
  { -- | Map of label => count of topic constituent messages with label These only contain counts of labels that are relevant for topic normalization\/denormalization. Eg. If a topic thread has 5 constituents, 4 of which are in inbox, this will contain ^i => 4. Some labels of interest are archive, inbox, trash, spam, etc.
    labelIdMessageCount :: (Core.Maybe TopicState_LabelIdMessageCount),
    -- | Number of constituents for this entity.
    numConstituents :: (Core.Maybe Core.Int32)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'TopicState' with the minimum fields required to make a request.
newTopicState ::
  TopicState
newTopicState =
  TopicState
    { labelIdMessageCount = Core.Nothing,
      numConstituents = Core.Nothing
    }

instance Core.FromJSON TopicState where
  parseJSON =
    Core.withObject
      "TopicState"
      ( \o ->
          TopicState
            Core.<$> (o Core..:? "labelIdMessageCount")
            Core.<*> (o Core..:? "numConstituents")
      )

instance Core.ToJSON TopicState where
  toJSON TopicState {..} =
    Core.object
      ( Core.catMaybes
          [ ("labelIdMessageCount" Core..=)
              Core.<$> labelIdMessageCount,
            ("numConstituents" Core..=)
              Core.<$> numConstituents
          ]
      )

-- | Map of label => count of topic constituent messages with label These only contain counts of labels that are relevant for topic normalization\/denormalization. Eg. If a topic thread has 5 constituents, 4 of which are in inbox, this will contain ^i => 4. Some labels of interest are archive, inbox, trash, spam, etc.
--
-- /See:/ 'newTopicState_LabelIdMessageCount' smart constructor.
newtype TopicState_LabelIdMessageCount = TopicState_LabelIdMessageCount
  { -- |
    additional :: (Core.HashMap Core.Text Core.Int32)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'TopicState_LabelIdMessageCount' with the minimum fields required to make a request.
newTopicState_LabelIdMessageCount ::
  -- |  See 'additional'.
  Core.HashMap Core.Text Core.Int32 ->
  TopicState_LabelIdMessageCount
newTopicState_LabelIdMessageCount additional =
  TopicState_LabelIdMessageCount {additional = additional}

instance Core.FromJSON TopicState_LabelIdMessageCount where
  parseJSON =
    Core.withObject
      "TopicState_LabelIdMessageCount"
      ( \o ->
          TopicState_LabelIdMessageCount
            Core.<$> (Core.parseJSONObject o)
      )

instance Core.ToJSON TopicState_LabelIdMessageCount where
  toJSON TopicState_LabelIdMessageCount {..} =
    Core.toJSON additional

--
-- /See:/ 'newTopicStateUpdate' smart constructor.
newtype TopicStateUpdate = TopicStateUpdate
  { -- |
    topicState :: (Core.Maybe TopicState)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'TopicStateUpdate' with the minimum fields required to make a request.
newTopicStateUpdate ::
  TopicStateUpdate
newTopicStateUpdate = TopicStateUpdate {topicState = Core.Nothing}

instance Core.FromJSON TopicStateUpdate where
  parseJSON =
    Core.withObject
      "TopicStateUpdate"
      ( \o ->
          TopicStateUpdate Core.<$> (o Core..:? "topicState")
      )

instance Core.ToJSON TopicStateUpdate where
  toJSON TopicStateUpdate {..} =
    Core.object
      ( Core.catMaybes
          [("topicState" Core..=) Core.<$> topicState]
      )

-- | Storage information pertaining to the transaction with which a HistoryRecord is associated.
--
-- /See:/ 'newTransactionContext' smart constructor.
data TransactionContext = TransactionContext
  { -- | The last HistoryRecord of the transaction. Note that this may correspond to a record that is filtered by Tingle (and thus not returned to the client). See http:\/\/b\/9513464.
    endingRecordId :: (Core.Maybe Core.Word64),
    -- | The first HistoryRecord of the transaction. Note that this may be a record of type INTERNAL.
    startingRecordId :: (Core.Maybe Core.Word64),
    -- | The microsecond timestamp of the transaction.
    writeTimestampUs :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'TransactionContext' with the minimum fields required to make a request.
newTransactionContext ::
  TransactionContext
newTransactionContext =
  TransactionContext
    { endingRecordId = Core.Nothing,
      startingRecordId = Core.Nothing,
      writeTimestampUs = Core.Nothing
    }

instance Core.FromJSON TransactionContext where
  parseJSON =
    Core.withObject
      "TransactionContext"
      ( \o ->
          TransactionContext
            Core.<$> ( o Core..:? "endingRecordId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> ( o Core..:? "startingRecordId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> ( o Core..:? "writeTimestampUs"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON TransactionContext where
  toJSON TransactionContext {..} =
    Core.object
      ( Core.catMaybes
          [ ("endingRecordId" Core..=) Core.. Core.AsText
              Core.<$> endingRecordId,
            ("startingRecordId" Core..=) Core.. Core.AsText
              Core.<$> startingRecordId,
            ("writeTimestampUs" Core..=) Core.. Core.AsText
              Core.<$> writeTimestampUs
          ]
      )

-- | HistoryRecord for debug info associated with the transaction, namely: TXN/DEBUG/INFO TODO(b\/143845917) This is a short-term workaround for unblocking fusebox writes migration. Clean up the code or land a long-term solution after the rollout. go\/diff-to-historyrecord
--
-- /See:/ 'newTransactionDebugInfo' smart constructor.
data TransactionDebugInfo = TransactionDebugInfo
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'TransactionDebugInfo' with the minimum fields required to make a request.
newTransactionDebugInfo ::
  TransactionDebugInfo
newTransactionDebugInfo = TransactionDebugInfo

instance Core.FromJSON TransactionDebugInfo where
  parseJSON =
    Core.withObject
      "TransactionDebugInfo"
      (\o -> Core.pure TransactionDebugInfo)

instance Core.ToJSON TransactionDebugInfo where
  toJSON = Core.const Core.emptyObject

-- | Information about a transcription session.
--
-- /See:/ 'newTranscriptionSessionInfo' smart constructor.
data TranscriptionSessionInfo = TranscriptionSessionInfo
  { -- | Transcription session\'s state information.
    sessionStateInfo :: (Core.Maybe SessionStateInfo),
    -- | A unique server-generated ID for the transcription session.
    transcriptionSessionId :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'TranscriptionSessionInfo' with the minimum fields required to make a request.
newTranscriptionSessionInfo ::
  TranscriptionSessionInfo
newTranscriptionSessionInfo =
  TranscriptionSessionInfo
    { sessionStateInfo = Core.Nothing,
      transcriptionSessionId = Core.Nothing
    }

instance Core.FromJSON TranscriptionSessionInfo where
  parseJSON =
    Core.withObject
      "TranscriptionSessionInfo"
      ( \o ->
          TranscriptionSessionInfo
            Core.<$> (o Core..:? "sessionStateInfo")
            Core.<*> (o Core..:? "transcriptionSessionId")
      )

instance Core.ToJSON TranscriptionSessionInfo where
  toJSON TranscriptionSessionInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("sessionStateInfo" Core..=)
              Core.<$> sessionStateInfo,
            ("transcriptionSessionId" Core..=)
              Core.<$> transcriptionSessionId
          ]
      )

-- | Transient generic data that will not be saved on the server.
--
-- /See:/ 'newTransientData' smart constructor.
data TransientData = TransientData
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'TransientData' with the minimum fields required to make a request.
newTransientData ::
  TransientData
newTransientData = TransientData

instance Core.FromJSON TransientData where
  parseJSON =
    Core.withObject
      "TransientData"
      (\o -> Core.pure TransientData)

instance Core.ToJSON TransientData where
  toJSON = Core.const Core.emptyObject

--
-- /See:/ 'newTrigger' smart constructor.
data Trigger = Trigger
  { -- | Each dispatcher should use an enum to for the actions that it supports. If a dispatcher has only one action, this does not need to be set. (It can be expanded later, defining the default behaviour as type 0.) For purposes such as batching, the type of a trigger is (dispatcher, action_type).
    actionType :: (Core.Maybe Core.Word32),
    -- | Maximum possible delay in micros that can be tolerated so triggers can be batched, which makes processing more efficient compared to firing triggers individually. Note that the actual fire time will be somewhere in the timerange interval [fire/time/us, fire/time/us + batch/time/us).
    batchTimeUs :: (Core.Maybe Core.Int64),
    -- | Must be set for DISPATCHER/STUBBY/DISPATCHER.
    dispatchId :: (Core.Maybe Core.Word32),
    -- | Which server should interpret action_type.
    dispatcher :: (Core.Maybe Trigger_Dispatcher),
    -- | Earliest time to fire at in microseconds. The actual time that the trigger will fire will be in the timerange: [fire/time/us, fire/time/us + batch/time/us).
    fireTimeUs :: (Core.Maybe Core.Int64),
    -- | Must be set for DISPATCHER/JOBSETTED/PRIMARY.
    jobsettedServerSpec :: (Core.Maybe JobsettedServerSpec),
    -- | The trigger key, if applicable.
    key :: (Core.Maybe Core.Text),
    -- |
    rpcOptions :: (Core.Maybe RpcOptions),
    -- | The slice/fire/time/us is automatically computed and stored as part of the trigger write. It represents the exact fire time at which the trigger will be queued to fire and will satisfy fire/time/us \< slice/fire/time/us \<= fire/time/us + batch/time/us Triggers have an index row in the slice trigger index with the row prefix matching this time. Note that this field is internal to gmail_cp and is ignored if set by external clients when adding \/ updating triggers.
    sliceFireTimeUs :: (Core.Maybe Core.Int64),
    -- | Trigger action to perform. This should always be set.
    triggerAction :: (Core.Maybe TriggerAction),
    -- | The TriggerKey will uniquely determine a trigger within a given context. A context is a single message for message triggers or a single account for account triggers.
    triggerKey :: (Core.Maybe TriggerKey)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Trigger' with the minimum fields required to make a request.
newTrigger ::
  Trigger
newTrigger =
  Trigger
    { actionType = Core.Nothing,
      batchTimeUs = Core.Nothing,
      dispatchId = Core.Nothing,
      dispatcher = Core.Nothing,
      fireTimeUs = Core.Nothing,
      jobsettedServerSpec = Core.Nothing,
      key = Core.Nothing,
      rpcOptions = Core.Nothing,
      sliceFireTimeUs = Core.Nothing,
      triggerAction = Core.Nothing,
      triggerKey = Core.Nothing
    }

instance Core.FromJSON Trigger where
  parseJSON =
    Core.withObject
      "Trigger"
      ( \o ->
          Trigger
            Core.<$> (o Core..:? "actionType")
            Core.<*> ( o Core..:? "batchTimeUs"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "dispatchId")
            Core.<*> (o Core..:? "dispatcher")
            Core.<*> ( o Core..:? "fireTimeUs"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "jobsettedServerSpec")
            Core.<*> (o Core..:? "key")
            Core.<*> (o Core..:? "rpcOptions")
            Core.<*> ( o Core..:? "sliceFireTimeUs"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "triggerAction")
            Core.<*> (o Core..:? "triggerKey")
      )

instance Core.ToJSON Trigger where
  toJSON Trigger {..} =
    Core.object
      ( Core.catMaybes
          [ ("actionType" Core..=) Core.<$> actionType,
            ("batchTimeUs" Core..=) Core.. Core.AsText
              Core.<$> batchTimeUs,
            ("dispatchId" Core..=) Core.<$> dispatchId,
            ("dispatcher" Core..=) Core.<$> dispatcher,
            ("fireTimeUs" Core..=) Core.. Core.AsText
              Core.<$> fireTimeUs,
            ("jobsettedServerSpec" Core..=)
              Core.<$> jobsettedServerSpec,
            ("key" Core..=) Core.<$> key,
            ("rpcOptions" Core..=) Core.<$> rpcOptions,
            ("sliceFireTimeUs" Core..=) Core.. Core.AsText
              Core.<$> sliceFireTimeUs,
            ("triggerAction" Core..=) Core.<$> triggerAction,
            ("triggerKey" Core..=) Core.<$> triggerKey
          ]
      )

--
-- /See:/ 'newTriggerAction' smart constructor.
data TriggerAction = TriggerAction
  { -- |
    action :: (Core.Maybe TriggerAction_Action),
    -- | Clients should use extensions on the Trigger message instead.
    data' :: (Core.Maybe Core.Base64),
    -- |
    dataInt :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'TriggerAction' with the minimum fields required to make a request.
newTriggerAction ::
  TriggerAction
newTriggerAction =
  TriggerAction
    { action = Core.Nothing,
      data' = Core.Nothing,
      dataInt = Core.Nothing
    }

instance Core.FromJSON TriggerAction where
  parseJSON =
    Core.withObject
      "TriggerAction"
      ( \o ->
          TriggerAction
            Core.<$> (o Core..:? "action")
            Core.<*> (o Core..:? "data")
            Core.<*> ( o Core..:? "dataInt"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON TriggerAction where
  toJSON TriggerAction {..} =
    Core.object
      ( Core.catMaybes
          [ ("action" Core..=) Core.<$> action,
            ("data" Core..=) Core.<$> data',
            ("dataInt" Core..=) Core.. Core.AsText
              Core.<$> dataInt
          ]
      )

-- | A TriggerKey (type + instance_id) uniquely identifies a trigger within a message for a message-trigger and within an account for an account-trigger.
--
-- /See:/ 'newTriggerKey' smart constructor.
data TriggerKey = TriggerKey
  { -- | Identifier to distinguish multiple Triggers of the same type (per message or per account).
    instanceId :: (Core.Maybe Core.Text),
    -- | A non-empty string that identifies the type of Trigger. Triggers of the same type may be batched together. The universe of values for the type field should be finite as it is used as a stats key.
    type' :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'TriggerKey' with the minimum fields required to make a request.
newTriggerKey ::
  TriggerKey
newTriggerKey = TriggerKey {instanceId = Core.Nothing, type' = Core.Nothing}

instance Core.FromJSON TriggerKey where
  parseJSON =
    Core.withObject
      "TriggerKey"
      ( \o ->
          TriggerKey
            Core.<$> (o Core..:? "instanceId")
            Core.<*> (o Core..:? "type")
      )

instance Core.ToJSON TriggerKey where
  toJSON TriggerKey {..} =
    Core.object
      ( Core.catMaybes
          [ ("instanceId" Core..=) Core.<$> instanceId,
            ("type" Core..=) Core.<$> type'
          ]
      )

--
-- /See:/ 'newTriggers' smart constructor.
newtype Triggers = Triggers
  { -- | A list of triggers.
    triggers :: (Core.Maybe [Trigger])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Triggers' with the minimum fields required to make a request.
newTriggers ::
  Triggers
newTriggers = Triggers {triggers = Core.Nothing}

instance Core.FromJSON Triggers where
  parseJSON =
    Core.withObject
      "Triggers"
      (\o -> Triggers Core.<$> (o Core..:? "triggers"))

instance Core.ToJSON Triggers where
  toJSON Triggers {..} =
    Core.object
      ( Core.catMaybes
          [("triggers" Core..=) Core.<$> triggers]
      )

-- | Message containing a string that is safe to use in all URL contexts in DOM APIs and HTML documents; even where the referred-to resource is interpreted as code, e.g., as the src of a script element.
--
-- /See:/ 'newTrustedResourceUrlProto' smart constructor.
newtype TrustedResourceUrlProto = TrustedResourceUrlProto
  { -- | IMPORTANT: Never set or read this field, even from tests, it is private. See documentation at the top of .proto file for programming language packages with which to create or read this message.
    privateDoNotAccessOrElseTrustedResourceUrlWrappedValue :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'TrustedResourceUrlProto' with the minimum fields required to make a request.
newTrustedResourceUrlProto ::
  TrustedResourceUrlProto
newTrustedResourceUrlProto =
  TrustedResourceUrlProto
    { privateDoNotAccessOrElseTrustedResourceUrlWrappedValue = Core.Nothing
    }

instance Core.FromJSON TrustedResourceUrlProto where
  parseJSON =
    Core.withObject
      "TrustedResourceUrlProto"
      ( \o ->
          TrustedResourceUrlProto
            Core.<$> ( o
                         Core..:? "privateDoNotAccessOrElseTrustedResourceUrlWrappedValue"
                     )
      )

instance Core.ToJSON TrustedResourceUrlProto where
  toJSON TrustedResourceUrlProto {..} =
    Core.object
      ( Core.catMaybes
          [ ( "privateDoNotAccessOrElseTrustedResourceUrlWrappedValue"
                Core..=
            )
              Core.<$> privateDoNotAccessOrElseTrustedResourceUrlWrappedValue
          ]
      )

-- | Next tag: 2
--
-- /See:/ 'newTypeInfo' smart constructor.
newtype TypeInfo = TypeInfo
  { -- | Contains additional video information only if document_type is VIDEO.
    videoInfo :: (Core.Maybe VideoInfo)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'TypeInfo' with the minimum fields required to make a request.
newTypeInfo ::
  TypeInfo
newTypeInfo = TypeInfo {videoInfo = Core.Nothing}

instance Core.FromJSON TypeInfo where
  parseJSON =
    Core.withObject
      "TypeInfo"
      (\o -> TypeInfo Core.<$> (o Core..:? "videoInfo"))

instance Core.ToJSON TypeInfo where
  toJSON TypeInfo {..} =
    Core.object
      ( Core.catMaybes
          [("videoInfo" Core..=) Core.<$> videoInfo]
      )

-- | Universal phone access contains information required to dial into a conference using one of a static list of phone numbers and a universal PIN. The phone number list is distributed separately.
--
-- /See:/ 'newUniversalPhoneAccess' smart constructor.
data UniversalPhoneAccess = UniversalPhoneAccess
  { -- | The PIN that users must enter after dialing a universal number. The pin consists of only decimal digits and the length may vary, though it generally is longer than a PhoneAccess.pin.
    pin :: (Core.Maybe Core.Text),
    -- | This field has the same contents as the MeetingSpace.more/join/url field, and is included for compatibility reasons. Clients should use the other field instead. This field is deprecated and will be removed.
    pstnInfoUrl :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'UniversalPhoneAccess' with the minimum fields required to make a request.
newUniversalPhoneAccess ::
  UniversalPhoneAccess
newUniversalPhoneAccess =
  UniversalPhoneAccess {pin = Core.Nothing, pstnInfoUrl = Core.Nothing}

instance Core.FromJSON UniversalPhoneAccess where
  parseJSON =
    Core.withObject
      "UniversalPhoneAccess"
      ( \o ->
          UniversalPhoneAccess
            Core.<$> (o Core..:? "pin")
            Core.<*> (o Core..:? "pstnInfoUrl")
      )

instance Core.ToJSON UniversalPhoneAccess where
  toJSON UniversalPhoneAccess {..} =
    Core.object
      ( Core.catMaybes
          [ ("pin" Core..=) Core.<$> pin,
            ("pstnInfoUrl" Core..=) Core.<$> pstnInfoUrl
          ]
      )

--
-- /See:/ 'newUnmappedIdentity' smart constructor.
data UnmappedIdentity = UnmappedIdentity
  { -- | The resource name for an external user.
    externalIdentity :: (Core.Maybe Principal),
    -- | The resolution status for the external identity.
    resolutionStatusCode :: (Core.Maybe UnmappedIdentity_ResolutionStatusCode)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'UnmappedIdentity' with the minimum fields required to make a request.
newUnmappedIdentity ::
  UnmappedIdentity
newUnmappedIdentity =
  UnmappedIdentity
    { externalIdentity = Core.Nothing,
      resolutionStatusCode = Core.Nothing
    }

instance Core.FromJSON UnmappedIdentity where
  parseJSON =
    Core.withObject
      "UnmappedIdentity"
      ( \o ->
          UnmappedIdentity
            Core.<$> (o Core..:? "externalIdentity")
            Core.<*> (o Core..:? "resolutionStatusCode")
      )

instance Core.ToJSON UnmappedIdentity where
  toJSON UnmappedIdentity {..} =
    Core.object
      ( Core.catMaybes
          [ ("externalIdentity" Core..=)
              Core.<$> externalIdentity,
            ("resolutionStatusCode" Core..=)
              Core.<$> resolutionStatusCode
          ]
      )

--
-- /See:/ 'newUnreserveItemsRequest' smart constructor.
data UnreserveItemsRequest = UnreserveItemsRequest
  { -- | The name of connector making this call. Format: datasources\/{source_id}\/connectors\/{ID}
    connectorName :: (Core.Maybe Core.Text),
    -- | Common debug options.
    debugOptions :: (Core.Maybe DebugOptions),
    -- | The name of a queue to unreserve items from.
    queue :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'UnreserveItemsRequest' with the minimum fields required to make a request.
newUnreserveItemsRequest ::
  UnreserveItemsRequest
newUnreserveItemsRequest =
  UnreserveItemsRequest
    { connectorName = Core.Nothing,
      debugOptions = Core.Nothing,
      queue = Core.Nothing
    }

instance Core.FromJSON UnreserveItemsRequest where
  parseJSON =
    Core.withObject
      "UnreserveItemsRequest"
      ( \o ->
          UnreserveItemsRequest
            Core.<$> (o Core..:? "connectorName")
            Core.<*> (o Core..:? "debugOptions")
            Core.<*> (o Core..:? "queue")
      )

instance Core.ToJSON UnreserveItemsRequest where
  toJSON UnreserveItemsRequest {..} =
    Core.object
      ( Core.catMaybes
          [ ("connectorName" Core..=) Core.<$> connectorName,
            ("debugOptions" Core..=) Core.<$> debugOptions,
            ("queue" Core..=) Core.<$> queue
          ]
      )

--
-- /See:/ 'newUpdateBccRecipients' smart constructor.
newtype UpdateBccRecipients = UpdateBccRecipients
  { -- |
    bccRecipients :: (Core.Maybe [Recipient])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'UpdateBccRecipients' with the minimum fields required to make a request.
newUpdateBccRecipients ::
  UpdateBccRecipients
newUpdateBccRecipients = UpdateBccRecipients {bccRecipients = Core.Nothing}

instance Core.FromJSON UpdateBccRecipients where
  parseJSON =
    Core.withObject
      "UpdateBccRecipients"
      ( \o ->
          UpdateBccRecipients
            Core.<$> (o Core..:? "bccRecipients")
      )

instance Core.ToJSON UpdateBccRecipients where
  toJSON UpdateBccRecipients {..} =
    Core.object
      ( Core.catMaybes
          [("bccRecipients" Core..=) Core.<$> bccRecipients]
      )

--
-- /See:/ 'newUpdateBody' smart constructor.
data UpdateBody = UpdateBody
  { -- | A repeated field that contains a series of content to insert into the draft that the user is currently editing. The content can contain HTML content or plain text content.
    insertContents :: (Core.Maybe [InsertContent]),
    -- |
    type' :: (Core.Maybe UpdateBody_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'UpdateBody' with the minimum fields required to make a request.
newUpdateBody ::
  UpdateBody
newUpdateBody = UpdateBody {insertContents = Core.Nothing, type' = Core.Nothing}

instance Core.FromJSON UpdateBody where
  parseJSON =
    Core.withObject
      "UpdateBody"
      ( \o ->
          UpdateBody
            Core.<$> (o Core..:? "insertContents")
            Core.<*> (o Core..:? "type")
      )

instance Core.ToJSON UpdateBody where
  toJSON UpdateBody {..} =
    Core.object
      ( Core.catMaybes
          [ ("insertContents" Core..=) Core.<$> insertContents,
            ("type" Core..=) Core.<$> type'
          ]
      )

--
-- /See:/ 'newUpdateCcRecipients' smart constructor.
newtype UpdateCcRecipients = UpdateCcRecipients
  { -- |
    ccRecipients :: (Core.Maybe [Recipient])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'UpdateCcRecipients' with the minimum fields required to make a request.
newUpdateCcRecipients ::
  UpdateCcRecipients
newUpdateCcRecipients = UpdateCcRecipients {ccRecipients = Core.Nothing}

instance Core.FromJSON UpdateCcRecipients where
  parseJSON =
    Core.withObject
      "UpdateCcRecipients"
      ( \o ->
          UpdateCcRecipients
            Core.<$> (o Core..:? "ccRecipients")
      )

instance Core.ToJSON UpdateCcRecipients where
  toJSON UpdateCcRecipients {..} =
    Core.object
      ( Core.catMaybes
          [("ccRecipients" Core..=) Core.<$> ccRecipients]
      )

--
-- /See:/ 'newUpdateDataSourceRequest' smart constructor.
data UpdateDataSourceRequest = UpdateDataSourceRequest
  { -- | Common debug options.
    debugOptions :: (Core.Maybe DebugOptions),
    -- |
    source :: (Core.Maybe DataSource),
    -- | Only applies to <https://developers.google.com/cloud-search/docs/reference/rest/v1/settings.datasources/patch settings.datasources.patch>. Update mask to control which fields to update. Example field paths: @name@, @displayName@. * If @update_mask@ is non-empty, then only the fields specified in the @update_mask@ are updated. * If you specify a field in the @update_mask@, but don\'t specify its value in the source, that field is cleared. * If the @update_mask@ is not present or empty or has the value @*@, then all fields are updated.
    updateMask :: (Core.Maybe Core.FieldMask)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'UpdateDataSourceRequest' with the minimum fields required to make a request.
newUpdateDataSourceRequest ::
  UpdateDataSourceRequest
newUpdateDataSourceRequest =
  UpdateDataSourceRequest
    { debugOptions = Core.Nothing,
      source = Core.Nothing,
      updateMask = Core.Nothing
    }

instance Core.FromJSON UpdateDataSourceRequest where
  parseJSON =
    Core.withObject
      "UpdateDataSourceRequest"
      ( \o ->
          UpdateDataSourceRequest
            Core.<$> (o Core..:? "debugOptions")
            Core.<*> (o Core..:? "source")
            Core.<*> (o Core..:? "updateMask")
      )

instance Core.ToJSON UpdateDataSourceRequest where
  toJSON UpdateDataSourceRequest {..} =
    Core.object
      ( Core.catMaybes
          [ ("debugOptions" Core..=) Core.<$> debugOptions,
            ("source" Core..=) Core.<$> source,
            ("updateMask" Core..=) Core.<$> updateMask
          ]
      )

--
-- /See:/ 'newUpdateDraftActionMarkup' smart constructor.
data UpdateDraftActionMarkup = UpdateDraftActionMarkup
  { -- | If set, replaces the existing Bcc recipients of the draft the user is currently editing.
    updateBccRecipients :: (Core.Maybe UpdateBccRecipients),
    -- | A field that contains a series of update actions to perform on the draft body that the user is currently editing.
    updateBody :: (Core.Maybe UpdateBody),
    -- | If set, replaces the existing Cc recipients of the draft the user is currently editing.
    updateCcRecipients :: (Core.Maybe UpdateCcRecipients),
    -- | If set, replaces the existing subject of the draft the user is currently editing.
    updateSubject :: (Core.Maybe UpdateSubject),
    -- | If set, replaces the existing To recipients of the draft the user is currently editing.
    updateToRecipients :: (Core.Maybe UpdateToRecipients)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'UpdateDraftActionMarkup' with the minimum fields required to make a request.
newUpdateDraftActionMarkup ::
  UpdateDraftActionMarkup
newUpdateDraftActionMarkup =
  UpdateDraftActionMarkup
    { updateBccRecipients = Core.Nothing,
      updateBody = Core.Nothing,
      updateCcRecipients = Core.Nothing,
      updateSubject = Core.Nothing,
      updateToRecipients = Core.Nothing
    }

instance Core.FromJSON UpdateDraftActionMarkup where
  parseJSON =
    Core.withObject
      "UpdateDraftActionMarkup"
      ( \o ->
          UpdateDraftActionMarkup
            Core.<$> (o Core..:? "updateBccRecipients")
            Core.<*> (o Core..:? "updateBody")
            Core.<*> (o Core..:? "updateCcRecipients")
            Core.<*> (o Core..:? "updateSubject")
            Core.<*> (o Core..:? "updateToRecipients")
      )

instance Core.ToJSON UpdateDraftActionMarkup where
  toJSON UpdateDraftActionMarkup {..} =
    Core.object
      ( Core.catMaybes
          [ ("updateBccRecipients" Core..=)
              Core.<$> updateBccRecipients,
            ("updateBody" Core..=) Core.<$> updateBody,
            ("updateCcRecipients" Core..=)
              Core.<$> updateCcRecipients,
            ("updateSubject" Core..=) Core.<$> updateSubject,
            ("updateToRecipients" Core..=)
              Core.<$> updateToRecipients
          ]
      )

--
-- /See:/ 'newUpdateSchemaRequest' smart constructor.
data UpdateSchemaRequest = UpdateSchemaRequest
  { -- | Common debug options.
    debugOptions :: (Core.Maybe DebugOptions),
    -- | The new schema for the source.
    schema :: (Core.Maybe Schema),
    -- | If true, the schema will be checked for validity, but will not be registered with the data source, even if valid.
    validateOnly :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'UpdateSchemaRequest' with the minimum fields required to make a request.
newUpdateSchemaRequest ::
  UpdateSchemaRequest
newUpdateSchemaRequest =
  UpdateSchemaRequest
    { debugOptions = Core.Nothing,
      schema = Core.Nothing,
      validateOnly = Core.Nothing
    }

instance Core.FromJSON UpdateSchemaRequest where
  parseJSON =
    Core.withObject
      "UpdateSchemaRequest"
      ( \o ->
          UpdateSchemaRequest
            Core.<$> (o Core..:? "debugOptions")
            Core.<*> (o Core..:? "schema")
            Core.<*> (o Core..:? "validateOnly")
      )

instance Core.ToJSON UpdateSchemaRequest where
  toJSON UpdateSchemaRequest {..} =
    Core.object
      ( Core.catMaybes
          [ ("debugOptions" Core..=) Core.<$> debugOptions,
            ("schema" Core..=) Core.<$> schema,
            ("validateOnly" Core..=) Core.<$> validateOnly
          ]
      )

--
-- /See:/ 'newUpdateSubject' smart constructor.
newtype UpdateSubject = UpdateSubject
  { -- |
    subject :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'UpdateSubject' with the minimum fields required to make a request.
newUpdateSubject ::
  UpdateSubject
newUpdateSubject = UpdateSubject {subject = Core.Nothing}

instance Core.FromJSON UpdateSubject where
  parseJSON =
    Core.withObject
      "UpdateSubject"
      ( \o ->
          UpdateSubject Core.<$> (o Core..:? "subject")
      )

instance Core.ToJSON UpdateSubject where
  toJSON UpdateSubject {..} =
    Core.object
      ( Core.catMaybes
          [("subject" Core..=) Core.<$> subject]
      )

--
-- /See:/ 'newUpdateToRecipients' smart constructor.
newtype UpdateToRecipients = UpdateToRecipients
  { -- |
    toRecipients :: (Core.Maybe [Recipient])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'UpdateToRecipients' with the minimum fields required to make a request.
newUpdateToRecipients ::
  UpdateToRecipients
newUpdateToRecipients = UpdateToRecipients {toRecipients = Core.Nothing}

instance Core.FromJSON UpdateToRecipients where
  parseJSON =
    Core.withObject
      "UpdateToRecipients"
      ( \o ->
          UpdateToRecipients
            Core.<$> (o Core..:? "toRecipients")
      )

instance Core.ToJSON UpdateToRecipients where
  toJSON UpdateToRecipients {..} =
    Core.object
      ( Core.catMaybes
          [("toRecipients" Core..=) Core.<$> toRecipients]
      )

-- | Represents an upload session reference. This reference is created via upload method. This reference is valid for 30 days after its creation. Updating of item content may refer to this uploaded content via contentDataRef.
--
-- /See:/ 'newUploadItemRef' smart constructor.
newtype UploadItemRef = UploadItemRef
  { -- | The name of the content reference. The maximum length is 2048 characters.
    name :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'UploadItemRef' with the minimum fields required to make a request.
newUploadItemRef ::
  UploadItemRef
newUploadItemRef = UploadItemRef {name = Core.Nothing}

instance Core.FromJSON UploadItemRef where
  parseJSON =
    Core.withObject
      "UploadItemRef"
      (\o -> UploadItemRef Core.<$> (o Core..:? "name"))

instance Core.ToJSON UploadItemRef where
  toJSON UploadItemRef {..} =
    Core.object
      (Core.catMaybes [("name" Core..=) Core.<$> name])

-- | Annotation metadata for user Upload artifacts.
--
-- /See:/ 'newUploadMetadata' smart constructor.
data UploadMetadata = UploadMetadata
  { -- | Opaque token. Clients shall simply pass it back to the Backend. There is no guarantee the attachment_token returned on subsequent reads is the same even if nothing has changed. This field will NOT be saved into storage.
    attachmentToken :: (Core.Maybe Core.Text),
    -- | Information about the uploaded attachment that is only used in Backend. This field will NOT be sent out of Google.
    backendUploadMetadata :: (Core.Maybe AppsDynamiteSharedBackendUploadMetadata),
    -- | The \"new\" secure identifier for Drive files. Should be used instead of the deprecated string drive/id field above. This should only be set if the upload file has been added to Drive. Note that older Drive files that do not have a ResourceKey should still use this field, with the resource/key field unset.
    clonedAuthorizedItemId :: (Core.Maybe AuthorizedItemId),
    -- | DriveAction for organizing the cloned version of this upload in Drive, if the file has been added to Drive. This field is not set if the file has not been added to Drive. Additionally, this field is only set when part of a FileResult in a ListFilesResponse.
    clonedDriveAction :: (Core.Maybe UploadMetadata_ClonedDriveAction),
    -- | Reference to a Drive ID, if this upload file has been previously cloned to Drive. Note: this is deprecated in favor of the AuthorizedItemId below.
    clonedDriveId :: (Core.Maybe Core.Text),
    -- | The original file name for the content, not the full path.
    contentName :: (Core.Maybe Core.Text),
    -- | Type is from Scotty\'s best/guess by default: http:\/\/google3\/uploader\/agent\/scotty/agent.proto?l=51&rcl=140889785
    contentType :: (Core.Maybe Core.Text),
    -- | The metrics metadata of the Data Loss Prevention attachment scan.
    dlpMetricsMetadata :: (Core.Maybe AppsDynamiteSharedDlpMetricsMetadata),
    -- | The timestamp of the most recent virus scan completed (in microseconds).
    latestVirusScanTimestamp :: (Core.Maybe Core.Int64),
    -- | A copy of the LocalId in Annotation. This field is supposed to be filled by server only.
    localId :: (Core.Maybe Core.Text),
    -- | Original dimension of the content. Only set for image attachments.
    originalDimension :: (Core.Maybe AppsDynamiteSharedDimension),
    -- | Reference to a transcoded video attachment. Only set for video attachments.
    videoReference :: (Core.Maybe AppsDynamiteSharedVideoReference),
    -- | Result for a virus scan. It\'s duplicated in the above field apps.dynamite.shared.BackendUploadMetadata
    virusScanResult :: (Core.Maybe UploadMetadata_VirusScanResult)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'UploadMetadata' with the minimum fields required to make a request.
newUploadMetadata ::
  UploadMetadata
newUploadMetadata =
  UploadMetadata
    { attachmentToken = Core.Nothing,
      backendUploadMetadata = Core.Nothing,
      clonedAuthorizedItemId = Core.Nothing,
      clonedDriveAction = Core.Nothing,
      clonedDriveId = Core.Nothing,
      contentName = Core.Nothing,
      contentType = Core.Nothing,
      dlpMetricsMetadata = Core.Nothing,
      latestVirusScanTimestamp = Core.Nothing,
      localId = Core.Nothing,
      originalDimension = Core.Nothing,
      videoReference = Core.Nothing,
      virusScanResult = Core.Nothing
    }

instance Core.FromJSON UploadMetadata where
  parseJSON =
    Core.withObject
      "UploadMetadata"
      ( \o ->
          UploadMetadata
            Core.<$> (o Core..:? "attachmentToken")
            Core.<*> (o Core..:? "backendUploadMetadata")
            Core.<*> (o Core..:? "clonedAuthorizedItemId")
            Core.<*> (o Core..:? "clonedDriveAction")
            Core.<*> (o Core..:? "clonedDriveId")
            Core.<*> (o Core..:? "contentName")
            Core.<*> (o Core..:? "contentType")
            Core.<*> (o Core..:? "dlpMetricsMetadata")
            Core.<*> ( o Core..:? "latestVirusScanTimestamp"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "localId")
            Core.<*> (o Core..:? "originalDimension")
            Core.<*> (o Core..:? "videoReference")
            Core.<*> (o Core..:? "virusScanResult")
      )

instance Core.ToJSON UploadMetadata where
  toJSON UploadMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("attachmentToken" Core..=)
              Core.<$> attachmentToken,
            ("backendUploadMetadata" Core..=)
              Core.<$> backendUploadMetadata,
            ("clonedAuthorizedItemId" Core..=)
              Core.<$> clonedAuthorizedItemId,
            ("clonedDriveAction" Core..=)
              Core.<$> clonedDriveAction,
            ("clonedDriveId" Core..=) Core.<$> clonedDriveId,
            ("contentName" Core..=) Core.<$> contentName,
            ("contentType" Core..=) Core.<$> contentType,
            ("dlpMetricsMetadata" Core..=)
              Core.<$> dlpMetricsMetadata,
            ("latestVirusScanTimestamp" Core..=)
              Core.. Core.AsText
              Core.<$> latestVirusScanTimestamp,
            ("localId" Core..=) Core.<$> localId,
            ("originalDimension" Core..=)
              Core.<$> originalDimension,
            ("videoReference" Core..=) Core.<$> videoReference,
            ("virusScanResult" Core..=)
              Core.<$> virusScanResult
          ]
      )

-- | Annotation metadata for a Weblink. In case of pasted link it can qualify to be other types in addition to being a URL - like DRIVE/DOC\/DRIVE/SHEET and so on. The URL metadata will also be present and it\'s up to the client to decide which metadata to render it with. These fields are filled in using page render service.
--
-- /See:/ 'newUrlMetadata' smart constructor.
data UrlMetadata = UrlMetadata
  { -- | Domain for this url. If it\'s an IP address the address is returned.
    domain :: (Core.Maybe Core.Text),
    -- | The signed GWS URL.
    gwsUrl :: (Core.Maybe SafeUrlProto),
    -- | The expiration timestamp for GWS URL, only set when gws_url is set.
    gwsUrlExpirationTimestamp :: (Core.Maybe Core.Int64),
    -- | Dimensions of the image: height. This field is string to match with page render service response. Deprecated. Use int/image/height instead.
    imageHeight :: (Core.Maybe Core.Text),
    -- | Representative image of the website.
    imageUrl :: (Core.Maybe Core.Text),
    -- | Dimensions of the image: width. This field is string to match with page render service response. Deprecated. Use int/image/height instead.
    imageWidth :: (Core.Maybe Core.Text),
    -- | Dimensions of the image: height.
    intImageHeight :: (Core.Maybe Core.Int32),
    -- | Dimensions of the image: width.
    intImageWidth :: (Core.Maybe Core.Int32),
    -- | Mime type of the content (Currently mapped from Page Render Service ItemType) Note that this is not necessarily the mime type of the http resource. For example a text\/html from youtube or vimeo may actually be classified as a video type. Then we shall mark it as video\/* since we don\'t know exactly what type of video it is.
    mimeType :: (Core.Maybe Core.Text),
    -- | The stable redirect URL pointing to frontend server.
    redirectUrl :: (Core.Maybe SafeUrlProto),
    -- | If the UrlMetadata is missing data for rendering a chip. Deprecated. Use Annotation.ChipRenderType instead.
    shouldNotRender :: (Core.Maybe Core.Bool),
    -- | Snippet\/small description of the weblink.
    snippet :: (Core.Maybe Core.Text),
    -- | Title of the Weblink.
    title :: (Core.Maybe Core.Text),
    -- | The original URL.
    url :: (Core.Maybe SafeUrlProto),
    -- |
    urlSource :: (Core.Maybe UrlMetadata_UrlSource)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'UrlMetadata' with the minimum fields required to make a request.
newUrlMetadata ::
  UrlMetadata
newUrlMetadata =
  UrlMetadata
    { domain = Core.Nothing,
      gwsUrl = Core.Nothing,
      gwsUrlExpirationTimestamp = Core.Nothing,
      imageHeight = Core.Nothing,
      imageUrl = Core.Nothing,
      imageWidth = Core.Nothing,
      intImageHeight = Core.Nothing,
      intImageWidth = Core.Nothing,
      mimeType = Core.Nothing,
      redirectUrl = Core.Nothing,
      shouldNotRender = Core.Nothing,
      snippet = Core.Nothing,
      title = Core.Nothing,
      url = Core.Nothing,
      urlSource = Core.Nothing
    }

instance Core.FromJSON UrlMetadata where
  parseJSON =
    Core.withObject
      "UrlMetadata"
      ( \o ->
          UrlMetadata
            Core.<$> (o Core..:? "domain")
            Core.<*> (o Core..:? "gwsUrl")
            Core.<*> ( o Core..:? "gwsUrlExpirationTimestamp"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "imageHeight")
            Core.<*> (o Core..:? "imageUrl")
            Core.<*> (o Core..:? "imageWidth")
            Core.<*> (o Core..:? "intImageHeight")
            Core.<*> (o Core..:? "intImageWidth")
            Core.<*> (o Core..:? "mimeType")
            Core.<*> (o Core..:? "redirectUrl")
            Core.<*> (o Core..:? "shouldNotRender")
            Core.<*> (o Core..:? "snippet")
            Core.<*> (o Core..:? "title")
            Core.<*> (o Core..:? "url")
            Core.<*> (o Core..:? "urlSource")
      )

instance Core.ToJSON UrlMetadata where
  toJSON UrlMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("domain" Core..=) Core.<$> domain,
            ("gwsUrl" Core..=) Core.<$> gwsUrl,
            ("gwsUrlExpirationTimestamp" Core..=)
              Core.. Core.AsText
              Core.<$> gwsUrlExpirationTimestamp,
            ("imageHeight" Core..=) Core.<$> imageHeight,
            ("imageUrl" Core..=) Core.<$> imageUrl,
            ("imageWidth" Core..=) Core.<$> imageWidth,
            ("intImageHeight" Core..=) Core.<$> intImageHeight,
            ("intImageWidth" Core..=) Core.<$> intImageWidth,
            ("mimeType" Core..=) Core.<$> mimeType,
            ("redirectUrl" Core..=) Core.<$> redirectUrl,
            ("shouldNotRender" Core..=) Core.<$> shouldNotRender,
            ("snippet" Core..=) Core.<$> snippet,
            ("title" Core..=) Core.<$> title,
            ("url" Core..=) Core.<$> url,
            ("urlSource" Core..=) Core.<$> urlSource
          ]
      )

-- | User profile information. This user is not necessarily member of a space.
--
-- /See:/ 'newUser' smart constructor.
data User = User
  { -- | URL for the avatar picture of the User in dynamite
    avatarUrl :: (Core.Maybe Core.Text),
    -- | Information about whether the user is blocked by requester and\/or has blocked requester.
    blockRelationship :: (Core.Maybe AppsDynamiteSharedUserBlockRelationship),
    -- | Bot-specific profile information. Leave it empty for human users.
    botInfo :: (Core.Maybe BotInfo),
    -- | Deleted flag, if true, means User has been soft-deleted\/purged Deprecated. Use user/account/state field instead.
    deleted :: (Core.Maybe Core.Bool),
    -- | Email ID of the user
    email :: (Core.Maybe Core.Text),
    -- | First or given name of the user
    firstName :: (Core.Maybe Core.Text),
    -- | Gender of the user
    gender :: (Core.Maybe Core.Text),
    -- | UserId
    id :: (Core.Maybe UserId),
    -- | Set to true if none of the depending services (Gaia, PeopleApi) returns any info for this user.
    isAnonymous :: (Core.Maybe Core.Bool),
    -- | Last or family name of the user
    lastName :: (Core.Maybe Core.Text),
    -- | Non-unique, user-defined display name of the User
    name :: (Core.Maybe Core.Text),
    -- | Information about whether the user is a consumer user, or the GSuite customer that they belong to.
    organizationInfo :: (Core.Maybe AppsDynamiteSharedOrganizationInfo),
    -- | Phone number(s) of the user
    phoneNumber :: (Core.Maybe [AppsDynamiteSharedPhoneNumber]),
    -- | State of user\'s Gaia Account
    userAccountState :: (Core.Maybe User_UserAccountState),
    -- | Visibility of user\'s Profile
    userProfileVisibility :: (Core.Maybe User_UserProfileVisibility)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'User' with the minimum fields required to make a request.
newUser ::
  User
newUser =
  User
    { avatarUrl = Core.Nothing,
      blockRelationship = Core.Nothing,
      botInfo = Core.Nothing,
      deleted = Core.Nothing,
      email = Core.Nothing,
      firstName = Core.Nothing,
      gender = Core.Nothing,
      id = Core.Nothing,
      isAnonymous = Core.Nothing,
      lastName = Core.Nothing,
      name = Core.Nothing,
      organizationInfo = Core.Nothing,
      phoneNumber = Core.Nothing,
      userAccountState = Core.Nothing,
      userProfileVisibility = Core.Nothing
    }

instance Core.FromJSON User where
  parseJSON =
    Core.withObject
      "User"
      ( \o ->
          User
            Core.<$> (o Core..:? "avatarUrl")
            Core.<*> (o Core..:? "blockRelationship")
            Core.<*> (o Core..:? "botInfo")
            Core.<*> (o Core..:? "deleted")
            Core.<*> (o Core..:? "email")
            Core.<*> (o Core..:? "firstName")
            Core.<*> (o Core..:? "gender")
            Core.<*> (o Core..:? "id")
            Core.<*> (o Core..:? "isAnonymous")
            Core.<*> (o Core..:? "lastName")
            Core.<*> (o Core..:? "name")
            Core.<*> (o Core..:? "organizationInfo")
            Core.<*> (o Core..:? "phoneNumber")
            Core.<*> (o Core..:? "userAccountState")
            Core.<*> (o Core..:? "userProfileVisibility")
      )

instance Core.ToJSON User where
  toJSON User {..} =
    Core.object
      ( Core.catMaybes
          [ ("avatarUrl" Core..=) Core.<$> avatarUrl,
            ("blockRelationship" Core..=)
              Core.<$> blockRelationship,
            ("botInfo" Core..=) Core.<$> botInfo,
            ("deleted" Core..=) Core.<$> deleted,
            ("email" Core..=) Core.<$> email,
            ("firstName" Core..=) Core.<$> firstName,
            ("gender" Core..=) Core.<$> gender,
            ("id" Core..=) Core.<$> id,
            ("isAnonymous" Core..=) Core.<$> isAnonymous,
            ("lastName" Core..=) Core.<$> lastName,
            ("name" Core..=) Core.<$> name,
            ("organizationInfo" Core..=)
              Core.<$> organizationInfo,
            ("phoneNumber" Core..=) Core.<$> phoneNumber,
            ("userAccountState" Core..=)
              Core.<$> userAccountState,
            ("userProfileVisibility" Core..=)
              Core.<$> userProfileVisibility
          ]
      )

-- | Resource for displaying user info
--
-- /See:/ 'newUserDisplayInfo' smart constructor.
data UserDisplayInfo = UserDisplayInfo
  { -- | The avatar to show for this user
    avatarUrl :: (Core.Maybe Core.Text),
    -- | The name to show for this user
    displayName :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'UserDisplayInfo' with the minimum fields required to make a request.
newUserDisplayInfo ::
  UserDisplayInfo
newUserDisplayInfo =
  UserDisplayInfo {avatarUrl = Core.Nothing, displayName = Core.Nothing}

instance Core.FromJSON UserDisplayInfo where
  parseJSON =
    Core.withObject
      "UserDisplayInfo"
      ( \o ->
          UserDisplayInfo
            Core.<$> (o Core..:? "avatarUrl")
            Core.<*> (o Core..:? "displayName")
      )

instance Core.ToJSON UserDisplayInfo where
  toJSON UserDisplayInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("avatarUrl" Core..=) Core.<$> avatarUrl,
            ("displayName" Core..=) Core.<$> displayName
          ]
      )

-- | Primary key for User resource.
--
-- /See:/ 'newUserId' smart constructor.
data UserId = UserId
  { -- | Optional. Opaque, server-assigned ID of the user profile associated with App\/user acting on behalf of the human user. This is currently only set when a 3P application is acting on the user\'s behalf.
    actingUserId :: (Core.Maybe Core.Text),
    -- | Opaque, server-assigned ID of the User.
    id :: (Core.Maybe Core.Text),
    -- | Optional. Identifier of the App involved (directly or on behalf of a human creator) in creating this message. This is not set if the user posted a message directly, but is used in the case of, for example, a message being generated by a 1P integration based on a user action (creating an event, creating a task etc). This should only be used on the BE. For clients, please use the field in the FE message proto instead (google3\/apps\/dynamite\/v1\/frontend\/api\/message.proto?q=origin/app/id).
    originAppId :: (Core.Maybe AppId),
    -- | Clients do not need to send UserType to Backend, but Backend will always send this field to clients per the following rule: 1. For HUMAN Ids, the field is empty but by default .getType() will return HUMAN. 2. For BOT Ids, the field is ALWAYS set to BOT.
    type' :: (Core.Maybe UserId_Type)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'UserId' with the minimum fields required to make a request.
newUserId ::
  UserId
newUserId =
  UserId
    { actingUserId = Core.Nothing,
      id = Core.Nothing,
      originAppId = Core.Nothing,
      type' = Core.Nothing
    }

instance Core.FromJSON UserId where
  parseJSON =
    Core.withObject
      "UserId"
      ( \o ->
          UserId
            Core.<$> (o Core..:? "actingUserId")
            Core.<*> (o Core..:? "id")
            Core.<*> (o Core..:? "originAppId")
            Core.<*> (o Core..:? "type")
      )

instance Core.ToJSON UserId where
  toJSON UserId {..} =
    Core.object
      ( Core.catMaybes
          [ ("actingUserId" Core..=) Core.<$> actingUserId,
            ("id" Core..=) Core.<$> id,
            ("originAppId" Core..=) Core.<$> originAppId,
            ("type" Core..=) Core.<$> type'
          ]
      )

-- | Contains info regarding the updater of an Activity Feed item. Next Id: 8
--
-- /See:/ 'newUserInfo' smart constructor.
data UserInfo = UserInfo
  { -- | Avatar url of the user who triggered the Drive Notification email. This field will be populated if we can extract such information from the Drive Notification email. This should only be used to fetch user avatars when updater/to/show_email is not populated. This field is not set for non-Drive Notification items.
    driveNotificationAvatarUrl :: (Core.Maybe Core.Text),
    -- | Describes how updater/count/to_show should be used.
    updaterCountDisplayType :: (Core.Maybe UserInfo_UpdaterCountDisplayType),
    -- | The number of updaters for clients to show depending on UpdaterCountDisplayType.
    updaterCountToShow :: (Core.Maybe Core.Int32),
    -- | The email of the updater for clients to show used for Gmail items. For Drive Notifications, this is the email of the user who triggered the Drive Notification email. This field will be populated if we can extract such information from the Drive Notification email. This is not the actual sender of the email, as the sender is always comments-noreply\@docs.google.com.
    updaterToShowEmail :: (Core.Maybe Core.Text),
    -- | The gaia id of the updater for clients to show used for Gmail items. If the updater is an external user, the email field below should be populated.
    updaterToShowGaiaId :: (Core.Maybe Core.Int64),
    -- | The display name of the updater for clients to show used for Gmail items. For non-Drive Notification items, this field will always be populated. If the display name cannot be found for the user, the fallback string will be the email address. For Drive Notification items, this is the name of the user who triggered the Drive notification email. This field will be populated if we can extract such information from the Drive Notification email. If the name cannot be extracted, then the email will be the fallback string, which is used as the display name text in the UI when needed. This is not the actual sender of the email, as the sender is always comments-noreply\@docs.google.com.
    updaterToShowName :: (Core.Maybe Core.Text),
    -- | The updater for clients to show used for Dynamite Chat items.
    updaterToShowUserId :: (Core.Maybe UserId)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'UserInfo' with the minimum fields required to make a request.
newUserInfo ::
  UserInfo
newUserInfo =
  UserInfo
    { driveNotificationAvatarUrl = Core.Nothing,
      updaterCountDisplayType = Core.Nothing,
      updaterCountToShow = Core.Nothing,
      updaterToShowEmail = Core.Nothing,
      updaterToShowGaiaId = Core.Nothing,
      updaterToShowName = Core.Nothing,
      updaterToShowUserId = Core.Nothing
    }

instance Core.FromJSON UserInfo where
  parseJSON =
    Core.withObject
      "UserInfo"
      ( \o ->
          UserInfo
            Core.<$> (o Core..:? "driveNotificationAvatarUrl")
            Core.<*> (o Core..:? "updaterCountDisplayType")
            Core.<*> (o Core..:? "updaterCountToShow")
            Core.<*> (o Core..:? "updaterToShowEmail")
            Core.<*> ( o Core..:? "updaterToShowGaiaId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "updaterToShowName")
            Core.<*> (o Core..:? "updaterToShowUserId")
      )

instance Core.ToJSON UserInfo where
  toJSON UserInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("driveNotificationAvatarUrl" Core..=)
              Core.<$> driveNotificationAvatarUrl,
            ("updaterCountDisplayType" Core..=)
              Core.<$> updaterCountDisplayType,
            ("updaterCountToShow" Core..=)
              Core.<$> updaterCountToShow,
            ("updaterToShowEmail" Core..=)
              Core.<$> updaterToShowEmail,
            ("updaterToShowGaiaId" Core..=) Core.. Core.AsText
              Core.<$> updaterToShowGaiaId,
            ("updaterToShowName" Core..=)
              Core.<$> updaterToShowName,
            ("updaterToShowUserId" Core..=)
              Core.<$> updaterToShowUserId
          ]
      )

-- | Person metadata, for USER/MENTION segments. Should always contain at least one of user/gaia/id, user/id, email or user. The exact set of populated fields may differ depending on the context and the level in the serving stack; for example, emails will be elided on the viewing path. But as a general rule, a proto having any one of the four is valid, subject to the standard constraints of the applied annotations -- that is, communication between servers and clients will ignore jspb.ignore fields, and communication between servers and other servers (or between servers and storage) will ignore client/only fields. For more on the annotations, see the comments in social\/common\/segment/annotations.proto
--
-- /See:/ 'newUserMentionData' smart constructor.
data UserMentionData = UserMentionData
  { -- |
    email :: (Core.Maybe Core.Text),
    -- | If the principal is backed by a gaia id, DO NOT use this field. Use user/gaia/id\/user_id fields instead.
    user :: (Core.Maybe PrincipalProto),
    -- | An unobfuscated gaia ID:
    userGaiaId :: (Core.Maybe Core.Int64),
    -- | An obfuscated gaia ID:
    userId :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'UserMentionData' with the minimum fields required to make a request.
newUserMentionData ::
  UserMentionData
newUserMentionData =
  UserMentionData
    { email = Core.Nothing,
      user = Core.Nothing,
      userGaiaId = Core.Nothing,
      userId = Core.Nothing
    }

instance Core.FromJSON UserMentionData where
  parseJSON =
    Core.withObject
      "UserMentionData"
      ( \o ->
          UserMentionData
            Core.<$> (o Core..:? "email")
            Core.<*> (o Core..:? "user")
            Core.<*> ( o Core..:? "userGaiaId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "userId")
      )

instance Core.ToJSON UserMentionData where
  toJSON UserMentionData {..} =
    Core.object
      ( Core.catMaybes
          [ ("email" Core..=) Core.<$> email,
            ("user" Core..=) Core.<$> user,
            ("userGaiaId" Core..=) Core.. Core.AsText
              Core.<$> userGaiaId,
            ("userId" Core..=) Core.<$> userId
          ]
      )

-- | Annotation metadata for user mentions (+\/\@\/-).
--
-- /See:/ 'newUserMentionMetadata' smart constructor.
data UserMentionMetadata = UserMentionMetadata
  { -- | Display name of the mentioned user. This field should remain empty when clients resolve a UserMention annotation. It will be filled in when a UserMention is generated by the Integration Server.
    displayName :: (Core.Maybe Core.Text),
    -- | Gender of the mentioned user. One of \"female\", \"male\" or \"other\". Used for choosing accurate translations for strings that contain the UserMention, when these need to be constructed (e.g. task assignment update message). This field should remain empty when clients resolve a UserMention. It will be filled in when a UserMention is generated by the Integration Server.
    gender :: (Core.Maybe Core.Text),
    -- | To be deprecated. Use invitee/info field instead. ID of the User mentioned. This field should remain empty when type == MENTION/ALL.
    id :: (Core.Maybe UserId),
    -- | Invitee UserId and email used when mentioned. This field should remain empty when type == MENTION/ALL. Invitee/info.email is only used when a user is \@-mentioned with an email address, and it will be empty when clients get messages from Backend.
    inviteeInfo :: (Core.Maybe InviteeInfo),
    -- |
    type' :: (Core.Maybe UserMentionMetadata_Type),
    -- | Specific reason for the user mention failing, for fine-grained processing by clients (i.e. specific error message for space limit exceeded case) IMPORTANT: Set this only for FAILED/TO/ADD case.
    userMentionError :: (Core.Maybe UserMentionMetadata_UserMentionError)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'UserMentionMetadata' with the minimum fields required to make a request.
newUserMentionMetadata ::
  UserMentionMetadata
newUserMentionMetadata =
  UserMentionMetadata
    { displayName = Core.Nothing,
      gender = Core.Nothing,
      id = Core.Nothing,
      inviteeInfo = Core.Nothing,
      type' = Core.Nothing,
      userMentionError = Core.Nothing
    }

instance Core.FromJSON UserMentionMetadata where
  parseJSON =
    Core.withObject
      "UserMentionMetadata"
      ( \o ->
          UserMentionMetadata
            Core.<$> (o Core..:? "displayName")
            Core.<*> (o Core..:? "gender")
            Core.<*> (o Core..:? "id")
            Core.<*> (o Core..:? "inviteeInfo")
            Core.<*> (o Core..:? "type")
            Core.<*> (o Core..:? "userMentionError")
      )

instance Core.ToJSON UserMentionMetadata where
  toJSON UserMentionMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("displayName" Core..=) Core.<$> displayName,
            ("gender" Core..=) Core.<$> gender,
            ("id" Core..=) Core.<$> id,
            ("inviteeInfo" Core..=) Core.<$> inviteeInfo,
            ("type" Core..=) Core.<$> type',
            ("userMentionError" Core..=)
              Core.<$> userMentionError
          ]
      )

--
-- /See:/ 'newVPCSettings' smart constructor.
newtype VPCSettings = VPCSettings
  { -- | The resource name of the GCP Project to be used for VPC SC policy check. VPC security settings on this project will be honored for Cloud Search APIs after project/name has been updated through CustomerService. Format: projects\/{project/id}
    project :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'VPCSettings' with the minimum fields required to make a request.
newVPCSettings ::
  VPCSettings
newVPCSettings = VPCSettings {project = Core.Nothing}

instance Core.FromJSON VPCSettings where
  parseJSON =
    Core.withObject
      "VPCSettings"
      (\o -> VPCSettings Core.<$> (o Core..:? "project"))

instance Core.ToJSON VPCSettings where
  toJSON VPCSettings {..} =
    Core.object
      ( Core.catMaybes
          [("project" Core..=) Core.<$> project]
      )

-- | Definition of a single value with generic type.
--
-- /See:/ 'newValue' smart constructor.
data Value = Value
  { -- |
    booleanValue :: (Core.Maybe Core.Bool),
    -- |
    dateValue :: (Core.Maybe Date),
    -- |
    doubleValue :: (Core.Maybe Core.Double),
    -- |
    integerValue :: (Core.Maybe Core.Int64),
    -- |
    stringValue :: (Core.Maybe Core.Text),
    -- |
    timestampValue :: (Core.Maybe Core.DateTime)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'Value' with the minimum fields required to make a request.
newValue ::
  Value
newValue =
  Value
    { booleanValue = Core.Nothing,
      dateValue = Core.Nothing,
      doubleValue = Core.Nothing,
      integerValue = Core.Nothing,
      stringValue = Core.Nothing,
      timestampValue = Core.Nothing
    }

instance Core.FromJSON Value where
  parseJSON =
    Core.withObject
      "Value"
      ( \o ->
          Value
            Core.<$> (o Core..:? "booleanValue")
            Core.<*> (o Core..:? "dateValue")
            Core.<*> (o Core..:? "doubleValue")
            Core.<*> ( o Core..:? "integerValue"
                         Core.<&> Core.fmap Core.fromAsText
                     )
            Core.<*> (o Core..:? "stringValue")
            Core.<*> (o Core..:? "timestampValue")
      )

instance Core.ToJSON Value where
  toJSON Value {..} =
    Core.object
      ( Core.catMaybes
          [ ("booleanValue" Core..=) Core.<$> booleanValue,
            ("dateValue" Core..=) Core.<$> dateValue,
            ("doubleValue" Core..=) Core.<$> doubleValue,
            ("integerValue" Core..=) Core.. Core.AsText
              Core.<$> integerValue,
            ("stringValue" Core..=) Core.<$> stringValue,
            ("timestampValue" Core..=) Core.<$> timestampValue
          ]
      )

--
-- /See:/ 'newValueFilter' smart constructor.
data ValueFilter = ValueFilter
  { -- | The @operator_name@ applied to the query, such as /price/greater/than/. The filter can work against both types of filters defined in the schema for your data source: 1. @operator_name@, where the query filters results by the property that matches the value. 2. @greater_than_operator_name@ or @less_than_operator_name@ in your schema. The query filters the results for the property values that are greater than or less than the supplied value in the query.
    operatorName :: (Core.Maybe Core.Text),
    -- | The value to be compared with.
    value :: (Core.Maybe Value)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ValueFilter' with the minimum fields required to make a request.
newValueFilter ::
  ValueFilter
newValueFilter = ValueFilter {operatorName = Core.Nothing, value = Core.Nothing}

instance Core.FromJSON ValueFilter where
  parseJSON =
    Core.withObject
      "ValueFilter"
      ( \o ->
          ValueFilter
            Core.<$> (o Core..:? "operatorName")
            Core.<*> (o Core..:? "value")
      )

instance Core.ToJSON ValueFilter where
  toJSON ValueFilter {..} =
    Core.object
      ( Core.catMaybes
          [ ("operatorName" Core..=) Core.<$> operatorName,
            ("value" Core..=) Core.<$> value
          ]
      )

--
-- /See:/ 'newVideoCallMetadata' smart constructor.
data VideoCallMetadata = VideoCallMetadata
  { -- | Thor meeting space.
    meetingSpace :: (Core.Maybe MeetingSpace),
    -- | If this field is set to true, server should still contact external backends to get metadata for search but clients should not render this chip.
    shouldNotRender :: (Core.Maybe Core.Bool),
    -- | Whether this meeting space was created via Dynamite in this Dynamite group.
    wasCreatedInCurrentGroup :: (Core.Maybe Core.Bool)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'VideoCallMetadata' with the minimum fields required to make a request.
newVideoCallMetadata ::
  VideoCallMetadata
newVideoCallMetadata =
  VideoCallMetadata
    { meetingSpace = Core.Nothing,
      shouldNotRender = Core.Nothing,
      wasCreatedInCurrentGroup = Core.Nothing
    }

instance Core.FromJSON VideoCallMetadata where
  parseJSON =
    Core.withObject
      "VideoCallMetadata"
      ( \o ->
          VideoCallMetadata
            Core.<$> (o Core..:? "meetingSpace")
            Core.<*> (o Core..:? "shouldNotRender")
            Core.<*> (o Core..:? "wasCreatedInCurrentGroup")
      )

instance Core.ToJSON VideoCallMetadata where
  toJSON VideoCallMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("meetingSpace" Core..=) Core.<$> meetingSpace,
            ("shouldNotRender" Core..=) Core.<$> shouldNotRender,
            ("wasCreatedInCurrentGroup" Core..=)
              Core.<$> wasCreatedInCurrentGroup
          ]
      )

-- | Next tag: 2
--
-- /See:/ 'newVideoInfo' smart constructor.
newtype VideoInfo = VideoInfo
  { -- | Duration of the video in milliseconds. This field can be absent for recently uploaded video or inaccurate sometimes.
    duration :: (Core.Maybe Core.Int32)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'VideoInfo' with the minimum fields required to make a request.
newVideoInfo ::
  VideoInfo
newVideoInfo = VideoInfo {duration = Core.Nothing}

instance Core.FromJSON VideoInfo where
  parseJSON =
    Core.withObject
      "VideoInfo"
      (\o -> VideoInfo Core.<$> (o Core..:? "duration"))

instance Core.ToJSON VideoInfo where
  toJSON VideoInfo {..} =
    Core.object
      ( Core.catMaybes
          [("duration" Core..=) Core.<$> duration]
      )

-- | Represents both long and short phone number that can be called or texted. Short telephone numbers are used to reach local services. Short numbers and their purpose differ from country to country. These numbers in US are in the form of N11 which is a three-digit abbreviated dialing telephone number.
--
-- /See:/ 'newVoicePhoneNumber' smart constructor.
data VoicePhoneNumber = VoicePhoneNumber
  { -- | E.164 formatted full phone number with leading +. This field also represents encoded form of short telephone numbers in E.164 format. e.g. \"911\" is encoded as \"+1911\".
    e164 :: (Core.Maybe Core.Text),
    -- | Additional data that could be added using the libphonenumber API.
    i18nData :: (Core.Maybe VoicePhoneNumberI18nData)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'VoicePhoneNumber' with the minimum fields required to make a request.
newVoicePhoneNumber ::
  VoicePhoneNumber
newVoicePhoneNumber =
  VoicePhoneNumber {e164 = Core.Nothing, i18nData = Core.Nothing}

instance Core.FromJSON VoicePhoneNumber where
  parseJSON =
    Core.withObject
      "VoicePhoneNumber"
      ( \o ->
          VoicePhoneNumber
            Core.<$> (o Core..:? "e164") Core.<*> (o Core..:? "i18nData")
      )

instance Core.ToJSON VoicePhoneNumber where
  toJSON VoicePhoneNumber {..} =
    Core.object
      ( Core.catMaybes
          [ ("e164" Core..=) Core.<$> e164,
            ("i18nData" Core..=) Core.<$> i18nData
          ]
      )

--
-- /See:/ 'newVoicePhoneNumberI18nData' smart constructor.
data VoicePhoneNumberI18nData = VoicePhoneNumberI18nData
  { -- | The country calling code for this number, as defined by the ITU. For example, this would be 1 for NANPA countries, and 33 for France (for more info see i18n.phonenumbers.PhoneNumber.country_code).
    countryCode :: (Core.Maybe Core.Int32),
    -- | Display number formatted using the INTERNATIONAL format.
    internationalNumber :: (Core.Maybe Core.Text),
    -- | When present, indicates the number is valid according to the libphonenumber\'s isValidNumber API (see https:\/\/code.google.com\/p\/libphonenumber\/).
    isValid :: (Core.Maybe Core.Bool),
    -- | Display number formatted using the NATIONAL format.
    nationalNumber :: (Core.Maybe Core.Text),
    -- | A region (country, territory, continent, etc), as defined by Unicode\'s \"CLDR\", itself based on ISO 3166 (UN country codes). For details, see https:\/\/www.corp.google.com\/~engdocs\/java\/com\/google\/i18n\/identifiers\/RegionCode.html
    regionCode :: (Core.Maybe Core.Text),
    -- | When set to a non-default value, indicates the validation reason that is set when phone number is invalid (is_valid is false).
    validationResult :: (Core.Maybe VoicePhoneNumberI18nData_ValidationResult)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'VoicePhoneNumberI18nData' with the minimum fields required to make a request.
newVoicePhoneNumberI18nData ::
  VoicePhoneNumberI18nData
newVoicePhoneNumberI18nData =
  VoicePhoneNumberI18nData
    { countryCode = Core.Nothing,
      internationalNumber = Core.Nothing,
      isValid = Core.Nothing,
      nationalNumber = Core.Nothing,
      regionCode = Core.Nothing,
      validationResult = Core.Nothing
    }

instance Core.FromJSON VoicePhoneNumberI18nData where
  parseJSON =
    Core.withObject
      "VoicePhoneNumberI18nData"
      ( \o ->
          VoicePhoneNumberI18nData
            Core.<$> (o Core..:? "countryCode")
            Core.<*> (o Core..:? "internationalNumber")
            Core.<*> (o Core..:? "isValid")
            Core.<*> (o Core..:? "nationalNumber")
            Core.<*> (o Core..:? "regionCode")
            Core.<*> (o Core..:? "validationResult")
      )

instance Core.ToJSON VoicePhoneNumberI18nData where
  toJSON VoicePhoneNumberI18nData {..} =
    Core.object
      ( Core.catMaybes
          [ ("countryCode" Core..=) Core.<$> countryCode,
            ("internationalNumber" Core..=)
              Core.<$> internationalNumber,
            ("isValid" Core..=) Core.<$> isValid,
            ("nationalNumber" Core..=) Core.<$> nationalNumber,
            ("regionCode" Core..=) Core.<$> regionCode,
            ("validationResult" Core..=)
              Core.<$> validationResult
          ]
      )

-- | Information on a whiteboard attached to an active conference. A whiteboard is a Jam document.
--
-- /See:/ 'newWhiteboardInfo' smart constructor.
data WhiteboardInfo = WhiteboardInfo
  { -- | The Cosmo Id of the whiteboard document (Jam).
    id :: (Core.Maybe Core.Text),
    -- | Title of the whiteboard document.
    title :: (Core.Maybe Core.Text),
    -- | The uri for whiteboard document.
    uri :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'WhiteboardInfo' with the minimum fields required to make a request.
newWhiteboardInfo ::
  WhiteboardInfo
newWhiteboardInfo =
  WhiteboardInfo {id = Core.Nothing, title = Core.Nothing, uri = Core.Nothing}

instance Core.FromJSON WhiteboardInfo where
  parseJSON =
    Core.withObject
      "WhiteboardInfo"
      ( \o ->
          WhiteboardInfo
            Core.<$> (o Core..:? "id")
            Core.<*> (o Core..:? "title")
            Core.<*> (o Core..:? "uri")
      )

instance Core.ToJSON WhiteboardInfo where
  toJSON WhiteboardInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("id" Core..=) Core.<$> id,
            ("title" Core..=) Core.<$> title,
            ("uri" Core..=) Core.<$> uri
          ]
      )

--
-- /See:/ 'newWidgetMarkup' smart constructor.
data WidgetMarkup = WidgetMarkup
  { -- | buttons is also oneof data and only one of these fields should be set.
    buttons :: (Core.Maybe [Button]),
    -- |
    dateTimePicker :: (Core.Maybe DateTimePicker),
    -- |
    divider :: (Core.Maybe Divider),
    -- |
    grid :: (Core.Maybe Grid),
    -- | The horizontal alignment of this widget.
    horizontalAlignment :: (Core.Maybe WidgetMarkup_HorizontalAlignment),
    -- |
    image :: (Core.Maybe Image),
    -- |
    imageKeyValue :: (Core.Maybe ImageKeyValue),
    -- |
    keyValue :: (Core.Maybe KeyValue),
    -- | Input Widgets
    menu :: (Core.Maybe Menu),
    -- |
    selectionControl :: (Core.Maybe SelectionControl),
    -- |
    textField :: (Core.Maybe TextField),
    -- |
    textKeyValue :: (Core.Maybe TextKeyValue),
    -- | Read-only Widgets
    textParagraph :: (Core.Maybe TextParagraph)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'WidgetMarkup' with the minimum fields required to make a request.
newWidgetMarkup ::
  WidgetMarkup
newWidgetMarkup =
  WidgetMarkup
    { buttons = Core.Nothing,
      dateTimePicker = Core.Nothing,
      divider = Core.Nothing,
      grid = Core.Nothing,
      horizontalAlignment = Core.Nothing,
      image = Core.Nothing,
      imageKeyValue = Core.Nothing,
      keyValue = Core.Nothing,
      menu = Core.Nothing,
      selectionControl = Core.Nothing,
      textField = Core.Nothing,
      textKeyValue = Core.Nothing,
      textParagraph = Core.Nothing
    }

instance Core.FromJSON WidgetMarkup where
  parseJSON =
    Core.withObject
      "WidgetMarkup"
      ( \o ->
          WidgetMarkup
            Core.<$> (o Core..:? "buttons")
            Core.<*> (o Core..:? "dateTimePicker")
            Core.<*> (o Core..:? "divider")
            Core.<*> (o Core..:? "grid")
            Core.<*> (o Core..:? "horizontalAlignment")
            Core.<*> (o Core..:? "image")
            Core.<*> (o Core..:? "imageKeyValue")
            Core.<*> (o Core..:? "keyValue")
            Core.<*> (o Core..:? "menu")
            Core.<*> (o Core..:? "selectionControl")
            Core.<*> (o Core..:? "textField")
            Core.<*> (o Core..:? "textKeyValue")
            Core.<*> (o Core..:? "textParagraph")
      )

instance Core.ToJSON WidgetMarkup where
  toJSON WidgetMarkup {..} =
    Core.object
      ( Core.catMaybes
          [ ("buttons" Core..=) Core.<$> buttons,
            ("dateTimePicker" Core..=) Core.<$> dateTimePicker,
            ("divider" Core..=) Core.<$> divider,
            ("grid" Core..=) Core.<$> grid,
            ("horizontalAlignment" Core..=)
              Core.<$> horizontalAlignment,
            ("image" Core..=) Core.<$> image,
            ("imageKeyValue" Core..=) Core.<$> imageKeyValue,
            ("keyValue" Core..=) Core.<$> keyValue,
            ("menu" Core..=) Core.<$> menu,
            ("selectionControl" Core..=)
              Core.<$> selectionControl,
            ("textField" Core..=) Core.<$> textField,
            ("textKeyValue" Core..=) Core.<$> textKeyValue,
            ("textParagraph" Core..=) Core.<$> textParagraph
          ]
      )

-- | Message delete history record extension that exports \/wonder\/message/mapping\/{vertical} attribute of deleted messages which have any smartmail label (eg. ^cob/sm_invoice). go\/how-dd-card-deletion
--
-- /See:/ 'newWonderCardDelete' smart constructor.
data WonderCardDelete = WonderCardDelete
  { -- | Contains \<{\@code WonderCardType} enum value, value of \/wonder\/message_mapping\/{vertical} attribute of deleted message> pairs.
    messageMappings :: (Core.Maybe WonderCardDelete_MessageMappings),
    -- | Message ID of the original deleted message
    msgId :: (Core.Maybe Core.Word64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'WonderCardDelete' with the minimum fields required to make a request.
newWonderCardDelete ::
  WonderCardDelete
newWonderCardDelete =
  WonderCardDelete {messageMappings = Core.Nothing, msgId = Core.Nothing}

instance Core.FromJSON WonderCardDelete where
  parseJSON =
    Core.withObject
      "WonderCardDelete"
      ( \o ->
          WonderCardDelete
            Core.<$> (o Core..:? "messageMappings")
            Core.<*> ( o Core..:? "msgId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON WonderCardDelete where
  toJSON WonderCardDelete {..} =
    Core.object
      ( Core.catMaybes
          [ ("messageMappings" Core..=)
              Core.<$> messageMappings,
            ("msgId" Core..=) Core.. Core.AsText Core.<$> msgId
          ]
      )

-- | Contains \<{\@code WonderCardType} enum value, value of \/wonder\/message_mapping\/{vertical} attribute of deleted message> pairs.
--
-- /See:/ 'newWonderCardDelete_MessageMappings' smart constructor.
newtype WonderCardDelete_MessageMappings = WonderCardDelete_MessageMappings
  { -- |
    additional :: (Core.HashMap Core.Text WonderMessageMapping)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'WonderCardDelete_MessageMappings' with the minimum fields required to make a request.
newWonderCardDelete_MessageMappings ::
  -- |  See 'additional'.
  Core.HashMap Core.Text WonderMessageMapping ->
  WonderCardDelete_MessageMappings
newWonderCardDelete_MessageMappings additional =
  WonderCardDelete_MessageMappings {additional = additional}

instance
  Core.FromJSON
    WonderCardDelete_MessageMappings
  where
  parseJSON =
    Core.withObject
      "WonderCardDelete_MessageMappings"
      ( \o ->
          WonderCardDelete_MessageMappings
            Core.<$> (Core.parseJSONObject o)
      )

instance Core.ToJSON WonderCardDelete_MessageMappings where
  toJSON WonderCardDelete_MessageMappings {..} =
    Core.toJSON additional

-- | Card mapping attached to original message as an attribute stored at \/wonder\/message_mapping\/{vertical} Next ID: 2
--
-- /See:/ 'newWonderMessageMapping' smart constructor.
newtype WonderMessageMapping = WonderMessageMapping
  { -- | List of wonder card (client-generated) message IDs generated based on the original message.
    wonderCardMessageId :: (Core.Maybe [Core.Text])
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'WonderMessageMapping' with the minimum fields required to make a request.
newWonderMessageMapping ::
  WonderMessageMapping
newWonderMessageMapping =
  WonderMessageMapping {wonderCardMessageId = Core.Nothing}

instance Core.FromJSON WonderMessageMapping where
  parseJSON =
    Core.withObject
      "WonderMessageMapping"
      ( \o ->
          WonderMessageMapping
            Core.<$> (o Core..:? "wonderCardMessageId")
      )

instance Core.ToJSON WonderMessageMapping where
  toJSON WonderMessageMapping {..} =
    Core.object
      ( Core.catMaybes
          [ ("wonderCardMessageId" Core..=)
              Core.<$> wonderCardMessageId
          ]
      )

-- | A wrapper around a raw resource key. The secret should never be logged, and this proto annotates those secret fields to ensure that they are not. Clients are encouraged to use this proto rather than defining their own, to ensure that secrets are correctly annotated.
--
-- /See:/ 'newWrappedResourceKey' smart constructor.
newtype WrappedResourceKey = WrappedResourceKey
  { -- | Resource key of the Drive item. This field should be unset if, depending on the context, the item does not have a resource key, or if none was specified. This must never be logged.
    resourceKey :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'WrappedResourceKey' with the minimum fields required to make a request.
newWrappedResourceKey ::
  WrappedResourceKey
newWrappedResourceKey = WrappedResourceKey {resourceKey = Core.Nothing}

instance Core.FromJSON WrappedResourceKey where
  parseJSON =
    Core.withObject
      "WrappedResourceKey"
      ( \o ->
          WrappedResourceKey
            Core.<$> (o Core..:? "resourceKey")
      )

instance Core.ToJSON WrappedResourceKey where
  toJSON WrappedResourceKey {..} =
    Core.object
      ( Core.catMaybes
          [("resourceKey" Core..=) Core.<$> resourceKey]
      )

-- | Information about a YouTube broadcast session.
--
-- /See:/ 'newYouTubeBroadcastSessionInfo' smart constructor.
data YouTubeBroadcastSessionInfo = YouTubeBroadcastSessionInfo
  { -- | Current broadcast session\'s statistics.
    broadcastStats :: (Core.Maybe YouTubeBroadcastStats),
    -- | YouTube broadcast session\'s state information.
    sessionStateInfo :: (Core.Maybe SessionStateInfo),
    -- | A unique server-generated ID for the broadcast session.
    youTubeBroadcastSessionId :: (Core.Maybe Core.Text),
    -- | The YouTube Live broadcast event that is being streamed to.
    youTubeLiveBroadcastEvent :: (Core.Maybe YouTubeLiveBroadcastEvent)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'YouTubeBroadcastSessionInfo' with the minimum fields required to make a request.
newYouTubeBroadcastSessionInfo ::
  YouTubeBroadcastSessionInfo
newYouTubeBroadcastSessionInfo =
  YouTubeBroadcastSessionInfo
    { broadcastStats = Core.Nothing,
      sessionStateInfo = Core.Nothing,
      youTubeBroadcastSessionId = Core.Nothing,
      youTubeLiveBroadcastEvent = Core.Nothing
    }

instance Core.FromJSON YouTubeBroadcastSessionInfo where
  parseJSON =
    Core.withObject
      "YouTubeBroadcastSessionInfo"
      ( \o ->
          YouTubeBroadcastSessionInfo
            Core.<$> (o Core..:? "broadcastStats")
            Core.<*> (o Core..:? "sessionStateInfo")
            Core.<*> (o Core..:? "youTubeBroadcastSessionId")
            Core.<*> (o Core..:? "youTubeLiveBroadcastEvent")
      )

instance Core.ToJSON YouTubeBroadcastSessionInfo where
  toJSON YouTubeBroadcastSessionInfo {..} =
    Core.object
      ( Core.catMaybes
          [ ("broadcastStats" Core..=) Core.<$> broadcastStats,
            ("sessionStateInfo" Core..=)
              Core.<$> sessionStateInfo,
            ("youTubeBroadcastSessionId" Core..=)
              Core.<$> youTubeBroadcastSessionId,
            ("youTubeLiveBroadcastEvent" Core..=)
              Core.<$> youTubeLiveBroadcastEvent
          ]
      )

-- | Statistics of the YouTube broadcast session.
--
-- /See:/ 'newYouTubeBroadcastStats' smart constructor.
newtype YouTubeBroadcastStats = YouTubeBroadcastStats
  { -- | Estimated concurrent viewer count.
    estimatedViewerCount :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'YouTubeBroadcastStats' with the minimum fields required to make a request.
newYouTubeBroadcastStats ::
  YouTubeBroadcastStats
newYouTubeBroadcastStats =
  YouTubeBroadcastStats {estimatedViewerCount = Core.Nothing}

instance Core.FromJSON YouTubeBroadcastStats where
  parseJSON =
    Core.withObject
      "YouTubeBroadcastStats"
      ( \o ->
          YouTubeBroadcastStats
            Core.<$> ( o Core..:? "estimatedViewerCount"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON YouTubeBroadcastStats where
  toJSON YouTubeBroadcastStats {..} =
    Core.object
      ( Core.catMaybes
          [ ("estimatedViewerCount" Core..=) Core.. Core.AsText
              Core.<$> estimatedViewerCount
          ]
      )

-- | Information about the broadcast to YouTube.
--
-- /See:/ 'newYouTubeLiveBroadcastEvent' smart constructor.
data YouTubeLiveBroadcastEvent = YouTubeLiveBroadcastEvent
  { -- | Input only. If the channel_id is for a YouTube Channel owned by a Brand Account, client is required to populate this field with the obfuscated gaia id of the Brand account when starting the broadcast.
    brandAccountGaiaId :: (Core.Maybe Core.Text),
    -- | Input only. The broadcast id, used to control the lifecycle of the event on YouTube
    broadcastId :: (Core.Maybe Core.Text),
    -- | YouTube Channel associated with the broadcast.
    channelId :: (Core.Maybe Core.Text),
    -- | Output only. A URL that can be used to watch the meeting broadcast. Will be populated by the backend.
    viewUrl :: (Core.Maybe Core.Text)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'YouTubeLiveBroadcastEvent' with the minimum fields required to make a request.
newYouTubeLiveBroadcastEvent ::
  YouTubeLiveBroadcastEvent
newYouTubeLiveBroadcastEvent =
  YouTubeLiveBroadcastEvent
    { brandAccountGaiaId = Core.Nothing,
      broadcastId = Core.Nothing,
      channelId = Core.Nothing,
      viewUrl = Core.Nothing
    }

instance Core.FromJSON YouTubeLiveBroadcastEvent where
  parseJSON =
    Core.withObject
      "YouTubeLiveBroadcastEvent"
      ( \o ->
          YouTubeLiveBroadcastEvent
            Core.<$> (o Core..:? "brandAccountGaiaId")
            Core.<*> (o Core..:? "broadcastId")
            Core.<*> (o Core..:? "channelId")
            Core.<*> (o Core..:? "viewUrl")
      )

instance Core.ToJSON YouTubeLiveBroadcastEvent where
  toJSON YouTubeLiveBroadcastEvent {..} =
    Core.object
      ( Core.catMaybes
          [ ("brandAccountGaiaId" Core..=)
              Core.<$> brandAccountGaiaId,
            ("broadcastId" Core..=) Core.<$> broadcastId,
            ("channelId" Core..=) Core.<$> channelId,
            ("viewUrl" Core..=) Core.<$> viewUrl
          ]
      )

-- | Annotation metadata for YouTube artifact.
--
-- /See:/ 'newYoutubeMetadata' smart constructor.
data YoutubeMetadata = YoutubeMetadata
  { -- | YouTube resource ID of the artifact.
    id :: (Core.Maybe Core.Text),
    -- | If this field is set to true, server should still contact external backends to get metadata for search but clients should not render this chip.
    shouldNotRender :: (Core.Maybe Core.Bool),
    -- | YouTube query parameter for timestamp. YouTube specific flag that allows users to embed time token when sharing a link. This property contains parsed time token in seconds.
    startTime :: (Core.Maybe Core.Int32)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'YoutubeMetadata' with the minimum fields required to make a request.
newYoutubeMetadata ::
  YoutubeMetadata
newYoutubeMetadata =
  YoutubeMetadata
    { id = Core.Nothing,
      shouldNotRender = Core.Nothing,
      startTime = Core.Nothing
    }

instance Core.FromJSON YoutubeMetadata where
  parseJSON =
    Core.withObject
      "YoutubeMetadata"
      ( \o ->
          YoutubeMetadata
            Core.<$> (o Core..:? "id")
            Core.<*> (o Core..:? "shouldNotRender")
            Core.<*> (o Core..:? "startTime")
      )

instance Core.ToJSON YoutubeMetadata where
  toJSON YoutubeMetadata {..} =
    Core.object
      ( Core.catMaybes
          [ ("id" Core..=) Core.<$> id,
            ("shouldNotRender" Core..=) Core.<$> shouldNotRender,
            ("startTime" Core..=) Core.<$> startTime
          ]
      )

--
-- /See:/ 'newYoutubeUserProto' smart constructor.
newtype YoutubeUserProto = YoutubeUserProto
  { -- |
    youtubeUserId :: (Core.Maybe Core.Int64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'YoutubeUserProto' with the minimum fields required to make a request.
newYoutubeUserProto ::
  YoutubeUserProto
newYoutubeUserProto = YoutubeUserProto {youtubeUserId = Core.Nothing}

instance Core.FromJSON YoutubeUserProto where
  parseJSON =
    Core.withObject
      "YoutubeUserProto"
      ( \o ->
          YoutubeUserProto
            Core.<$> ( o Core..:? "youtubeUserId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON YoutubeUserProto where
  toJSON YoutubeUserProto {..} =
    Core.object
      ( Core.catMaybes
          [ ("youtubeUserId" Core..=) Core.. Core.AsText
              Core.<$> youtubeUserId
          ]
      )

-- | See go\/zwieback. New uses of Zwieback sessions must be approved via go\/zwieback-request.
--
-- /See:/ 'newZwiebackSessionProto' smart constructor.
newtype ZwiebackSessionProto = ZwiebackSessionProto
  { -- |
    zwiebackSessionId :: (Core.Maybe Core.Word64)
  }
  deriving (Core.Eq, Core.Show, Core.Generic)

-- | Creates a value of 'ZwiebackSessionProto' with the minimum fields required to make a request.
newZwiebackSessionProto ::
  ZwiebackSessionProto
newZwiebackSessionProto =
  ZwiebackSessionProto {zwiebackSessionId = Core.Nothing}

instance Core.FromJSON ZwiebackSessionProto where
  parseJSON =
    Core.withObject
      "ZwiebackSessionProto"
      ( \o ->
          ZwiebackSessionProto
            Core.<$> ( o Core..:? "zwiebackSessionId"
                         Core.<&> Core.fmap Core.fromAsText
                     )
      )

instance Core.ToJSON ZwiebackSessionProto where
  toJSON ZwiebackSessionProto {..} =
    Core.object
      ( Core.catMaybes
          [ ("zwiebackSessionId" Core..=) Core.. Core.AsText
              Core.<$> zwiebackSessionId
          ]
      )
